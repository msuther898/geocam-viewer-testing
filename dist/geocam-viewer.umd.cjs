(function(vi,Ji){typeof exports=="object"&&typeof module<"u"?Ji(exports):typeof define=="function"&&define.amd?define(["exports"],Ji):(vi=typeof globalThis<"u"?globalThis:vi||self,Ji(vi.GeoCamViewer={}))})(this,function(vi){"use strict";var tA=Object.defineProperty;var nA=(vi,Ji,xo)=>Ji in vi?tA(vi,Ji,{enumerable:!0,configurable:!0,writable:!0,value:xo}):vi[Ji]=xo;var Ce=(vi,Ji,xo)=>(nA(vi,typeof Ji!="symbol"?Ji+"":Ji,xo),xo);function Ji(e,n){for(var t=0;t<n.length;t++){const i=n[t];if(typeof i!="string"&&!Array.isArray(i)){for(const r in i)if(r!=="default"&&!(r in e)){const a=Object.getOwnPropertyDescriptor(i,r);a&&Object.defineProperty(e,r,a.get?a:{enumerable:!0,get:()=>i[r]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}Number.EPSILON===void 0&&(Number.EPSILON=Math.pow(2,-52)),Number.isInteger===void 0&&(Number.isInteger=function(e){return typeof e=="number"&&isFinite(e)&&Math.floor(e)===e}),Math.sign===void 0&&(Math.sign=function(e){return e<0?-1:e>0?1:+e}),"name"in Function.prototype||Object.defineProperty(Function.prototype,"name",{get:function(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]}}),Object.assign===void 0&&(Object.assign=function(e){if(e==null)throw new TypeError("Cannot convert undefined or null to object");const n=Object(e);for(let t=1;t<arguments.length;t++){const i=arguments[t];if(i!=null)for(const r in i)Object.prototype.hasOwnProperty.call(i,r)&&(n[r]=i[r])}return n});const xo="119",zb=0,X0=1,$b=2,Y0=1,Nb=2,ku=3,Ou=0,li=1,_g=2,J0=1,$r=0,Fu=1,Q0=2,Z0=3,ew=4,Ub=5,Pa=100,Gb=101,Vb=102,tw=103,nw=104,jb=200,Wb=201,Hb=202,qb=203,iw=204,sw=205,Kb=206,Xb=207,Yb=208,Jb=209,Qb=210,Zb=0,eM=1,tM=2,Hy=3,nM=4,iM=5,sM=6,rM=7,yg=0,oM=1,aM=2,Aa=0,lM=1,cM=2,uM=3,dM=4,hM=5,qy=300,Ky=301,Xy=302,rw=303,Yy=304,Ru=306,vg=307,wg=1e3,Ni=1001,xg=1002,fi=1003,Jy=1004,Qy=1005,Pi=1006,ow=1007,bg=1008,Bu=1009,fM=1010,pM=1011,Mg=1012,mM=1013,Tg=1014,Nr=1015,Eg=1016,gM=1017,_M=1018,yM=1019,zu=1020,vM=1021,bo=1022,fs=1023,wM=1024,xM=1025,bM=fs,Ca=1026,$u=1027,MM=1028,TM=1029,EM=1030,SM=1031,PM=1032,AM=1033,aw=33776,lw=33777,cw=33778,uw=33779,dw=35840,hw=35841,fw=35842,pw=35843,CM=36196,mw=37492,gw=37496,IM=37808,LM=37809,DM=37810,kM=37811,OM=37812,FM=37813,RM=37814,BM=37815,zM=37816,$M=37817,NM=37818,UM=37819,GM=37820,VM=37821,jM=36492,WM=37840,HM=37841,qM=37842,KM=37843,XM=37844,YM=37845,JM=37846,QM=37847,ZM=37848,e1=37849,t1=37850,n1=37851,i1=37852,s1=37853,r1=2200,o1=2201,a1=2202,Sg=2300,Pg=2301,Zy=2302,Ia=2400,La=2401,Ag=2402,ev=2500,_w=2501,l1=0,Ui=3e3,Cg=3001,tv=3007,nv=3002,c1=3003,yw=3004,vw=3005,ww=3006,u1=3200,d1=3201,Da=0,h1=1,iv=7680,f1=519,Ig=35044,Nu=35048;function yr(){}Object.assign(yr.prototype,{addEventListener:function(e,n){this._listeners===void 0&&(this._listeners={});const t=this._listeners;t[e]===void 0&&(t[e]=[]),t[e].indexOf(n)===-1&&t[e].push(n)},hasEventListener:function(e,n){if(this._listeners===void 0)return!1;const t=this._listeners;return t[e]!==void 0&&t[e].indexOf(n)!==-1},removeEventListener:function(e,n){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const r=i.indexOf(n);r!==-1&&i.splice(r,1)}},dispatchEvent:function(e){if(this._listeners===void 0)return;const t=this._listeners[e.type];if(t!==void 0){e.target=this;const i=t.slice(0);for(let r=0,a=i.length;r<a;r++)i[r].call(this,e)}}});const wi=[];for(let e=0;e<256;e++)wi[e]=(e<16?"0":"")+e.toString(16);let Lg=1234567;const ln={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const e=Math.random()*4294967295|0,n=Math.random()*4294967295|0,t=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(wi[e&255]+wi[e>>8&255]+wi[e>>16&255]+wi[e>>24&255]+"-"+wi[n&255]+wi[n>>8&255]+"-"+wi[n>>16&15|64]+wi[n>>24&255]+"-"+wi[t&63|128]+wi[t>>8&255]+"-"+wi[t>>16&255]+wi[t>>24&255]+wi[i&255]+wi[i>>8&255]+wi[i>>16&255]+wi[i>>24&255]).toUpperCase()},clamp:function(e,n,t){return Math.max(n,Math.min(t,e))},euclideanModulo:function(e,n){return(e%n+n)%n},mapLinear:function(e,n,t,i,r){return i+(e-n)*(r-i)/(t-n)},lerp:function(e,n,t){return(1-t)*e+t*n},smoothstep:function(e,n,t){return e<=n?0:e>=t?1:(e=(e-n)/(t-n),e*e*(3-2*e))},smootherstep:function(e,n,t){return e<=n?0:e>=t?1:(e=(e-n)/(t-n),e*e*e*(e*(e*6-15)+10))},randInt:function(e,n){return e+Math.floor(Math.random()*(n-e+1))},randFloat:function(e,n){return e+Math.random()*(n-e)},randFloatSpread:function(e){return e*(.5-Math.random())},seededRandom:function(e){return e!==void 0&&(Lg=e%2147483647),Lg=Lg*16807%2147483647,(Lg-1)/2147483646},degToRad:function(e){return e*ln.DEG2RAD},radToDeg:function(e){return e*ln.RAD2DEG},isPowerOfTwo:function(e){return(e&e-1)===0&&e!==0},ceilPowerOfTwo:function(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))},floorPowerOfTwo:function(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))},setQuaternionFromProperEuler:function(e,n,t,i,r){const a=Math.cos,c=Math.sin,u=a(t/2),l=c(t/2),f=a((n+i)/2),m=c((n+i)/2),h=a((n-i)/2),p=c((n-i)/2),_=a((i-n)/2),v=c((i-n)/2);switch(r){case"XYX":e.set(u*m,l*h,l*p,u*f);break;case"YZY":e.set(l*p,u*m,l*h,u*f);break;case"ZXZ":e.set(l*h,l*p,u*m,u*f);break;case"XZX":e.set(u*m,l*v,l*_,u*f);break;case"YXY":e.set(l*_,u*m,l*v,u*f);break;case"ZYZ":e.set(l*v,l*_,u*m,u*f);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}};function vt(e=0,n=0){this.x=e,this.y=n}Object.defineProperties(vt.prototype,{width:{get:function(){return this.x},set:function(e){this.x=e}},height:{get:function(){return this.y},set:function(e){this.y=e}}}),Object.assign(vt.prototype,{isVector2:!0,set:function(e,n){return this.x=e,this.y=n,this},setScalar:function(e){return this.x=e,this.y=e,this},setX:function(e){return this.x=e,this},setY:function(e){return this.y=e,this},setComponent:function(e,n){switch(e){case 0:this.x=n;break;case 1:this.y=n;break;default:throw new Error("index is out of range: "+e)}return this},getComponent:function(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}},clone:function(){return new this.constructor(this.x,this.y)},copy:function(e){return this.x=e.x,this.y=e.y,this},add:function(e,n){return n!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,n)):(this.x+=e.x,this.y+=e.y,this)},addScalar:function(e){return this.x+=e,this.y+=e,this},addVectors:function(e,n){return this.x=e.x+n.x,this.y=e.y+n.y,this},addScaledVector:function(e,n){return this.x+=e.x*n,this.y+=e.y*n,this},sub:function(e,n){return n!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,n)):(this.x-=e.x,this.y-=e.y,this)},subScalar:function(e){return this.x-=e,this.y-=e,this},subVectors:function(e,n){return this.x=e.x-n.x,this.y=e.y-n.y,this},multiply:function(e){return this.x*=e.x,this.y*=e.y,this},multiplyScalar:function(e){return this.x*=e,this.y*=e,this},divide:function(e){return this.x/=e.x,this.y/=e.y,this},divideScalar:function(e){return this.multiplyScalar(1/e)},applyMatrix3:function(e){const n=this.x,t=this.y,i=e.elements;return this.x=i[0]*n+i[3]*t+i[6],this.y=i[1]*n+i[4]*t+i[7],this},min:function(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this},max:function(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this},clamp:function(e,n){return this.x=Math.max(e.x,Math.min(n.x,this.x)),this.y=Math.max(e.y,Math.min(n.y,this.y)),this},clampScalar:function(e,n){return this.x=Math.max(e,Math.min(n,this.x)),this.y=Math.max(e,Math.min(n,this.y)),this},clampLength:function(e,n){const t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(e,Math.min(n,t)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this},negate:function(){return this.x=-this.x,this.y=-this.y,this},dot:function(e){return this.x*e.x+this.y*e.y},cross:function(e){return this.x*e.y-this.y*e.x},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)},normalize:function(){return this.divideScalar(this.length()||1)},angle:function(){return Math.atan2(-this.y,-this.x)+Math.PI},distanceTo:function(e){return Math.sqrt(this.distanceToSquared(e))},distanceToSquared:function(e){const n=this.x-e.x,t=this.y-e.y;return n*n+t*t},manhattanDistanceTo:function(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)},setLength:function(e){return this.normalize().multiplyScalar(e)},lerp:function(e,n){return this.x+=(e.x-this.x)*n,this.y+=(e.y-this.y)*n,this},lerpVectors:function(e,n,t){return this.x=e.x+(n.x-e.x)*t,this.y=e.y+(n.y-e.y)*t,this},equals:function(e){return e.x===this.x&&e.y===this.y},fromArray:function(e,n){return n===void 0&&(n=0),this.x=e[n],this.y=e[n+1],this},toArray:function(e,n){return e===void 0&&(e=[]),n===void 0&&(n=0),e[n]=this.x,e[n+1]=this.y,e},fromBufferAttribute:function(e,n,t){return t!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(n),this.y=e.getY(n),this},rotateAround:function(e,n){const t=Math.cos(n),i=Math.sin(n),r=this.x-e.x,a=this.y-e.y;return this.x=r*t-a*i+e.x,this.y=r*i+a*t+e.y,this},random:function(){return this.x=Math.random(),this.y=Math.random(),this}});function Oi(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}Object.assign(Oi.prototype,{isMatrix3:!0,set:function(e,n,t,i,r,a,c,u,l){const f=this.elements;return f[0]=e,f[1]=i,f[2]=c,f[3]=n,f[4]=r,f[5]=u,f[6]=t,f[7]=a,f[8]=l,this},identity:function(){return this.set(1,0,0,0,1,0,0,0,1),this},clone:function(){return new this.constructor().fromArray(this.elements)},copy:function(e){const n=this.elements,t=e.elements;return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],this},extractBasis:function(e,n,t){return e.setFromMatrix3Column(this,0),n.setFromMatrix3Column(this,1),t.setFromMatrix3Column(this,2),this},setFromMatrix4:function(e){const n=e.elements;return this.set(n[0],n[4],n[8],n[1],n[5],n[9],n[2],n[6],n[10]),this},multiply:function(e){return this.multiplyMatrices(this,e)},premultiply:function(e){return this.multiplyMatrices(e,this)},multiplyMatrices:function(e,n){const t=e.elements,i=n.elements,r=this.elements,a=t[0],c=t[3],u=t[6],l=t[1],f=t[4],m=t[7],h=t[2],p=t[5],_=t[8],v=i[0],S=i[3],D=i[6],w=i[1],T=i[4],F=i[7],E=i[2],A=i[5],L=i[8];return r[0]=a*v+c*w+u*E,r[3]=a*S+c*T+u*A,r[6]=a*D+c*F+u*L,r[1]=l*v+f*w+m*E,r[4]=l*S+f*T+m*A,r[7]=l*D+f*F+m*L,r[2]=h*v+p*w+_*E,r[5]=h*S+p*T+_*A,r[8]=h*D+p*F+_*L,this},multiplyScalar:function(e){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=e,n[4]*=e,n[7]*=e,n[2]*=e,n[5]*=e,n[8]*=e,this},determinant:function(){const e=this.elements,n=e[0],t=e[1],i=e[2],r=e[3],a=e[4],c=e[5],u=e[6],l=e[7],f=e[8];return n*a*f-n*c*l-t*r*f+t*c*u+i*r*l-i*a*u},getInverse:function(e,n){n!==void 0&&console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");const t=e.elements,i=this.elements,r=t[0],a=t[1],c=t[2],u=t[3],l=t[4],f=t[5],m=t[6],h=t[7],p=t[8],_=p*l-f*h,v=f*m-p*u,S=h*u-l*m,D=r*_+a*v+c*S;if(D===0)return this.set(0,0,0,0,0,0,0,0,0);const w=1/D;return i[0]=_*w,i[1]=(c*h-p*a)*w,i[2]=(f*a-c*l)*w,i[3]=v*w,i[4]=(p*r-c*m)*w,i[5]=(c*u-f*r)*w,i[6]=S*w,i[7]=(a*m-h*r)*w,i[8]=(l*r-a*u)*w,this},transpose:function(){let e;const n=this.elements;return e=n[1],n[1]=n[3],n[3]=e,e=n[2],n[2]=n[6],n[6]=e,e=n[5],n[5]=n[7],n[7]=e,this},getNormalMatrix:function(e){return this.setFromMatrix4(e).getInverse(this).transpose()},transposeIntoArray:function(e){const n=this.elements;return e[0]=n[0],e[1]=n[3],e[2]=n[6],e[3]=n[1],e[4]=n[4],e[5]=n[7],e[6]=n[2],e[7]=n[5],e[8]=n[8],this},setUvTransform:function(e,n,t,i,r,a,c){const u=Math.cos(r),l=Math.sin(r);this.set(t*u,t*l,-t*(u*a+l*c)+a+e,-i*l,i*u,-i*(-l*a+u*c)+c+n,0,0,1)},scale:function(e,n){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=n,t[4]*=n,t[7]*=n,this},rotate:function(e){const n=Math.cos(e),t=Math.sin(e),i=this.elements,r=i[0],a=i[3],c=i[6],u=i[1],l=i[4],f=i[7];return i[0]=n*r+t*u,i[3]=n*a+t*l,i[6]=n*c+t*f,i[1]=-t*r+n*u,i[4]=-t*a+n*l,i[7]=-t*c+n*f,this},translate:function(e,n){const t=this.elements;return t[0]+=e*t[2],t[3]+=e*t[5],t[6]+=e*t[8],t[1]+=n*t[2],t[4]+=n*t[5],t[7]+=n*t[8],this},equals:function(e){const n=this.elements,t=e.elements;for(let i=0;i<9;i++)if(n[i]!==t[i])return!1;return!0},fromArray:function(e,n){n===void 0&&(n=0);for(let t=0;t<9;t++)this.elements[t]=e[t+n];return this},toArray:function(e,n){e===void 0&&(e=[]),n===void 0&&(n=0);const t=this.elements;return e[n]=t[0],e[n+1]=t[1],e[n+2]=t[2],e[n+3]=t[3],e[n+4]=t[4],e[n+5]=t[5],e[n+6]=t[6],e[n+7]=t[7],e[n+8]=t[8],e}});let ka;const Mo={getDataURL:function(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let n;if(e instanceof HTMLCanvasElement)n=e;else{ka===void 0&&(ka=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),ka.width=e.width,ka.height=e.height;const t=ka.getContext("2d");e instanceof ImageData?t.putImageData(e,0,0):t.drawImage(e,0,0,e.width,e.height),n=ka}return n.width>2048||n.height>2048?n.toDataURL("image/jpeg",.6):n.toDataURL("image/png")}};let p1=0;function Dn(e,n,t,i,r,a,c,u,l,f){Object.defineProperty(this,"id",{value:p1++}),this.uuid=ln.generateUUID(),this.name="",this.image=e!==void 0?e:Dn.DEFAULT_IMAGE,this.mipmaps=[],this.mapping=n!==void 0?n:Dn.DEFAULT_MAPPING,this.wrapS=t!==void 0?t:Ni,this.wrapT=i!==void 0?i:Ni,this.magFilter=r!==void 0?r:Pi,this.minFilter=a!==void 0?a:bg,this.anisotropy=l!==void 0?l:1,this.format=c!==void 0?c:fs,this.internalFormat=null,this.type=u!==void 0?u:Bu,this.offset=new vt(0,0),this.repeat=new vt(1,1),this.center=new vt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Oi,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=f!==void 0?f:Ui,this.version=0,this.onUpdate=null}Dn.DEFAULT_IMAGE=void 0,Dn.DEFAULT_MAPPING=qy,Dn.prototype=Object.assign(Object.create(yr.prototype),{constructor:Dn,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this},toJSON:function(e){const n=e===void 0||typeof e=="string";if(!n&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const t={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const i=this.image;if(i.uuid===void 0&&(i.uuid=ln.generateUUID()),!n&&e.images[i.uuid]===void 0){let r;if(Array.isArray(i)){r=[];for(let a=0,c=i.length;a<c;a++)r.push(Mo.getDataURL(i[a]))}else r=Mo.getDataURL(i);e.images[i.uuid]={uuid:i.uuid,url:r}}t.image=i.uuid}return n||(e.textures[this.uuid]=t),t},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(e){if(this.mapping!==qy)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case wg:e.x=e.x-Math.floor(e.x);break;case Ni:e.x=e.x<0?0:1;break;case xg:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case wg:e.y=e.y-Math.floor(e.y);break;case Ni:e.y=e.y<0?0:1;break;case xg:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}}),Object.defineProperty(Dn.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}});function An(e=0,n=0,t=0,i=1){this.x=e,this.y=n,this.z=t,this.w=i}Object.defineProperties(An.prototype,{width:{get:function(){return this.z},set:function(e){this.z=e}},height:{get:function(){return this.w},set:function(e){this.w=e}}}),Object.assign(An.prototype,{isVector4:!0,set:function(e,n,t,i){return this.x=e,this.y=n,this.z=t,this.w=i,this},setScalar:function(e){return this.x=e,this.y=e,this.z=e,this.w=e,this},setX:function(e){return this.x=e,this},setY:function(e){return this.y=e,this},setZ:function(e){return this.z=e,this},setW:function(e){return this.w=e,this},setComponent:function(e,n){switch(e){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;case 3:this.w=n;break;default:throw new Error("index is out of range: "+e)}return this},getComponent:function(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}},clone:function(){return new this.constructor(this.x,this.y,this.z,this.w)},copy:function(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this},add:function(e,n){return n!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,n)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)},addScalar:function(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this},addVectors:function(e,n){return this.x=e.x+n.x,this.y=e.y+n.y,this.z=e.z+n.z,this.w=e.w+n.w,this},addScaledVector:function(e,n){return this.x+=e.x*n,this.y+=e.y*n,this.z+=e.z*n,this.w+=e.w*n,this},sub:function(e,n){return n!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,n)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)},subScalar:function(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this},subVectors:function(e,n){return this.x=e.x-n.x,this.y=e.y-n.y,this.z=e.z-n.z,this.w=e.w-n.w,this},multiplyScalar:function(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this},applyMatrix4:function(e){const n=this.x,t=this.y,i=this.z,r=this.w,a=e.elements;return this.x=a[0]*n+a[4]*t+a[8]*i+a[12]*r,this.y=a[1]*n+a[5]*t+a[9]*i+a[13]*r,this.z=a[2]*n+a[6]*t+a[10]*i+a[14]*r,this.w=a[3]*n+a[7]*t+a[11]*i+a[15]*r,this},divideScalar:function(e){return this.multiplyScalar(1/e)},setAxisAngleFromQuaternion:function(e){this.w=2*Math.acos(e.w);const n=Math.sqrt(1-e.w*e.w);return n<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/n,this.y=e.y/n,this.z=e.z/n),this},setAxisAngleFromRotationMatrix:function(e){let n,t,i,r;const u=e.elements,l=u[0],f=u[4],m=u[8],h=u[1],p=u[5],_=u[9],v=u[2],S=u[6],D=u[10];if(Math.abs(f-h)<.01&&Math.abs(m-v)<.01&&Math.abs(_-S)<.01){if(Math.abs(f+h)<.1&&Math.abs(m+v)<.1&&Math.abs(_+S)<.1&&Math.abs(l+p+D-3)<.1)return this.set(1,0,0,0),this;n=Math.PI;const T=(l+1)/2,F=(p+1)/2,E=(D+1)/2,A=(f+h)/4,L=(m+v)/4,I=(_+S)/4;return T>F&&T>E?T<.01?(t=0,i=.707106781,r=.707106781):(t=Math.sqrt(T),i=A/t,r=L/t):F>E?F<.01?(t=.707106781,i=0,r=.707106781):(i=Math.sqrt(F),t=A/i,r=I/i):E<.01?(t=.707106781,i=.707106781,r=0):(r=Math.sqrt(E),t=L/r,i=I/r),this.set(t,i,r,n),this}let w=Math.sqrt((S-_)*(S-_)+(m-v)*(m-v)+(h-f)*(h-f));return Math.abs(w)<.001&&(w=1),this.x=(S-_)/w,this.y=(m-v)/w,this.z=(h-f)/w,this.w=Math.acos((l+p+D-1)/2),this},min:function(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this},max:function(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this},clamp:function(e,n){return this.x=Math.max(e.x,Math.min(n.x,this.x)),this.y=Math.max(e.y,Math.min(n.y,this.y)),this.z=Math.max(e.z,Math.min(n.z,this.z)),this.w=Math.max(e.w,Math.min(n.w,this.w)),this},clampScalar:function(e,n){return this.x=Math.max(e,Math.min(n,this.x)),this.y=Math.max(e,Math.min(n,this.y)),this.z=Math.max(e,Math.min(n,this.z)),this.w=Math.max(e,Math.min(n,this.w)),this},clampLength:function(e,n){const t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(e,Math.min(n,t)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this},negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this},dot:function(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(e){return this.normalize().multiplyScalar(e)},lerp:function(e,n){return this.x+=(e.x-this.x)*n,this.y+=(e.y-this.y)*n,this.z+=(e.z-this.z)*n,this.w+=(e.w-this.w)*n,this},lerpVectors:function(e,n,t){return this.x=e.x+(n.x-e.x)*t,this.y=e.y+(n.y-e.y)*t,this.z=e.z+(n.z-e.z)*t,this.w=e.w+(n.w-e.w)*t,this},equals:function(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w},fromArray:function(e,n){return n===void 0&&(n=0),this.x=e[n],this.y=e[n+1],this.z=e[n+2],this.w=e[n+3],this},toArray:function(e,n){return e===void 0&&(e=[]),n===void 0&&(n=0),e[n]=this.x,e[n+1]=this.y,e[n+2]=this.z,e[n+3]=this.w,e},fromBufferAttribute:function(e,n,t){return t!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(n),this.y=e.getY(n),this.z=e.getZ(n),this.w=e.getW(n),this},random:function(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}});function ps(e,n,t){this.width=e,this.height=n,this.scissor=new An(0,0,e,n),this.scissorTest=!1,this.viewport=new An(0,0,e,n),t=t||{},this.texture=new Dn(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=n,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Pi,this.depthBuffer=t.depthBuffer!==void 0?t.depthBuffer:!0,this.stencilBuffer=t.stencilBuffer!==void 0?t.stencilBuffer:!0,this.depthTexture=t.depthTexture!==void 0?t.depthTexture:null}ps.prototype=Object.assign(Object.create(yr.prototype),{constructor:ps,isWebGLRenderTarget:!0,setSize:function(e,n){(this.width!==e||this.height!==n)&&(this.width=e,this.height=n,this.texture.image.width=e,this.texture.image.height=n,this.dispose()),this.viewport.set(0,0,e,n),this.scissor.set(0,0,e,n)},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.width=e.width,this.height=e.height,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});function xw(e,n,t){ps.call(this,e,n,t),this.samples=4}xw.prototype=Object.assign(Object.create(ps.prototype),{constructor:xw,isWebGLMultisampleRenderTarget:!0,copy:function(e){return ps.prototype.copy.call(this,e),this.samples=e.samples,this}});function pi(e=0,n=0,t=0,i=1){this._x=e,this._y=n,this._z=t,this._w=i}Object.assign(pi,{slerp:function(e,n,t,i){return t.copy(e).slerp(n,i)},slerpFlat:function(e,n,t,i,r,a,c){let u=t[i+0],l=t[i+1],f=t[i+2],m=t[i+3];const h=r[a+0],p=r[a+1],_=r[a+2],v=r[a+3];if(m!==v||u!==h||l!==p||f!==_){let S=1-c,D=u*h+l*p+f*_+m*v,w=D>=0?1:-1,T=1-D*D;if(T>Number.EPSILON){const E=Math.sqrt(T),A=Math.atan2(E,D*w);S=Math.sin(S*A)/E,c=Math.sin(c*A)/E}const F=c*w;if(u=u*S+h*F,l=l*S+p*F,f=f*S+_*F,m=m*S+v*F,S===1-c){const E=1/Math.sqrt(u*u+l*l+f*f+m*m);u*=E,l*=E,f*=E,m*=E}}e[n]=u,e[n+1]=l,e[n+2]=f,e[n+3]=m},multiplyQuaternionsFlat:function(e,n,t,i,r,a){const c=t[i],u=t[i+1],l=t[i+2],f=t[i+3],m=r[a],h=r[a+1],p=r[a+2],_=r[a+3];return e[n]=c*_+f*m+u*p-l*h,e[n+1]=u*_+f*h+l*m-c*p,e[n+2]=l*_+f*p+c*h-u*m,e[n+3]=f*_-c*m-u*h-l*p,e}}),Object.defineProperties(pi.prototype,{x:{get:function(){return this._x},set:function(e){this._x=e,this._onChangeCallback()}},y:{get:function(){return this._y},set:function(e){this._y=e,this._onChangeCallback()}},z:{get:function(){return this._z},set:function(e){this._z=e,this._onChangeCallback()}},w:{get:function(){return this._w},set:function(e){this._w=e,this._onChangeCallback()}}}),Object.assign(pi.prototype,{isQuaternion:!0,set:function(e,n,t,i){return this._x=e,this._y=n,this._z=t,this._w=i,this._onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._w)},copy:function(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this},setFromEuler:function(e,n){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const t=e._x,i=e._y,r=e._z,a=e.order,c=Math.cos,u=Math.sin,l=c(t/2),f=c(i/2),m=c(r/2),h=u(t/2),p=u(i/2),_=u(r/2);switch(a){case"XYZ":this._x=h*f*m+l*p*_,this._y=l*p*m-h*f*_,this._z=l*f*_+h*p*m,this._w=l*f*m-h*p*_;break;case"YXZ":this._x=h*f*m+l*p*_,this._y=l*p*m-h*f*_,this._z=l*f*_-h*p*m,this._w=l*f*m+h*p*_;break;case"ZXY":this._x=h*f*m-l*p*_,this._y=l*p*m+h*f*_,this._z=l*f*_+h*p*m,this._w=l*f*m-h*p*_;break;case"ZYX":this._x=h*f*m-l*p*_,this._y=l*p*m+h*f*_,this._z=l*f*_-h*p*m,this._w=l*f*m+h*p*_;break;case"YZX":this._x=h*f*m+l*p*_,this._y=l*p*m+h*f*_,this._z=l*f*_-h*p*m,this._w=l*f*m-h*p*_;break;case"XZY":this._x=h*f*m-l*p*_,this._y=l*p*m-h*f*_,this._z=l*f*_+h*p*m,this._w=l*f*m+h*p*_;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return n!==!1&&this._onChangeCallback(),this},setFromAxisAngle:function(e,n){const t=n/2,i=Math.sin(t);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(t),this._onChangeCallback(),this},setFromRotationMatrix:function(e){const n=e.elements,t=n[0],i=n[4],r=n[8],a=n[1],c=n[5],u=n[9],l=n[2],f=n[6],m=n[10],h=t+c+m;if(h>0){const p=.5/Math.sqrt(h+1);this._w=.25/p,this._x=(f-u)*p,this._y=(r-l)*p,this._z=(a-i)*p}else if(t>c&&t>m){const p=2*Math.sqrt(1+t-c-m);this._w=(f-u)/p,this._x=.25*p,this._y=(i+a)/p,this._z=(r+l)/p}else if(c>m){const p=2*Math.sqrt(1+c-t-m);this._w=(r-l)/p,this._x=(i+a)/p,this._y=.25*p,this._z=(u+f)/p}else{const p=2*Math.sqrt(1+m-t-c);this._w=(a-i)/p,this._x=(r+l)/p,this._y=(u+f)/p,this._z=.25*p}return this._onChangeCallback(),this},setFromUnitVectors:function(e,n){let i=e.dot(n)+1;return i<1e-6?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*n.z-e.z*n.y,this._y=e.z*n.x-e.x*n.z,this._z=e.x*n.y-e.y*n.x,this._w=i),this.normalize()},angleTo:function(e){return 2*Math.acos(Math.abs(ln.clamp(this.dot(e),-1,1)))},rotateTowards:function(e,n){const t=this.angleTo(e);if(t===0)return this;const i=Math.min(1,n/t);return this.slerp(e,i),this},identity:function(){return this.set(0,0,0,1)},inverse:function(){return this.conjugate()},conjugate:function(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this},dot:function(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this},multiply:function(e,n){return n!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,n)):this.multiplyQuaternions(this,e)},premultiply:function(e){return this.multiplyQuaternions(e,this)},multiplyQuaternions:function(e,n){const t=e._x,i=e._y,r=e._z,a=e._w,c=n._x,u=n._y,l=n._z,f=n._w;return this._x=t*f+a*c+i*l-r*u,this._y=i*f+a*u+r*c-t*l,this._z=r*f+a*l+t*u-i*c,this._w=a*f-t*c-i*u-r*l,this._onChangeCallback(),this},slerp:function(e,n){if(n===0)return this;if(n===1)return this.copy(e);const t=this._x,i=this._y,r=this._z,a=this._w;let c=a*e._w+t*e._x+i*e._y+r*e._z;if(c<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,c=-c):this.copy(e),c>=1)return this._w=a,this._x=t,this._y=i,this._z=r,this;const u=1-c*c;if(u<=Number.EPSILON){const p=1-n;return this._w=p*a+n*this._w,this._x=p*t+n*this._x,this._y=p*i+n*this._y,this._z=p*r+n*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(u),f=Math.atan2(l,c),m=Math.sin((1-n)*f)/l,h=Math.sin(n*f)/l;return this._w=a*m+this._w*h,this._x=t*m+this._x*h,this._y=i*m+this._y*h,this._z=r*m+this._z*h,this._onChangeCallback(),this},equals:function(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w},fromArray:function(e,n){return n===void 0&&(n=0),this._x=e[n],this._y=e[n+1],this._z=e[n+2],this._w=e[n+3],this._onChangeCallback(),this},toArray:function(e,n){return e===void 0&&(e=[]),n===void 0&&(n=0),e[n]=this._x,e[n+1]=this._y,e[n+2]=this._z,e[n+3]=this._w,e},fromBufferAttribute:function(e,n){return this._x=e.getX(n),this._y=e.getY(n),this._z=e.getZ(n),this._w=e.getW(n),this},_onChange:function(e){return this._onChangeCallback=e,this},_onChangeCallback:function(){}});const sv=new ye,bw=new pi;function ye(e=0,n=0,t=0){this.x=e,this.y=n,this.z=t}Object.assign(ye.prototype,{isVector3:!0,set:function(e,n,t){return t===void 0&&(t=this.z),this.x=e,this.y=n,this.z=t,this},setScalar:function(e){return this.x=e,this.y=e,this.z=e,this},setX:function(e){return this.x=e,this},setY:function(e){return this.y=e,this},setZ:function(e){return this.z=e,this},setComponent:function(e,n){switch(e){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;default:throw new Error("index is out of range: "+e)}return this},getComponent:function(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}},clone:function(){return new this.constructor(this.x,this.y,this.z)},copy:function(e){return this.x=e.x,this.y=e.y,this.z=e.z,this},add:function(e,n){return n!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,n)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)},addScalar:function(e){return this.x+=e,this.y+=e,this.z+=e,this},addVectors:function(e,n){return this.x=e.x+n.x,this.y=e.y+n.y,this.z=e.z+n.z,this},addScaledVector:function(e,n){return this.x+=e.x*n,this.y+=e.y*n,this.z+=e.z*n,this},sub:function(e,n){return n!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,n)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)},subScalar:function(e){return this.x-=e,this.y-=e,this.z-=e,this},subVectors:function(e,n){return this.x=e.x-n.x,this.y=e.y-n.y,this.z=e.z-n.z,this},multiply:function(e,n){return n!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,n)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)},multiplyScalar:function(e){return this.x*=e,this.y*=e,this.z*=e,this},multiplyVectors:function(e,n){return this.x=e.x*n.x,this.y=e.y*n.y,this.z=e.z*n.z,this},applyEuler:function(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(bw.setFromEuler(e))},applyAxisAngle:function(e,n){return this.applyQuaternion(bw.setFromAxisAngle(e,n))},applyMatrix3:function(e){const n=this.x,t=this.y,i=this.z,r=e.elements;return this.x=r[0]*n+r[3]*t+r[6]*i,this.y=r[1]*n+r[4]*t+r[7]*i,this.z=r[2]*n+r[5]*t+r[8]*i,this},applyNormalMatrix:function(e){return this.applyMatrix3(e).normalize()},applyMatrix4:function(e){const n=this.x,t=this.y,i=this.z,r=e.elements,a=1/(r[3]*n+r[7]*t+r[11]*i+r[15]);return this.x=(r[0]*n+r[4]*t+r[8]*i+r[12])*a,this.y=(r[1]*n+r[5]*t+r[9]*i+r[13])*a,this.z=(r[2]*n+r[6]*t+r[10]*i+r[14])*a,this},applyQuaternion:function(e){const n=this.x,t=this.y,i=this.z,r=e.x,a=e.y,c=e.z,u=e.w,l=u*n+a*i-c*t,f=u*t+c*n-r*i,m=u*i+r*t-a*n,h=-r*n-a*t-c*i;return this.x=l*u+h*-r+f*-c-m*-a,this.y=f*u+h*-a+m*-r-l*-c,this.z=m*u+h*-c+l*-a-f*-r,this},project:function(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)},unproject:function(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)},transformDirection:function(e){const n=this.x,t=this.y,i=this.z,r=e.elements;return this.x=r[0]*n+r[4]*t+r[8]*i,this.y=r[1]*n+r[5]*t+r[9]*i,this.z=r[2]*n+r[6]*t+r[10]*i,this.normalize()},divide:function(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this},divideScalar:function(e){return this.multiplyScalar(1/e)},min:function(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this},max:function(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this},clamp:function(e,n){return this.x=Math.max(e.x,Math.min(n.x,this.x)),this.y=Math.max(e.y,Math.min(n.y,this.y)),this.z=Math.max(e.z,Math.min(n.z,this.z)),this},clampScalar:function(e,n){return this.x=Math.max(e,Math.min(n,this.x)),this.y=Math.max(e,Math.min(n,this.y)),this.z=Math.max(e,Math.min(n,this.z)),this},clampLength:function(e,n){const t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(e,Math.min(n,t)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this},negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this},dot:function(e){return this.x*e.x+this.y*e.y+this.z*e.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(e){return this.normalize().multiplyScalar(e)},lerp:function(e,n){return this.x+=(e.x-this.x)*n,this.y+=(e.y-this.y)*n,this.z+=(e.z-this.z)*n,this},lerpVectors:function(e,n,t){return this.x=e.x+(n.x-e.x)*t,this.y=e.y+(n.y-e.y)*t,this.z=e.z+(n.z-e.z)*t,this},cross:function(e,n){return n!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,n)):this.crossVectors(this,e)},crossVectors:function(e,n){const t=e.x,i=e.y,r=e.z,a=n.x,c=n.y,u=n.z;return this.x=i*u-r*c,this.y=r*a-t*u,this.z=t*c-i*a,this},projectOnVector:function(e){const n=e.lengthSq();if(n===0)return this.set(0,0,0);const t=e.dot(this)/n;return this.copy(e).multiplyScalar(t)},projectOnPlane:function(e){return sv.copy(this).projectOnVector(e),this.sub(sv)},reflect:function(e){return this.sub(sv.copy(e).multiplyScalar(2*this.dot(e)))},angleTo:function(e){const n=Math.sqrt(this.lengthSq()*e.lengthSq());if(n===0)return Math.PI/2;const t=this.dot(e)/n;return Math.acos(ln.clamp(t,-1,1))},distanceTo:function(e){return Math.sqrt(this.distanceToSquared(e))},distanceToSquared:function(e){const n=this.x-e.x,t=this.y-e.y,i=this.z-e.z;return n*n+t*t+i*i},manhattanDistanceTo:function(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)},setFromSpherical:function(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)},setFromSphericalCoords:function(e,n,t){const i=Math.sin(n)*e;return this.x=i*Math.sin(t),this.y=Math.cos(n)*e,this.z=i*Math.cos(t),this},setFromCylindrical:function(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)},setFromCylindricalCoords:function(e,n,t){return this.x=e*Math.sin(n),this.y=t,this.z=e*Math.cos(n),this},setFromMatrixPosition:function(e){const n=e.elements;return this.x=n[12],this.y=n[13],this.z=n[14],this},setFromMatrixScale:function(e){const n=this.setFromMatrixColumn(e,0).length(),t=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=n,this.y=t,this.z=i,this},setFromMatrixColumn:function(e,n){return this.fromArray(e.elements,n*4)},setFromMatrix3Column:function(e,n){return this.fromArray(e.elements,n*3)},equals:function(e){return e.x===this.x&&e.y===this.y&&e.z===this.z},fromArray:function(e,n){return n===void 0&&(n=0),this.x=e[n],this.y=e[n+1],this.z=e[n+2],this},toArray:function(e,n){return e===void 0&&(e=[]),n===void 0&&(n=0),e[n]=this.x,e[n+1]=this.y,e[n+2]=this.z,e},fromBufferAttribute:function(e,n,t){return t!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(n),this.y=e.getY(n),this.z=e.getZ(n),this},random:function(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}});const Oa=new ye,Cs=new dn,m1=new ye(0,0,0),g1=new ye(1,1,1),Ur=new ye,Dg=new ye,Qi=new ye;function dn(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}Object.assign(dn.prototype,{isMatrix4:!0,set:function(e,n,t,i,r,a,c,u,l,f,m,h,p,_,v,S){const D=this.elements;return D[0]=e,D[4]=n,D[8]=t,D[12]=i,D[1]=r,D[5]=a,D[9]=c,D[13]=u,D[2]=l,D[6]=f,D[10]=m,D[14]=h,D[3]=p,D[7]=_,D[11]=v,D[15]=S,this},identity:function(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this},clone:function(){return new dn().fromArray(this.elements)},copy:function(e){const n=this.elements,t=e.elements;return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],this},copyPosition:function(e){const n=this.elements,t=e.elements;return n[12]=t[12],n[13]=t[13],n[14]=t[14],this},extractBasis:function(e,n,t){return e.setFromMatrixColumn(this,0),n.setFromMatrixColumn(this,1),t.setFromMatrixColumn(this,2),this},makeBasis:function(e,n,t){return this.set(e.x,n.x,t.x,0,e.y,n.y,t.y,0,e.z,n.z,t.z,0,0,0,0,1),this},extractRotation:function(e){const n=this.elements,t=e.elements,i=1/Oa.setFromMatrixColumn(e,0).length(),r=1/Oa.setFromMatrixColumn(e,1).length(),a=1/Oa.setFromMatrixColumn(e,2).length();return n[0]=t[0]*i,n[1]=t[1]*i,n[2]=t[2]*i,n[3]=0,n[4]=t[4]*r,n[5]=t[5]*r,n[6]=t[6]*r,n[7]=0,n[8]=t[8]*a,n[9]=t[9]*a,n[10]=t[10]*a,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this},makeRotationFromEuler:function(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const n=this.elements,t=e.x,i=e.y,r=e.z,a=Math.cos(t),c=Math.sin(t),u=Math.cos(i),l=Math.sin(i),f=Math.cos(r),m=Math.sin(r);if(e.order==="XYZ"){const h=a*f,p=a*m,_=c*f,v=c*m;n[0]=u*f,n[4]=-u*m,n[8]=l,n[1]=p+_*l,n[5]=h-v*l,n[9]=-c*u,n[2]=v-h*l,n[6]=_+p*l,n[10]=a*u}else if(e.order==="YXZ"){const h=u*f,p=u*m,_=l*f,v=l*m;n[0]=h+v*c,n[4]=_*c-p,n[8]=a*l,n[1]=a*m,n[5]=a*f,n[9]=-c,n[2]=p*c-_,n[6]=v+h*c,n[10]=a*u}else if(e.order==="ZXY"){const h=u*f,p=u*m,_=l*f,v=l*m;n[0]=h-v*c,n[4]=-a*m,n[8]=_+p*c,n[1]=p+_*c,n[5]=a*f,n[9]=v-h*c,n[2]=-a*l,n[6]=c,n[10]=a*u}else if(e.order==="ZYX"){const h=a*f,p=a*m,_=c*f,v=c*m;n[0]=u*f,n[4]=_*l-p,n[8]=h*l+v,n[1]=u*m,n[5]=v*l+h,n[9]=p*l-_,n[2]=-l,n[6]=c*u,n[10]=a*u}else if(e.order==="YZX"){const h=a*u,p=a*l,_=c*u,v=c*l;n[0]=u*f,n[4]=v-h*m,n[8]=_*m+p,n[1]=m,n[5]=a*f,n[9]=-c*f,n[2]=-l*f,n[6]=p*m+_,n[10]=h-v*m}else if(e.order==="XZY"){const h=a*u,p=a*l,_=c*u,v=c*l;n[0]=u*f,n[4]=-m,n[8]=l*f,n[1]=h*m+v,n[5]=a*f,n[9]=p*m-_,n[2]=_*m-p,n[6]=c*f,n[10]=v*m+h}return n[3]=0,n[7]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this},makeRotationFromQuaternion:function(e){return this.compose(m1,e,g1)},lookAt:function(e,n,t){const i=this.elements;return Qi.subVectors(e,n),Qi.lengthSq()===0&&(Qi.z=1),Qi.normalize(),Ur.crossVectors(t,Qi),Ur.lengthSq()===0&&(Math.abs(t.z)===1?Qi.x+=1e-4:Qi.z+=1e-4,Qi.normalize(),Ur.crossVectors(t,Qi)),Ur.normalize(),Dg.crossVectors(Qi,Ur),i[0]=Ur.x,i[4]=Dg.x,i[8]=Qi.x,i[1]=Ur.y,i[5]=Dg.y,i[9]=Qi.y,i[2]=Ur.z,i[6]=Dg.z,i[10]=Qi.z,this},multiply:function(e,n){return n!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,n)):this.multiplyMatrices(this,e)},premultiply:function(e){return this.multiplyMatrices(e,this)},multiplyMatrices:function(e,n){const t=e.elements,i=n.elements,r=this.elements,a=t[0],c=t[4],u=t[8],l=t[12],f=t[1],m=t[5],h=t[9],p=t[13],_=t[2],v=t[6],S=t[10],D=t[14],w=t[3],T=t[7],F=t[11],E=t[15],A=i[0],L=i[4],I=i[8],R=i[12],N=i[1],q=i[5],ne=i[9],Q=i[13],W=i[2],te=i[6],K=i[10],pe=i[14],be=i[3],Ee=i[7],Ge=i[11],_e=i[15];return r[0]=a*A+c*N+u*W+l*be,r[4]=a*L+c*q+u*te+l*Ee,r[8]=a*I+c*ne+u*K+l*Ge,r[12]=a*R+c*Q+u*pe+l*_e,r[1]=f*A+m*N+h*W+p*be,r[5]=f*L+m*q+h*te+p*Ee,r[9]=f*I+m*ne+h*K+p*Ge,r[13]=f*R+m*Q+h*pe+p*_e,r[2]=_*A+v*N+S*W+D*be,r[6]=_*L+v*q+S*te+D*Ee,r[10]=_*I+v*ne+S*K+D*Ge,r[14]=_*R+v*Q+S*pe+D*_e,r[3]=w*A+T*N+F*W+E*be,r[7]=w*L+T*q+F*te+E*Ee,r[11]=w*I+T*ne+F*K+E*Ge,r[15]=w*R+T*Q+F*pe+E*_e,this},multiplyScalar:function(e){const n=this.elements;return n[0]*=e,n[4]*=e,n[8]*=e,n[12]*=e,n[1]*=e,n[5]*=e,n[9]*=e,n[13]*=e,n[2]*=e,n[6]*=e,n[10]*=e,n[14]*=e,n[3]*=e,n[7]*=e,n[11]*=e,n[15]*=e,this},determinant:function(){const e=this.elements,n=e[0],t=e[4],i=e[8],r=e[12],a=e[1],c=e[5],u=e[9],l=e[13],f=e[2],m=e[6],h=e[10],p=e[14],_=e[3],v=e[7],S=e[11],D=e[15];return _*(+r*u*m-i*l*m-r*c*h+t*l*h+i*c*p-t*u*p)+v*(+n*u*p-n*l*h+r*a*h-i*a*p+i*l*f-r*u*f)+S*(+n*l*m-n*c*p-r*a*m+t*a*p+r*c*f-t*l*f)+D*(-i*c*f-n*u*m+n*c*h+i*a*m-t*a*h+t*u*f)},transpose:function(){const e=this.elements;let n;return n=e[1],e[1]=e[4],e[4]=n,n=e[2],e[2]=e[8],e[8]=n,n=e[6],e[6]=e[9],e[9]=n,n=e[3],e[3]=e[12],e[12]=n,n=e[7],e[7]=e[13],e[13]=n,n=e[11],e[11]=e[14],e[14]=n,this},setPosition:function(e,n,t){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=n,i[14]=t),this},getInverse:function(e,n){n!==void 0&&console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");const t=this.elements,i=e.elements,r=i[0],a=i[1],c=i[2],u=i[3],l=i[4],f=i[5],m=i[6],h=i[7],p=i[8],_=i[9],v=i[10],S=i[11],D=i[12],w=i[13],T=i[14],F=i[15],E=_*T*h-w*v*h+w*m*S-f*T*S-_*m*F+f*v*F,A=D*v*h-p*T*h-D*m*S+l*T*S+p*m*F-l*v*F,L=p*w*h-D*_*h+D*f*S-l*w*S-p*f*F+l*_*F,I=D*_*m-p*w*m-D*f*v+l*w*v+p*f*T-l*_*T,R=r*E+a*A+c*L+u*I;if(R===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const N=1/R;return t[0]=E*N,t[1]=(w*v*u-_*T*u-w*c*S+a*T*S+_*c*F-a*v*F)*N,t[2]=(f*T*u-w*m*u+w*c*h-a*T*h-f*c*F+a*m*F)*N,t[3]=(_*m*u-f*v*u-_*c*h+a*v*h+f*c*S-a*m*S)*N,t[4]=A*N,t[5]=(p*T*u-D*v*u+D*c*S-r*T*S-p*c*F+r*v*F)*N,t[6]=(D*m*u-l*T*u-D*c*h+r*T*h+l*c*F-r*m*F)*N,t[7]=(l*v*u-p*m*u+p*c*h-r*v*h-l*c*S+r*m*S)*N,t[8]=L*N,t[9]=(D*_*u-p*w*u-D*a*S+r*w*S+p*a*F-r*_*F)*N,t[10]=(l*w*u-D*f*u+D*a*h-r*w*h-l*a*F+r*f*F)*N,t[11]=(p*f*u-l*_*u-p*a*h+r*_*h+l*a*S-r*f*S)*N,t[12]=I*N,t[13]=(p*w*c-D*_*c+D*a*v-r*w*v-p*a*T+r*_*T)*N,t[14]=(D*f*c-l*w*c-D*a*m+r*w*m+l*a*T-r*f*T)*N,t[15]=(l*_*c-p*f*c+p*a*m-r*_*m-l*a*v+r*f*v)*N,this},scale:function(e){const n=this.elements,t=e.x,i=e.y,r=e.z;return n[0]*=t,n[4]*=i,n[8]*=r,n[1]*=t,n[5]*=i,n[9]*=r,n[2]*=t,n[6]*=i,n[10]*=r,n[3]*=t,n[7]*=i,n[11]*=r,this},getMaxScaleOnAxis:function(){const e=this.elements,n=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],t=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(n,t,i))},makeTranslation:function(e,n,t){return this.set(1,0,0,e,0,1,0,n,0,0,1,t,0,0,0,1),this},makeRotationX:function(e){const n=Math.cos(e),t=Math.sin(e);return this.set(1,0,0,0,0,n,-t,0,0,t,n,0,0,0,0,1),this},makeRotationY:function(e){const n=Math.cos(e),t=Math.sin(e);return this.set(n,0,t,0,0,1,0,0,-t,0,n,0,0,0,0,1),this},makeRotationZ:function(e){const n=Math.cos(e),t=Math.sin(e);return this.set(n,-t,0,0,t,n,0,0,0,0,1,0,0,0,0,1),this},makeRotationAxis:function(e,n){const t=Math.cos(n),i=Math.sin(n),r=1-t,a=e.x,c=e.y,u=e.z,l=r*a,f=r*c;return this.set(l*a+t,l*c-i*u,l*u+i*c,0,l*c+i*u,f*c+t,f*u-i*a,0,l*u-i*c,f*u+i*a,r*u*u+t,0,0,0,0,1),this},makeScale:function(e,n,t){return this.set(e,0,0,0,0,n,0,0,0,0,t,0,0,0,0,1),this},makeShear:function(e,n,t){return this.set(1,n,t,0,e,1,t,0,e,n,1,0,0,0,0,1),this},compose:function(e,n,t){const i=this.elements,r=n._x,a=n._y,c=n._z,u=n._w,l=r+r,f=a+a,m=c+c,h=r*l,p=r*f,_=r*m,v=a*f,S=a*m,D=c*m,w=u*l,T=u*f,F=u*m,E=t.x,A=t.y,L=t.z;return i[0]=(1-(v+D))*E,i[1]=(p+F)*E,i[2]=(_-T)*E,i[3]=0,i[4]=(p-F)*A,i[5]=(1-(h+D))*A,i[6]=(S+w)*A,i[7]=0,i[8]=(_+T)*L,i[9]=(S-w)*L,i[10]=(1-(h+v))*L,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this},decompose:function(e,n,t){const i=this.elements;let r=Oa.set(i[0],i[1],i[2]).length(),a=Oa.set(i[4],i[5],i[6]).length(),c=Oa.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),e.x=i[12],e.y=i[13],e.z=i[14],Cs.copy(this);const l=1/r,f=1/a,m=1/c;return Cs.elements[0]*=l,Cs.elements[1]*=l,Cs.elements[2]*=l,Cs.elements[4]*=f,Cs.elements[5]*=f,Cs.elements[6]*=f,Cs.elements[8]*=m,Cs.elements[9]*=m,Cs.elements[10]*=m,n.setFromRotationMatrix(Cs),t.x=r,t.y=a,t.z=c,this},makePerspective:function(e,n,t,i,r,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const c=this.elements,u=2*r/(n-e),l=2*r/(t-i),f=(n+e)/(n-e),m=(t+i)/(t-i),h=-(a+r)/(a-r),p=-2*a*r/(a-r);return c[0]=u,c[4]=0,c[8]=f,c[12]=0,c[1]=0,c[5]=l,c[9]=m,c[13]=0,c[2]=0,c[6]=0,c[10]=h,c[14]=p,c[3]=0,c[7]=0,c[11]=-1,c[15]=0,this},makeOrthographic:function(e,n,t,i,r,a){const c=this.elements,u=1/(n-e),l=1/(t-i),f=1/(a-r),m=(n+e)*u,h=(t+i)*l,p=(a+r)*f;return c[0]=2*u,c[4]=0,c[8]=0,c[12]=-m,c[1]=0,c[5]=2*l,c[9]=0,c[13]=-h,c[2]=0,c[6]=0,c[10]=-2*f,c[14]=-p,c[3]=0,c[7]=0,c[11]=0,c[15]=1,this},equals:function(e){const n=this.elements,t=e.elements;for(let i=0;i<16;i++)if(n[i]!==t[i])return!1;return!0},fromArray:function(e,n){n===void 0&&(n=0);for(let t=0;t<16;t++)this.elements[t]=e[t+n];return this},toArray:function(e,n){e===void 0&&(e=[]),n===void 0&&(n=0);const t=this.elements;return e[n]=t[0],e[n+1]=t[1],e[n+2]=t[2],e[n+3]=t[3],e[n+4]=t[4],e[n+5]=t[5],e[n+6]=t[6],e[n+7]=t[7],e[n+8]=t[8],e[n+9]=t[9],e[n+10]=t[10],e[n+11]=t[11],e[n+12]=t[12],e[n+13]=t[13],e[n+14]=t[14],e[n+15]=t[15],e}});const Mw=new dn,Tw=new pi;function Fa(e=0,n=0,t=0,i=Fa.DefaultOrder){this._x=e,this._y=n,this._z=t,this._order=i}Fa.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"],Fa.DefaultOrder="XYZ",Object.defineProperties(Fa.prototype,{x:{get:function(){return this._x},set:function(e){this._x=e,this._onChangeCallback()}},y:{get:function(){return this._y},set:function(e){this._y=e,this._onChangeCallback()}},z:{get:function(){return this._z},set:function(e){this._z=e,this._onChangeCallback()}},order:{get:function(){return this._order},set:function(e){this._order=e,this._onChangeCallback()}}}),Object.assign(Fa.prototype,{isEuler:!0,set:function(e,n,t,i){return this._x=e,this._y=n,this._z=t,this._order=i||this._order,this._onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._order)},copy:function(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this},setFromRotationMatrix:function(e,n,t){const i=ln.clamp,r=e.elements,a=r[0],c=r[4],u=r[8],l=r[1],f=r[5],m=r[9],h=r[2],p=r[6],_=r[10];switch(n=n||this._order,n){case"XYZ":this._y=Math.asin(i(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(-m,_),this._z=Math.atan2(-c,a)):(this._x=Math.atan2(p,f),this._z=0);break;case"YXZ":this._x=Math.asin(-i(m,-1,1)),Math.abs(m)<.9999999?(this._y=Math.atan2(u,_),this._z=Math.atan2(l,f)):(this._y=Math.atan2(-h,a),this._z=0);break;case"ZXY":this._x=Math.asin(i(p,-1,1)),Math.abs(p)<.9999999?(this._y=Math.atan2(-h,_),this._z=Math.atan2(-c,f)):(this._y=0,this._z=Math.atan2(l,a));break;case"ZYX":this._y=Math.asin(-i(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(p,_),this._z=Math.atan2(l,a)):(this._x=0,this._z=Math.atan2(-c,f));break;case"YZX":this._z=Math.asin(i(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-m,f),this._y=Math.atan2(-h,a)):(this._x=0,this._y=Math.atan2(u,_));break;case"XZY":this._z=Math.asin(-i(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(p,f),this._y=Math.atan2(u,a)):(this._x=Math.atan2(-m,_),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+n)}return this._order=n,t!==!1&&this._onChangeCallback(),this},setFromQuaternion:function(e,n,t){return Mw.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Mw,n,t)},setFromVector3:function(e,n){return this.set(e.x,e.y,e.z,n||this._order)},reorder:function(e){return Tw.setFromEuler(this),this.setFromQuaternion(Tw,e)},equals:function(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order},fromArray:function(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this},toArray:function(e,n){return e===void 0&&(e=[]),n===void 0&&(n=0),e[n]=this._x,e[n+1]=this._y,e[n+2]=this._z,e[n+3]=this._order,e},toVector3:function(e){return e?e.set(this._x,this._y,this._z):new ye(this._x,this._y,this._z)},_onChange:function(e){return this._onChangeCallback=e,this},_onChangeCallback:function(){}});function rv(){this.mask=1}Object.assign(rv.prototype,{set:function(e){this.mask=1<<e|0},enable:function(e){this.mask|=1<<e|0},enableAll:function(){this.mask=-1},toggle:function(e){this.mask^=1<<e|0},disable:function(e){this.mask&=~(1<<e|0)},disableAll:function(){this.mask=0},test:function(e){return(this.mask&e.mask)!==0}});let _1=0;const Ew=new ye,Ra=new pi,vr=new dn,kg=new ye,Uu=new ye,y1=new ye,v1=new pi,Sw=new ye(1,0,0),Pw=new ye(0,1,0),Aw=new ye(0,0,1),w1={type:"added"},x1={type:"removed"};function Ot(){Object.defineProperty(this,"id",{value:_1++}),this.uuid=ln.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Ot.DefaultUp.clone();const e=new ye,n=new Fa,t=new pi,i=new ye(1,1,1);function r(){t.setFromEuler(n,!1)}function a(){n.setFromQuaternion(t,void 0,!1)}n._onChange(r),t._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:n},quaternion:{configurable:!0,enumerable:!0,value:t},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new dn},normalMatrix:{value:new Oi}}),this.matrix=new dn,this.matrixWorld=new dn,this.matrixAutoUpdate=Ot.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new rv,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.userData={}}Ot.DefaultUp=new ye(0,1,0),Ot.DefaultMatrixAutoUpdate=!0,Ot.prototype=Object.assign(Object.create(yr.prototype),{constructor:Ot,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(e){return this.quaternion.premultiply(e),this},setRotationFromAxisAngle:function(e,n){this.quaternion.setFromAxisAngle(e,n)},setRotationFromEuler:function(e){this.quaternion.setFromEuler(e,!0)},setRotationFromMatrix:function(e){this.quaternion.setFromRotationMatrix(e)},setRotationFromQuaternion:function(e){this.quaternion.copy(e)},rotateOnAxis:function(e,n){return Ra.setFromAxisAngle(e,n),this.quaternion.multiply(Ra),this},rotateOnWorldAxis:function(e,n){return Ra.setFromAxisAngle(e,n),this.quaternion.premultiply(Ra),this},rotateX:function(e){return this.rotateOnAxis(Sw,e)},rotateY:function(e){return this.rotateOnAxis(Pw,e)},rotateZ:function(e){return this.rotateOnAxis(Aw,e)},translateOnAxis:function(e,n){return Ew.copy(e).applyQuaternion(this.quaternion),this.position.add(Ew.multiplyScalar(n)),this},translateX:function(e){return this.translateOnAxis(Sw,e)},translateY:function(e){return this.translateOnAxis(Pw,e)},translateZ:function(e){return this.translateOnAxis(Aw,e)},localToWorld:function(e){return e.applyMatrix4(this.matrixWorld)},worldToLocal:function(e){return e.applyMatrix4(vr.getInverse(this.matrixWorld))},lookAt:function(e,n,t){e.isVector3?kg.copy(e):kg.set(e,n,t);const i=this.parent;this.updateWorldMatrix(!0,!1),Uu.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?vr.lookAt(Uu,kg,this.up):vr.lookAt(kg,Uu,this.up),this.quaternion.setFromRotationMatrix(vr),i&&(vr.extractRotation(i.matrixWorld),Ra.setFromRotationMatrix(vr),this.quaternion.premultiply(Ra.inverse()))},add:function(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.add(arguments[n]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(w1)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)},remove:function(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const n=this.children.indexOf(e);return n!==-1&&(e.parent=null,this.children.splice(n,1),e.dispatchEvent(x1)),this},attach:function(e){return this.updateWorldMatrix(!0,!1),vr.getInverse(this.matrixWorld),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),vr.multiply(e.parent.matrixWorld)),e.applyMatrix4(vr),e.updateWorldMatrix(!1,!1),this.add(e),this},getObjectById:function(e){return this.getObjectByProperty("id",e)},getObjectByName:function(e){return this.getObjectByProperty("name",e)},getObjectByProperty:function(e,n){if(this[e]===n)return this;for(let t=0,i=this.children.length;t<i;t++){const a=this.children[t].getObjectByProperty(e,n);if(a!==void 0)return a}},getWorldPosition:function(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),e=new ye),this.updateMatrixWorld(!0),e.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),e=new pi),this.updateMatrixWorld(!0),this.matrixWorld.decompose(Uu,e,y1),e},getWorldScale:function(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),e=new ye),this.updateMatrixWorld(!0),this.matrixWorld.decompose(Uu,v1,e),e},getWorldDirection:function(e){e===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),e=new ye),this.updateMatrixWorld(!0);const n=this.matrixWorld.elements;return e.set(n[8],n[9],n[10]).normalize()},raycast:function(){},traverse:function(e){e(this);const n=this.children;for(let t=0,i=n.length;t<i;t++)n[t].traverse(e)},traverseVisible:function(e){if(this.visible===!1)return;e(this);const n=this.children;for(let t=0,i=n.length;t<i;t++)n[t].traverseVisible(e)},traverseAncestors:function(e){const n=this.parent;n!==null&&(e(n),n.traverseAncestors(e))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const n=this.children;for(let t=0,i=n.length;t<i;t++)n[t].updateMatrixWorld(e)},updateWorldMatrix:function(e,n){const t=this.parent;if(e===!0&&t!==null&&t.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),n===!0){const i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].updateWorldMatrix(!1,!0)}},toJSON:function(e){const n=e===void 0||typeof e=="string",t={};n&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{}},t.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON());function r(c,u){return c[u.uuid]===void 0&&(c[u.uuid]=u.toJSON(e)),u.uuid}if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);const c=this.geometry.parameters;if(c!==void 0&&c.shapes!==void 0){const u=c.shapes;if(Array.isArray(u))for(let l=0,f=u.length;l<f;l++){const m=u[l];r(e.shapes,m)}else r(e.shapes,u)}}if(this.material!==void 0)if(Array.isArray(this.material)){const c=[];for(let u=0,l=this.material.length;u<l;u++)c.push(r(e.materials,this.material[u]));i.material=c}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let c=0;c<this.children.length;c++)i.children.push(this.children[c].toJSON(e).object)}if(n){const c=a(e.geometries),u=a(e.materials),l=a(e.textures),f=a(e.images),m=a(e.shapes);c.length>0&&(t.geometries=c),u.length>0&&(t.materials=u),l.length>0&&(t.textures=l),f.length>0&&(t.images=f),m.length>0&&(t.shapes=m)}return t.object=i,t;function a(c){const u=[];for(const l in c){const f=c[l];delete f.metadata,u.push(f)}return u}},clone:function(e){return new this.constructor().copy(this,e)},copy:function(e,n){if(n===void 0&&(n=!0),this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),n===!0)for(let t=0;t<e.children.length;t++){const i=e.children[t];this.add(i.clone())}return this}});function Gu(){Ot.call(this),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}Gu.prototype=Object.assign(Object.create(Ot.prototype),{constructor:Gu,isScene:!0,copy:function(e,n){return Ot.prototype.copy.call(this,e,n),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this},toJSON:function(e){const n=Ot.prototype.toJSON.call(this,e);return this.background!==null&&(n.object.background=this.background.toJSON(e)),this.environment!==null&&(n.object.environment=this.environment.toJSON(e)),this.fog!==null&&(n.object.fog=this.fog.toJSON()),n},dispose:function(){this.dispatchEvent({type:"dispose"})}});const wr=[new ye,new ye,new ye,new ye,new ye,new ye,new ye,new ye],Vu=new ye,ov=new qs,Ba=new ye,za=new ye,$a=new ye,Gr=new ye,Vr=new ye,To=new ye,ju=new ye,Og=new ye,Fg=new ye,Eo=new ye;function qs(e,n){this.min=e!==void 0?e:new ye(1/0,1/0,1/0),this.max=n!==void 0?n:new ye(-1/0,-1/0,-1/0)}Object.assign(qs.prototype,{isBox3:!0,set:function(e,n){return this.min.copy(e),this.max.copy(n),this},setFromArray:function(e){let n=1/0,t=1/0,i=1/0,r=-1/0,a=-1/0,c=-1/0;for(let u=0,l=e.length;u<l;u+=3){const f=e[u],m=e[u+1],h=e[u+2];f<n&&(n=f),m<t&&(t=m),h<i&&(i=h),f>r&&(r=f),m>a&&(a=m),h>c&&(c=h)}return this.min.set(n,t,i),this.max.set(r,a,c),this},setFromBufferAttribute:function(e){let n=1/0,t=1/0,i=1/0,r=-1/0,a=-1/0,c=-1/0;for(let u=0,l=e.count;u<l;u++){const f=e.getX(u),m=e.getY(u),h=e.getZ(u);f<n&&(n=f),m<t&&(t=m),h<i&&(i=h),f>r&&(r=f),m>a&&(a=m),h>c&&(c=h)}return this.min.set(n,t,i),this.max.set(r,a,c),this},setFromPoints:function(e){this.makeEmpty();for(let n=0,t=e.length;n<t;n++)this.expandByPoint(e[n]);return this},setFromCenterAndSize:function(e,n){const t=Vu.copy(n).multiplyScalar(.5);return this.min.copy(e).sub(t),this.max.copy(e).add(t),this},setFromObject:function(e){return this.makeEmpty(),this.expandByObject(e)},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.min.copy(e.min),this.max.copy(e.max),this},makeEmpty:function(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},getCenter:function(e){return e===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new ye),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(e){return e===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new ye),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)},expandByPoint:function(e){return this.min.min(e),this.max.max(e),this},expandByVector:function(e){return this.min.sub(e),this.max.add(e),this},expandByScalar:function(e){return this.min.addScalar(-e),this.max.addScalar(e),this},expandByObject:function(e){e.updateWorldMatrix(!1,!1);const n=e.geometry;n!==void 0&&(n.boundingBox===null&&n.computeBoundingBox(),ov.copy(n.boundingBox),ov.applyMatrix4(e.matrixWorld),this.union(ov));const t=e.children;for(let i=0,r=t.length;i<r;i++)this.expandByObject(t[i]);return this},containsPoint:function(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)},containsBox:function(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z},getParameter:function(e,n){return n===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),n=new ye),n.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))},intersectsBox:function(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)},intersectsSphere:function(e){return this.clampPoint(e.center,Vu),Vu.distanceToSquared(e.center)<=e.radius*e.radius},intersectsPlane:function(e){let n,t;return e.normal.x>0?(n=e.normal.x*this.min.x,t=e.normal.x*this.max.x):(n=e.normal.x*this.max.x,t=e.normal.x*this.min.x),e.normal.y>0?(n+=e.normal.y*this.min.y,t+=e.normal.y*this.max.y):(n+=e.normal.y*this.max.y,t+=e.normal.y*this.min.y),e.normal.z>0?(n+=e.normal.z*this.min.z,t+=e.normal.z*this.max.z):(n+=e.normal.z*this.max.z,t+=e.normal.z*this.min.z),n<=-e.constant&&t>=-e.constant},intersectsTriangle:function(e){if(this.isEmpty())return!1;this.getCenter(ju),Og.subVectors(this.max,ju),Ba.subVectors(e.a,ju),za.subVectors(e.b,ju),$a.subVectors(e.c,ju),Gr.subVectors(za,Ba),Vr.subVectors($a,za),To.subVectors(Ba,$a);let n=[0,-Gr.z,Gr.y,0,-Vr.z,Vr.y,0,-To.z,To.y,Gr.z,0,-Gr.x,Vr.z,0,-Vr.x,To.z,0,-To.x,-Gr.y,Gr.x,0,-Vr.y,Vr.x,0,-To.y,To.x,0];return!av(n,Ba,za,$a,Og)||(n=[1,0,0,0,1,0,0,0,1],!av(n,Ba,za,$a,Og))?!1:(Fg.crossVectors(Gr,Vr),n=[Fg.x,Fg.y,Fg.z],av(n,Ba,za,$a,Og))},clampPoint:function(e,n){return n===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),n=new ye),n.copy(e).clamp(this.min,this.max)},distanceToPoint:function(e){return Vu.copy(e).clamp(this.min,this.max).sub(e).length()},getBoundingSphere:function(e){return e===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=this.getSize(Vu).length()*.5,e},intersect:function(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this},union:function(e){return this.min.min(e.min),this.max.max(e.max),this},applyMatrix4:function(e){return this.isEmpty()?this:(wr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),wr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),wr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),wr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),wr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),wr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),wr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),wr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(wr),this)},translate:function(e){return this.min.add(e),this.max.add(e),this},equals:function(e){return e.min.equals(this.min)&&e.max.equals(this.max)}});function av(e,n,t,i,r){for(let a=0,c=e.length-3;a<=c;a+=3){Eo.fromArray(e,a);const u=r.x*Math.abs(Eo.x)+r.y*Math.abs(Eo.y)+r.z*Math.abs(Eo.z),l=n.dot(Eo),f=t.dot(Eo),m=i.dot(Eo);if(Math.max(-Math.max(l,f,m),Math.min(l,f,m))>u)return!1}return!0}const b1=new qs;function xr(e,n){this.center=e!==void 0?e:new ye,this.radius=n!==void 0?n:-1}Object.assign(xr.prototype,{set:function(e,n){return this.center.copy(e),this.radius=n,this},setFromPoints:function(e,n){const t=this.center;n!==void 0?t.copy(n):b1.setFromPoints(e).getCenter(t);let i=0;for(let r=0,a=e.length;r<a;r++)i=Math.max(i,t.distanceToSquared(e[r]));return this.radius=Math.sqrt(i),this},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.center.copy(e.center),this.radius=e.radius,this},isEmpty:function(){return this.radius<0},makeEmpty:function(){return this.center.set(0,0,0),this.radius=-1,this},containsPoint:function(e){return e.distanceToSquared(this.center)<=this.radius*this.radius},distanceToPoint:function(e){return e.distanceTo(this.center)-this.radius},intersectsSphere:function(e){const n=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=n*n},intersectsBox:function(e){return e.intersectsSphere(this)},intersectsPlane:function(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius},clampPoint:function(e,n){const t=this.center.distanceToSquared(e);return n===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),n=new ye),n.copy(e),t>this.radius*this.radius&&(n.sub(this.center).normalize(),n.multiplyScalar(this.radius).add(this.center)),n},getBoundingBox:function(e){return e===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new qs),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)},applyMatrix4:function(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this},translate:function(e){return this.center.add(e),this},equals:function(e){return e.center.equals(this.center)&&e.radius===this.radius}});const br=new ye,lv=new ye,Rg=new ye,jr=new ye,cv=new ye,Bg=new ye,uv=new ye;function Na(e,n){this.origin=e!==void 0?e:new ye,this.direction=n!==void 0?n:new ye(0,0,-1)}Object.assign(Na.prototype,{set:function(e,n){return this.origin.copy(e),this.direction.copy(n),this},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this},at:function(e,n){return n===void 0&&(console.warn("THREE.Ray: .at() target is now required"),n=new ye),n.copy(this.direction).multiplyScalar(e).add(this.origin)},lookAt:function(e){return this.direction.copy(e).sub(this.origin).normalize(),this},recast:function(e){return this.origin.copy(this.at(e,br)),this},closestPointToPoint:function(e,n){n===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),n=new ye),n.subVectors(e,this.origin);const t=n.dot(this.direction);return t<0?n.copy(this.origin):n.copy(this.direction).multiplyScalar(t).add(this.origin)},distanceToPoint:function(e){return Math.sqrt(this.distanceSqToPoint(e))},distanceSqToPoint:function(e){const n=br.subVectors(e,this.origin).dot(this.direction);return n<0?this.origin.distanceToSquared(e):(br.copy(this.direction).multiplyScalar(n).add(this.origin),br.distanceToSquared(e))},distanceSqToSegment:function(e,n,t,i){lv.copy(e).add(n).multiplyScalar(.5),Rg.copy(n).sub(e).normalize(),jr.copy(this.origin).sub(lv);const r=e.distanceTo(n)*.5,a=-this.direction.dot(Rg),c=jr.dot(this.direction),u=-jr.dot(Rg),l=jr.lengthSq(),f=Math.abs(1-a*a);let m,h,p,_;if(f>0)if(m=a*u-c,h=a*c-u,_=r*f,m>=0)if(h>=-_)if(h<=_){const v=1/f;m*=v,h*=v,p=m*(m+a*h+2*c)+h*(a*m+h+2*u)+l}else h=r,m=Math.max(0,-(a*h+c)),p=-m*m+h*(h+2*u)+l;else h=-r,m=Math.max(0,-(a*h+c)),p=-m*m+h*(h+2*u)+l;else h<=-_?(m=Math.max(0,-(-a*r+c)),h=m>0?-r:Math.min(Math.max(-r,-u),r),p=-m*m+h*(h+2*u)+l):h<=_?(m=0,h=Math.min(Math.max(-r,-u),r),p=h*(h+2*u)+l):(m=Math.max(0,-(a*r+c)),h=m>0?r:Math.min(Math.max(-r,-u),r),p=-m*m+h*(h+2*u)+l);else h=a>0?-r:r,m=Math.max(0,-(a*h+c)),p=-m*m+h*(h+2*u)+l;return t&&t.copy(this.direction).multiplyScalar(m).add(this.origin),i&&i.copy(Rg).multiplyScalar(h).add(lv),p},intersectSphere:function(e,n){br.subVectors(e.center,this.origin);const t=br.dot(this.direction),i=br.dot(br)-t*t,r=e.radius*e.radius;if(i>r)return null;const a=Math.sqrt(r-i),c=t-a,u=t+a;return c<0&&u<0?null:c<0?this.at(u,n):this.at(c,n)},intersectsSphere:function(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius},distanceToPlane:function(e){const n=e.normal.dot(this.direction);if(n===0)return e.distanceToPoint(this.origin)===0?0:null;const t=-(this.origin.dot(e.normal)+e.constant)/n;return t>=0?t:null},intersectPlane:function(e,n){const t=this.distanceToPlane(e);return t===null?null:this.at(t,n)},intersectsPlane:function(e){const n=e.distanceToPoint(this.origin);return n===0||e.normal.dot(this.direction)*n<0},intersectBox:function(e,n){let t,i,r,a,c,u;const l=1/this.direction.x,f=1/this.direction.y,m=1/this.direction.z,h=this.origin;return l>=0?(t=(e.min.x-h.x)*l,i=(e.max.x-h.x)*l):(t=(e.max.x-h.x)*l,i=(e.min.x-h.x)*l),f>=0?(r=(e.min.y-h.y)*f,a=(e.max.y-h.y)*f):(r=(e.max.y-h.y)*f,a=(e.min.y-h.y)*f),t>a||r>i||((r>t||t!==t)&&(t=r),(a<i||i!==i)&&(i=a),m>=0?(c=(e.min.z-h.z)*m,u=(e.max.z-h.z)*m):(c=(e.max.z-h.z)*m,u=(e.min.z-h.z)*m),t>u||c>i)||((c>t||t!==t)&&(t=c),(u<i||i!==i)&&(i=u),i<0)?null:this.at(t>=0?t:i,n)},intersectsBox:function(e){return this.intersectBox(e,br)!==null},intersectTriangle:function(e,n,t,i,r){cv.subVectors(n,e),Bg.subVectors(t,e),uv.crossVectors(cv,Bg);let a=this.direction.dot(uv),c;if(a>0){if(i)return null;c=1}else if(a<0)c=-1,a=-a;else return null;jr.subVectors(this.origin,e);const u=c*this.direction.dot(Bg.crossVectors(jr,Bg));if(u<0)return null;const l=c*this.direction.dot(cv.cross(jr));if(l<0||u+l>a)return null;const f=-c*jr.dot(uv);return f<0?null:this.at(f/a,r)},applyMatrix4:function(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this},equals:function(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}});const dv=new ye,M1=new ye,T1=new Oi;function Ks(e,n){this.normal=e!==void 0?e:new ye(1,0,0),this.constant=n!==void 0?n:0}Object.assign(Ks.prototype,{isPlane:!0,set:function(e,n){return this.normal.copy(e),this.constant=n,this},setComponents:function(e,n,t,i){return this.normal.set(e,n,t),this.constant=i,this},setFromNormalAndCoplanarPoint:function(e,n){return this.normal.copy(e),this.constant=-n.dot(this.normal),this},setFromCoplanarPoints:function(e,n,t){const i=dv.subVectors(t,n).cross(M1.subVectors(e,n)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.normal.copy(e.normal),this.constant=e.constant,this},normalize:function(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this},negate:function(){return this.constant*=-1,this.normal.negate(),this},distanceToPoint:function(e){return this.normal.dot(e)+this.constant},distanceToSphere:function(e){return this.distanceToPoint(e.center)-e.radius},projectPoint:function(e,n){return n===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),n=new ye),n.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)},intersectLine:function(e,n){n===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),n=new ye);const t=e.delta(dv),i=this.normal.dot(t);if(i===0)return this.distanceToPoint(e.start)===0?n.copy(e.start):void 0;const r=-(e.start.dot(this.normal)+this.constant)/i;if(!(r<0||r>1))return n.copy(t).multiplyScalar(r).add(e.start)},intersectsLine:function(e){const n=this.distanceToPoint(e.start),t=this.distanceToPoint(e.end);return n<0&&t>0||t<0&&n>0},intersectsBox:function(e){return e.intersectsPlane(this)},intersectsSphere:function(e){return e.intersectsPlane(this)},coplanarPoint:function(e){return e===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new ye),e.copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(e,n){const t=n||T1.getNormalMatrix(e),i=this.coplanarPoint(dv).applyMatrix4(e),r=this.normal.applyMatrix3(t).normalize();return this.constant=-i.dot(r),this},translate:function(e){return this.constant-=e.dot(this.normal),this},equals:function(e){return e.normal.equals(this.normal)&&e.constant===this.constant}});const Is=new ye,Mr=new ye,hv=new ye,Tr=new ye,Ua=new ye,Ga=new ye,Cw=new ye,fv=new ye,pv=new ye,mv=new ye;function xi(e,n,t){this.a=e!==void 0?e:new ye,this.b=n!==void 0?n:new ye,this.c=t!==void 0?t:new ye}Object.assign(xi,{getNormal:function(e,n,t,i){i===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),i=new ye),i.subVectors(t,n),Is.subVectors(e,n),i.cross(Is);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)},getBarycoord:function(e,n,t,i,r){Is.subVectors(i,n),Mr.subVectors(t,n),hv.subVectors(e,n);const a=Is.dot(Is),c=Is.dot(Mr),u=Is.dot(hv),l=Mr.dot(Mr),f=Mr.dot(hv),m=a*l-c*c;if(r===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),r=new ye),m===0)return r.set(-2,-1,-1);const h=1/m,p=(l*u-c*f)*h,_=(a*f-c*u)*h;return r.set(1-p-_,_,p)},containsPoint:function(e,n,t,i){return xi.getBarycoord(e,n,t,i,Tr),Tr.x>=0&&Tr.y>=0&&Tr.x+Tr.y<=1},getUV:function(e,n,t,i,r,a,c,u){return this.getBarycoord(e,n,t,i,Tr),u.set(0,0),u.addScaledVector(r,Tr.x),u.addScaledVector(a,Tr.y),u.addScaledVector(c,Tr.z),u},isFrontFacing:function(e,n,t,i){return Is.subVectors(t,n),Mr.subVectors(e,n),Is.cross(Mr).dot(i)<0}}),Object.assign(xi.prototype,{set:function(e,n,t){return this.a.copy(e),this.b.copy(n),this.c.copy(t),this},setFromPointsAndIndices:function(e,n,t,i){return this.a.copy(e[n]),this.b.copy(e[t]),this.c.copy(e[i]),this},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this},getArea:function(){return Is.subVectors(this.c,this.b),Mr.subVectors(this.a,this.b),Is.cross(Mr).length()*.5},getMidpoint:function(e){return e===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new ye),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},getNormal:function(e){return xi.getNormal(this.a,this.b,this.c,e)},getPlane:function(e){return e===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new Ks),e.setFromCoplanarPoints(this.a,this.b,this.c)},getBarycoord:function(e,n){return xi.getBarycoord(e,this.a,this.b,this.c,n)},getUV:function(e,n,t,i,r){return xi.getUV(e,this.a,this.b,this.c,n,t,i,r)},containsPoint:function(e){return xi.containsPoint(e,this.a,this.b,this.c)},isFrontFacing:function(e){return xi.isFrontFacing(this.a,this.b,this.c,e)},intersectsBox:function(e){return e.intersectsTriangle(this)},closestPointToPoint:function(e,n){n===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),n=new ye);const t=this.a,i=this.b,r=this.c;let a,c;Ua.subVectors(i,t),Ga.subVectors(r,t),fv.subVectors(e,t);const u=Ua.dot(fv),l=Ga.dot(fv);if(u<=0&&l<=0)return n.copy(t);pv.subVectors(e,i);const f=Ua.dot(pv),m=Ga.dot(pv);if(f>=0&&m<=f)return n.copy(i);const h=u*m-f*l;if(h<=0&&u>=0&&f<=0)return a=u/(u-f),n.copy(t).addScaledVector(Ua,a);mv.subVectors(e,r);const p=Ua.dot(mv),_=Ga.dot(mv);if(_>=0&&p<=_)return n.copy(r);const v=p*l-u*_;if(v<=0&&l>=0&&_<=0)return c=l/(l-_),n.copy(t).addScaledVector(Ga,c);const S=f*_-p*m;if(S<=0&&m-f>=0&&p-_>=0)return Cw.subVectors(r,i),c=(m-f)/(m-f+(p-_)),n.copy(i).addScaledVector(Cw,c);const D=1/(S+v+h);return a=v*D,c=h*D,n.copy(t).addScaledVector(Ua,a).addScaledVector(Ga,c)},equals:function(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}});const Iw={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ls={h:0,s:0,l:0},zg={h:0,s:0,l:0};function jt(e,n,t){return n===void 0&&t===void 0?this.set(e):this.setRGB(e,n,t)}function gv(e,n,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?e+(n-e)*6*t:t<1/2?n:t<2/3?e+(n-e)*6*(2/3-t):e}function _v(e){return e<.04045?e*.0773993808:Math.pow(e*.9478672986+.0521327014,2.4)}function yv(e){return e<.0031308?e*12.92:1.055*Math.pow(e,.41666)-.055}Object.assign(jt.prototype,{isColor:!0,r:1,g:1,b:1,set:function(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this},setScalar:function(e){return this.r=e,this.g=e,this.b=e,this},setHex:function(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this},setRGB:function(e,n,t){return this.r=e,this.g=n,this.b=t,this},setHSL:function(e,n,t){if(e=ln.euclideanModulo(e,1),n=ln.clamp(n,0,1),t=ln.clamp(t,0,1),n===0)this.r=this.g=this.b=t;else{const i=t<=.5?t*(1+n):t+n-t*n,r=2*t-i;this.r=gv(r,i,e+1/3),this.g=gv(r,i,e),this.b=gv(r,i,e-1/3)}return this},setStyle:function(e){function n(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let t;if(t=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)){let i;const r=t[1],a=t[2];switch(r){case"rgb":case"rgba":if(i=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(i[1],10))/255,this.g=Math.min(255,parseInt(i[2],10))/255,this.b=Math.min(255,parseInt(i[3],10))/255,n(i[5]),this;if(i=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(i[1],10))/100,this.g=Math.min(100,parseInt(i[2],10))/100,this.b=Math.min(100,parseInt(i[3],10))/100,n(i[5]),this;break;case"hsl":case"hsla":if(i=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)){const c=parseFloat(i[1])/360,u=parseInt(i[2],10)/100,l=parseInt(i[3],10)/100;return n(i[5]),this.setHSL(c,u,l)}break}}else if(t=/^\#([A-Fa-f0-9]+)$/.exec(e)){const i=t[1],r=i.length;if(r===3)return this.r=parseInt(i.charAt(0)+i.charAt(0),16)/255,this.g=parseInt(i.charAt(1)+i.charAt(1),16)/255,this.b=parseInt(i.charAt(2)+i.charAt(2),16)/255,this;if(r===6)return this.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,this.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,this.b=parseInt(i.charAt(4)+i.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this},setColorName:function(e){const n=Iw[e];return n!==void 0?this.setHex(n):console.warn("THREE.Color: Unknown color "+e),this},clone:function(){return new this.constructor(this.r,this.g,this.b)},copy:function(e){return this.r=e.r,this.g=e.g,this.b=e.b,this},copyGammaToLinear:function(e,n){return n===void 0&&(n=2),this.r=Math.pow(e.r,n),this.g=Math.pow(e.g,n),this.b=Math.pow(e.b,n),this},copyLinearToGamma:function(e,n){n===void 0&&(n=2);const t=n>0?1/n:1;return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this},convertGammaToLinear:function(e){return this.copyGammaToLinear(this,e),this},convertLinearToGamma:function(e){return this.copyLinearToGamma(this,e),this},copySRGBToLinear:function(e){return this.r=_v(e.r),this.g=_v(e.g),this.b=_v(e.b),this},copyLinearToSRGB:function(e){return this.r=yv(e.r),this.g=yv(e.g),this.b=yv(e.b),this},convertSRGBToLinear:function(){return this.copySRGBToLinear(this),this},convertLinearToSRGB:function(){return this.copyLinearToSRGB(this),this},getHex:function(){return this.r*255<<16^this.g*255<<8^this.b*255<<0},getHexString:function(){return("000000"+this.getHex().toString(16)).slice(-6)},getHSL:function(e){e===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const n=this.r,t=this.g,i=this.b,r=Math.max(n,t,i),a=Math.min(n,t,i);let c,u;const l=(a+r)/2;if(a===r)c=0,u=0;else{const f=r-a;switch(u=l<=.5?f/(r+a):f/(2-r-a),r){case n:c=(t-i)/f+(t<i?6:0);break;case t:c=(i-n)/f+2;break;case i:c=(n-t)/f+4;break}c/=6}return e.h=c,e.s=u,e.l=l,e},getStyle:function(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"},offsetHSL:function(e,n,t){return this.getHSL(Ls),Ls.h+=e,Ls.s+=n,Ls.l+=t,this.setHSL(Ls.h,Ls.s,Ls.l),this},add:function(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this},addColors:function(e,n){return this.r=e.r+n.r,this.g=e.g+n.g,this.b=e.b+n.b,this},addScalar:function(e){return this.r+=e,this.g+=e,this.b+=e,this},sub:function(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this},multiply:function(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this},multiplyScalar:function(e){return this.r*=e,this.g*=e,this.b*=e,this},lerp:function(e,n){return this.r+=(e.r-this.r)*n,this.g+=(e.g-this.g)*n,this.b+=(e.b-this.b)*n,this},lerpHSL:function(e,n){this.getHSL(Ls),e.getHSL(zg);const t=ln.lerp(Ls.h,zg.h,n),i=ln.lerp(Ls.s,zg.s,n),r=ln.lerp(Ls.l,zg.l,n);return this.setHSL(t,i,r),this},equals:function(e){return e.r===this.r&&e.g===this.g&&e.b===this.b},fromArray:function(e,n){return n===void 0&&(n=0),this.r=e[n],this.g=e[n+1],this.b=e[n+2],this},toArray:function(e,n){return e===void 0&&(e=[]),n===void 0&&(n=0),e[n]=this.r,e[n+1]=this.g,e[n+2]=this.b,e},fromBufferAttribute:function(e,n){return this.r=e.getX(n),this.g=e.getY(n),this.b=e.getZ(n),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this},toJSON:function(){return this.getHex()}}),jt.NAMES=Iw;function $g(e,n,t,i,r,a){this.a=e,this.b=n,this.c=t,this.normal=i&&i.isVector3?i:new ye,this.vertexNormals=Array.isArray(i)?i:[],this.color=r&&r.isColor?r:new jt,this.vertexColors=Array.isArray(r)?r:[],this.materialIndex=a!==void 0?a:0}Object.assign($g.prototype,{clone:function(){return new this.constructor().copy(this)},copy:function(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let n=0,t=e.vertexNormals.length;n<t;n++)this.vertexNormals[n]=e.vertexNormals[n].clone();for(let n=0,t=e.vertexColors.length;n<t;n++)this.vertexColors[n]=e.vertexColors[n].clone();return this}});let E1=0;function rn(){Object.defineProperty(this,"id",{value:E1++}),this.uuid=ln.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=Fu,this.side=Ou,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=iw,this.blendDst=sw,this.blendEquation=Pa,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Hy,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=f1,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=iv,this.stencilZFail=iv,this.stencilZPass=iv,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}rn.prototype=Object.assign(Object.create(yr.prototype),{constructor:rn,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(e){if(e!==void 0)for(const n in e){const t=e[n];if(t===void 0){console.warn("THREE.Material: '"+n+"' parameter is undefined.");continue}if(n==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=t===J0;continue}const i=this[n];if(i===void 0){console.warn("THREE."+this.type+": '"+n+"' is not a property of this material.");continue}i&&i.isColor?i.set(t):i&&i.isVector3&&t&&t.isVector3?i.copy(t):this[n]=t}},toJSON:function(e){const n=e===void 0||typeof e=="string";n&&(e={textures:{},images:{}});const t={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),this.color&&this.color.isColor&&(t.color=this.color.getHex()),this.roughness!==void 0&&(t.roughness=this.roughness),this.metalness!==void 0&&(t.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(t.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(t.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(t.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(t.specular=this.specular.getHex()),this.shininess!==void 0&&(t.shininess=this.shininess),this.clearcoat!==void 0&&(t.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(t.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(t.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(t.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(t.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,t.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(t.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(t.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(t.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(t.lightMap=this.lightMap.toJSON(e).uuid),this.aoMap&&this.aoMap.isTexture&&(t.aoMap=this.aoMap.toJSON(e).uuid,t.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(t.bumpMap=this.bumpMap.toJSON(e).uuid,t.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(t.normalMap=this.normalMap.toJSON(e).uuid,t.normalMapType=this.normalMapType,t.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(t.displacementMap=this.displacementMap.toJSON(e).uuid,t.displacementScale=this.displacementScale,t.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(t.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(t.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(t.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(t.specularMap=this.specularMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(t.envMap=this.envMap.toJSON(e).uuid,t.reflectivity=this.reflectivity,t.refractionRatio=this.refractionRatio,this.combine!==void 0&&(t.combine=this.combine),this.envMapIntensity!==void 0&&(t.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(t.gradientMap=this.gradientMap.toJSON(e).uuid),this.size!==void 0&&(t.size=this.size),this.sizeAttenuation!==void 0&&(t.sizeAttenuation=this.sizeAttenuation),this.blending!==Fu&&(t.blending=this.blending),this.flatShading===!0&&(t.flatShading=this.flatShading),this.side!==Ou&&(t.side=this.side),this.vertexColors&&(t.vertexColors=!0),this.opacity<1&&(t.opacity=this.opacity),this.transparent===!0&&(t.transparent=this.transparent),t.depthFunc=this.depthFunc,t.depthTest=this.depthTest,t.depthWrite=this.depthWrite,t.stencilWrite=this.stencilWrite,t.stencilWriteMask=this.stencilWriteMask,t.stencilFunc=this.stencilFunc,t.stencilRef=this.stencilRef,t.stencilFuncMask=this.stencilFuncMask,t.stencilFail=this.stencilFail,t.stencilZFail=this.stencilZFail,t.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(t.rotation=this.rotation),this.polygonOffset===!0&&(t.polygonOffset=!0),this.polygonOffsetFactor!==0&&(t.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(t.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(t.linewidth=this.linewidth),this.dashSize!==void 0&&(t.dashSize=this.dashSize),this.gapSize!==void 0&&(t.gapSize=this.gapSize),this.scale!==void 0&&(t.scale=this.scale),this.dithering===!0&&(t.dithering=!0),this.alphaTest>0&&(t.alphaTest=this.alphaTest),this.premultipliedAlpha===!0&&(t.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(t.wireframe=this.wireframe),this.wireframeLinewidth>1&&(t.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(t.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(t.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(t.morphTargets=!0),this.morphNormals===!0&&(t.morphNormals=!0),this.skinning===!0&&(t.skinning=!0),this.visible===!1&&(t.visible=!1),this.toneMapped===!1&&(t.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(t.userData=this.userData);function i(r){const a=[];for(const c in r){const u=r[c];delete u.metadata,a.push(u)}return a}if(n){const r=i(e.textures),a=i(e.images);r.length>0&&(t.textures=r),a.length>0&&(t.images=a)}return t},clone:function(){return new this.constructor().copy(this)},copy:function(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.flatShading=e.flatShading,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const n=e.clippingPlanes;let t=null;if(n!==null){const i=n.length;t=new Array(i);for(let r=0;r!==i;++r)t[r]=n[r].clone()}return this.clippingPlanes=t,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(rn.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}});function ms(e){rn.call(this),this.type="MeshBasicMaterial",this.color=new jt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=yg,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(e)}ms.prototype=Object.create(rn.prototype),ms.prototype.constructor=ms,ms.prototype.isMeshBasicMaterial=!0,ms.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this};const Rn=new ye,Ng=new vt;function Kt(e,n,t){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=n,this.count=e!==void 0?e.length/n:0,this.normalized=t===!0,this.usage=Ig,this.updateRange={offset:0,count:-1},this.version=0}Object.defineProperty(Kt.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}}),Object.assign(Kt.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this},copyAt:function(e,n,t){e*=this.itemSize,t*=n.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=n.array[t+i];return this},copyArray:function(e){return this.array.set(e),this},copyColorsArray:function(e){const n=this.array;let t=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),a=new jt),n[t++]=a.r,n[t++]=a.g,n[t++]=a.b}return this},copyVector2sArray:function(e){const n=this.array;let t=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),a=new vt),n[t++]=a.x,n[t++]=a.y}return this},copyVector3sArray:function(e){const n=this.array;let t=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),a=new ye),n[t++]=a.x,n[t++]=a.y,n[t++]=a.z}return this},copyVector4sArray:function(e){const n=this.array;let t=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),a=new An),n[t++]=a.x,n[t++]=a.y,n[t++]=a.z,n[t++]=a.w}return this},applyMatrix3:function(e){if(this.itemSize===2)for(let n=0,t=this.count;n<t;n++)Ng.fromBufferAttribute(this,n),Ng.applyMatrix3(e),this.setXY(n,Ng.x,Ng.y);else if(this.itemSize===3)for(let n=0,t=this.count;n<t;n++)Rn.fromBufferAttribute(this,n),Rn.applyMatrix3(e),this.setXYZ(n,Rn.x,Rn.y,Rn.z);return this},applyMatrix4:function(e){for(let n=0,t=this.count;n<t;n++)Rn.x=this.getX(n),Rn.y=this.getY(n),Rn.z=this.getZ(n),Rn.applyMatrix4(e),this.setXYZ(n,Rn.x,Rn.y,Rn.z);return this},applyNormalMatrix:function(e){for(let n=0,t=this.count;n<t;n++)Rn.x=this.getX(n),Rn.y=this.getY(n),Rn.z=this.getZ(n),Rn.applyNormalMatrix(e),this.setXYZ(n,Rn.x,Rn.y,Rn.z);return this},transformDirection:function(e){for(let n=0,t=this.count;n<t;n++)Rn.x=this.getX(n),Rn.y=this.getY(n),Rn.z=this.getZ(n),Rn.transformDirection(e),this.setXYZ(n,Rn.x,Rn.y,Rn.z);return this},set:function(e,n){return n===void 0&&(n=0),this.array.set(e,n),this},getX:function(e){return this.array[e*this.itemSize]},setX:function(e,n){return this.array[e*this.itemSize]=n,this},getY:function(e){return this.array[e*this.itemSize+1]},setY:function(e,n){return this.array[e*this.itemSize+1]=n,this},getZ:function(e){return this.array[e*this.itemSize+2]},setZ:function(e,n){return this.array[e*this.itemSize+2]=n,this},getW:function(e){return this.array[e*this.itemSize+3]},setW:function(e,n){return this.array[e*this.itemSize+3]=n,this},setXY:function(e,n,t){return e*=this.itemSize,this.array[e+0]=n,this.array[e+1]=t,this},setXYZ:function(e,n,t,i){return e*=this.itemSize,this.array[e+0]=n,this.array[e+1]=t,this.array[e+2]=i,this},setXYZW:function(e,n,t,i,r){return e*=this.itemSize,this.array[e+0]=n,this.array[e+1]=t,this.array[e+2]=i,this.array[e+3]=r,this},onUpload:function(e){return this.onUploadCallback=e,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}});function vv(e,n,t){Kt.call(this,new Int8Array(e),n,t)}vv.prototype=Object.create(Kt.prototype),vv.prototype.constructor=vv;function wv(e,n,t){Kt.call(this,new Uint8Array(e),n,t)}wv.prototype=Object.create(Kt.prototype),wv.prototype.constructor=wv;function xv(e,n,t){Kt.call(this,new Uint8ClampedArray(e),n,t)}xv.prototype=Object.create(Kt.prototype),xv.prototype.constructor=xv;function bv(e,n,t){Kt.call(this,new Int16Array(e),n,t)}bv.prototype=Object.create(Kt.prototype),bv.prototype.constructor=bv;function Wu(e,n,t){Kt.call(this,new Uint16Array(e),n,t)}Wu.prototype=Object.create(Kt.prototype),Wu.prototype.constructor=Wu;function Mv(e,n,t){Kt.call(this,new Int32Array(e),n,t)}Mv.prototype=Object.create(Kt.prototype),Mv.prototype.constructor=Mv;function Hu(e,n,t){Kt.call(this,new Uint32Array(e),n,t)}Hu.prototype=Object.create(Kt.prototype),Hu.prototype.constructor=Hu;function Bt(e,n,t){Kt.call(this,new Float32Array(e),n,t)}Bt.prototype=Object.create(Kt.prototype),Bt.prototype.constructor=Bt;function Tv(e,n,t){Kt.call(this,new Float64Array(e),n,t)}Tv.prototype=Object.create(Kt.prototype),Tv.prototype.constructor=Tv;function Lw(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}Object.assign(Lw.prototype,{computeGroups:function(e){const n=[];let t,i,r;const a=e.faces;for(i=0;i<a.length;i++){const c=a[i];c.materialIndex!==r&&(r=c.materialIndex,t!==void 0&&(t.count=i*3-t.start,n.push(t)),t={start:i*3,materialIndex:r})}t!==void 0&&(t.count=i*3-t.start,n.push(t)),this.groups=n},fromGeometry:function(e){const n=e.faces,t=e.vertices,i=e.faceVertexUvs,r=i[0]&&i[0].length>0,a=i[1]&&i[1].length>0,c=e.morphTargets,u=c.length;let l;if(u>0){l=[];for(let D=0;D<u;D++)l[D]={name:c[D].name,data:[]};this.morphTargets.position=l}const f=e.morphNormals,m=f.length;let h;if(m>0){h=[];for(let D=0;D<m;D++)h[D]={name:f[D].name,data:[]};this.morphTargets.normal=h}const p=e.skinIndices,_=e.skinWeights,v=p.length===t.length,S=_.length===t.length;t.length>0&&n.length===0&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let D=0;D<n.length;D++){const w=n[D];this.vertices.push(t[w.a],t[w.b],t[w.c]);const T=w.vertexNormals;if(T.length===3)this.normals.push(T[0],T[1],T[2]);else{const E=w.normal;this.normals.push(E,E,E)}const F=w.vertexColors;if(F.length===3)this.colors.push(F[0],F[1],F[2]);else{const E=w.color;this.colors.push(E,E,E)}if(r===!0){const E=i[0][D];E!==void 0?this.uvs.push(E[0],E[1],E[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",D),this.uvs.push(new vt,new vt,new vt))}if(a===!0){const E=i[1][D];E!==void 0?this.uvs2.push(E[0],E[1],E[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",D),this.uvs2.push(new vt,new vt,new vt))}for(let E=0;E<u;E++){const A=c[E].vertices;l[E].data.push(A[w.a],A[w.b],A[w.c])}for(let E=0;E<m;E++){const A=f[E].vertexNormals[D];h[E].data.push(A.a,A.b,A.c)}v&&this.skinIndices.push(p[w.a],p[w.b],p[w.c]),S&&this.skinWeights.push(_[w.a],_[w.b],_[w.c])}return this.computeGroups(e),this.verticesNeedUpdate=e.verticesNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),this}});function Dw(e){if(e.length===0)return-1/0;let n=e[0];for(let t=1,i=e.length;t<i;++t)e[t]>n&&(n=e[t]);return n}let S1=1;const Xs=new dn,Ev=new Ot,Va=new ye,Zi=new qs,qu=new qs,mi=new ye;function Ut(){Object.defineProperty(this,"id",{value:S1+=2}),this.uuid=ln.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}Ut.prototype=Object.assign(Object.create(yr.prototype),{constructor:Ut,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(e){Array.isArray(e)?this.index=new(Dw(e)>65535?Hu:Wu)(e,1):this.index=e},getAttribute:function(e){return this.attributes[e]},setAttribute:function(e,n){return this.attributes[e]=n,this},deleteAttribute:function(e){return delete this.attributes[e],this},addGroup:function(e,n,t){this.groups.push({start:e,count:n,materialIndex:t!==void 0?t:0})},clearGroups:function(){this.groups=[]},setDrawRange:function(e,n){this.drawRange.start=e,this.drawRange.count=n},applyMatrix4:function(e){const n=this.attributes.position;n!==void 0&&(n.applyMatrix4(e),n.needsUpdate=!0);const t=this.attributes.normal;if(t!==void 0){const r=new Oi().getNormalMatrix(e);t.applyNormalMatrix(r),t.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this},rotateX:function(e){return Xs.makeRotationX(e),this.applyMatrix4(Xs),this},rotateY:function(e){return Xs.makeRotationY(e),this.applyMatrix4(Xs),this},rotateZ:function(e){return Xs.makeRotationZ(e),this.applyMatrix4(Xs),this},translate:function(e,n,t){return Xs.makeTranslation(e,n,t),this.applyMatrix4(Xs),this},scale:function(e,n,t){return Xs.makeScale(e,n,t),this.applyMatrix4(Xs),this},lookAt:function(e){return Ev.lookAt(e),Ev.updateMatrix(),this.applyMatrix4(Ev.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Va).negate(),this.translate(Va.x,Va.y,Va.z),this},setFromObject:function(e){const n=e.geometry;if(e.isPoints||e.isLine){const t=new Bt(n.vertices.length*3,3),i=new Bt(n.colors.length*3,3);if(this.setAttribute("position",t.copyVector3sArray(n.vertices)),this.setAttribute("color",i.copyColorsArray(n.colors)),n.lineDistances&&n.lineDistances.length===n.vertices.length){const r=new Bt(n.lineDistances.length,1);this.setAttribute("lineDistance",r.copyArray(n.lineDistances))}n.boundingSphere!==null&&(this.boundingSphere=n.boundingSphere.clone()),n.boundingBox!==null&&(this.boundingBox=n.boundingBox.clone())}else e.isMesh&&n&&n.isGeometry&&this.fromGeometry(n);return this},setFromPoints:function(e){const n=[];for(let t=0,i=e.length;t<i;t++){const r=e[t];n.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Bt(n,3)),this},updateFromObject:function(e){let n=e.geometry;if(e.isMesh){let t=n.__directGeometry;if(n.elementsNeedUpdate===!0&&(t=void 0,n.elementsNeedUpdate=!1),t===void 0)return this.fromGeometry(n);t.verticesNeedUpdate=n.verticesNeedUpdate,t.normalsNeedUpdate=n.normalsNeedUpdate,t.colorsNeedUpdate=n.colorsNeedUpdate,t.uvsNeedUpdate=n.uvsNeedUpdate,t.groupsNeedUpdate=n.groupsNeedUpdate,n.verticesNeedUpdate=!1,n.normalsNeedUpdate=!1,n.colorsNeedUpdate=!1,n.uvsNeedUpdate=!1,n.groupsNeedUpdate=!1,n=t}if(n.verticesNeedUpdate===!0){const t=this.attributes.position;t!==void 0&&(t.copyVector3sArray(n.vertices),t.needsUpdate=!0),n.verticesNeedUpdate=!1}if(n.normalsNeedUpdate===!0){const t=this.attributes.normal;t!==void 0&&(t.copyVector3sArray(n.normals),t.needsUpdate=!0),n.normalsNeedUpdate=!1}if(n.colorsNeedUpdate===!0){const t=this.attributes.color;t!==void 0&&(t.copyColorsArray(n.colors),t.needsUpdate=!0),n.colorsNeedUpdate=!1}if(n.uvsNeedUpdate){const t=this.attributes.uv;t!==void 0&&(t.copyVector2sArray(n.uvs),t.needsUpdate=!0),n.uvsNeedUpdate=!1}if(n.lineDistancesNeedUpdate){const t=this.attributes.lineDistance;t!==void 0&&(t.copyArray(n.lineDistances),t.needsUpdate=!0),n.lineDistancesNeedUpdate=!1}return n.groupsNeedUpdate&&(n.computeGroups(e.geometry),this.groups=n.groups,n.groupsNeedUpdate=!1),this},fromGeometry:function(e){return e.__directGeometry=new Lw().fromGeometry(e),this.fromDirectGeometry(e.__directGeometry)},fromDirectGeometry:function(e){const n=new Float32Array(e.vertices.length*3);if(this.setAttribute("position",new Kt(n,3).copyVector3sArray(e.vertices)),e.normals.length>0){const t=new Float32Array(e.normals.length*3);this.setAttribute("normal",new Kt(t,3).copyVector3sArray(e.normals))}if(e.colors.length>0){const t=new Float32Array(e.colors.length*3);this.setAttribute("color",new Kt(t,3).copyColorsArray(e.colors))}if(e.uvs.length>0){const t=new Float32Array(e.uvs.length*2);this.setAttribute("uv",new Kt(t,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){const t=new Float32Array(e.uvs2.length*2);this.setAttribute("uv2",new Kt(t,2).copyVector2sArray(e.uvs2))}this.groups=e.groups;for(const t in e.morphTargets){const i=[],r=e.morphTargets[t];for(let a=0,c=r.length;a<c;a++){const u=r[a],l=new Bt(u.data.length*3,3);l.name=u.name,i.push(l.copyVector3sArray(u.data))}this.morphAttributes[t]=i}if(e.skinIndices.length>0){const t=new Bt(e.skinIndices.length*4,4);this.setAttribute("skinIndex",t.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){const t=new Bt(e.skinWeights.length*4,4);this.setAttribute("skinWeight",t.copyVector4sArray(e.skinWeights))}return e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),this},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new qs);const e=this.attributes.position,n=this.morphAttributes.position;if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),n)for(let t=0,i=n.length;t<i;t++){const r=n[t];Zi.setFromBufferAttribute(r),this.morphTargetsRelative?(mi.addVectors(this.boundingBox.min,Zi.min),this.boundingBox.expandByPoint(mi),mi.addVectors(this.boundingBox.max,Zi.max),this.boundingBox.expandByPoint(mi)):(this.boundingBox.expandByPoint(Zi.min),this.boundingBox.expandByPoint(Zi.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new xr);const e=this.attributes.position,n=this.morphAttributes.position;if(e){const t=this.boundingSphere.center;if(Zi.setFromBufferAttribute(e),n)for(let r=0,a=n.length;r<a;r++){const c=n[r];qu.setFromBufferAttribute(c),this.morphTargetsRelative?(mi.addVectors(Zi.min,qu.min),Zi.expandByPoint(mi),mi.addVectors(Zi.max,qu.max),Zi.expandByPoint(mi)):(Zi.expandByPoint(qu.min),Zi.expandByPoint(qu.max))}Zi.getCenter(t);let i=0;for(let r=0,a=e.count;r<a;r++)mi.fromBufferAttribute(e,r),i=Math.max(i,t.distanceToSquared(mi));if(n)for(let r=0,a=n.length;r<a;r++){const c=n[r],u=this.morphTargetsRelative;for(let l=0,f=c.count;l<f;l++)mi.fromBufferAttribute(c,l),u&&(Va.fromBufferAttribute(e,l),mi.add(Va)),i=Math.max(i,t.distanceToSquared(mi))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeVertexNormals:function(){const e=this.index,n=this.getAttribute("position");if(n!==void 0){let t=this.getAttribute("normal");if(t===void 0)t=new Kt(new Float32Array(n.count*3),3),this.setAttribute("normal",t);else for(let h=0,p=t.count;h<p;h++)t.setXYZ(h,0,0,0);const i=new ye,r=new ye,a=new ye,c=new ye,u=new ye,l=new ye,f=new ye,m=new ye;if(e)for(let h=0,p=e.count;h<p;h+=3){const _=e.getX(h+0),v=e.getX(h+1),S=e.getX(h+2);i.fromBufferAttribute(n,_),r.fromBufferAttribute(n,v),a.fromBufferAttribute(n,S),f.subVectors(a,r),m.subVectors(i,r),f.cross(m),c.fromBufferAttribute(t,_),u.fromBufferAttribute(t,v),l.fromBufferAttribute(t,S),c.add(f),u.add(f),l.add(f),t.setXYZ(_,c.x,c.y,c.z),t.setXYZ(v,u.x,u.y,u.z),t.setXYZ(S,l.x,l.y,l.z)}else for(let h=0,p=n.count;h<p;h+=3)i.fromBufferAttribute(n,h+0),r.fromBufferAttribute(n,h+1),a.fromBufferAttribute(n,h+2),f.subVectors(a,r),m.subVectors(i,r),f.cross(m),t.setXYZ(h+0,f.x,f.y,f.z),t.setXYZ(h+1,f.x,f.y,f.z),t.setXYZ(h+2,f.x,f.y,f.z);this.normalizeNormals(),t.needsUpdate=!0}},merge:function(e,n){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}n===void 0&&(n=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const t=this.attributes;for(const i in t){if(e.attributes[i]===void 0)continue;const a=t[i].array,c=e.attributes[i],u=c.array,l=c.itemSize*n,f=Math.min(u.length,a.length-l);for(let m=0,h=l;m<f;m++,h++)a[h]=u[m]}return this},normalizeNormals:function(){const e=this.attributes.normal;for(let n=0,t=e.count;n<t;n++)mi.fromBufferAttribute(e,n),mi.normalize(),e.setXYZ(n,mi.x,mi.y,mi.z)},toNonIndexed:function(){function e(c,u){const l=c.array,f=c.itemSize,m=c.normalized,h=new l.constructor(u.length*f);let p=0,_=0;for(let v=0,S=u.length;v<S;v++){p=u[v]*f;for(let D=0;D<f;D++)h[_++]=l[p++]}return new Kt(h,f,m)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),this;const n=new Ut,t=this.index.array,i=this.attributes;for(const c in i){const u=i[c],l=e(u,t);n.setAttribute(c,l)}const r=this.morphAttributes;for(const c in r){const u=[],l=r[c];for(let f=0,m=l.length;f<m;f++){const h=l[f],p=e(h,t);u.push(p)}n.morphAttributes[c]=u}n.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let c=0,u=a.length;c<u;c++){const l=a[c];n.addGroup(l.start,l.count,l.materialIndex)}return n},toJSON:function(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const u=this.parameters;for(const l in u)u[l]!==void 0&&(e[l]=u[l]);return e}e.data={attributes:{}};const n=this.index;n!==null&&(e.data.index={type:n.array.constructor.name,array:Array.prototype.slice.call(n.array)});const t=this.attributes;for(const u in t){const l=t[u],f=l.toJSON(e.data);l.name!==""&&(f.name=l.name),e.data.attributes[u]=f}const i={};let r=!1;for(const u in this.morphAttributes){const l=this.morphAttributes[u],f=[];for(let m=0,h=l.length;m<h;m++){const p=l[m],_=p.toJSON(e.data);p.name!==""&&(_.name=p.name),f.push(_)}f.length>0&&(i[u]=f,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const c=this.boundingSphere;return c!==null&&(e.data.boundingSphere={center:c.center.toArray(),radius:c.radius}),e},clone:function(){return new Ut().copy(this)},copy:function(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const n={};this.name=e.name;const t=e.index;t!==null&&this.setIndex(t.clone(n));const i=e.attributes;for(const l in i){const f=i[l];this.setAttribute(l,f.clone(n))}const r=e.morphAttributes;for(const l in r){const f=[],m=r[l];for(let h=0,p=m.length;h<p;h++)f.push(m[h].clone(n));this.morphAttributes[l]=f}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let l=0,f=a.length;l<f;l++){const m=a[l];this.addGroup(m.start,m.count,m.materialIndex)}const c=e.boundingBox;c!==null&&(this.boundingBox=c.clone());const u=e.boundingSphere;return u!==null&&(this.boundingSphere=u.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const kw=new dn,So=new Na,Sv=new xr,Wr=new ye,Hr=new ye,qr=new ye,Pv=new ye,Av=new ye,Cv=new ye,Ug=new ye,Gg=new ye,Vg=new ye,ja=new vt,Wa=new vt,Ha=new vt,Ku=new ye,jg=new ye;function Ln(e,n){Ot.call(this),this.type="Mesh",this.geometry=e!==void 0?e:new Ut,this.material=n!==void 0?n:new ms,this.updateMorphTargets()}Ln.prototype=Object.assign(Object.create(Ot.prototype),{constructor:Ln,isMesh:!0,copy:function(e){return Ot.prototype.copy.call(this,e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const n=e.morphAttributes,t=Object.keys(n);if(t.length>0){const i=n[t[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const c=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[c]=r}}}}else{const n=e.morphTargets;n!==void 0&&n.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(e,n){const t=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(t.boundingSphere===null&&t.computeBoundingSphere(),Sv.copy(t.boundingSphere),Sv.applyMatrix4(r),e.ray.intersectsSphere(Sv)===!1)||(kw.getInverse(r),So.copy(e.ray).applyMatrix4(kw),t.boundingBox!==null&&So.intersectsBox(t.boundingBox)===!1))return;let a;if(t.isBufferGeometry){const c=t.index,u=t.attributes.position,l=t.morphAttributes.position,f=t.morphTargetsRelative,m=t.attributes.uv,h=t.attributes.uv2,p=t.groups,_=t.drawRange;if(c!==null)if(Array.isArray(i))for(let v=0,S=p.length;v<S;v++){const D=p[v],w=i[D.materialIndex],T=Math.max(D.start,_.start),F=Math.min(D.start+D.count,_.start+_.count);for(let E=T,A=F;E<A;E+=3){const L=c.getX(E),I=c.getX(E+1),R=c.getX(E+2);a=Wg(this,w,e,So,u,l,f,m,h,L,I,R),a&&(a.faceIndex=Math.floor(E/3),a.face.materialIndex=D.materialIndex,n.push(a))}}else{const v=Math.max(0,_.start),S=Math.min(c.count,_.start+_.count);for(let D=v,w=S;D<w;D+=3){const T=c.getX(D),F=c.getX(D+1),E=c.getX(D+2);a=Wg(this,i,e,So,u,l,f,m,h,T,F,E),a&&(a.faceIndex=Math.floor(D/3),n.push(a))}}else if(u!==void 0)if(Array.isArray(i))for(let v=0,S=p.length;v<S;v++){const D=p[v],w=i[D.materialIndex],T=Math.max(D.start,_.start),F=Math.min(D.start+D.count,_.start+_.count);for(let E=T,A=F;E<A;E+=3){const L=E,I=E+1,R=E+2;a=Wg(this,w,e,So,u,l,f,m,h,L,I,R),a&&(a.faceIndex=Math.floor(E/3),a.face.materialIndex=D.materialIndex,n.push(a))}}else{const v=Math.max(0,_.start),S=Math.min(u.count,_.start+_.count);for(let D=v,w=S;D<w;D+=3){const T=D,F=D+1,E=D+2;a=Wg(this,i,e,So,u,l,f,m,h,T,F,E),a&&(a.faceIndex=Math.floor(D/3),n.push(a))}}}else if(t.isGeometry){const c=Array.isArray(i),u=t.vertices,l=t.faces;let f;const m=t.faceVertexUvs[0];m.length>0&&(f=m);for(let h=0,p=l.length;h<p;h++){const _=l[h],v=c?i[_.materialIndex]:i;if(v===void 0)continue;const S=u[_.a],D=u[_.b],w=u[_.c];if(a=Ow(this,v,e,So,S,D,w,Ku),a){if(f&&f[h]){const T=f[h];ja.copy(T[0]),Wa.copy(T[1]),Ha.copy(T[2]),a.uv=xi.getUV(Ku,S,D,w,ja,Wa,Ha,new vt)}a.face=_,a.faceIndex=h,n.push(a)}}}}});function Ow(e,n,t,i,r,a,c,u){let l;if(n.side===li?l=i.intersectTriangle(c,a,r,!0,u):l=i.intersectTriangle(r,a,c,n.side!==_g,u),l===null)return null;jg.copy(u),jg.applyMatrix4(e.matrixWorld);const f=t.ray.origin.distanceTo(jg);return f<t.near||f>t.far?null:{distance:f,point:jg.clone(),object:e}}function Wg(e,n,t,i,r,a,c,u,l,f,m,h){Wr.fromBufferAttribute(r,f),Hr.fromBufferAttribute(r,m),qr.fromBufferAttribute(r,h);const p=e.morphTargetInfluences;if(n.morphTargets&&a&&p){Ug.set(0,0,0),Gg.set(0,0,0),Vg.set(0,0,0);for(let v=0,S=a.length;v<S;v++){const D=p[v],w=a[v];D!==0&&(Pv.fromBufferAttribute(w,f),Av.fromBufferAttribute(w,m),Cv.fromBufferAttribute(w,h),c?(Ug.addScaledVector(Pv,D),Gg.addScaledVector(Av,D),Vg.addScaledVector(Cv,D)):(Ug.addScaledVector(Pv.sub(Wr),D),Gg.addScaledVector(Av.sub(Hr),D),Vg.addScaledVector(Cv.sub(qr),D)))}Wr.add(Ug),Hr.add(Gg),qr.add(Vg)}e.isSkinnedMesh&&(e.boneTransform(f,Wr),e.boneTransform(m,Hr),e.boneTransform(h,qr));const _=Ow(e,n,t,i,Wr,Hr,qr,Ku);if(_){u&&(ja.fromBufferAttribute(u,f),Wa.fromBufferAttribute(u,m),Ha.fromBufferAttribute(u,h),_.uv=xi.getUV(Ku,Wr,Hr,qr,ja,Wa,Ha,new vt)),l&&(ja.fromBufferAttribute(l,f),Wa.fromBufferAttribute(l,m),Ha.fromBufferAttribute(l,h),_.uv2=xi.getUV(Ku,Wr,Hr,qr,ja,Wa,Ha,new vt));const v=new $g(f,m,h);xi.getNormal(Wr,Hr,qr,v.normal),_.face=v}return _}let P1=0;const Ys=new dn,Iv=new Ot,Hg=new ye;function on(){Object.defineProperty(this,"id",{value:P1+=2}),this.uuid=ln.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}on.prototype=Object.assign(Object.create(yr.prototype),{constructor:on,isGeometry:!0,applyMatrix4:function(e){const n=new Oi().getNormalMatrix(e);for(let t=0,i=this.vertices.length;t<i;t++)this.vertices[t].applyMatrix4(e);for(let t=0,i=this.faces.length;t<i;t++){const r=this.faces[t];r.normal.applyMatrix3(n).normalize();for(let a=0,c=r.vertexNormals.length;a<c;a++)r.vertexNormals[a].applyMatrix3(n).normalize()}return this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(e){return Ys.makeRotationX(e),this.applyMatrix4(Ys),this},rotateY:function(e){return Ys.makeRotationY(e),this.applyMatrix4(Ys),this},rotateZ:function(e){return Ys.makeRotationZ(e),this.applyMatrix4(Ys),this},translate:function(e,n,t){return Ys.makeTranslation(e,n,t),this.applyMatrix4(Ys),this},scale:function(e,n,t){return Ys.makeScale(e,n,t),this.applyMatrix4(Ys),this},lookAt:function(e){return Iv.lookAt(e),Iv.updateMatrix(),this.applyMatrix4(Iv.matrix),this},fromBufferGeometry:function(e){const n=this,t=e.index!==null?e.index:void 0,i=e.attributes;if(i.position===void 0)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const r=i.position,a=i.normal,c=i.color,u=i.uv,l=i.uv2;l!==void 0&&(this.faceVertexUvs[1]=[]);for(let h=0;h<r.count;h++)n.vertices.push(new ye().fromBufferAttribute(r,h)),c!==void 0&&n.colors.push(new jt().fromBufferAttribute(c,h));function f(h,p,_,v){const S=c===void 0?[]:[n.colors[h].clone(),n.colors[p].clone(),n.colors[_].clone()],D=a===void 0?[]:[new ye().fromBufferAttribute(a,h),new ye().fromBufferAttribute(a,p),new ye().fromBufferAttribute(a,_)],w=new $g(h,p,_,D,S,v);n.faces.push(w),u!==void 0&&n.faceVertexUvs[0].push([new vt().fromBufferAttribute(u,h),new vt().fromBufferAttribute(u,p),new vt().fromBufferAttribute(u,_)]),l!==void 0&&n.faceVertexUvs[1].push([new vt().fromBufferAttribute(l,h),new vt().fromBufferAttribute(l,p),new vt().fromBufferAttribute(l,_)])}const m=e.groups;if(m.length>0)for(let h=0;h<m.length;h++){const p=m[h],_=p.start,v=p.count;for(let S=_,D=_+v;S<D;S+=3)t!==void 0?f(t.getX(S),t.getX(S+1),t.getX(S+2),p.materialIndex):f(S,S+1,S+2,p.materialIndex)}else if(t!==void 0)for(let h=0;h<t.count;h+=3)f(t.getX(h),t.getX(h+1),t.getX(h+2));else for(let h=0;h<r.count;h+=3)f(h,h+1,h+2);return this.computeFaceNormals(),e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Hg).negate(),this.translate(Hg.x,Hg.y,Hg.z),this},normalize:function(){this.computeBoundingSphere();const e=this.boundingSphere.center,n=this.boundingSphere.radius,t=n===0?1:1/n,i=new dn;return i.set(t,0,0,-t*e.x,0,t,0,-t*e.y,0,0,t,-t*e.z,0,0,0,1),this.applyMatrix4(i),this},computeFaceNormals:function(){const e=new ye,n=new ye;for(let t=0,i=this.faces.length;t<i;t++){const r=this.faces[t],a=this.vertices[r.a],c=this.vertices[r.b],u=this.vertices[r.c];e.subVectors(u,c),n.subVectors(a,c),e.cross(n),e.normalize(),r.normal.copy(e)}},computeVertexNormals:function(e){e===void 0&&(e=!0);const n=new Array(this.vertices.length);for(let t=0,i=this.vertices.length;t<i;t++)n[t]=new ye;if(e){const t=new ye,i=new ye;for(let r=0,a=this.faces.length;r<a;r++){const c=this.faces[r],u=this.vertices[c.a],l=this.vertices[c.b],f=this.vertices[c.c];t.subVectors(f,l),i.subVectors(u,l),t.cross(i),n[c.a].add(t),n[c.b].add(t),n[c.c].add(t)}}else{this.computeFaceNormals();for(let t=0,i=this.faces.length;t<i;t++){const r=this.faces[t];n[r.a].add(r.normal),n[r.b].add(r.normal),n[r.c].add(r.normal)}}for(let t=0,i=this.vertices.length;t<i;t++)n[t].normalize();for(let t=0,i=this.faces.length;t<i;t++){const r=this.faces[t],a=r.vertexNormals;a.length===3?(a[0].copy(n[r.a]),a[1].copy(n[r.b]),a[2].copy(n[r.c])):(a[0]=n[r.a].clone(),a[1]=n[r.b].clone(),a[2]=n[r.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){this.computeFaceNormals();for(let e=0,n=this.faces.length;e<n;e++){const t=this.faces[e],i=t.vertexNormals;i.length===3?(i[0].copy(t.normal),i[1].copy(t.normal),i[2].copy(t.normal)):(i[0]=t.normal.clone(),i[1]=t.normal.clone(),i[2]=t.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){for(let n=0,t=this.faces.length;n<t;n++){const i=this.faces[n];i.__originalFaceNormal?i.__originalFaceNormal.copy(i.normal):i.__originalFaceNormal=i.normal.clone(),i.__originalVertexNormals||(i.__originalVertexNormals=[]);for(let r=0,a=i.vertexNormals.length;r<a;r++)i.__originalVertexNormals[r]?i.__originalVertexNormals[r].copy(i.vertexNormals[r]):i.__originalVertexNormals[r]=i.vertexNormals[r].clone()}const e=new on;e.faces=this.faces;for(let n=0,t=this.morphTargets.length;n<t;n++){if(!this.morphNormals[n]){this.morphNormals[n]={},this.morphNormals[n].faceNormals=[],this.morphNormals[n].vertexNormals=[];const r=this.morphNormals[n].faceNormals,a=this.morphNormals[n].vertexNormals;for(let c=0,u=this.faces.length;c<u;c++){const l=new ye,f={a:new ye,b:new ye,c:new ye};r.push(l),a.push(f)}}const i=this.morphNormals[n];e.vertices=this.morphTargets[n].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let r=0,a=this.faces.length;r<a;r++){const c=this.faces[r],u=i.faceNormals[r],l=i.vertexNormals[r];u.copy(c.normal),l.a.copy(c.vertexNormals[0]),l.b.copy(c.vertexNormals[1]),l.c.copy(c.vertexNormals[2])}}for(let n=0,t=this.faces.length;n<t;n++){const i=this.faces[n];i.normal=i.__originalFaceNormal,i.vertexNormals=i.__originalVertexNormals}},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new qs),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new xr),this.boundingSphere.setFromPoints(this.vertices)},merge:function(e,n,t){if(!(e&&e.isGeometry)){console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);return}let i,r=this.vertices.length,a=this.vertices,c=e.vertices,u=this.faces,l=e.faces,f=this.colors,m=e.colors;t===void 0&&(t=0),n!==void 0&&(i=new Oi().getNormalMatrix(n));for(let h=0,p=c.length;h<p;h++){const v=c[h].clone();n!==void 0&&v.applyMatrix4(n),a.push(v)}for(let h=0,p=m.length;h<p;h++)f.push(m[h].clone());for(let h=0,p=l.length;h<p;h++){let _=l[h],v,S,D,w=_.vertexNormals,T=_.vertexColors;v=new $g(_.a+r,_.b+r,_.c+r),v.normal.copy(_.normal),i!==void 0&&v.normal.applyMatrix3(i).normalize();for(let F=0,E=w.length;F<E;F++)S=w[F].clone(),i!==void 0&&S.applyMatrix3(i).normalize(),v.vertexNormals.push(S);v.color.copy(_.color);for(let F=0,E=T.length;F<E;F++)D=T[F],v.vertexColors.push(D.clone());v.materialIndex=_.materialIndex+t,u.push(v)}for(let h=0,p=e.faceVertexUvs.length;h<p;h++){const _=e.faceVertexUvs[h];this.faceVertexUvs[h]===void 0&&(this.faceVertexUvs[h]=[]);for(let v=0,S=_.length;v<S;v++){const D=_[v],w=[];for(let T=0,F=D.length;T<F;T++)w.push(D[T].clone());this.faceVertexUvs[h].push(w)}}},mergeMesh:function(e){if(!(e&&e.isMesh)){console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e);return}e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)},mergeVertices:function(){const e={},n=[],t=[],r=Math.pow(10,4);for(let u=0,l=this.vertices.length;u<l;u++){const f=this.vertices[u],m=Math.round(f.x*r)+"_"+Math.round(f.y*r)+"_"+Math.round(f.z*r);e[m]===void 0?(e[m]=u,n.push(this.vertices[u]),t[u]=n.length-1):t[u]=t[e[m]]}const a=[];for(let u=0,l=this.faces.length;u<l;u++){const f=this.faces[u];f.a=t[f.a],f.b=t[f.b],f.c=t[f.c];const m=[f.a,f.b,f.c];for(let h=0;h<3;h++)if(m[h]===m[(h+1)%3]){a.push(u);break}}for(let u=a.length-1;u>=0;u--){const l=a[u];this.faces.splice(l,1);for(let f=0,m=this.faceVertexUvs.length;f<m;f++)this.faceVertexUvs[f].splice(l,1)}const c=this.vertices.length-n.length;return this.vertices=n,c},setFromPoints:function(e){this.vertices=[];for(let n=0,t=e.length;n<t;n++){const i=e[n];this.vertices.push(new ye(i.x,i.y,i.z||0))}return this},sortFacesByMaterialIndex:function(){const e=this.faces,n=e.length;for(let u=0;u<n;u++)e[u]._id=u;function t(u,l){return u.materialIndex-l.materialIndex}e.sort(t);const i=this.faceVertexUvs[0],r=this.faceVertexUvs[1];let a,c;i&&i.length===n&&(a=[]),r&&r.length===n&&(c=[]);for(let u=0;u<n;u++){const l=e[u]._id;a&&a.push(i[l]),c&&c.push(r[l])}a&&(this.faceVertexUvs[0]=a),c&&(this.faceVertexUvs[1]=c)},toJSON:function(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),this.parameters!==void 0){const _=this.parameters;for(const v in _)_[v]!==void 0&&(e[v]=_[v]);return e}const n=[];for(let _=0;_<this.vertices.length;_++){const v=this.vertices[_];n.push(v.x,v.y,v.z)}const t=[],i=[],r={},a=[],c={},u=[],l={};for(let _=0;_<this.faces.length;_++){const v=this.faces[_],S=!0,D=!1,w=this.faceVertexUvs[0][_]!==void 0,T=v.normal.length()>0,F=v.vertexNormals.length>0,E=v.color.r!==1||v.color.g!==1||v.color.b!==1,A=v.vertexColors.length>0;let L=0;if(L=f(L,0,0),L=f(L,1,S),L=f(L,2,D),L=f(L,3,w),L=f(L,4,T),L=f(L,5,F),L=f(L,6,E),L=f(L,7,A),t.push(L),t.push(v.a,v.b,v.c),t.push(v.materialIndex),w){const I=this.faceVertexUvs[0][_];t.push(p(I[0]),p(I[1]),p(I[2]))}if(T&&t.push(m(v.normal)),F){const I=v.vertexNormals;t.push(m(I[0]),m(I[1]),m(I[2]))}if(E&&t.push(h(v.color)),A){const I=v.vertexColors;t.push(h(I[0]),h(I[1]),h(I[2]))}}function f(_,v,S){return S?_|1<<v:_&~(1<<v)}function m(_){const v=_.x.toString()+_.y.toString()+_.z.toString();return r[v]!==void 0||(r[v]=i.length/3,i.push(_.x,_.y,_.z)),r[v]}function h(_){const v=_.r.toString()+_.g.toString()+_.b.toString();return c[v]!==void 0||(c[v]=a.length,a.push(_.getHex())),c[v]}function p(_){const v=_.x.toString()+_.y.toString();return l[v]!==void 0||(l[v]=u.length/2,u.push(_.x,_.y)),l[v]}return e.data={},e.data.vertices=n,e.data.normals=i,a.length>0&&(e.data.colors=a),u.length>0&&(e.data.uvs=[u]),e.data.faces=t,e},clone:function(){return new on().copy(this)},copy:function(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const n=e.vertices;for(let h=0,p=n.length;h<p;h++)this.vertices.push(n[h].clone());const t=e.colors;for(let h=0,p=t.length;h<p;h++)this.colors.push(t[h].clone());const i=e.faces;for(let h=0,p=i.length;h<p;h++)this.faces.push(i[h].clone());for(let h=0,p=e.faceVertexUvs.length;h<p;h++){const _=e.faceVertexUvs[h];this.faceVertexUvs[h]===void 0&&(this.faceVertexUvs[h]=[]);for(let v=0,S=_.length;v<S;v++){const D=_[v],w=[];for(let T=0,F=D.length;T<F;T++){const E=D[T];w.push(E.clone())}this.faceVertexUvs[h].push(w)}}const r=e.morphTargets;for(let h=0,p=r.length;h<p;h++){const _={};if(_.name=r[h].name,r[h].vertices!==void 0){_.vertices=[];for(let v=0,S=r[h].vertices.length;v<S;v++)_.vertices.push(r[h].vertices[v].clone())}if(r[h].normals!==void 0){_.normals=[];for(let v=0,S=r[h].normals.length;v<S;v++)_.normals.push(r[h].normals[v].clone())}this.morphTargets.push(_)}const a=e.morphNormals;for(let h=0,p=a.length;h<p;h++){const _={};if(a[h].vertexNormals!==void 0){_.vertexNormals=[];for(let v=0,S=a[h].vertexNormals.length;v<S;v++){const D=a[h].vertexNormals[v],w={};w.a=D.a.clone(),w.b=D.b.clone(),w.c=D.c.clone(),_.vertexNormals.push(w)}}if(a[h].faceNormals!==void 0){_.faceNormals=[];for(let v=0,S=a[h].faceNormals.length;v<S;v++)_.faceNormals.push(a[h].faceNormals[v].clone())}this.morphNormals.push(_)}const c=e.skinWeights;for(let h=0,p=c.length;h<p;h++)this.skinWeights.push(c[h].clone());const u=e.skinIndices;for(let h=0,p=u.length;h<p;h++)this.skinIndices.push(u[h].clone());const l=e.lineDistances;for(let h=0,p=l.length;h<p;h++)this.lineDistances.push(l[h]);const f=e.boundingBox;f!==null&&(this.boundingBox=f.clone());const m=e.boundingSphere;return m!==null&&(this.boundingSphere=m.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});class A1 extends on{constructor(n,t,i,r,a,c){super(),this.type="BoxGeometry",this.parameters={width:n,height:t,depth:i,widthSegments:r,heightSegments:a,depthSegments:c},this.fromBufferGeometry(new qg(n,t,i,r,a,c)),this.mergeVertices()}}class qg extends Ut{constructor(n=1,t=1,i=1,r=1,a=1,c=1){super(),this.type="BoxBufferGeometry",this.parameters={width:n,height:t,depth:i,widthSegments:r,heightSegments:a,depthSegments:c};const u=this;r=Math.floor(r),a=Math.floor(a),c=Math.floor(c);const l=[],f=[],m=[],h=[];let p=0,_=0;v("z","y","x",-1,-1,i,t,n,c,a,0),v("z","y","x",1,-1,i,t,-n,c,a,1),v("x","z","y",1,1,n,i,t,r,c,2),v("x","z","y",1,-1,n,i,-t,r,c,3),v("x","y","z",1,-1,n,t,i,r,a,4),v("x","y","z",-1,-1,n,t,-i,r,a,5),this.setIndex(l),this.setAttribute("position",new Bt(f,3)),this.setAttribute("normal",new Bt(m,3)),this.setAttribute("uv",new Bt(h,2));function v(S,D,w,T,F,E,A,L,I,R,N){const q=E/I,ne=A/R,Q=E/2,W=A/2,te=L/2,K=I+1,pe=R+1;let be=0,Ee=0;const Ge=new ye;for(let _e=0;_e<pe;_e++){const De=_e*ne-W;for(let he=0;he<K;he++){const Z=he*q-Q;Ge[S]=Z*T,Ge[D]=De*F,Ge[w]=te,f.push(Ge.x,Ge.y,Ge.z),Ge[S]=0,Ge[D]=0,Ge[w]=L>0?1:-1,m.push(Ge.x,Ge.y,Ge.z),h.push(he/I),h.push(1-_e/R),be+=1}}for(let _e=0;_e<R;_e++)for(let De=0;De<I;De++){const he=p+De+K*_e,Z=p+De+K*(_e+1),me=p+(De+1)+K*(_e+1),we=p+(De+1)+K*_e;l.push(he,Z,we),l.push(Z,me,we),Ee+=6}u.addGroup(_,Ee,N),_+=Ee,p+=be}}}function qa(e){const n={};for(const t in e){n[t]={};for(const i in e[t]){const r=e[t][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture)?n[t][i]=r.clone():Array.isArray(r)?n[t][i]=r.slice():n[t][i]=r}}return n}function Ai(e){const n={};for(let t=0;t<e.length;t++){const i=qa(e[t]);for(const r in i)n[r]=i[r]}return n}const C1={clone:qa,merge:Ai};var I1=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,L1=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;function Gi(e){rn.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=I1,this.fragmentShader=L1,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}Gi.prototype=Object.create(rn.prototype),Gi.prototype.constructor=Gi,Gi.prototype.isShaderMaterial=!0,Gi.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=qa(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.extensions=Object.assign({},e.extensions),this},Gi.prototype.toJSON=function(e){const n=rn.prototype.toJSON.call(this,e);n.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?n.uniforms[i]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?n.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?n.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?n.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?n.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?n.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?n.uniforms[i]={type:"m4",value:a.toArray()}:n.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(n.defines=this.defines),n.vertexShader=this.vertexShader,n.fragmentShader=this.fragmentShader;const t={};for(const i in this.extensions)this.extensions[i]===!0&&(t[i]=!0);return Object.keys(t).length>0&&(n.extensions=t),n};function Er(){Ot.call(this),this.type="Camera",this.matrixWorldInverse=new dn,this.projectionMatrix=new dn,this.projectionMatrixInverse=new dn}Er.prototype=Object.assign(Object.create(Ot.prototype),{constructor:Er,isCamera:!0,copy:function(e,n){return Ot.prototype.copy.call(this,e,n),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this},getWorldDirection:function(e){e===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),e=new ye),this.updateMatrixWorld(!0);const n=this.matrixWorld.elements;return e.set(-n[8],-n[9],-n[10]).normalize()},updateMatrixWorld:function(e){Ot.prototype.updateMatrixWorld.call(this,e),this.matrixWorldInverse.getInverse(this.matrixWorld)},updateWorldMatrix:function(e,n){Ot.prototype.updateWorldMatrix.call(this,e,n),this.matrixWorldInverse.getInverse(this.matrixWorld)},clone:function(){return new this.constructor().copy(this)}});function ii(e,n,t,i){Er.call(this),this.type="PerspectiveCamera",this.fov=e!==void 0?e:50,this.zoom=1,this.near=t!==void 0?t:.1,this.far=i!==void 0?i:2e3,this.focus=10,this.aspect=n!==void 0?n:1,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}ii.prototype=Object.assign(Object.create(Er.prototype),{constructor:ii,isPerspectiveCamera:!0,copy:function(e,n){return Er.prototype.copy.call(this,e,n),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this},setFocalLength:function(e){const n=.5*this.getFilmHeight()/e;this.fov=ln.RAD2DEG*2*Math.atan(n),this.updateProjectionMatrix()},getFocalLength:function(){const e=Math.tan(ln.DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/e},getEffectiveFOV:function(){return ln.RAD2DEG*2*Math.atan(Math.tan(ln.DEG2RAD*.5*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(e,n,t,i,r,a){this.aspect=e/n,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=n,this.view.offsetX=t,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){let e=this.near,n=e*Math.tan(ln.DEG2RAD*.5*this.fov)/this.zoom,t=2*n,i=this.aspect*t,r=-.5*i,a=this.view;if(this.view!==null&&this.view.enabled){const u=a.fullWidth,l=a.fullHeight;r+=a.offsetX*i/u,n-=a.offsetY*t/l,i*=a.width/u,t*=a.height/l}const c=this.filmOffset;c!==0&&(r+=e*c/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,n,n-t,e,this.far),this.projectionMatrixInverse.getInverse(this.projectionMatrix)},toJSON:function(e){const n=Ot.prototype.toJSON.call(this,e);return n.object.fov=this.fov,n.object.zoom=this.zoom,n.object.near=this.near,n.object.far=this.far,n.object.focus=this.focus,n.object.aspect=this.aspect,this.view!==null&&(n.object.view=Object.assign({},this.view)),n.object.filmGauge=this.filmGauge,n.object.filmOffset=this.filmOffset,n}});const Ka=90,Xa=1;function Xu(e,n,t){if(Ot.call(this),this.type="CubeCamera",t.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=t;const i=new ii(Ka,Xa,e,n);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new ye(1,0,0)),this.add(i);const r=new ii(Ka,Xa,e,n);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new ye(-1,0,0)),this.add(r);const a=new ii(Ka,Xa,e,n);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new ye(0,1,0)),this.add(a);const c=new ii(Ka,Xa,e,n);c.layers=this.layers,c.up.set(0,0,-1),c.lookAt(new ye(0,-1,0)),this.add(c);const u=new ii(Ka,Xa,e,n);u.layers=this.layers,u.up.set(0,-1,0),u.lookAt(new ye(0,0,1)),this.add(u);const l=new ii(Ka,Xa,e,n);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new ye(0,0,-1)),this.add(l),this.update=function(f,m){this.parent===null&&this.updateMatrixWorld();const h=f.xr.enabled,p=f.getRenderTarget();f.xr.enabled=!1;const _=t.texture.generateMipmaps;t.texture.generateMipmaps=!1,f.setRenderTarget(t,0),f.render(m,i),f.setRenderTarget(t,1),f.render(m,r),f.setRenderTarget(t,2),f.render(m,a),f.setRenderTarget(t,3),f.render(m,c),f.setRenderTarget(t,4),f.render(m,u),t.texture.generateMipmaps=_,f.setRenderTarget(t,5),f.render(m,l),f.setRenderTarget(p),f.xr.enabled=h},this.clear=function(f,m,h,p){const _=f.getRenderTarget();for(let v=0;v<6;v++)f.setRenderTarget(t,v),f.clear(m,h,p);f.setRenderTarget(_)}}Xu.prototype=Object.create(Ot.prototype),Xu.prototype.constructor=Xu;function Yu(e,n,t){Number.isInteger(n)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),n=t),ps.call(this,e,e,n)}Yu.prototype=Object.create(ps.prototype),Yu.prototype.constructor=Yu,Yu.prototype.isWebGLCubeRenderTarget=!0,Yu.prototype.fromEquirectangularTexture=function(e,n){this.texture.type=n.type,this.texture.format=fs,this.texture.encoding=n.encoding,this.texture.generateMipmaps=n.generateMipmaps,this.texture.minFilter=n.minFilter,this.texture.magFilter=n.magFilter;const t=new Gu,i={uniforms:{tEquirect:{value:null}},vertexShader:`

			varying vec3 vWorldDirection;

			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

			}

			void main() {

				vWorldDirection = transformDirection( position, modelMatrix );

				#include <begin_vertex>
				#include <project_vertex>

			}
		`,fragmentShader:`

			uniform sampler2D tEquirect;

			varying vec3 vWorldDirection;

			#include <common>

			void main() {

				vec3 direction = normalize( vWorldDirection );

				vec2 sampleUV = equirectUv( direction );

				gl_FragColor = texture2D( tEquirect, sampleUV );

			}
		`},r=new Gi({name:"CubemapFromEquirect",uniforms:qa(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:li,blending:$r});r.uniforms.tEquirect.value=n;const a=new Ln(new qg(5,5,5),r);return t.add(a),new Xu(1,10,this).update(e,t),a.geometry.dispose(),a.material.dispose(),this};function Ya(e,n,t,i,r,a,c,u,l,f,m,h){Dn.call(this,null,a,c,u,l,f,i,r,m,h),this.image={data:e||null,width:n||1,height:t||1},this.magFilter=l!==void 0?l:fi,this.minFilter=f!==void 0?f:fi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}Ya.prototype=Object.create(Dn.prototype),Ya.prototype.constructor=Ya,Ya.prototype.isDataTexture=!0;const Ja=new xr,Kg=new ye;function Ju(e,n,t,i,r,a){this.planes=[e!==void 0?e:new Ks,n!==void 0?n:new Ks,t!==void 0?t:new Ks,i!==void 0?i:new Ks,r!==void 0?r:new Ks,a!==void 0?a:new Ks]}Object.assign(Ju.prototype,{set:function(e,n,t,i,r,a){const c=this.planes;return c[0].copy(e),c[1].copy(n),c[2].copy(t),c[3].copy(i),c[4].copy(r),c[5].copy(a),this},clone:function(){return new this.constructor().copy(this)},copy:function(e){const n=this.planes;for(let t=0;t<6;t++)n[t].copy(e.planes[t]);return this},setFromProjectionMatrix:function(e){const n=this.planes,t=e.elements,i=t[0],r=t[1],a=t[2],c=t[3],u=t[4],l=t[5],f=t[6],m=t[7],h=t[8],p=t[9],_=t[10],v=t[11],S=t[12],D=t[13],w=t[14],T=t[15];return n[0].setComponents(c-i,m-u,v-h,T-S).normalize(),n[1].setComponents(c+i,m+u,v+h,T+S).normalize(),n[2].setComponents(c+r,m+l,v+p,T+D).normalize(),n[3].setComponents(c-r,m-l,v-p,T-D).normalize(),n[4].setComponents(c-a,m-f,v-_,T-w).normalize(),n[5].setComponents(c+a,m+f,v+_,T+w).normalize(),this},intersectsObject:function(e){const n=e.geometry;return n.boundingSphere===null&&n.computeBoundingSphere(),Ja.copy(n.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Ja)},intersectsSprite:function(e){return Ja.center.set(0,0,0),Ja.radius=.7071067811865476,Ja.applyMatrix4(e.matrixWorld),this.intersectsSphere(Ja)},intersectsSphere:function(e){const n=this.planes,t=e.center,i=-e.radius;for(let r=0;r<6;r++)if(n[r].distanceToPoint(t)<i)return!1;return!0},intersectsBox:function(e){const n=this.planes;for(let t=0;t<6;t++){const i=n[t];if(Kg.x=i.normal.x>0?e.max.x:e.min.x,Kg.y=i.normal.y>0?e.max.y:e.min.y,Kg.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(Kg)<0)return!1}return!0},containsPoint:function(e){const n=this.planes;for(let t=0;t<6;t++)if(n[t].distanceToPoint(e)<0)return!1;return!0}});const zt={common:{diffuse:{value:new jt(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new Oi},uv2Transform:{value:new Oi},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new vt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new jt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new jt(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Oi}},sprite:{diffuse:{value:new jt(15658734)},opacity:{value:1},center:{value:new vt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Oi}}};function Fw(){let e=null,n=!1,t=null,i=null;function r(a,c){t(a,c),i=e.requestAnimationFrame(r)}return{start:function(){n!==!0&&t!==null&&(i=e.requestAnimationFrame(r),n=!0)},stop:function(){e.cancelAnimationFrame(i),n=!1},setAnimationLoop:function(a){t=a},setContext:function(a){e=a}}}function D1(e,n){const t=n.isWebGL2,i=new WeakMap;function r(f,m){const h=f.array,p=f.usage,_=e.createBuffer();e.bindBuffer(m,_),e.bufferData(m,h,p),f.onUploadCallback();let v=5126;return h instanceof Float32Array?v=5126:h instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):h instanceof Uint16Array?v=5123:h instanceof Int16Array?v=5122:h instanceof Uint32Array?v=5125:h instanceof Int32Array?v=5124:h instanceof Int8Array?v=5120:h instanceof Uint8Array&&(v=5121),{buffer:_,type:v,bytesPerElement:h.BYTES_PER_ELEMENT,version:f.version}}function a(f,m,h){const p=m.array,_=m.updateRange;e.bindBuffer(h,f),_.count===-1?e.bufferSubData(h,0,p):(t?e.bufferSubData(h,_.offset*p.BYTES_PER_ELEMENT,p,_.offset,_.count):e.bufferSubData(h,_.offset*p.BYTES_PER_ELEMENT,p.subarray(_.offset,_.offset+_.count)),_.count=-1)}function c(f){return f.isInterleavedBufferAttribute&&(f=f.data),i.get(f)}function u(f){f.isInterleavedBufferAttribute&&(f=f.data);const m=i.get(f);m&&(e.deleteBuffer(m.buffer),i.delete(f))}function l(f,m){f.isInterleavedBufferAttribute&&(f=f.data);const h=i.get(f);h===void 0?i.set(f,r(f,m)):h.version<f.version&&(a(h.buffer,f,m),h.version=f.version)}return{get:c,remove:u,update:l}}function Xg(e,n,t,i){on.call(this),this.type="PlaneGeometry",this.parameters={width:e,height:n,widthSegments:t,heightSegments:i},this.fromBufferGeometry(new Qa(e,n,t,i)),this.mergeVertices()}Xg.prototype=Object.create(on.prototype),Xg.prototype.constructor=Xg;function Qa(e,n,t,i){Ut.call(this),this.type="PlaneBufferGeometry",this.parameters={width:e,height:n,widthSegments:t,heightSegments:i},e=e||1,n=n||1;const r=e/2,a=n/2,c=Math.floor(t)||1,u=Math.floor(i)||1,l=c+1,f=u+1,m=e/c,h=n/u,p=[],_=[],v=[],S=[];for(let D=0;D<f;D++){const w=D*h-a;for(let T=0;T<l;T++){const F=T*m-r;_.push(F,-w,0),v.push(0,0,1),S.push(T/c),S.push(1-D/u)}}for(let D=0;D<u;D++)for(let w=0;w<c;w++){const T=w+l*D,F=w+l*(D+1),E=w+1+l*(D+1),A=w+1+l*D;p.push(T,F,A),p.push(F,E,A)}this.setIndex(p),this.setAttribute("position",new Bt(_,3)),this.setAttribute("normal",new Bt(v,3)),this.setAttribute("uv",new Bt(S,2))}Qa.prototype=Object.create(Ut.prototype),Qa.prototype.constructor=Qa;var k1=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,O1=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,F1=`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,R1=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,B1=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,z1="vec3 transformed = vec3( position );",$1=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,N1=`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha  = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,U1=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,G1=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,V1=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,j1=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,W1=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,H1=`#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,q1=`#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,K1=`#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,X1=`#ifdef USE_COLOR
	vColor.xyz = color.xyz;
#endif`,Y1=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,J1=`#ifdef ENVMAP_TYPE_CUBE_UV
#define cubeUV_maxMipLevel 8.0
#define cubeUV_minMipLevel 4.0
#define cubeUV_maxTileSize 256.0
#define cubeUV_minTileSize 16.0
float getFace(vec3 direction) {
    vec3 absDirection = abs(direction);
    float face = -1.0;
    if (absDirection.x > absDirection.z) {
      if (absDirection.x > absDirection.y)
        face = direction.x > 0.0 ? 0.0 : 3.0;
      else
        face = direction.y > 0.0 ? 1.0 : 4.0;
    } else {
      if (absDirection.z > absDirection.y)
        face = direction.z > 0.0 ? 2.0 : 5.0;
      else
        face = direction.y > 0.0 ? 1.0 : 4.0;
    }
    return face;
}
vec2 getUV(vec3 direction, float face) {
    vec2 uv;
    if (face == 0.0) {
      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {
      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {
      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {
      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {
      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {
      uv = vec2(direction.x, direction.y) / abs(direction.z);    }
    return 0.5 * (uv + 1.0);
}
vec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
  float face = getFace(direction);
  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
  mipInt = max(mipInt, cubeUV_minMipLevel);
  float faceSize = exp2(mipInt);
  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
  vec2 uv = getUV(direction, face) * (faceSize - 1.0);
  vec2 f = fract(uv);
  uv += 0.5 - f;
  if (face > 2.0) {
    uv.y += faceSize;
    face -= 3.0;
  }
  uv.x += face * faceSize;
  if(mipInt < cubeUV_maxMipLevel){
    uv.y += 2.0 * cubeUV_maxTileSize;
  }
  uv.y += filterInt * 2.0 * cubeUV_minTileSize;
  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
  uv *= texelSize;
  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.x += texelSize;
  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.y += texelSize;
  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.x -= texelSize;
  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  vec3 tm = mix(tl, tr, f.x);
  vec3 bm = mix(bl, br, f.x);
  return mix(tm, bm, f.y);
}
#define r0 1.0
#define v0 0.339
#define m0 -2.0
#define r1 0.8
#define v1 0.276
#define m1 -1.0
#define r4 0.4
#define v4 0.046
#define m4 2.0
#define r5 0.305
#define v5 0.016
#define m5 3.0
#define r6 0.21
#define v6 0.0038
#define m6 4.0
float roughnessToMip(float roughness) {
  float mip = 0.0;
  if (roughness >= r1) {
    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
  } else if (roughness >= r4) {
    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
  } else if (roughness >= r5) {
    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
  } else if (roughness >= r6) {
    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
  } else {
    mip = -2.0 * log2(1.16 * roughness);  }
  return mip;
}
vec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {
  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);
  float mipF = fract(mip);
  float mipInt = floor(mip);
  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);
  if (mipF == 0.0) {
    return vec4(color0, 1.0);
  } else {
    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);
    return vec4(mix(color0, color1, mipF), 1.0);
  }
}
#endif`,Q1=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Z1=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,eT=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,tT=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,nT=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,iT="gl_FragColor = linearToOutputTexel( gl_FragColor );",sT=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,rT=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		}  else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#elif defined( ENVMAP_TYPE_EQUIREC )
		reflectVec = normalize( reflectVec );
		vec2 sampleUV = equirectUv( reflectVec );
		vec4 envColor = texture2D( envMap, sampleUV );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,oT=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,aT=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,lT=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,cT=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,uT=`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,dT=`#ifdef USE_FOG
	varying float fogDepth;
#endif`,hT=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fT=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,pT=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,mT=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,gT=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,_T=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,yT=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,vT=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
		  vec3 reflectVec = reflect( -viewDir, normal );
		  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
		  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#elif defined( ENVMAP_TYPE_EQUIREC )
			vec2 sampleUV = equirectUv( reflectVec );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,wT=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,xT=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,bT=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,MT=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,TT=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,ET=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,ST=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,PT=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,AT=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,CT=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,IT=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,LT=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,DT=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,kT=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,OT=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,FT=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,RT=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,BT=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,zT=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,$T=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,NT=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,UT=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,GT=`#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,VT=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif`,jT=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif`,WT=`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,HT=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );
	#endif
#endif`,qT=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,KT=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,XT=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,YT=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,JT=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,QT=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,ZT=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,eE=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,tE=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,nE=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,iE=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,sE=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,rE=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,oE=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,aE=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,lE=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,cE=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,uE=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,dE=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,hE=`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,fE=`#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,pE=`#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,mE=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,gE=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,_E=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,yE=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,vE=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,wE=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,xE=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,bE=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,ME=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,TE=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,EE=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,SE=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,PE=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,AE=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,CE=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,IE=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,LE=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,DE=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,kE=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,OE=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,FE=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,RE=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,BE=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,zE=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,$E=`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,NE=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,UE=`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,GE=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,VE=`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,jE=`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,WE=`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,HE=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,qE=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,KE=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,XE=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,YE=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,JE=`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,QE=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,ZE=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;const fn={alphamap_fragment:k1,alphamap_pars_fragment:O1,alphatest_fragment:F1,aomap_fragment:R1,aomap_pars_fragment:B1,begin_vertex:z1,beginnormal_vertex:$1,bsdfs:N1,bumpmap_pars_fragment:U1,clipping_planes_fragment:G1,clipping_planes_pars_fragment:V1,clipping_planes_pars_vertex:j1,clipping_planes_vertex:W1,color_fragment:H1,color_pars_fragment:q1,color_pars_vertex:K1,color_vertex:X1,common:Y1,cube_uv_reflection_fragment:J1,defaultnormal_vertex:Q1,displacementmap_pars_vertex:Z1,displacementmap_vertex:eT,emissivemap_fragment:tT,emissivemap_pars_fragment:nT,encodings_fragment:iT,encodings_pars_fragment:sT,envmap_fragment:rT,envmap_common_pars_fragment:oT,envmap_pars_fragment:aT,envmap_pars_vertex:lT,envmap_physical_pars_fragment:vT,envmap_vertex:cT,fog_vertex:uT,fog_pars_vertex:dT,fog_fragment:hT,fog_pars_fragment:fT,gradientmap_pars_fragment:pT,lightmap_fragment:mT,lightmap_pars_fragment:gT,lights_lambert_vertex:_T,lights_pars_begin:yT,lights_toon_fragment:wT,lights_toon_pars_fragment:xT,lights_phong_fragment:bT,lights_phong_pars_fragment:MT,lights_physical_fragment:TT,lights_physical_pars_fragment:ET,lights_fragment_begin:ST,lights_fragment_maps:PT,lights_fragment_end:AT,logdepthbuf_fragment:CT,logdepthbuf_pars_fragment:IT,logdepthbuf_pars_vertex:LT,logdepthbuf_vertex:DT,map_fragment:kT,map_pars_fragment:OT,map_particle_fragment:FT,map_particle_pars_fragment:RT,metalnessmap_fragment:BT,metalnessmap_pars_fragment:zT,morphnormal_vertex:$T,morphtarget_pars_vertex:NT,morphtarget_vertex:UT,normal_fragment_begin:GT,normal_fragment_maps:VT,normalmap_pars_fragment:jT,clearcoat_normal_fragment_begin:WT,clearcoat_normal_fragment_maps:HT,clearcoat_pars_fragment:qT,packing:KT,premultiplied_alpha_fragment:XT,project_vertex:YT,dithering_fragment:JT,dithering_pars_fragment:QT,roughnessmap_fragment:ZT,roughnessmap_pars_fragment:eE,shadowmap_pars_fragment:tE,shadowmap_pars_vertex:nE,shadowmap_vertex:iE,shadowmask_pars_fragment:sE,skinbase_vertex:rE,skinning_pars_vertex:oE,skinning_vertex:aE,skinnormal_vertex:lE,specularmap_fragment:cE,specularmap_pars_fragment:uE,tonemapping_fragment:dE,tonemapping_pars_fragment:hE,transmissionmap_fragment:fE,transmissionmap_pars_fragment:pE,uv_pars_fragment:mE,uv_pars_vertex:gE,uv_vertex:_E,uv2_pars_fragment:yE,uv2_pars_vertex:vE,uv2_vertex:wE,worldpos_vertex:xE,background_frag:bE,background_vert:ME,cube_frag:TE,cube_vert:EE,depth_frag:SE,depth_vert:PE,distanceRGBA_frag:AE,distanceRGBA_vert:CE,equirect_frag:IE,equirect_vert:LE,linedashed_frag:DE,linedashed_vert:kE,meshbasic_frag:OE,meshbasic_vert:FE,meshlambert_frag:RE,meshlambert_vert:BE,meshmatcap_frag:zE,meshmatcap_vert:$E,meshtoon_frag:NE,meshtoon_vert:UE,meshphong_frag:GE,meshphong_vert:VE,meshphysical_frag:jE,meshphysical_vert:WE,normal_frag:HE,normal_vert:qE,points_frag:KE,points_vert:XE,shadow_frag:YE,shadow_vert:JE,sprite_frag:QE,sprite_vert:ZE},Js={basic:{uniforms:Ai([zt.common,zt.specularmap,zt.envmap,zt.aomap,zt.lightmap,zt.fog]),vertexShader:fn.meshbasic_vert,fragmentShader:fn.meshbasic_frag},lambert:{uniforms:Ai([zt.common,zt.specularmap,zt.envmap,zt.aomap,zt.lightmap,zt.emissivemap,zt.fog,zt.lights,{emissive:{value:new jt(0)}}]),vertexShader:fn.meshlambert_vert,fragmentShader:fn.meshlambert_frag},phong:{uniforms:Ai([zt.common,zt.specularmap,zt.envmap,zt.aomap,zt.lightmap,zt.emissivemap,zt.bumpmap,zt.normalmap,zt.displacementmap,zt.fog,zt.lights,{emissive:{value:new jt(0)},specular:{value:new jt(1118481)},shininess:{value:30}}]),vertexShader:fn.meshphong_vert,fragmentShader:fn.meshphong_frag},standard:{uniforms:Ai([zt.common,zt.envmap,zt.aomap,zt.lightmap,zt.emissivemap,zt.bumpmap,zt.normalmap,zt.displacementmap,zt.roughnessmap,zt.metalnessmap,zt.fog,zt.lights,{emissive:{value:new jt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:fn.meshphysical_vert,fragmentShader:fn.meshphysical_frag},toon:{uniforms:Ai([zt.common,zt.aomap,zt.lightmap,zt.emissivemap,zt.bumpmap,zt.normalmap,zt.displacementmap,zt.gradientmap,zt.fog,zt.lights,{emissive:{value:new jt(0)}}]),vertexShader:fn.meshtoon_vert,fragmentShader:fn.meshtoon_frag},matcap:{uniforms:Ai([zt.common,zt.bumpmap,zt.normalmap,zt.displacementmap,zt.fog,{matcap:{value:null}}]),vertexShader:fn.meshmatcap_vert,fragmentShader:fn.meshmatcap_frag},points:{uniforms:Ai([zt.points,zt.fog]),vertexShader:fn.points_vert,fragmentShader:fn.points_frag},dashed:{uniforms:Ai([zt.common,zt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:fn.linedashed_vert,fragmentShader:fn.linedashed_frag},depth:{uniforms:Ai([zt.common,zt.displacementmap]),vertexShader:fn.depth_vert,fragmentShader:fn.depth_frag},normal:{uniforms:Ai([zt.common,zt.bumpmap,zt.normalmap,zt.displacementmap,{opacity:{value:1}}]),vertexShader:fn.normal_vert,fragmentShader:fn.normal_frag},sprite:{uniforms:Ai([zt.sprite,zt.fog]),vertexShader:fn.sprite_vert,fragmentShader:fn.sprite_frag},background:{uniforms:{uvTransform:{value:new Oi},t2D:{value:null}},vertexShader:fn.background_vert,fragmentShader:fn.background_frag},cube:{uniforms:Ai([zt.envmap,{opacity:{value:1}}]),vertexShader:fn.cube_vert,fragmentShader:fn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:fn.equirect_vert,fragmentShader:fn.equirect_frag},distanceRGBA:{uniforms:Ai([zt.common,zt.displacementmap,{referencePosition:{value:new ye},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:fn.distanceRGBA_vert,fragmentShader:fn.distanceRGBA_frag},shadow:{uniforms:Ai([zt.lights,zt.fog,{color:{value:new jt(0)},opacity:{value:1}}]),vertexShader:fn.shadow_vert,fragmentShader:fn.shadow_frag}};Js.physical={uniforms:Ai([Js.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new vt(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new jt(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:fn.meshphysical_vert,fragmentShader:fn.meshphysical_frag};function e2(e,n,t,i){const r=new jt(0);let a=0,c,u,l=null,f=0,m=null;function h(_,v,S,D){let w=v.isScene===!0?v.background:null;const T=e.xr,F=T.getSession&&T.getSession();if(F&&F.environmentBlendMode==="additive"&&(w=null),w===null?p(r,a):w&&w.isColor&&(p(w,1),D=!0),(e.autoClear||D)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),w&&(w.isCubeTexture||w.isWebGLCubeRenderTarget||w.mapping===Ru)){u===void 0&&(u=new Ln(new qg(1,1,1),new Gi({name:"BackgroundCubeMaterial",uniforms:qa(Js.cube.uniforms),vertexShader:Js.cube.vertexShader,fragmentShader:Js.cube.fragmentShader,side:li,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(A,L,I){this.matrixWorld.copyPosition(I.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),t.update(u));const E=w.isWebGLCubeRenderTarget?w.texture:w;u.material.uniforms.envMap.value=E,u.material.uniforms.flipEnvMap.value=E.isCubeTexture?-1:1,(l!==w||f!==E.version||m!==e.toneMapping)&&(u.material.needsUpdate=!0,l=w,f=E.version,m=e.toneMapping),_.unshift(u,u.geometry,u.material,0,0,null)}else w&&w.isTexture&&(c===void 0&&(c=new Ln(new Qa(2,2),new Gi({name:"BackgroundMaterial",uniforms:qa(Js.background.uniforms),vertexShader:Js.background.vertexShader,fragmentShader:Js.background.fragmentShader,side:Ou,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),t.update(c)),c.material.uniforms.t2D.value=w,w.matrixAutoUpdate===!0&&w.updateMatrix(),c.material.uniforms.uvTransform.value.copy(w.matrix),(l!==w||f!==w.version||m!==e.toneMapping)&&(c.material.needsUpdate=!0,l=w,f=w.version,m=e.toneMapping),_.unshift(c,c.geometry,c.material,0,0,null))}function p(_,v){n.buffers.color.setClear(_.r,_.g,_.b,v,i)}return{getClearColor:function(){return r},setClearColor:function(_,v){r.set(_),a=v!==void 0?v:1,p(r,a)},getClearAlpha:function(){return a},setClearAlpha:function(_){a=_,p(r,a)},render:h}}function t2(e,n,t,i){const r=e.getParameter(34921),a=i.isWebGL2?null:n.get("OES_vertex_array_object"),c=i.isWebGL2||a!==null,u={},l=S(null);let f=l;function m(W,te,K,pe,be){let Ee=!1;if(c){const Ge=v(pe,K,te);f!==Ge&&(f=Ge,p(f.object)),Ee=D(pe),Ee&&w(pe)}else{const Ge=te.wireframe===!0;(f.geometry!==pe.id||f.program!==K.id||f.wireframe!==Ge)&&(f.geometry=pe.id,f.program=K.id,f.wireframe=Ge,Ee=!0)}W.isInstancedMesh===!0&&(Ee=!0),be!==null&&t.update(be,34963),Ee&&(I(W,te,K,pe),be!==null&&e.bindBuffer(34963,t.get(be).buffer))}function h(){return i.isWebGL2?e.createVertexArray():a.createVertexArrayOES()}function p(W){return i.isWebGL2?e.bindVertexArray(W):a.bindVertexArrayOES(W)}function _(W){return i.isWebGL2?e.deleteVertexArray(W):a.deleteVertexArrayOES(W)}function v(W,te,K){const pe=K.wireframe===!0;let be=u[W.id];be===void 0&&(be={},u[W.id]=be);let Ee=be[te.id];Ee===void 0&&(Ee={},be[te.id]=Ee);let Ge=Ee[pe];return Ge===void 0&&(Ge=S(h()),Ee[pe]=Ge),Ge}function S(W){const te=[],K=[],pe=[];for(let be=0;be<r;be++)te[be]=0,K[be]=0,pe[be]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:te,enabledAttributes:K,attributeDivisors:pe,object:W,attributes:{}}}function D(W){const te=f.attributes,K=W.attributes;if(Object.keys(te).length!==Object.keys(K).length)return!0;for(const pe in K){const be=te[pe],Ee=K[pe];if(be.attribute!==Ee||be.data!==Ee.data)return!0}return!1}function w(W){const te={},K=W.attributes;for(const pe in K){const be=K[pe],Ee={};Ee.attribute=be,be.data&&(Ee.data=be.data),te[pe]=Ee}f.attributes=te}function T(){const W=f.newAttributes;for(let te=0,K=W.length;te<K;te++)W[te]=0}function F(W){E(W,0)}function E(W,te){const K=f.newAttributes,pe=f.enabledAttributes,be=f.attributeDivisors;K[W]=1,pe[W]===0&&(e.enableVertexAttribArray(W),pe[W]=1),be[W]!==te&&((i.isWebGL2?e:n.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](W,te),be[W]=te)}function A(){const W=f.newAttributes,te=f.enabledAttributes;for(let K=0,pe=te.length;K<pe;K++)te[K]!==W[K]&&(e.disableVertexAttribArray(K),te[K]=0)}function L(W,te,K,pe,be,Ee){i.isWebGL2===!0&&(K===5124||K===5125)?e.vertexAttribIPointer(W,te,K,be,Ee):e.vertexAttribPointer(W,te,K,pe,be,Ee)}function I(W,te,K,pe){if(i.isWebGL2===!1&&(W.isInstancedMesh||pe.isInstancedBufferGeometry)&&n.get("ANGLE_instanced_arrays")===null)return;T();const be=pe.attributes,Ee=K.getAttributes(),Ge=te.defaultAttributeValues;for(const _e in Ee){const De=Ee[_e];if(De>=0){const he=be[_e];if(he!==void 0){const Z=he.normalized,me=he.itemSize,we=t.get(he);if(we===void 0)continue;const xe=we.buffer,et=we.type,Ve=we.bytesPerElement;if(he.isInterleavedBufferAttribute){const nt=he.data,Be=nt.stride,ae=he.offset;nt&&nt.isInstancedInterleavedBuffer?(E(De,nt.meshPerAttribute),pe._maxInstanceCount===void 0&&(pe._maxInstanceCount=nt.meshPerAttribute*nt.count)):F(De),e.bindBuffer(34962,xe),L(De,me,et,Z,Be*Ve,ae*Ve)}else he.isInstancedBufferAttribute?(E(De,he.meshPerAttribute),pe._maxInstanceCount===void 0&&(pe._maxInstanceCount=he.meshPerAttribute*he.count)):F(De),e.bindBuffer(34962,xe),L(De,me,et,Z,0,0)}else if(_e==="instanceMatrix"){const Z=t.get(W.instanceMatrix);if(Z===void 0)continue;const me=Z.buffer,we=Z.type;E(De+0,1),E(De+1,1),E(De+2,1),E(De+3,1),e.bindBuffer(34962,me),e.vertexAttribPointer(De+0,4,we,!1,64,0),e.vertexAttribPointer(De+1,4,we,!1,64,16),e.vertexAttribPointer(De+2,4,we,!1,64,32),e.vertexAttribPointer(De+3,4,we,!1,64,48)}else if(Ge!==void 0){const Z=Ge[_e];if(Z!==void 0)switch(Z.length){case 2:e.vertexAttrib2fv(De,Z);break;case 3:e.vertexAttrib3fv(De,Z);break;case 4:e.vertexAttrib4fv(De,Z);break;default:e.vertexAttrib1fv(De,Z)}}}}A()}function R(){ne();for(const W in u){const te=u[W];for(const K in te){const pe=te[K];for(const be in pe)_(pe[be].object),delete pe[be];delete te[K]}delete u[W]}}function N(W){if(u[W.id]===void 0)return;const te=u[W.id];for(const K in te){const pe=te[K];for(const be in pe)_(pe[be].object),delete pe[be];delete te[K]}delete u[W.id]}function q(W){for(const te in u){const K=u[te];if(K[W.id]===void 0)continue;const pe=K[W.id];for(const be in pe)_(pe[be].object),delete pe[be];delete K[W.id]}}function ne(){Q(),f!==l&&(f=l,p(f.object))}function Q(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:m,reset:ne,resetDefaultState:Q,dispose:R,releaseStatesOfGeometry:N,releaseStatesOfProgram:q,initAttributes:T,enableAttribute:F,disableUnusedAttributes:A}}function n2(e,n,t,i){const r=i.isWebGL2;let a;function c(f){a=f}function u(f,m){e.drawArrays(a,f,m),t.update(m,a,1)}function l(f,m,h){if(h===0)return;let p,_;if(r)p=e,_="drawArraysInstanced";else if(p=n.get("ANGLE_instanced_arrays"),_="drawArraysInstancedANGLE",p===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}p[_](a,f,m,h),t.update(m,a,h)}this.setMode=c,this.render=u,this.renderInstances=l}function i2(e,n,t){let i;function r(){if(i!==void 0)return i;const L=n.get("EXT_texture_filter_anisotropic");return L!==null?i=e.getParameter(L.MAX_TEXTURE_MAX_ANISOTROPY_EXT):i=0,i}function a(L){if(L==="highp"){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";L="mediump"}return L==="mediump"&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const c=typeof WebGL2RenderingContext<"u"&&e instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&e instanceof WebGL2ComputeRenderingContext;let u=t.precision!==void 0?t.precision:"highp";const l=a(u);l!==u&&(console.warn("THREE.WebGLRenderer:",u,"not supported, using",l,"instead."),u=l);const f=t.logarithmicDepthBuffer===!0,m=e.getParameter(34930),h=e.getParameter(35660),p=e.getParameter(3379),_=e.getParameter(34076),v=e.getParameter(34921),S=e.getParameter(36347),D=e.getParameter(36348),w=e.getParameter(36349),T=h>0,F=c||!!n.get("OES_texture_float"),E=T&&F,A=c?e.getParameter(36183):0;return{isWebGL2:c,getMaxAnisotropy:r,getMaxPrecision:a,precision:u,logarithmicDepthBuffer:f,maxTextures:m,maxVertexTextures:h,maxTextureSize:p,maxCubemapSize:_,maxAttributes:v,maxVertexUniforms:S,maxVaryings:D,maxFragmentUniforms:w,vertexTextures:T,floatFragmentTextures:F,floatVertexTextures:E,maxSamples:A}}function s2(){const e=this;let n=null,t=0,i=!1,r=!1;const a=new Ks,c=new Oi,u={value:null,needsUpdate:!1};this.uniform=u,this.numPlanes=0,this.numIntersection=0,this.init=function(m,h,p){const _=m.length!==0||h||t!==0||i;return i=h,n=f(m,p,0),t=m.length,_},this.beginShadows=function(){r=!0,f(null)},this.endShadows=function(){r=!1,l()},this.setState=function(m,h,p,_,v,S){if(!i||m===null||m.length===0||r&&!p)r?f(null):l();else{const D=r?0:t,w=D*4;let T=v.clippingState||null;u.value=T,T=f(m,_,w,S);for(let F=0;F!==w;++F)T[F]=n[F];v.clippingState=T,this.numIntersection=h?this.numPlanes:0,this.numPlanes+=D}};function l(){u.value!==n&&(u.value=n,u.needsUpdate=t>0),e.numPlanes=t,e.numIntersection=0}function f(m,h,p,_){let v=m!==null?m.length:0,S=null;if(v!==0){if(S=u.value,_!==!0||S===null){const D=p+v*4,w=h.matrixWorldInverse;c.getNormalMatrix(w),(S===null||S.length<D)&&(S=new Float32Array(D));for(let T=0,F=p;T!==v;++T,F+=4)a.copy(m[T]).applyMatrix4(w,c),a.normal.toArray(S,F),S[F+3]=a.constant}u.value=S,u.needsUpdate=!0}return e.numPlanes=v,e.numIntersection=0,S}}function r2(e){const n={};return{has:function(t){if(n[t]!==void 0)return n[t];let i;switch(t){case"WEBGL_depth_texture":i=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=e.getExtension(t)}return n[t]=i,!!i},get:function(t){return this.has(t)||console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),n[t]}}}function o2(e,n,t,i){const r=new WeakMap,a=new WeakMap;function c(h){const p=h.target,_=r.get(p);_.index!==null&&n.remove(_.index);for(const S in _.attributes)n.remove(_.attributes[S]);p.removeEventListener("dispose",c),r.delete(p);const v=a.get(_);v&&(n.remove(v),a.delete(_)),i.releaseStatesOfGeometry(p),p.isInstancedBufferGeometry===!0&&delete p._maxInstanceCount,t.memory.geometries--}function u(h,p){let _=r.get(p);return _||(p.addEventListener("dispose",c),p.isBufferGeometry?_=p:p.isGeometry&&(p._bufferGeometry===void 0&&(p._bufferGeometry=new Ut().setFromObject(h)),_=p._bufferGeometry),r.set(p,_),t.memory.geometries++,_)}function l(h){const p=h.attributes;for(const v in p)n.update(p[v],34962);const _=h.morphAttributes;for(const v in _){const S=_[v];for(let D=0,w=S.length;D<w;D++)n.update(S[D],34962)}}function f(h){const p=[],_=h.index,v=h.attributes.position;let S=0;if(_!==null){const T=_.array;S=_.version;for(let F=0,E=T.length;F<E;F+=3){const A=T[F+0],L=T[F+1],I=T[F+2];p.push(A,L,L,I,I,A)}}else{const T=v.array;S=v.version;for(let F=0,E=T.length/3-1;F<E;F+=3){const A=F+0,L=F+1,I=F+2;p.push(A,L,L,I,I,A)}}const D=new(Dw(p)>65535?Hu:Wu)(p,1);D.version=S;const w=a.get(h);w&&n.remove(w),a.set(h,D)}function m(h){const p=a.get(h);if(p){const _=h.index;_!==null&&p.version<_.version&&f(h)}else f(h);return a.get(h)}return{get:u,update:l,getWireframeAttribute:m}}function a2(e,n,t,i){const r=i.isWebGL2;let a;function c(p){a=p}let u,l;function f(p){u=p.type,l=p.bytesPerElement}function m(p,_){e.drawElements(a,_,u,p*l),t.update(_,a,1)}function h(p,_,v){if(v===0)return;let S,D;if(r)S=e,D="drawElementsInstanced";else if(S=n.get("ANGLE_instanced_arrays"),D="drawElementsInstancedANGLE",S===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}S[D](a,_,u,p*l,v),t.update(_,a,v)}this.setMode=c,this.setIndex=f,this.render=m,this.renderInstances=h}function l2(e){const n={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function i(a,c,u){switch(t.calls++,c){case 4:t.triangles+=u*(a/3);break;case 1:t.lines+=u*(a/2);break;case 3:t.lines+=u*(a-1);break;case 2:t.lines+=u*a;break;case 0:t.points+=u*a;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",c);break}}function r(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:n,render:t,programs:null,autoReset:!0,reset:r,update:i}}function c2(e,n){return e[0]-n[0]}function u2(e,n){return Math.abs(n[1])-Math.abs(e[1])}function d2(e){const n={},t=new Float32Array(8),i=[];for(let a=0;a<8;a++)i[a]=[a,0];function r(a,c,u,l){const f=a.morphTargetInfluences,m=f===void 0?0:f.length;let h=n[c.id];if(h===void 0){h=[];for(let D=0;D<m;D++)h[D]=[D,0];n[c.id]=h}for(let D=0;D<m;D++){const w=h[D];w[0]=D,w[1]=f[D]}h.sort(u2);for(let D=0;D<8;D++)D<m&&h[D][1]?(i[D][0]=h[D][0],i[D][1]=h[D][1]):(i[D][0]=Number.MAX_SAFE_INTEGER,i[D][1]=0);i.sort(c2);const p=u.morphTargets&&c.morphAttributes.position,_=u.morphNormals&&c.morphAttributes.normal;let v=0;for(let D=0;D<8;D++){const w=i[D],T=w[0],F=w[1];T!==Number.MAX_SAFE_INTEGER&&F?(p&&c.getAttribute("morphTarget"+D)!==p[T]&&c.setAttribute("morphTarget"+D,p[T]),_&&c.getAttribute("morphNormal"+D)!==_[T]&&c.setAttribute("morphNormal"+D,_[T]),t[D]=F,v+=F):(p&&c.getAttribute("morphTarget"+D)!==void 0&&c.deleteAttribute("morphTarget"+D),_&&c.getAttribute("morphNormal"+D)!==void 0&&c.deleteAttribute("morphNormal"+D),t[D]=0)}const S=c.morphTargetsRelative?1:1-v;l.getUniforms().setValue(e,"morphTargetBaseInfluence",S),l.getUniforms().setValue(e,"morphTargetInfluences",t)}return{update:r}}function h2(e,n,t,i){let r=new WeakMap;function a(u){const l=i.render.frame,f=u.geometry,m=n.get(u,f);return r.get(m)!==l&&(f.isGeometry&&m.updateFromObject(u),n.update(m),r.set(m,l)),u.isInstancedMesh&&t.update(u.instanceMatrix,34962),m}function c(){r=new WeakMap}return{update:a,dispose:c}}function Kr(e,n,t,i,r,a,c,u,l,f){e=e!==void 0?e:[],n=n!==void 0?n:Ky,c=c!==void 0?c:bo,Dn.call(this,e,n,t,i,r,a,c,u,l,f),this.flipY=!1}Kr.prototype=Object.create(Dn.prototype),Kr.prototype.constructor=Kr,Kr.prototype.isCubeTexture=!0,Object.defineProperty(Kr.prototype,"images",{get:function(){return this.image},set:function(e){this.image=e}});function Qu(e,n,t,i){Dn.call(this,null),this.image={data:e||null,width:n||1,height:t||1,depth:i||1},this.magFilter=fi,this.minFilter=fi,this.wrapR=Ni,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}Qu.prototype=Object.create(Dn.prototype),Qu.prototype.constructor=Qu,Qu.prototype.isDataTexture2DArray=!0;function Zu(e,n,t,i){Dn.call(this,null),this.image={data:e||null,width:n||1,height:t||1,depth:i||1},this.magFilter=fi,this.minFilter=fi,this.wrapR=Ni,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}Zu.prototype=Object.create(Dn.prototype),Zu.prototype.constructor=Zu,Zu.prototype.isDataTexture3D=!0;const Rw=new Dn,f2=new Qu,p2=new Zu,Bw=new Kr,zw=[],$w=[],Nw=new Float32Array(16),Uw=new Float32Array(9),Gw=new Float32Array(4);function Za(e,n,t){const i=e[0];if(i<=0||i>0)return e;let r=n*t,a=zw[r];if(a===void 0&&(a=new Float32Array(r),zw[r]=a),n!==0){i.toArray(a,0);for(let c=1,u=0;c!==n;++c)u+=t,e[c].toArray(a,u)}return a}function gs(e,n){if(e.length!==n.length)return!1;for(let t=0,i=e.length;t<i;t++)if(e[t]!==n[t])return!1;return!0}function es(e,n){for(let t=0,i=n.length;t<i;t++)e[t]=n[t]}function Vw(e,n){let t=$w[n];t===void 0&&(t=new Int32Array(n),$w[n]=t);for(let i=0;i!==n;++i)t[i]=e.allocateTextureUnit();return t}function m2(e,n){const t=this.cache;t[0]!==n&&(e.uniform1f(this.addr,n),t[0]=n)}function g2(e,n){const t=this.cache;if(n.x!==void 0)(t[0]!==n.x||t[1]!==n.y)&&(e.uniform2f(this.addr,n.x,n.y),t[0]=n.x,t[1]=n.y);else{if(gs(t,n))return;e.uniform2fv(this.addr,n),es(t,n)}}function _2(e,n){const t=this.cache;if(n.x!==void 0)(t[0]!==n.x||t[1]!==n.y||t[2]!==n.z)&&(e.uniform3f(this.addr,n.x,n.y,n.z),t[0]=n.x,t[1]=n.y,t[2]=n.z);else if(n.r!==void 0)(t[0]!==n.r||t[1]!==n.g||t[2]!==n.b)&&(e.uniform3f(this.addr,n.r,n.g,n.b),t[0]=n.r,t[1]=n.g,t[2]=n.b);else{if(gs(t,n))return;e.uniform3fv(this.addr,n),es(t,n)}}function y2(e,n){const t=this.cache;if(n.x!==void 0)(t[0]!==n.x||t[1]!==n.y||t[2]!==n.z||t[3]!==n.w)&&(e.uniform4f(this.addr,n.x,n.y,n.z,n.w),t[0]=n.x,t[1]=n.y,t[2]=n.z,t[3]=n.w);else{if(gs(t,n))return;e.uniform4fv(this.addr,n),es(t,n)}}function v2(e,n){const t=this.cache,i=n.elements;if(i===void 0){if(gs(t,n))return;e.uniformMatrix2fv(this.addr,!1,n),es(t,n)}else{if(gs(t,i))return;Gw.set(i),e.uniformMatrix2fv(this.addr,!1,Gw),es(t,i)}}function w2(e,n){const t=this.cache,i=n.elements;if(i===void 0){if(gs(t,n))return;e.uniformMatrix3fv(this.addr,!1,n),es(t,n)}else{if(gs(t,i))return;Uw.set(i),e.uniformMatrix3fv(this.addr,!1,Uw),es(t,i)}}function x2(e,n){const t=this.cache,i=n.elements;if(i===void 0){if(gs(t,n))return;e.uniformMatrix4fv(this.addr,!1,n),es(t,n)}else{if(gs(t,i))return;Nw.set(i),e.uniformMatrix4fv(this.addr,!1,Nw),es(t,i)}}function b2(e,n,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(e.uniform1i(this.addr,r),i[0]=r),t.safeSetTexture2D(n||Rw,r)}function M2(e,n,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(e.uniform1i(this.addr,r),i[0]=r),t.setTexture2DArray(n||f2,r)}function T2(e,n,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(e.uniform1i(this.addr,r),i[0]=r),t.setTexture3D(n||p2,r)}function E2(e,n,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(e.uniform1i(this.addr,r),i[0]=r),t.safeSetTextureCube(n||Bw,r)}function S2(e,n){const t=this.cache;t[0]!==n&&(e.uniform1i(this.addr,n),t[0]=n)}function P2(e,n){const t=this.cache;gs(t,n)||(e.uniform2iv(this.addr,n),es(t,n))}function A2(e,n){const t=this.cache;gs(t,n)||(e.uniform3iv(this.addr,n),es(t,n))}function C2(e,n){const t=this.cache;gs(t,n)||(e.uniform4iv(this.addr,n),es(t,n))}function I2(e,n){const t=this.cache;t[0]!==n&&(e.uniform1ui(this.addr,n),t[0]=n)}function L2(e){switch(e){case 5126:return m2;case 35664:return g2;case 35665:return _2;case 35666:return y2;case 35674:return v2;case 35675:return w2;case 35676:return x2;case 5124:case 35670:return S2;case 35667:case 35671:return P2;case 35668:case 35672:return A2;case 35669:case 35673:return C2;case 5125:return I2;case 35678:case 36198:case 36298:case 36306:case 35682:return b2;case 35679:case 36299:case 36307:return T2;case 35680:case 36300:case 36308:case 36293:return E2;case 36289:case 36303:case 36311:case 36292:return M2}}function D2(e,n){e.uniform1fv(this.addr,n)}function k2(e,n){e.uniform1iv(this.addr,n)}function O2(e,n){e.uniform2iv(this.addr,n)}function F2(e,n){e.uniform3iv(this.addr,n)}function R2(e,n){e.uniform4iv(this.addr,n)}function B2(e,n){const t=Za(n,this.size,2);e.uniform2fv(this.addr,t)}function z2(e,n){const t=Za(n,this.size,3);e.uniform3fv(this.addr,t)}function $2(e,n){const t=Za(n,this.size,4);e.uniform4fv(this.addr,t)}function N2(e,n){const t=Za(n,this.size,4);e.uniformMatrix2fv(this.addr,!1,t)}function U2(e,n){const t=Za(n,this.size,9);e.uniformMatrix3fv(this.addr,!1,t)}function G2(e,n){const t=Za(n,this.size,16);e.uniformMatrix4fv(this.addr,!1,t)}function V2(e,n,t){const i=n.length,r=Vw(t,i);e.uniform1iv(this.addr,r);for(let a=0;a!==i;++a)t.safeSetTexture2D(n[a]||Rw,r[a])}function j2(e,n,t){const i=n.length,r=Vw(t,i);e.uniform1iv(this.addr,r);for(let a=0;a!==i;++a)t.safeSetTextureCube(n[a]||Bw,r[a])}function W2(e){switch(e){case 5126:return D2;case 35664:return B2;case 35665:return z2;case 35666:return $2;case 35674:return N2;case 35675:return U2;case 35676:return G2;case 5124:case 35670:return k2;case 35667:case 35671:return O2;case 35668:case 35672:return F2;case 35669:case 35673:return R2;case 35678:case 36198:case 36298:case 36306:case 35682:return V2;case 35680:case 36300:case 36308:case 36293:return j2}}function H2(e,n,t){this.id=e,this.addr=t,this.cache=[],this.setValue=L2(n.type)}function jw(e,n,t){this.id=e,this.addr=t,this.cache=[],this.size=n.size,this.setValue=W2(n.type)}jw.prototype.updateCache=function(e){let n=this.cache;e instanceof Float32Array&&n.length!==e.length&&(this.cache=new Float32Array(e.length)),es(n,e)};function Ww(e){this.id=e,this.seq=[],this.map={}}Ww.prototype.setValue=function(e,n,t){const i=this.seq;for(let r=0,a=i.length;r!==a;++r){const c=i[r];c.setValue(e,n[c.id],t)}};const Lv=/([\w\d_]+)(\])?(\[|\.)?/g;function Hw(e,n){e.seq.push(n),e.map[n.id]=n}function q2(e,n,t){const i=e.name,r=i.length;for(Lv.lastIndex=0;;){const a=Lv.exec(i),c=Lv.lastIndex;let u=a[1],l=a[2]==="]",f=a[3];if(l&&(u=u|0),f===void 0||f==="["&&c+2===r){Hw(t,f===void 0?new H2(u,e,n):new jw(u,e,n));break}else{let h=t.map[u];h===void 0&&(h=new Ww(u),Hw(t,h)),t=h}}}function Xr(e,n){this.seq=[],this.map={};const t=e.getProgramParameter(n,35718);for(let i=0;i<t;++i){const r=e.getActiveUniform(n,i),a=e.getUniformLocation(n,r.name);q2(r,a,this)}}Xr.prototype.setValue=function(e,n,t,i){const r=this.map[n];r!==void 0&&r.setValue(e,t,i)},Xr.prototype.setOptional=function(e,n,t){const i=n[t];i!==void 0&&this.setValue(e,t,i)},Xr.upload=function(e,n,t,i){for(let r=0,a=n.length;r!==a;++r){const c=n[r],u=t[c.id];u.needsUpdate!==!1&&c.setValue(e,u.value,i)}},Xr.seqWithValue=function(e,n){const t=[];for(let i=0,r=e.length;i!==r;++i){const a=e[i];a.id in n&&t.push(a)}return t};function qw(e,n,t){const i=e.createShader(n);return e.shaderSource(i,t),e.compileShader(i),i}let K2=0;function X2(e){const n=e.split(`
`);for(let t=0;t<n.length;t++)n[t]=t+1+": "+n[t];return n.join(`
`)}function Kw(e){switch(e){case Ui:return["Linear","( value )"];case Cg:return["sRGB","( value )"];case nv:return["RGBE","( value )"];case yw:return["RGBM","( value, 7.0 )"];case vw:return["RGBM","( value, 16.0 )"];case ww:return["RGBD","( value, 256.0 )"];case tv:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case c1:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}function Xw(e,n,t){const i=e.getShaderParameter(n,35713),r=e.getShaderInfoLog(n).trim();if(i&&r==="")return"";const a=e.getShaderSource(n);return"THREE.WebGLShader: gl.getShaderInfoLog() "+t+`
`+r+X2(a)}function ed(e,n){const t=Kw(n);return"vec4 "+e+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function Y2(e,n){const t=Kw(n);return"vec4 "+e+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function J2(e,n){let t;switch(n){case lM:t="Linear";break;case cM:t="Reinhard";break;case uM:t="OptimizedCineon";break;case dM:t="ACESFilmic";break;case hM:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",n),t="Linear"}return"vec3 "+e+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function Q2(e){return[e.extensionDerivatives||e.envMapCubeUV||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||e.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(td).join(`
`)}function Z2(e){const n=[];for(const t in e){const i=e[t];i!==!1&&n.push("#define "+t+" "+i)}return n.join(`
`)}function eS(e,n){const t={},i=e.getProgramParameter(n,35721);for(let r=0;r<i;r++){const c=e.getActiveAttrib(n,r).name;t[c]=e.getAttribLocation(n,c)}return t}function td(e){return e!==""}function Yw(e,n){return e.replace(/NUM_DIR_LIGHTS/g,n.numDirLights).replace(/NUM_SPOT_LIGHTS/g,n.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,n.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,n.numPointLights).replace(/NUM_HEMI_LIGHTS/g,n.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,n.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,n.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,n.numPointLightShadows)}function Jw(e,n){return e.replace(/NUM_CLIPPING_PLANES/g,n.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,n.numClippingPlanes-n.numClipIntersection)}const tS=/^[ \t]*#include +<([\w\d./]+)>/gm;function Dv(e){return e.replace(tS,nS)}function nS(e,n){const t=fn[n];if(t===void 0)throw new Error("Can not resolve #include <"+n+">");return Dv(t)}const iS=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,sS=/#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;function Qw(e){return e.replace(sS,Zw).replace(iS,rS)}function rS(e,n,t,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Zw(e,n,t,i)}function Zw(e,n,t,i){let r="";for(let a=parseInt(n);a<parseInt(t);a++)r+=i.replace(/\[ i \]/g,"[ "+a+" ]").replace(/UNROLLED_LOOP_INDEX/g,a);return r}function ex(e){let n="precision "+e.precision+` float;
precision `+e.precision+" int;";return e.precision==="highp"?n+=`
#define HIGH_PRECISION`:e.precision==="mediump"?n+=`
#define MEDIUM_PRECISION`:e.precision==="lowp"&&(n+=`
#define LOW_PRECISION`),n}function oS(e){let n="SHADOWMAP_TYPE_BASIC";return e.shadowMapType===Y0?n="SHADOWMAP_TYPE_PCF":e.shadowMapType===Nb?n="SHADOWMAP_TYPE_PCF_SOFT":e.shadowMapType===ku&&(n="SHADOWMAP_TYPE_VSM"),n}function aS(e){let n="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case Ky:case Xy:n="ENVMAP_TYPE_CUBE";break;case Ru:case vg:n="ENVMAP_TYPE_CUBE_UV";break;case rw:case Yy:n="ENVMAP_TYPE_EQUIREC";break}return n}function lS(e){let n="ENVMAP_MODE_REFLECTION";if(e.envMap)switch(e.envMapMode){case Xy:case Yy:case vg:n="ENVMAP_MODE_REFRACTION";break}return n}function cS(e){let n="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case yg:n="ENVMAP_BLENDING_MULTIPLY";break;case oM:n="ENVMAP_BLENDING_MIX";break;case aM:n="ENVMAP_BLENDING_ADD";break}return n}function uS(e,n,t,i){const r=e.getContext(),a=t.defines;let c=t.vertexShader,u=t.fragmentShader;const l=oS(t),f=aS(t),m=lS(t),h=cS(t),p=e.gammaFactor>0?e.gammaFactor:1,_=t.isWebGL2?"":Q2(t),v=Z2(a),S=r.createProgram();let D,w;t.isRawShaderMaterial?(D=[v].filter(td).join(`
`),D.length>0&&(D+=`
`),w=[_,v].filter(td).join(`
`),w.length>0&&(w+=`
`)):(D=[ex(t),"#define SHADER_NAME "+t.shaderName,v,t.instancing?"#define USE_INSTANCING":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+p,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+m:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING"," attribute mat4 instanceMatrix;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#ifdef USE_COLOR","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(td).join(`
`),w=[_,ex(t),"#define SHADER_NAME "+t.shaderName,v,t.alphaTest?"#define ALPHATEST "+t.alphaTest+(t.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+p,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+f:"",t.envMap?"#define "+m:"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.sheen?"#define USE_SHEEN":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Aa?"#define TONE_MAPPING":"",t.toneMapping!==Aa?fn.tonemapping_pars_fragment:"",t.toneMapping!==Aa?J2("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",fn.encodings_pars_fragment,t.map?ed("mapTexelToLinear",t.mapEncoding):"",t.matcap?ed("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?ed("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?ed("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.lightMap?ed("lightMapTexelToLinear",t.lightMapEncoding):"",Y2("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(td).join(`
`)),c=Dv(c),c=Yw(c,t),c=Jw(c,t),u=Dv(u),u=Yw(u,t),u=Jw(u,t),c=Qw(c),u=Qw(u),t.isWebGL2&&!t.isRawShaderMaterial&&(D=[`#version 300 es
`,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+D,w=[`#version 300 es
`,"#define varying in","out highp vec4 pc_fragColor;","#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+w);const T=D+c,F=w+u,E=qw(r,35633,T),A=qw(r,35632,F);if(r.attachShader(S,E),r.attachShader(S,A),t.index0AttributeName!==void 0?r.bindAttribLocation(S,0,t.index0AttributeName):t.morphTargets===!0&&r.bindAttribLocation(S,0,"position"),r.linkProgram(S),e.debug.checkShaderErrors){const R=r.getProgramInfoLog(S).trim(),N=r.getShaderInfoLog(E).trim(),q=r.getShaderInfoLog(A).trim();let ne=!0,Q=!0;if(r.getProgramParameter(S,35714)===!1){ne=!1;const W=Xw(r,E,"vertex"),te=Xw(r,A,"fragment");console.error("THREE.WebGLProgram: shader error: ",r.getError(),"35715",r.getProgramParameter(S,35715),"gl.getProgramInfoLog",R,W,te)}else R!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",R):(N===""||q==="")&&(Q=!1);Q&&(this.diagnostics={runnable:ne,programLog:R,vertexShader:{log:N,prefix:D},fragmentShader:{log:q,prefix:w}})}r.deleteShader(E),r.deleteShader(A);let L;this.getUniforms=function(){return L===void 0&&(L=new Xr(r,S)),L};let I;return this.getAttributes=function(){return I===void 0&&(I=eS(r,S)),I},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(S),this.program=void 0},this.name=t.shaderName,this.id=K2++,this.cacheKey=n,this.usedTimes=1,this.program=S,this.vertexShader=E,this.fragmentShader=A,this}function dS(e,n,t,i){const r=[],a=t.isWebGL2,c=t.logarithmicDepthBuffer,u=t.floatVertexTextures,l=t.maxVertexUniforms,f=t.vertexTextures;let m=t.precision;const h={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},p=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function _(E){const L=E.skeleton.bones;if(u)return 1024;{const R=Math.floor((l-20)/4),N=Math.min(R,L.length);return N<L.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+L.length+" bones. This GPU supports "+N+"."),0):N}}function v(E){let A;return E?E.isTexture?A=E.encoding:E.isWebGLRenderTarget&&(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),A=E.texture.encoding):A=Ui,A}function S(E,A,L,I,R,N,q){const ne=I.fog,Q=E.isMeshStandardMaterial?I.environment:null,W=E.envMap||Q,te=h[E.type],K=q.isSkinnedMesh?_(q):0;E.precision!==null&&(m=t.getMaxPrecision(E.precision),m!==E.precision&&console.warn("THREE.WebGLProgram.getParameters:",E.precision,"not supported, using",m,"instead."));let pe,be;if(te){const _e=Js[te];pe=_e.vertexShader,be=_e.fragmentShader}else pe=E.vertexShader,be=E.fragmentShader;const Ee=e.getRenderTarget();return{isWebGL2:a,shaderID:te,shaderName:E.type,vertexShader:pe,fragmentShader:be,defines:E.defines,isRawShaderMaterial:E.isRawShaderMaterial,isShaderMaterial:E.isShaderMaterial,precision:m,instancing:q.isInstancedMesh===!0,supportsVertexTextures:f,outputEncoding:Ee!==null?v(Ee.texture):e.outputEncoding,map:!!E.map,mapEncoding:v(E.map),matcap:!!E.matcap,matcapEncoding:v(E.matcap),envMap:!!W,envMapMode:W&&W.mapping,envMapEncoding:v(W),envMapCubeUV:!!W&&(W.mapping===Ru||W.mapping===vg),lightMap:!!E.lightMap,lightMapEncoding:v(E.lightMap),aoMap:!!E.aoMap,emissiveMap:!!E.emissiveMap,emissiveMapEncoding:v(E.emissiveMap),bumpMap:!!E.bumpMap,normalMap:!!E.normalMap,objectSpaceNormalMap:E.normalMapType===h1,tangentSpaceNormalMap:E.normalMapType===Da,clearcoatMap:!!E.clearcoatMap,clearcoatRoughnessMap:!!E.clearcoatRoughnessMap,clearcoatNormalMap:!!E.clearcoatNormalMap,displacementMap:!!E.displacementMap,roughnessMap:!!E.roughnessMap,metalnessMap:!!E.metalnessMap,specularMap:!!E.specularMap,alphaMap:!!E.alphaMap,gradientMap:!!E.gradientMap,sheen:!!E.sheen,transmissionMap:!!E.transmissionMap,combine:E.combine,vertexTangents:E.normalMap&&E.vertexTangents,vertexColors:E.vertexColors,vertexUvs:!!E.map||!!E.bumpMap||!!E.normalMap||!!E.specularMap||!!E.alphaMap||!!E.emissiveMap||!!E.roughnessMap||!!E.metalnessMap||!!E.clearcoatMap||!!E.clearcoatRoughnessMap||!!E.clearcoatNormalMap||!!E.displacementMap||!!E.transmissionMap,uvsVertexOnly:!(E.map||E.bumpMap||E.normalMap||E.specularMap||E.alphaMap||E.emissiveMap||E.roughnessMap||E.metalnessMap||E.clearcoatNormalMap||E.transmissionMap)&&!!E.displacementMap,fog:!!ne,useFog:E.fog,fogExp2:ne&&ne.isFogExp2,flatShading:E.flatShading,sizeAttenuation:E.sizeAttenuation,logarithmicDepthBuffer:c,skinning:E.skinning&&K>0,maxBones:K,useVertexTexture:u,morphTargets:E.morphTargets,morphNormals:E.morphNormals,maxMorphTargets:e.maxMorphTargets,maxMorphNormals:e.maxMorphNormals,numDirLights:A.directional.length,numPointLights:A.point.length,numSpotLights:A.spot.length,numRectAreaLights:A.rectArea.length,numHemiLights:A.hemi.length,numDirLightShadows:A.directionalShadowMap.length,numPointLightShadows:A.pointShadowMap.length,numSpotLightShadows:A.spotShadowMap.length,numClippingPlanes:R,numClipIntersection:N,dithering:E.dithering,shadowMapEnabled:e.shadowMap.enabled&&L.length>0,shadowMapType:e.shadowMap.type,toneMapping:E.toneMapped?e.toneMapping:Aa,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:E.premultipliedAlpha,alphaTest:E.alphaTest,doubleSided:E.side===_g,flipSided:E.side===li,depthPacking:E.depthPacking!==void 0?E.depthPacking:!1,index0AttributeName:E.index0AttributeName,extensionDerivatives:E.extensions&&E.extensions.derivatives,extensionFragDepth:E.extensions&&E.extensions.fragDepth,extensionDrawBuffers:E.extensions&&E.extensions.drawBuffers,extensionShaderTextureLOD:E.extensions&&E.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||n.get("EXT_frag_depth")!==null,rendererExtensionDrawBuffers:a||n.get("WEBGL_draw_buffers")!==null,rendererExtensionShaderTextureLod:a||n.get("EXT_shader_texture_lod")!==null,customProgramCacheKey:E.customProgramCacheKey()}}function D(E){const A=[];if(E.shaderID?A.push(E.shaderID):(A.push(E.fragmentShader),A.push(E.vertexShader)),E.defines!==void 0)for(const L in E.defines)A.push(L),A.push(E.defines[L]);if(E.isRawShaderMaterial===void 0){for(let L=0;L<p.length;L++)A.push(E[p[L]]);A.push(e.outputEncoding),A.push(e.gammaFactor)}return A.push(E.customProgramCacheKey),A.join()}function w(E){const A=h[E.type];let L;if(A){const I=Js[A];L=C1.clone(I.uniforms)}else L=E.uniforms;return L}function T(E,A){let L;for(let I=0,R=r.length;I<R;I++){const N=r[I];if(N.cacheKey===A){L=N,++L.usedTimes;break}}return L===void 0&&(L=new uS(e,A,E,i),r.push(L)),L}function F(E){if(--E.usedTimes===0){const A=r.indexOf(E);r[A]=r[r.length-1],r.pop(),E.destroy()}}return{getParameters:S,getProgramCacheKey:D,getUniforms:w,acquireProgram:T,releaseProgram:F,programs:r}}function hS(){let e=new WeakMap;function n(a){let c=e.get(a);return c===void 0&&(c={},e.set(a,c)),c}function t(a){e.delete(a)}function i(a,c,u){e.get(a)[c]=u}function r(){e=new WeakMap}return{get:n,remove:t,update:i,dispose:r}}function fS(e,n){return e.groupOrder!==n.groupOrder?e.groupOrder-n.groupOrder:e.renderOrder!==n.renderOrder?e.renderOrder-n.renderOrder:e.program!==n.program?e.program.id-n.program.id:e.material.id!==n.material.id?e.material.id-n.material.id:e.z!==n.z?e.z-n.z:e.id-n.id}function pS(e,n){return e.groupOrder!==n.groupOrder?e.groupOrder-n.groupOrder:e.renderOrder!==n.renderOrder?e.renderOrder-n.renderOrder:e.z!==n.z?n.z-e.z:e.id-n.id}function tx(e){const n=[];let t=0;const i=[],r=[],a={id:-1};function c(){t=0,i.length=0,r.length=0}function u(p,_,v,S,D,w){let T=n[t];const F=e.get(v);return T===void 0?(T={id:p.id,object:p,geometry:_,material:v,program:F.program||a,groupOrder:S,renderOrder:p.renderOrder,z:D,group:w},n[t]=T):(T.id=p.id,T.object=p,T.geometry=_,T.material=v,T.program=F.program||a,T.groupOrder=S,T.renderOrder=p.renderOrder,T.z=D,T.group=w),t++,T}function l(p,_,v,S,D,w){const T=u(p,_,v,S,D,w);(v.transparent===!0?r:i).push(T)}function f(p,_,v,S,D,w){const T=u(p,_,v,S,D,w);(v.transparent===!0?r:i).unshift(T)}function m(p,_){i.length>1&&i.sort(p||fS),r.length>1&&r.sort(_||pS)}function h(){for(let p=t,_=n.length;p<_;p++){const v=n[p];if(v.id===null)break;v.id=null,v.object=null,v.geometry=null,v.material=null,v.program=null,v.group=null}}return{opaque:i,transparent:r,init:c,push:l,unshift:f,finish:h,sort:m}}function mS(e){let n=new WeakMap;function t(a){const c=a.target;c.removeEventListener("dispose",t),n.delete(c)}function i(a,c){const u=n.get(a);let l;return u===void 0?(l=new tx(e),n.set(a,new WeakMap),n.get(a).set(c,l),a.addEventListener("dispose",t)):(l=u.get(c),l===void 0&&(l=new tx(e),u.set(c,l))),l}function r(){n=new WeakMap}return{get:i,dispose:r}}function gS(){const e={};return{get:function(n){if(e[n.id]!==void 0)return e[n.id];let t;switch(n.type){case"DirectionalLight":t={direction:new ye,color:new jt};break;case"SpotLight":t={position:new ye,direction:new ye,color:new jt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new ye,color:new jt,distance:0,decay:0};break;case"HemisphereLight":t={direction:new ye,skyColor:new jt,groundColor:new jt};break;case"RectAreaLight":t={color:new jt,position:new ye,halfWidth:new ye,halfHeight:new ye};break}return e[n.id]=t,t}}}function _S(){const e={};return{get:function(n){if(e[n.id]!==void 0)return e[n.id];let t;switch(n.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new vt};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new vt};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new vt,shadowCameraNear:1,shadowCameraFar:1e3};break}return e[n.id]=t,t}}}let yS=0;function vS(e,n){return(n.castShadow?1:0)-(e.castShadow?1:0)}function wS(){const e=new gS,n=_S(),t={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)t.probe.push(new ye);const i=new ye,r=new dn,a=new dn;function c(u,l,f){let m=0,h=0,p=0;for(let I=0;I<9;I++)t.probe[I].set(0,0,0);let _=0,v=0,S=0,D=0,w=0,T=0,F=0,E=0;const A=f.matrixWorldInverse;u.sort(vS);for(let I=0,R=u.length;I<R;I++){const N=u[I],q=N.color,ne=N.intensity,Q=N.distance,W=N.shadow&&N.shadow.map?N.shadow.map.texture:null;if(N.isAmbientLight)m+=q.r*ne,h+=q.g*ne,p+=q.b*ne;else if(N.isLightProbe)for(let te=0;te<9;te++)t.probe[te].addScaledVector(N.sh.coefficients[te],ne);else if(N.isDirectionalLight){const te=e.get(N);if(te.color.copy(N.color).multiplyScalar(N.intensity),te.direction.setFromMatrixPosition(N.matrixWorld),i.setFromMatrixPosition(N.target.matrixWorld),te.direction.sub(i),te.direction.transformDirection(A),N.castShadow){const K=N.shadow,pe=n.get(N);pe.shadowBias=K.bias,pe.shadowNormalBias=K.normalBias,pe.shadowRadius=K.radius,pe.shadowMapSize=K.mapSize,t.directionalShadow[_]=pe,t.directionalShadowMap[_]=W,t.directionalShadowMatrix[_]=N.shadow.matrix,T++}t.directional[_]=te,_++}else if(N.isSpotLight){const te=e.get(N);if(te.position.setFromMatrixPosition(N.matrixWorld),te.position.applyMatrix4(A),te.color.copy(q).multiplyScalar(ne),te.distance=Q,te.direction.setFromMatrixPosition(N.matrixWorld),i.setFromMatrixPosition(N.target.matrixWorld),te.direction.sub(i),te.direction.transformDirection(A),te.coneCos=Math.cos(N.angle),te.penumbraCos=Math.cos(N.angle*(1-N.penumbra)),te.decay=N.decay,N.castShadow){const K=N.shadow,pe=n.get(N);pe.shadowBias=K.bias,pe.shadowNormalBias=K.normalBias,pe.shadowRadius=K.radius,pe.shadowMapSize=K.mapSize,t.spotShadow[S]=pe,t.spotShadowMap[S]=W,t.spotShadowMatrix[S]=N.shadow.matrix,E++}t.spot[S]=te,S++}else if(N.isRectAreaLight){const te=e.get(N);te.color.copy(q).multiplyScalar(ne),te.position.setFromMatrixPosition(N.matrixWorld),te.position.applyMatrix4(A),a.identity(),r.copy(N.matrixWorld),r.premultiply(A),a.extractRotation(r),te.halfWidth.set(N.width*.5,0,0),te.halfHeight.set(0,N.height*.5,0),te.halfWidth.applyMatrix4(a),te.halfHeight.applyMatrix4(a),t.rectArea[D]=te,D++}else if(N.isPointLight){const te=e.get(N);if(te.position.setFromMatrixPosition(N.matrixWorld),te.position.applyMatrix4(A),te.color.copy(N.color).multiplyScalar(N.intensity),te.distance=N.distance,te.decay=N.decay,N.castShadow){const K=N.shadow,pe=n.get(N);pe.shadowBias=K.bias,pe.shadowNormalBias=K.normalBias,pe.shadowRadius=K.radius,pe.shadowMapSize=K.mapSize,pe.shadowCameraNear=K.camera.near,pe.shadowCameraFar=K.camera.far,t.pointShadow[v]=pe,t.pointShadowMap[v]=W,t.pointShadowMatrix[v]=N.shadow.matrix,F++}t.point[v]=te,v++}else if(N.isHemisphereLight){const te=e.get(N);te.direction.setFromMatrixPosition(N.matrixWorld),te.direction.transformDirection(A),te.direction.normalize(),te.skyColor.copy(N.color).multiplyScalar(ne),te.groundColor.copy(N.groundColor).multiplyScalar(ne),t.hemi[w]=te,w++}}t.ambient[0]=m,t.ambient[1]=h,t.ambient[2]=p;const L=t.hash;(L.directionalLength!==_||L.pointLength!==v||L.spotLength!==S||L.rectAreaLength!==D||L.hemiLength!==w||L.numDirectionalShadows!==T||L.numPointShadows!==F||L.numSpotShadows!==E)&&(t.directional.length=_,t.spot.length=S,t.rectArea.length=D,t.point.length=v,t.hemi.length=w,t.directionalShadow.length=T,t.directionalShadowMap.length=T,t.pointShadow.length=F,t.pointShadowMap.length=F,t.spotShadow.length=E,t.spotShadowMap.length=E,t.directionalShadowMatrix.length=T,t.pointShadowMatrix.length=F,t.spotShadowMatrix.length=E,L.directionalLength=_,L.pointLength=v,L.spotLength=S,L.rectAreaLength=D,L.hemiLength=w,L.numDirectionalShadows=T,L.numPointShadows=F,L.numSpotShadows=E,t.version=yS++)}return{setup:c,state:t}}function nx(){const e=new wS,n=[],t=[];function i(){n.length=0,t.length=0}function r(l){n.push(l)}function a(l){t.push(l)}function c(l){e.setup(n,t,l)}return{init:i,state:{lightsArray:n,shadowsArray:t,lights:e},setupLights:c,pushLight:r,pushShadow:a}}function xS(){let e=new WeakMap;function n(r){const a=r.target;a.removeEventListener("dispose",n),e.delete(a)}function t(r,a){let c;return e.has(r)===!1?(c=new nx,e.set(r,new WeakMap),e.get(r).set(a,c),r.addEventListener("dispose",n)):e.get(r).has(a)===!1?(c=new nx,e.get(r).set(a,c)):c=e.get(r).get(a),c}function i(){e=new WeakMap}return{get:t,dispose:i}}function Po(e){rn.call(this),this.type="MeshDepthMaterial",this.depthPacking=u1,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}Po.prototype=Object.create(rn.prototype),Po.prototype.constructor=Po,Po.prototype.isMeshDepthMaterial=!0,Po.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.depthPacking=e.depthPacking,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this};function Ao(e){rn.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new ye,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}Ao.prototype=Object.create(rn.prototype),Ao.prototype.constructor=Ao,Ao.prototype.isMeshDistanceMaterial=!0,Ao.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this};var bS=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
  float mean = 0.0;
  float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );
  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
    #ifdef HORIZONAL_PASS
      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
      mean += distribution.x;
      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
    #else
      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );
      mean += depth;
      squared_mean += depth * depth;
    #endif
  }
  mean = mean * HALF_SAMPLE_RATE;
  squared_mean = squared_mean * HALF_SAMPLE_RATE;
  float std_dev = sqrt( squared_mean - mean * mean );
  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,MS=`void main() {
	gl_Position = vec4( position, 1.0 );
}`;function ix(e,n,t){let i=new Ju;const r=new vt,a=new vt,c=new An,u=[],l=[],f={},m={0:li,1:Ou,2:_g},h=new Gi({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new vt},radius:{value:4}},vertexShader:MS,fragmentShader:bS}),p=h.clone();p.defines.HORIZONAL_PASS=1;const _=new Ut;_.setAttribute("position",new Kt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const v=new Ln(_,h),S=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Y0,this.render=function(A,L,I){if(S.enabled===!1||S.autoUpdate===!1&&S.needsUpdate===!1||A.length===0)return;const R=e.getRenderTarget(),N=e.getActiveCubeFace(),q=e.getActiveMipmapLevel(),ne=e.state;ne.setBlending($r),ne.buffers.color.setClear(1,1,1,1),ne.buffers.depth.setTest(!0),ne.setScissorTest(!1);for(let Q=0,W=A.length;Q<W;Q++){const te=A[Q],K=te.shadow;if(K.autoUpdate===!1&&K.needsUpdate===!1)continue;if(K===void 0){console.warn("THREE.WebGLShadowMap:",te,"has no shadow.");continue}r.copy(K.mapSize);const pe=K.getFrameExtents();if(r.multiply(pe),a.copy(K.mapSize),(r.x>t||r.y>t)&&(r.x>t&&(a.x=Math.floor(t/pe.x),r.x=a.x*pe.x,K.mapSize.x=a.x),r.y>t&&(a.y=Math.floor(t/pe.y),r.y=a.y*pe.y,K.mapSize.y=a.y)),K.map===null&&!K.isPointLightShadow&&this.type===ku){const Ee={minFilter:Pi,magFilter:Pi,format:fs,stencilBuffer:!1};K.map=new ps(r.x,r.y,Ee),K.map.texture.name=te.name+".shadowMap",K.mapPass=new ps(r.x,r.y,Ee),K.camera.updateProjectionMatrix()}if(K.map===null){const Ee={minFilter:fi,magFilter:fi,format:fs,stencilBuffer:!1};K.map=new ps(r.x,r.y,Ee),K.map.texture.name=te.name+".shadowMap",K.camera.updateProjectionMatrix()}e.setRenderTarget(K.map),e.clear();const be=K.getViewportCount();for(let Ee=0;Ee<be;Ee++){const Ge=K.getViewport(Ee);c.set(a.x*Ge.x,a.y*Ge.y,a.x*Ge.z,a.y*Ge.w),ne.viewport(c),K.updateMatrices(te,Ee),i=K.getFrustum(),E(L,I,K.camera,te,this.type)}!K.isPointLightShadow&&this.type===ku&&D(K,I),K.needsUpdate=!1}S.needsUpdate=!1,e.setRenderTarget(R,N,q)};function D(A,L){const I=n.update(v);h.uniforms.shadow_pass.value=A.map.texture,h.uniforms.resolution.value=A.mapSize,h.uniforms.radius.value=A.radius,e.setRenderTarget(A.mapPass),e.clear(),e.renderBufferDirect(L,null,I,h,v,null),p.uniforms.shadow_pass.value=A.mapPass.texture,p.uniforms.resolution.value=A.mapSize,p.uniforms.radius.value=A.radius,e.setRenderTarget(A.map),e.clear(),e.renderBufferDirect(L,null,I,p,v,null)}function w(A,L,I){const R=A<<0|L<<1|I<<2;let N=u[R];return N===void 0&&(N=new Po({depthPacking:d1,morphTargets:A,skinning:L}),u[R]=N),N}function T(A,L,I){const R=A<<0|L<<1|I<<2;let N=l[R];return N===void 0&&(N=new Ao({morphTargets:A,skinning:L}),l[R]=N),N}function F(A,L,I,R,N,q,ne){let Q=null,W=w,te=A.customDepthMaterial;if(R.isPointLight===!0&&(W=T,te=A.customDistanceMaterial),te===void 0){let K=!1;I.morphTargets===!0&&(K=L.morphAttributes&&L.morphAttributes.position&&L.morphAttributes.position.length>0);let pe=!1;A.isSkinnedMesh===!0&&(I.skinning===!0?pe=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",A));const be=A.isInstancedMesh===!0;Q=W(K,pe,be)}else Q=te;if(e.localClippingEnabled&&I.clipShadows===!0&&I.clippingPlanes.length!==0){const K=Q.uuid,pe=I.uuid;let be=f[K];be===void 0&&(be={},f[K]=be);let Ee=be[pe];Ee===void 0&&(Ee=Q.clone(),be[pe]=Ee),Q=Ee}return Q.visible=I.visible,Q.wireframe=I.wireframe,ne===ku?Q.side=I.shadowSide!==null?I.shadowSide:I.side:Q.side=I.shadowSide!==null?I.shadowSide:m[I.side],Q.clipShadows=I.clipShadows,Q.clippingPlanes=I.clippingPlanes,Q.clipIntersection=I.clipIntersection,Q.wireframeLinewidth=I.wireframeLinewidth,Q.linewidth=I.linewidth,R.isPointLight===!0&&Q.isMeshDistanceMaterial===!0&&(Q.referencePosition.setFromMatrixPosition(R.matrixWorld),Q.nearDistance=N,Q.farDistance=q),Q}function E(A,L,I,R,N){if(A.visible===!1)return;if(A.layers.test(L.layers)&&(A.isMesh||A.isLine||A.isPoints)&&(A.castShadow||A.receiveShadow&&N===ku)&&(!A.frustumCulled||i.intersectsObject(A))){A.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse,A.matrixWorld);const Q=n.update(A),W=A.material;if(Array.isArray(W)){const te=Q.groups;for(let K=0,pe=te.length;K<pe;K++){const be=te[K],Ee=W[be.materialIndex];if(Ee&&Ee.visible){const Ge=F(A,Q,Ee,R,I.near,I.far,N);e.renderBufferDirect(I,null,Q,Ge,A,be)}}}else if(W.visible){const te=F(A,Q,W,R,I.near,I.far,N);e.renderBufferDirect(I,null,Q,te,A,null)}}const ne=A.children;for(let Q=0,W=ne.length;Q<W;Q++)E(ne[Q],L,I,R,N)}}function TS(e,n,t){const i=t.isWebGL2;function r(){let fe=!1;const Qe=new An;let Ne=null;const ut=new An(0,0,0,0);return{setMask:function(de){Ne!==de&&!fe&&(e.colorMask(de,de,de,de),Ne=de)},setLocked:function(de){fe=de},setClear:function(de,qe,tt,He,je){je===!0&&(de*=He,qe*=He,tt*=He),Qe.set(de,qe,tt,He),ut.equals(Qe)===!1&&(e.clearColor(de,qe,tt,He),ut.copy(Qe))},reset:function(){fe=!1,Ne=null,ut.set(-1,0,0,0)}}}function a(){let fe=!1,Qe=null,Ne=null,ut=null;return{setTest:function(de){de?_e(2929):De(2929)},setMask:function(de){Qe!==de&&!fe&&(e.depthMask(de),Qe=de)},setFunc:function(de){if(Ne!==de){if(de)switch(de){case Zb:e.depthFunc(512);break;case eM:e.depthFunc(519);break;case tM:e.depthFunc(513);break;case Hy:e.depthFunc(515);break;case nM:e.depthFunc(514);break;case iM:e.depthFunc(518);break;case sM:e.depthFunc(516);break;case rM:e.depthFunc(517);break;default:e.depthFunc(515)}else e.depthFunc(515);Ne=de}},setLocked:function(de){fe=de},setClear:function(de){ut!==de&&(e.clearDepth(de),ut=de)},reset:function(){fe=!1,Qe=null,Ne=null,ut=null}}}function c(){let fe=!1,Qe=null,Ne=null,ut=null,de=null,qe=null,tt=null,He=null,je=null;return{setTest:function(lt){fe||(lt?_e(2960):De(2960))},setMask:function(lt){Qe!==lt&&!fe&&(e.stencilMask(lt),Qe=lt)},setFunc:function(lt,Mt,Rt){(Ne!==lt||ut!==Mt||de!==Rt)&&(e.stencilFunc(lt,Mt,Rt),Ne=lt,ut=Mt,de=Rt)},setOp:function(lt,Mt,Rt){(qe!==lt||tt!==Mt||He!==Rt)&&(e.stencilOp(lt,Mt,Rt),qe=lt,tt=Mt,He=Rt)},setLocked:function(lt){fe=lt},setClear:function(lt){je!==lt&&(e.clearStencil(lt),je=lt)},reset:function(){fe=!1,Qe=null,Ne=null,ut=null,de=null,qe=null,tt=null,He=null,je=null}}}const u=new r,l=new a,f=new c;let m={},h=null,p=null,_=null,v=null,S=null,D=null,w=null,T=null,F=null,E=!1,A=null,L=null,I=null,R=null,N=null;const q=e.getParameter(35661);let ne=!1,Q=0;const W=e.getParameter(7938);W.indexOf("WebGL")!==-1?(Q=parseFloat(/^WebGL\ ([0-9])/.exec(W)[1]),ne=Q>=1):W.indexOf("OpenGL ES")!==-1&&(Q=parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(W)[1]),ne=Q>=2);let te=null,K={};const pe=new An,be=new An;function Ee(fe,Qe,Ne){const ut=new Uint8Array(4),de=e.createTexture();e.bindTexture(fe,de),e.texParameteri(fe,10241,9728),e.texParameteri(fe,10240,9728);for(let qe=0;qe<Ne;qe++)e.texImage2D(Qe+qe,0,6408,1,1,0,6408,5121,ut);return de}const Ge={};Ge[3553]=Ee(3553,3553,1),Ge[34067]=Ee(34067,34069,6),u.setClear(0,0,0,1),l.setClear(1),f.setClear(0),_e(2929),l.setFunc(Hy),et(!1),Ve(X0),_e(2884),we($r);function _e(fe){m[fe]!==!0&&(e.enable(fe),m[fe]=!0)}function De(fe){m[fe]!==!1&&(e.disable(fe),m[fe]=!1)}function he(fe){return h!==fe?(e.useProgram(fe),h=fe,!0):!1}const Z={[Pa]:32774,[Gb]:32778,[Vb]:32779};if(i)Z[tw]=32775,Z[nw]=32776;else{const fe=n.get("EXT_blend_minmax");fe!==null&&(Z[tw]=fe.MIN_EXT,Z[nw]=fe.MAX_EXT)}const me={[jb]:0,[Wb]:1,[Hb]:768,[iw]:770,[Qb]:776,[Yb]:774,[Kb]:772,[qb]:769,[sw]:771,[Jb]:775,[Xb]:773};function we(fe,Qe,Ne,ut,de,qe,tt,He){if(fe===$r){p&&(De(3042),p=!1);return}if(p||(_e(3042),p=!0),fe!==Ub){if(fe!==_||He!==E){if((v!==Pa||w!==Pa)&&(e.blendEquation(32774),v=Pa,w=Pa),He)switch(fe){case Fu:e.blendFuncSeparate(1,771,1,771);break;case Q0:e.blendFunc(1,1);break;case Z0:e.blendFuncSeparate(0,0,769,771);break;case ew:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",fe);break}else switch(fe){case Fu:e.blendFuncSeparate(770,771,1,771);break;case Q0:e.blendFunc(770,1);break;case Z0:e.blendFunc(0,769);break;case ew:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",fe);break}S=null,D=null,T=null,F=null,_=fe,E=He}return}de=de||Qe,qe=qe||Ne,tt=tt||ut,(Qe!==v||de!==w)&&(e.blendEquationSeparate(Z[Qe],Z[de]),v=Qe,w=de),(Ne!==S||ut!==D||qe!==T||tt!==F)&&(e.blendFuncSeparate(me[Ne],me[ut],me[qe],me[tt]),S=Ne,D=ut,T=qe,F=tt),_=fe,E=null}function xe(fe,Qe){fe.side===_g?De(2884):_e(2884);let Ne=fe.side===li;Qe&&(Ne=!Ne),et(Ne),fe.blending===Fu&&fe.transparent===!1?we($r):we(fe.blending,fe.blendEquation,fe.blendSrc,fe.blendDst,fe.blendEquationAlpha,fe.blendSrcAlpha,fe.blendDstAlpha,fe.premultipliedAlpha),l.setFunc(fe.depthFunc),l.setTest(fe.depthTest),l.setMask(fe.depthWrite),u.setMask(fe.colorWrite);const ut=fe.stencilWrite;f.setTest(ut),ut&&(f.setMask(fe.stencilWriteMask),f.setFunc(fe.stencilFunc,fe.stencilRef,fe.stencilFuncMask),f.setOp(fe.stencilFail,fe.stencilZFail,fe.stencilZPass)),Be(fe.polygonOffset,fe.polygonOffsetFactor,fe.polygonOffsetUnits)}function et(fe){A!==fe&&(fe?e.frontFace(2304):e.frontFace(2305),A=fe)}function Ve(fe){fe!==zb?(_e(2884),fe!==L&&(fe===X0?e.cullFace(1029):fe===$b?e.cullFace(1028):e.cullFace(1032))):De(2884),L=fe}function nt(fe){fe!==I&&(ne&&e.lineWidth(fe),I=fe)}function Be(fe,Qe,Ne){fe?(_e(32823),(R!==Qe||N!==Ne)&&(e.polygonOffset(Qe,Ne),R=Qe,N=Ne)):De(32823)}function ae(fe){fe?_e(3089):De(3089)}function U(fe){fe===void 0&&(fe=33984+q-1),te!==fe&&(e.activeTexture(fe),te=fe)}function Se(fe,Qe){te===null&&U();let Ne=K[te];Ne===void 0&&(Ne={type:void 0,texture:void 0},K[te]=Ne),(Ne.type!==fe||Ne.texture!==Qe)&&(e.bindTexture(fe,Qe||Ge[fe]),Ne.type=fe,Ne.texture=Qe)}function ze(){const fe=K[te];fe!==void 0&&fe.type!==void 0&&(e.bindTexture(fe.type,null),fe.type=void 0,fe.texture=void 0)}function Oe(){try{e.compressedTexImage2D.apply(e,arguments)}catch(fe){console.error("THREE.WebGLState:",fe)}}function Ye(){try{e.texImage2D.apply(e,arguments)}catch(fe){console.error("THREE.WebGLState:",fe)}}function H(){try{e.texImage3D.apply(e,arguments)}catch(fe){console.error("THREE.WebGLState:",fe)}}function Y(fe){pe.equals(fe)===!1&&(e.scissor(fe.x,fe.y,fe.z,fe.w),pe.copy(fe))}function $e(fe){be.equals(fe)===!1&&(e.viewport(fe.x,fe.y,fe.z,fe.w),be.copy(fe))}function Ie(){m={},te=null,K={},h=null,_=null,A=null,L=null,u.reset(),l.reset(),f.reset()}return{buffers:{color:u,depth:l,stencil:f},enable:_e,disable:De,useProgram:he,setBlending:we,setMaterial:xe,setFlipSided:et,setCullFace:Ve,setLineWidth:nt,setPolygonOffset:Be,setScissorTest:ae,activeTexture:U,bindTexture:Se,unbindTexture:ze,compressedTexImage2D:Oe,texImage2D:Ye,texImage3D:H,scissor:Y,viewport:$e,reset:Ie}}function ES(e,n,t,i,r,a,c){const u=r.isWebGL2,l=r.maxTextures,f=r.maxCubemapSize,m=r.maxTextureSize,h=r.maxSamples,p=new WeakMap;let _,v=!1;try{v=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function S(H,Y){return v?new OffscreenCanvas(H,Y):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function D(H,Y,$e,Ie){let fe=1;if((H.width>Ie||H.height>Ie)&&(fe=Ie/Math.max(H.width,H.height)),fe<1||Y===!0)if(typeof HTMLImageElement<"u"&&H instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&H instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&H instanceof ImageBitmap){const Qe=Y?ln.floorPowerOfTwo:Math.floor,Ne=Qe(fe*H.width),ut=Qe(fe*H.height);_===void 0&&(_=S(Ne,ut));const de=$e?S(Ne,ut):_;return de.width=Ne,de.height=ut,de.getContext("2d").drawImage(H,0,0,Ne,ut),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+H.width+"x"+H.height+") to ("+Ne+"x"+ut+")."),de}else return"data"in H&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+H.width+"x"+H.height+")."),H;return H}function w(H){return ln.isPowerOfTwo(H.width)&&ln.isPowerOfTwo(H.height)}function T(H){return u?!1:H.wrapS!==Ni||H.wrapT!==Ni||H.minFilter!==fi&&H.minFilter!==Pi}function F(H,Y){return H.generateMipmaps&&Y&&H.minFilter!==fi&&H.minFilter!==Pi}function E(H,Y,$e,Ie){e.generateMipmap(H);const fe=i.get(Y);fe.__maxMipLevel=Math.log(Math.max($e,Ie))*Math.LOG2E}function A(H,Y,$e){if(u===!1)return Y;if(H!==null){if(e[H]!==void 0)return e[H];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+H+"'")}let Ie=Y;return Y===6403&&($e===5126&&(Ie=33326),$e===5131&&(Ie=33325),$e===5121&&(Ie=33321)),Y===6407&&($e===5126&&(Ie=34837),$e===5131&&(Ie=34843),$e===5121&&(Ie=32849)),Y===6408&&($e===5126&&(Ie=34836),$e===5131&&(Ie=34842),$e===5121&&(Ie=32856)),(Ie===33325||Ie===33326||Ie===34842||Ie===34836)&&n.get("EXT_color_buffer_float"),Ie}function L(H){return H===fi||H===Jy||H===Qy?9728:9729}function I(H){const Y=H.target;Y.removeEventListener("dispose",I),N(Y),Y.isVideoTexture&&p.delete(Y),c.memory.textures--}function R(H){const Y=H.target;Y.removeEventListener("dispose",R),q(Y),c.memory.textures--}function N(H){const Y=i.get(H);Y.__webglInit!==void 0&&(e.deleteTexture(Y.__webglTexture),i.remove(H))}function q(H){const Y=i.get(H),$e=i.get(H.texture);if(H){if($e.__webglTexture!==void 0&&e.deleteTexture($e.__webglTexture),H.depthTexture&&H.depthTexture.dispose(),H.isWebGLCubeRenderTarget)for(let Ie=0;Ie<6;Ie++)e.deleteFramebuffer(Y.__webglFramebuffer[Ie]),Y.__webglDepthbuffer&&e.deleteRenderbuffer(Y.__webglDepthbuffer[Ie]);else e.deleteFramebuffer(Y.__webglFramebuffer),Y.__webglDepthbuffer&&e.deleteRenderbuffer(Y.__webglDepthbuffer),Y.__webglMultisampledFramebuffer&&e.deleteFramebuffer(Y.__webglMultisampledFramebuffer),Y.__webglColorRenderbuffer&&e.deleteRenderbuffer(Y.__webglColorRenderbuffer),Y.__webglDepthRenderbuffer&&e.deleteRenderbuffer(Y.__webglDepthRenderbuffer);i.remove(H.texture),i.remove(H)}}let ne=0;function Q(){ne=0}function W(){const H=ne;return H>=l&&console.warn("THREE.WebGLTextures: Trying to use "+H+" texture units while this GPU supports only "+l),ne+=1,H}function te(H,Y){const $e=i.get(H);if(H.isVideoTexture&&U(H),H.version>0&&$e.__version!==H.version){const Ie=H.image;if(Ie===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(Ie.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Z($e,H,Y);return}}t.activeTexture(33984+Y),t.bindTexture(3553,$e.__webglTexture)}function K(H,Y){const $e=i.get(H);if(H.version>0&&$e.__version!==H.version){Z($e,H,Y);return}t.activeTexture(33984+Y),t.bindTexture(35866,$e.__webglTexture)}function pe(H,Y){const $e=i.get(H);if(H.version>0&&$e.__version!==H.version){Z($e,H,Y);return}t.activeTexture(33984+Y),t.bindTexture(32879,$e.__webglTexture)}function be(H,Y){if(H.image.length!==6)return;const $e=i.get(H);if(H.version>0&&$e.__version!==H.version){he($e,H),t.activeTexture(33984+Y),t.bindTexture(34067,$e.__webglTexture),e.pixelStorei(37440,H.flipY);const Ie=H&&(H.isCompressedTexture||H.image[0].isCompressedTexture),fe=H.image[0]&&H.image[0].isDataTexture,Qe=[];for(let je=0;je<6;je++)!Ie&&!fe?Qe[je]=D(H.image[je],!1,!0,f):Qe[je]=fe?H.image[je].image:H.image[je];const Ne=Qe[0],ut=w(Ne)||u,de=a.convert(H.format),qe=a.convert(H.type),tt=A(H.internalFormat,de,qe);De(34067,H,ut);let He;if(Ie){for(let je=0;je<6;je++){He=Qe[je].mipmaps;for(let lt=0;lt<He.length;lt++){const Mt=He[lt];H.format!==fs&&H.format!==bo?de!==null?t.compressedTexImage2D(34069+je,lt,tt,Mt.width,Mt.height,0,Mt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+je,lt,tt,Mt.width,Mt.height,0,de,qe,Mt.data)}}$e.__maxMipLevel=He.length-1}else{He=H.mipmaps;for(let je=0;je<6;je++)if(fe){t.texImage2D(34069+je,0,tt,Qe[je].width,Qe[je].height,0,de,qe,Qe[je].data);for(let lt=0;lt<He.length;lt++){const Rt=He[lt].image[je].image;t.texImage2D(34069+je,lt+1,tt,Rt.width,Rt.height,0,de,qe,Rt.data)}}else{t.texImage2D(34069+je,0,tt,de,qe,Qe[je]);for(let lt=0;lt<He.length;lt++){const Mt=He[lt];t.texImage2D(34069+je,lt+1,tt,de,qe,Mt.image[je])}}$e.__maxMipLevel=He.length}F(H,ut)&&E(34067,H,Ne.width,Ne.height),$e.__version=H.version,H.onUpdate&&H.onUpdate(H)}else t.activeTexture(33984+Y),t.bindTexture(34067,$e.__webglTexture)}function Ee(H,Y){t.activeTexture(33984+Y),t.bindTexture(34067,i.get(H).__webglTexture)}const Ge={[wg]:10497,[Ni]:33071,[xg]:33648},_e={[fi]:9728,[Jy]:9984,[Qy]:9986,[Pi]:9729,[ow]:9985,[bg]:9987};function De(H,Y,$e){$e?(e.texParameteri(H,10242,Ge[Y.wrapS]),e.texParameteri(H,10243,Ge[Y.wrapT]),(H===32879||H===35866)&&e.texParameteri(H,32882,Ge[Y.wrapR]),e.texParameteri(H,10240,_e[Y.magFilter]),e.texParameteri(H,10241,_e[Y.minFilter])):(e.texParameteri(H,10242,33071),e.texParameteri(H,10243,33071),(H===32879||H===35866)&&e.texParameteri(H,32882,33071),(Y.wrapS!==Ni||Y.wrapT!==Ni)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(H,10240,L(Y.magFilter)),e.texParameteri(H,10241,L(Y.minFilter)),Y.minFilter!==fi&&Y.minFilter!==Pi&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const Ie=n.get("EXT_texture_filter_anisotropic");if(Ie){if(Y.type===Nr&&n.get("OES_texture_float_linear")===null||Y.type===Eg&&(u||n.get("OES_texture_half_float_linear"))===null)return;(Y.anisotropy>1||i.get(Y).__currentAnisotropy)&&(e.texParameterf(H,Ie.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(Y.anisotropy,r.getMaxAnisotropy())),i.get(Y).__currentAnisotropy=Y.anisotropy)}}function he(H,Y){H.__webglInit===void 0&&(H.__webglInit=!0,Y.addEventListener("dispose",I),H.__webglTexture=e.createTexture(),c.memory.textures++)}function Z(H,Y,$e){let Ie=3553;Y.isDataTexture2DArray&&(Ie=35866),Y.isDataTexture3D&&(Ie=32879),he(H,Y),t.activeTexture(33984+$e),t.bindTexture(Ie,H.__webglTexture),e.pixelStorei(37440,Y.flipY),e.pixelStorei(37441,Y.premultiplyAlpha),e.pixelStorei(3317,Y.unpackAlignment);const fe=T(Y)&&w(Y.image)===!1,Qe=D(Y.image,fe,!1,m),Ne=w(Qe)||u,ut=a.convert(Y.format);let de=a.convert(Y.type),qe=A(Y.internalFormat,ut,de);De(Ie,Y,Ne);let tt;const He=Y.mipmaps;if(Y.isDepthTexture)qe=6402,u?Y.type===Nr?qe=36012:Y.type===Tg?qe=33190:Y.type===zu?qe=35056:qe=33189:Y.type===Nr&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),Y.format===Ca&&qe===6402&&Y.type!==Mg&&Y.type!==Tg&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),Y.type=Mg,de=a.convert(Y.type)),Y.format===$u&&qe===6402&&(qe=34041,Y.type!==zu&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),Y.type=zu,de=a.convert(Y.type))),t.texImage2D(3553,0,qe,Qe.width,Qe.height,0,ut,de,null);else if(Y.isDataTexture)if(He.length>0&&Ne){for(let je=0,lt=He.length;je<lt;je++)tt=He[je],t.texImage2D(3553,je,qe,tt.width,tt.height,0,ut,de,tt.data);Y.generateMipmaps=!1,H.__maxMipLevel=He.length-1}else t.texImage2D(3553,0,qe,Qe.width,Qe.height,0,ut,de,Qe.data),H.__maxMipLevel=0;else if(Y.isCompressedTexture){for(let je=0,lt=He.length;je<lt;je++)tt=He[je],Y.format!==fs&&Y.format!==bo?ut!==null?t.compressedTexImage2D(3553,je,qe,tt.width,tt.height,0,tt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,je,qe,tt.width,tt.height,0,ut,de,tt.data);H.__maxMipLevel=He.length-1}else if(Y.isDataTexture2DArray)t.texImage3D(35866,0,qe,Qe.width,Qe.height,Qe.depth,0,ut,de,Qe.data),H.__maxMipLevel=0;else if(Y.isDataTexture3D)t.texImage3D(32879,0,qe,Qe.width,Qe.height,Qe.depth,0,ut,de,Qe.data),H.__maxMipLevel=0;else if(He.length>0&&Ne){for(let je=0,lt=He.length;je<lt;je++)tt=He[je],t.texImage2D(3553,je,qe,ut,de,tt);Y.generateMipmaps=!1,H.__maxMipLevel=He.length-1}else t.texImage2D(3553,0,qe,ut,de,Qe),H.__maxMipLevel=0;F(Y,Ne)&&E(Ie,Y,Qe.width,Qe.height),H.__version=Y.version,Y.onUpdate&&Y.onUpdate(Y)}function me(H,Y,$e,Ie){const fe=a.convert(Y.texture.format),Qe=a.convert(Y.texture.type),Ne=A(Y.texture.internalFormat,fe,Qe);t.texImage2D(Ie,0,Ne,Y.width,Y.height,0,fe,Qe,null),e.bindFramebuffer(36160,H),e.framebufferTexture2D(36160,$e,Ie,i.get(Y.texture).__webglTexture,0),e.bindFramebuffer(36160,null)}function we(H,Y,$e){if(e.bindRenderbuffer(36161,H),Y.depthBuffer&&!Y.stencilBuffer){let Ie=33189;if($e){const fe=Y.depthTexture;fe&&fe.isDepthTexture&&(fe.type===Nr?Ie=36012:fe.type===Tg&&(Ie=33190));const Qe=ae(Y);e.renderbufferStorageMultisample(36161,Qe,Ie,Y.width,Y.height)}else e.renderbufferStorage(36161,Ie,Y.width,Y.height);e.framebufferRenderbuffer(36160,36096,36161,H)}else if(Y.depthBuffer&&Y.stencilBuffer){if($e){const Ie=ae(Y);e.renderbufferStorageMultisample(36161,Ie,35056,Y.width,Y.height)}else e.renderbufferStorage(36161,34041,Y.width,Y.height);e.framebufferRenderbuffer(36160,33306,36161,H)}else{const Ie=a.convert(Y.texture.format),fe=a.convert(Y.texture.type),Qe=A(Y.texture.internalFormat,Ie,fe);if($e){const Ne=ae(Y);e.renderbufferStorageMultisample(36161,Ne,Qe,Y.width,Y.height)}else e.renderbufferStorage(36161,Qe,Y.width,Y.height)}e.bindRenderbuffer(36161,null)}function xe(H,Y){if(Y&&Y.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,H),!(Y.depthTexture&&Y.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!i.get(Y.depthTexture).__webglTexture||Y.depthTexture.image.width!==Y.width||Y.depthTexture.image.height!==Y.height)&&(Y.depthTexture.image.width=Y.width,Y.depthTexture.image.height=Y.height,Y.depthTexture.needsUpdate=!0),te(Y.depthTexture,0);const Ie=i.get(Y.depthTexture).__webglTexture;if(Y.depthTexture.format===Ca)e.framebufferTexture2D(36160,36096,3553,Ie,0);else if(Y.depthTexture.format===$u)e.framebufferTexture2D(36160,33306,3553,Ie,0);else throw new Error("Unknown depthTexture format")}function et(H){const Y=i.get(H),$e=H.isWebGLCubeRenderTarget===!0;if(H.depthTexture){if($e)throw new Error("target.depthTexture not supported in Cube render targets");xe(Y.__webglFramebuffer,H)}else if($e){Y.__webglDepthbuffer=[];for(let Ie=0;Ie<6;Ie++)e.bindFramebuffer(36160,Y.__webglFramebuffer[Ie]),Y.__webglDepthbuffer[Ie]=e.createRenderbuffer(),we(Y.__webglDepthbuffer[Ie],H,!1)}else e.bindFramebuffer(36160,Y.__webglFramebuffer),Y.__webglDepthbuffer=e.createRenderbuffer(),we(Y.__webglDepthbuffer,H,!1);e.bindFramebuffer(36160,null)}function Ve(H){const Y=i.get(H),$e=i.get(H.texture);H.addEventListener("dispose",R),$e.__webglTexture=e.createTexture(),c.memory.textures++;const Ie=H.isWebGLCubeRenderTarget===!0,fe=H.isWebGLMultisampleRenderTarget===!0,Qe=w(H)||u;if(u&&H.texture.format===bo&&(H.texture.type===Nr||H.texture.type===Eg)&&(H.texture.format=fs,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),Ie){Y.__webglFramebuffer=[];for(let Ne=0;Ne<6;Ne++)Y.__webglFramebuffer[Ne]=e.createFramebuffer()}else if(Y.__webglFramebuffer=e.createFramebuffer(),fe)if(u){Y.__webglMultisampledFramebuffer=e.createFramebuffer(),Y.__webglColorRenderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(36161,Y.__webglColorRenderbuffer);const Ne=a.convert(H.texture.format),ut=a.convert(H.texture.type),de=A(H.texture.internalFormat,Ne,ut),qe=ae(H);e.renderbufferStorageMultisample(36161,qe,de,H.width,H.height),e.bindFramebuffer(36160,Y.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064,36161,Y.__webglColorRenderbuffer),e.bindRenderbuffer(36161,null),H.depthBuffer&&(Y.__webglDepthRenderbuffer=e.createRenderbuffer(),we(Y.__webglDepthRenderbuffer,H,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(Ie){t.bindTexture(34067,$e.__webglTexture),De(34067,H.texture,Qe);for(let Ne=0;Ne<6;Ne++)me(Y.__webglFramebuffer[Ne],H,36064,34069+Ne);F(H.texture,Qe)&&E(34067,H.texture,H.width,H.height),t.bindTexture(34067,null)}else t.bindTexture(3553,$e.__webglTexture),De(3553,H.texture,Qe),me(Y.__webglFramebuffer,H,36064,3553),F(H.texture,Qe)&&E(3553,H.texture,H.width,H.height),t.bindTexture(3553,null);H.depthBuffer&&et(H)}function nt(H){const Y=H.texture,$e=w(H)||u;if(F(Y,$e)){const Ie=H.isWebGLCubeRenderTarget?34067:3553,fe=i.get(Y).__webglTexture;t.bindTexture(Ie,fe),E(Ie,Y,H.width,H.height),t.bindTexture(Ie,null)}}function Be(H){if(H.isWebGLMultisampleRenderTarget)if(u){const Y=i.get(H);e.bindFramebuffer(36008,Y.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,Y.__webglFramebuffer);const $e=H.width,Ie=H.height;let fe=16384;H.depthBuffer&&(fe|=256),H.stencilBuffer&&(fe|=1024),e.blitFramebuffer(0,0,$e,Ie,0,0,$e,Ie,fe,9728),e.bindFramebuffer(36160,Y.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function ae(H){return u&&H.isWebGLMultisampleRenderTarget?Math.min(h,H.samples):0}function U(H){const Y=c.render.frame;p.get(H)!==Y&&(p.set(H,Y),H.update())}let Se=!1,ze=!1;function Oe(H,Y){H&&H.isWebGLRenderTarget&&(Se===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Se=!0),H=H.texture),te(H,Y)}function Ye(H,Y){H&&H.isWebGLCubeRenderTarget&&(ze===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),ze=!0),H=H.texture),H&&H.isCubeTexture||Array.isArray(H.image)&&H.image.length===6?be(H,Y):Ee(H,Y)}this.allocateTextureUnit=W,this.resetTextureUnits=Q,this.setTexture2D=te,this.setTexture2DArray=K,this.setTexture3D=pe,this.setTextureCube=be,this.setTextureCubeDynamic=Ee,this.setupRenderTarget=Ve,this.updateRenderTargetMipmap=nt,this.updateMultisampleRenderTarget=Be,this.safeSetTexture2D=Oe,this.safeSetTextureCube=Ye}function SS(e,n,t){const i=t.isWebGL2;function r(a){let c;if(a===Bu)return 5121;if(a===gM)return 32819;if(a===_M)return 32820;if(a===yM)return 33635;if(a===fM)return 5120;if(a===pM)return 5122;if(a===Mg)return 5123;if(a===mM)return 5124;if(a===Tg)return 5125;if(a===Nr)return 5126;if(a===Eg)return i?5131:(c=n.get("OES_texture_half_float"),c!==null?c.HALF_FLOAT_OES:null);if(a===vM)return 6406;if(a===bo)return 6407;if(a===fs)return 6408;if(a===wM)return 6409;if(a===xM)return 6410;if(a===Ca)return 6402;if(a===$u)return 34041;if(a===MM)return 6403;if(a===TM)return 36244;if(a===EM)return 33319;if(a===SM)return 33320;if(a===PM)return 36248;if(a===AM)return 36249;if(a===aw||a===lw||a===cw||a===uw)if(c=n.get("WEBGL_compressed_texture_s3tc"),c!==null){if(a===aw)return c.COMPRESSED_RGB_S3TC_DXT1_EXT;if(a===lw)return c.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(a===cw)return c.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(a===uw)return c.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(a===dw||a===hw||a===fw||a===pw)if(c=n.get("WEBGL_compressed_texture_pvrtc"),c!==null){if(a===dw)return c.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(a===hw)return c.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(a===fw)return c.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(a===pw)return c.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(a===CM)return c=n.get("WEBGL_compressed_texture_etc1"),c!==null?c.COMPRESSED_RGB_ETC1_WEBGL:null;if((a===mw||a===gw)&&(c=n.get("WEBGL_compressed_texture_etc"),c!==null)){if(a===mw)return c.COMPRESSED_RGB8_ETC2;if(a===gw)return c.COMPRESSED_RGBA8_ETC2_EAC}if(a===IM||a===LM||a===DM||a===kM||a===OM||a===FM||a===RM||a===BM||a===zM||a===$M||a===NM||a===UM||a===GM||a===VM||a===WM||a===HM||a===qM||a===KM||a===XM||a===YM||a===JM||a===QM||a===ZM||a===e1||a===t1||a===n1||a===i1||a===s1)return c=n.get("WEBGL_compressed_texture_astc"),c!==null?a:null;if(a===jM)return c=n.get("EXT_texture_compression_bptc"),c!==null?a:null;if(a===zu)return i?34042:(c=n.get("WEBGL_depth_texture"),c!==null?c.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:r}}function kv(e){ii.call(this),this.cameras=e||[]}kv.prototype=Object.assign(Object.create(ii.prototype),{constructor:kv,isArrayCamera:!0});function Yr(){Ot.call(this),this.type="Group"}Yr.prototype=Object.assign(Object.create(Ot.prototype),{constructor:Yr,isGroup:!0});function nd(){this._targetRay=null,this._grip=null,this._hand=null}Object.assign(nd.prototype,{constructor:nd,getHandSpace:function(){if(this._hand===null&&(this._hand=new Yr,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints=[],this._hand.inputState={pinching:!1},window.XRHand))for(let e=0;e<=window.XRHand.LITTLE_PHALANX_TIP;e++){let n=new Yr;n.matrixAutoUpdate=!1,n.visible=!1,this._hand.joints.push(n),this._hand.add(n)}return this._hand},getTargetRaySpace:function(){return this._targetRay===null&&(this._targetRay=new Yr,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return this._grip===null&&(this._grip=new Yr,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this},disconnect:function(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this},update:function(e,n,t){let i=null,r=null,a=null;const c=this._targetRay,u=this._grip,l=this._hand;if(e)if(e.hand){a=!0;for(let f=0;f<=window.XRHand.LITTLE_PHALANX_TIP;f++)if(e.hand[f]){let m=n.getJointPose(e.hand[f],t);const h=l.joints[f];m!==null&&(h.matrix.fromArray(m.transform.matrix),h.matrix.decompose(h.position,h.rotation,h.scale),h.jointRadius=m.radius),h.visible=m!==null;const p=l.joints[window.XRHand.INDEX_PHALANX_TIP],_=l.joints[window.XRHand.THUMB_PHALANX_TIP],v=p.position.distanceTo(_.position),S=.02,D=.005;l.inputState.pinching&&v>S+D?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&v<=S-D&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}}else c!==null&&(i=n.getPose(e.targetRaySpace,t),i!==null&&(c.matrix.fromArray(i.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale))),u!==null&&e.gripSpace&&(r=n.getPose(e.gripSpace,t),r!==null&&(u.matrix.fromArray(r.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale)));return c!==null&&(c.visible=i!==null),u!==null&&(u.visible=r!==null),l!==null&&(l.visible=a!==null),this}});function sx(e,n){const t=this;let i=null,r=1,a=null,c="local-floor",u=null;const l=[],f=new Map,m=new ii;m.layers.enable(1),m.viewport=new An;const h=new ii;h.layers.enable(2),h.viewport=new An;const p=[m,h],_=new kv;_.layers.enable(1),_.layers.enable(2);let v=null,S=null;this.enabled=!1,this.isPresenting=!1,this.getController=function(ne){let Q=l[ne];return Q===void 0&&(Q=new nd,l[ne]=Q),Q.getTargetRaySpace()},this.getControllerGrip=function(ne){let Q=l[ne];return Q===void 0&&(Q=new nd,l[ne]=Q),Q.getGripSpace()},this.getHand=function(ne){let Q=l[ne];return Q===void 0&&(Q=new nd,l[ne]=Q),Q.getHandSpace()};function D(ne){const Q=f.get(ne.inputSource);Q&&Q.dispatchEvent({type:ne.type})}function w(){f.forEach(function(ne,Q){ne.disconnect(Q)}),f.clear(),e.setFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),q.stop(),t.isPresenting=!1,t.dispatchEvent({type:"sessionend"})}function T(ne){a=ne,q.setContext(i),q.start(),t.isPresenting=!0,t.dispatchEvent({type:"sessionstart"})}this.setFramebufferScaleFactor=function(ne){r=ne,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(ne){c=ne,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return a},this.getSession=function(){return i},this.setSession=function(ne){if(i=ne,i!==null){i.addEventListener("select",D),i.addEventListener("selectstart",D),i.addEventListener("selectend",D),i.addEventListener("squeeze",D),i.addEventListener("squeezestart",D),i.addEventListener("squeezeend",D),i.addEventListener("end",w);const Q=n.getContextAttributes();Q.xrCompatible!==!0&&n.makeXRCompatible();const W={antialias:Q.antialias,alpha:Q.alpha,depth:Q.depth,stencil:Q.stencil,framebufferScaleFactor:r},te=new XRWebGLLayer(i,n,W);i.updateRenderState({baseLayer:te}),i.requestReferenceSpace(c).then(T),i.addEventListener("inputsourceschange",F)}};function F(ne){const Q=i.inputSources;for(let W=0;W<l.length;W++)f.set(Q[W],l[W]);for(let W=0;W<ne.removed.length;W++){const te=ne.removed[W],K=f.get(te);K&&(K.dispatchEvent({type:"disconnected",data:te}),f.delete(te))}for(let W=0;W<ne.added.length;W++){const te=ne.added[W],K=f.get(te);K&&K.dispatchEvent({type:"connected",data:te})}}const E=new ye,A=new ye;function L(ne,Q,W){E.setFromMatrixPosition(Q.matrixWorld),A.setFromMatrixPosition(W.matrixWorld);const te=E.distanceTo(A),K=Q.projectionMatrix.elements,pe=W.projectionMatrix.elements,be=K[14]/(K[10]-1),Ee=K[14]/(K[10]+1),Ge=(K[9]+1)/K[5],_e=(K[9]-1)/K[5],De=(K[8]-1)/K[0],he=(pe[8]+1)/pe[0],Z=be*De,me=be*he,we=te/(-De+he),xe=we*-De;Q.matrixWorld.decompose(ne.position,ne.quaternion,ne.scale),ne.translateX(xe),ne.translateZ(we),ne.matrixWorld.compose(ne.position,ne.quaternion,ne.scale),ne.matrixWorldInverse.getInverse(ne.matrixWorld);const et=be+we,Ve=Ee+we,nt=Z-xe,Be=me+(te-xe),ae=Ge*Ee/Ve*et,U=_e*Ee/Ve*et;ne.projectionMatrix.makePerspective(nt,Be,ae,U,et,Ve)}function I(ne,Q){Q===null?ne.matrixWorld.copy(ne.matrix):ne.matrixWorld.multiplyMatrices(Q.matrixWorld,ne.matrix),ne.matrixWorldInverse.getInverse(ne.matrixWorld)}this.getCamera=function(ne){_.near=h.near=m.near=ne.near,_.far=h.far=m.far=ne.far,(v!==_.near||S!==_.far)&&(i.updateRenderState({depthNear:_.near,depthFar:_.far}),v=_.near,S=_.far);const Q=ne.parent,W=_.cameras;I(_,Q);for(let K=0;K<W.length;K++)I(W[K],Q);ne.matrixWorld.copy(_.matrixWorld);const te=ne.children;for(let K=0,pe=te.length;K<pe;K++)te[K].updateMatrixWorld(!0);return W.length===2?L(_,m,h):_.projectionMatrix.copy(m.projectionMatrix),_};let R=null;function N(ne,Q){if(u=Q.getViewerPose(a),u!==null){const te=u.views,K=i.renderState.baseLayer;e.setFramebuffer(K.framebuffer);let pe=!1;te.length!==_.cameras.length&&(_.cameras.length=0,pe=!0);for(let be=0;be<te.length;be++){const Ee=te[be],Ge=K.getViewport(Ee),_e=p[be];_e.matrix.fromArray(Ee.transform.matrix),_e.projectionMatrix.fromArray(Ee.projectionMatrix),_e.viewport.set(Ge.x,Ge.y,Ge.width,Ge.height),be===0&&_.matrix.copy(_e.matrix),pe===!0&&_.cameras.push(_e)}}const W=i.inputSources;for(let te=0;te<l.length;te++){const K=l[te],pe=W[te];K.update(pe,Q,a)}R&&R(ne,Q)}const q=new Fw;q.setAnimationLoop(N),this.setAnimationLoop=function(ne){R=ne},this.dispose=function(){}}Object.assign(sx.prototype,yr.prototype);function PS(e){function n(w,T){w.fogColor.value.copy(T.color),T.isFog?(w.fogNear.value=T.near,w.fogFar.value=T.far):T.isFogExp2&&(w.fogDensity.value=T.density)}function t(w,T,F,E,A){T.isMeshBasicMaterial?i(w,T):T.isMeshLambertMaterial?(i(w,T),l(w,T)):T.isMeshToonMaterial?(i(w,T),m(w,T)):T.isMeshPhongMaterial?(i(w,T),f(w,T)):T.isMeshStandardMaterial?(i(w,T,F),T.isMeshPhysicalMaterial?p(w,T,F):h(w,T,F)):T.isMeshMatcapMaterial?(i(w,T),_(w,T)):T.isMeshDepthMaterial?(i(w,T),v(w,T)):T.isMeshDistanceMaterial?(i(w,T),S(w,T)):T.isMeshNormalMaterial?(i(w,T),D(w,T)):T.isLineBasicMaterial?(r(w,T),T.isLineDashedMaterial&&a(w,T)):T.isPointsMaterial?c(w,T,E,A):T.isSpriteMaterial?u(w,T):T.isShadowMaterial?(w.color.value.copy(T.color),w.opacity.value=T.opacity):T.isShaderMaterial&&(T.uniformsNeedUpdate=!1)}function i(w,T,F){w.opacity.value=T.opacity,T.color&&w.diffuse.value.copy(T.color),T.emissive&&w.emissive.value.copy(T.emissive).multiplyScalar(T.emissiveIntensity),T.map&&(w.map.value=T.map),T.alphaMap&&(w.alphaMap.value=T.alphaMap),T.specularMap&&(w.specularMap.value=T.specularMap);const E=T.envMap||F;if(E){w.envMap.value=E,w.flipEnvMap.value=E.isCubeTexture?-1:1,w.reflectivity.value=T.reflectivity,w.refractionRatio.value=T.refractionRatio;var A=e.get(E).__maxMipLevel;A!==void 0&&(w.maxMipLevel.value=A)}T.lightMap&&(w.lightMap.value=T.lightMap,w.lightMapIntensity.value=T.lightMapIntensity),T.aoMap&&(w.aoMap.value=T.aoMap,w.aoMapIntensity.value=T.aoMapIntensity);let L;T.map?L=T.map:T.specularMap?L=T.specularMap:T.displacementMap?L=T.displacementMap:T.normalMap?L=T.normalMap:T.bumpMap?L=T.bumpMap:T.roughnessMap?L=T.roughnessMap:T.metalnessMap?L=T.metalnessMap:T.alphaMap?L=T.alphaMap:T.emissiveMap&&(L=T.emissiveMap),L!==void 0&&(L.isWebGLRenderTarget&&(L=L.texture),L.matrixAutoUpdate===!0&&L.updateMatrix(),w.uvTransform.value.copy(L.matrix));let I;T.aoMap?I=T.aoMap:T.lightMap&&(I=T.lightMap),I!==void 0&&(I.isWebGLRenderTarget&&(I=I.texture),I.matrixAutoUpdate===!0&&I.updateMatrix(),w.uv2Transform.value.copy(I.matrix))}function r(w,T){w.diffuse.value.copy(T.color),w.opacity.value=T.opacity}function a(w,T){w.dashSize.value=T.dashSize,w.totalSize.value=T.dashSize+T.gapSize,w.scale.value=T.scale}function c(w,T,F,E){w.diffuse.value.copy(T.color),w.opacity.value=T.opacity,w.size.value=T.size*F,w.scale.value=E*.5,T.map&&(w.map.value=T.map),T.alphaMap&&(w.alphaMap.value=T.alphaMap);let A;T.map?A=T.map:T.alphaMap&&(A=T.alphaMap),A!==void 0&&(A.matrixAutoUpdate===!0&&A.updateMatrix(),w.uvTransform.value.copy(A.matrix))}function u(w,T){w.diffuse.value.copy(T.color),w.opacity.value=T.opacity,w.rotation.value=T.rotation,T.map&&(w.map.value=T.map),T.alphaMap&&(w.alphaMap.value=T.alphaMap);let F;T.map?F=T.map:T.alphaMap&&(F=T.alphaMap),F!==void 0&&(F.matrixAutoUpdate===!0&&F.updateMatrix(),w.uvTransform.value.copy(F.matrix))}function l(w,T){T.emissiveMap&&(w.emissiveMap.value=T.emissiveMap)}function f(w,T){w.specular.value.copy(T.specular),w.shininess.value=Math.max(T.shininess,1e-4),T.emissiveMap&&(w.emissiveMap.value=T.emissiveMap),T.bumpMap&&(w.bumpMap.value=T.bumpMap,w.bumpScale.value=T.bumpScale,T.side===li&&(w.bumpScale.value*=-1)),T.normalMap&&(w.normalMap.value=T.normalMap,w.normalScale.value.copy(T.normalScale),T.side===li&&w.normalScale.value.negate()),T.displacementMap&&(w.displacementMap.value=T.displacementMap,w.displacementScale.value=T.displacementScale,w.displacementBias.value=T.displacementBias)}function m(w,T){T.gradientMap&&(w.gradientMap.value=T.gradientMap),T.emissiveMap&&(w.emissiveMap.value=T.emissiveMap),T.bumpMap&&(w.bumpMap.value=T.bumpMap,w.bumpScale.value=T.bumpScale,T.side===li&&(w.bumpScale.value*=-1)),T.normalMap&&(w.normalMap.value=T.normalMap,w.normalScale.value.copy(T.normalScale),T.side===li&&w.normalScale.value.negate()),T.displacementMap&&(w.displacementMap.value=T.displacementMap,w.displacementScale.value=T.displacementScale,w.displacementBias.value=T.displacementBias)}function h(w,T,F){w.roughness.value=T.roughness,w.metalness.value=T.metalness,T.roughnessMap&&(w.roughnessMap.value=T.roughnessMap),T.metalnessMap&&(w.metalnessMap.value=T.metalnessMap),T.emissiveMap&&(w.emissiveMap.value=T.emissiveMap),T.bumpMap&&(w.bumpMap.value=T.bumpMap,w.bumpScale.value=T.bumpScale,T.side===li&&(w.bumpScale.value*=-1)),T.normalMap&&(w.normalMap.value=T.normalMap,w.normalScale.value.copy(T.normalScale),T.side===li&&w.normalScale.value.negate()),T.displacementMap&&(w.displacementMap.value=T.displacementMap,w.displacementScale.value=T.displacementScale,w.displacementBias.value=T.displacementBias),(T.envMap||F)&&(w.envMapIntensity.value=T.envMapIntensity)}function p(w,T,F){h(w,T,F),w.reflectivity.value=T.reflectivity,w.clearcoat.value=T.clearcoat,w.clearcoatRoughness.value=T.clearcoatRoughness,T.sheen&&w.sheen.value.copy(T.sheen),T.clearcoatMap&&(w.clearcoatMap.value=T.clearcoatMap),T.clearcoatRoughnessMap&&(w.clearcoatRoughnessMap.value=T.clearcoatRoughnessMap),T.clearcoatNormalMap&&(w.clearcoatNormalScale.value.copy(T.clearcoatNormalScale),w.clearcoatNormalMap.value=T.clearcoatNormalMap,T.side===li&&w.clearcoatNormalScale.value.negate()),w.transmission.value=T.transmission,T.transmissionMap&&(w.transmissionMap.value=T.transmissionMap)}function _(w,T){T.matcap&&(w.matcap.value=T.matcap),T.bumpMap&&(w.bumpMap.value=T.bumpMap,w.bumpScale.value=T.bumpScale,T.side===li&&(w.bumpScale.value*=-1)),T.normalMap&&(w.normalMap.value=T.normalMap,w.normalScale.value.copy(T.normalScale),T.side===li&&w.normalScale.value.negate()),T.displacementMap&&(w.displacementMap.value=T.displacementMap,w.displacementScale.value=T.displacementScale,w.displacementBias.value=T.displacementBias)}function v(w,T){T.displacementMap&&(w.displacementMap.value=T.displacementMap,w.displacementScale.value=T.displacementScale,w.displacementBias.value=T.displacementBias)}function S(w,T){T.displacementMap&&(w.displacementMap.value=T.displacementMap,w.displacementScale.value=T.displacementScale,w.displacementBias.value=T.displacementBias),w.referencePosition.value.copy(T.referencePosition),w.nearDistance.value=T.nearDistance,w.farDistance.value=T.farDistance}function D(w,T){T.bumpMap&&(w.bumpMap.value=T.bumpMap,w.bumpScale.value=T.bumpScale,T.side===li&&(w.bumpScale.value*=-1)),T.normalMap&&(w.normalMap.value=T.normalMap,w.normalScale.value.copy(T.normalScale),T.side===li&&w.normalScale.value.negate()),T.displacementMap&&(w.displacementMap.value=T.displacementMap,w.displacementScale.value=T.displacementScale,w.displacementBias.value=T.displacementBias)}return{refreshFogUniforms:n,refreshMaterialUniforms:t}}function id(e){e=e||{};const n=e.canvas!==void 0?e.canvas:document.createElementNS("http://www.w3.org/1999/xhtml","canvas"),t=e.context!==void 0?e.context:null,i=e.alpha!==void 0?e.alpha:!1,r=e.depth!==void 0?e.depth:!0,a=e.stencil!==void 0?e.stencil:!0,c=e.antialias!==void 0?e.antialias:!1,u=e.premultipliedAlpha!==void 0?e.premultipliedAlpha:!0,l=e.preserveDrawingBuffer!==void 0?e.preserveDrawingBuffer:!1,f=e.powerPreference!==void 0?e.powerPreference:"default",m=e.failIfMajorPerformanceCaveat!==void 0?e.failIfMajorPerformanceCaveat:!1;let h=null,p=null;this.domElement=n,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Ui,this.physicallyCorrectLights=!1,this.toneMapping=Aa,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const _=this;let v=!1,S=null,D=0,w=0,T=null,F=null,E=-1,A=null,L=null;const I=new An,R=new An;let N=null,q=n.width,ne=n.height,Q=1,W=null,te=null;const K=new An(0,0,q,ne),pe=new An(0,0,q,ne);let be=!1;const Ee=new Ju,Ge=new s2;let _e=!1,De=!1;const he=new dn,Z=new ye,me={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function we(){return T===null?Q:1}let xe=t;function et(Me,at){for(let rt=0;rt<Me.length;rt++){const mt=Me[rt],_t=n.getContext(mt,at);if(_t!==null)return _t}return null}try{const Me={alpha:i,depth:r,stencil:a,antialias:c,premultipliedAlpha:u,preserveDrawingBuffer:l,powerPreference:f,failIfMajorPerformanceCaveat:m};if(n.addEventListener("webglcontextlost",lt,!1),n.addEventListener("webglcontextrestored",Mt,!1),xe===null){const at=["webgl2","webgl","experimental-webgl"];if(_.isWebGL1Renderer===!0&&at.shift(),xe=et(at,Me),xe===null)throw et(at)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}xe.getShaderPrecisionFormat===void 0&&(xe.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Me){throw console.error("THREE.WebGLRenderer: "+Me.message),Me}let Ve,nt,Be,ae,U,Se,ze,Oe,Ye,H,Y,$e,Ie,fe,Qe,Ne,ut,de,qe;function tt(){Ve=new r2(xe),nt=new i2(xe,Ve,e),nt.isWebGL2===!1&&(Ve.get("WEBGL_depth_texture"),Ve.get("OES_texture_float"),Ve.get("OES_texture_half_float"),Ve.get("OES_texture_half_float_linear"),Ve.get("OES_standard_derivatives"),Ve.get("OES_element_index_uint"),Ve.get("OES_vertex_array_object"),Ve.get("ANGLE_instanced_arrays")),Ve.get("OES_texture_float_linear"),de=new SS(xe,Ve,nt),Be=new TS(xe,Ve,nt),Be.scissor(R.copy(pe).multiplyScalar(Q).floor()),Be.viewport(I.copy(K).multiplyScalar(Q).floor()),ae=new l2,U=new hS,Se=new ES(xe,Ve,Be,U,nt,de,ae),ze=new D1(xe,nt),qe=new t2(xe,Ve,ze,nt),Oe=new o2(xe,ze,ae,qe),Ye=new h2(xe,Oe,ze,ae),Qe=new d2(xe),H=new dS(_,Ve,nt,qe),Y=new PS(U),$e=new mS(U),Ie=new xS,fe=new e2(_,Be,Ye,u),Ne=new n2(xe,Ve,ae,nt),ut=new a2(xe,Ve,ae,nt),ae.programs=H.programs,_.capabilities=nt,_.extensions=Ve,_.properties=U,_.renderLists=$e,_.state=Be,_.info=ae}tt();const He=new sx(_,xe);this.xr=He;const je=new ix(_,Ye,nt.maxTextureSize);this.shadowMap=je,this.getContext=function(){return xe},this.getContextAttributes=function(){return xe.getContextAttributes()},this.forceContextLoss=function(){const Me=Ve.get("WEBGL_lose_context");Me&&Me.loseContext()},this.forceContextRestore=function(){const Me=Ve.get("WEBGL_lose_context");Me&&Me.restoreContext()},this.getPixelRatio=function(){return Q},this.setPixelRatio=function(Me){Me!==void 0&&(Q=Me,this.setSize(q,ne,!1))},this.getSize=function(Me){return Me===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),Me=new vt),Me.set(q,ne)},this.setSize=function(Me,at,rt){if(He.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}q=Me,ne=at,n.width=Math.floor(Me*Q),n.height=Math.floor(at*Q),rt!==!1&&(n.style.width=Me+"px",n.style.height=at+"px"),this.setViewport(0,0,Me,at)},this.getDrawingBufferSize=function(Me){return Me===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),Me=new vt),Me.set(q*Q,ne*Q).floor()},this.setDrawingBufferSize=function(Me,at,rt){q=Me,ne=at,Q=rt,n.width=Math.floor(Me*rt),n.height=Math.floor(at*rt),this.setViewport(0,0,Me,at)},this.getCurrentViewport=function(Me){return Me===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),Me=new An),Me.copy(I)},this.getViewport=function(Me){return Me.copy(K)},this.setViewport=function(Me,at,rt,mt){Me.isVector4?K.set(Me.x,Me.y,Me.z,Me.w):K.set(Me,at,rt,mt),Be.viewport(I.copy(K).multiplyScalar(Q).floor())},this.getScissor=function(Me){return Me.copy(pe)},this.setScissor=function(Me,at,rt,mt){Me.isVector4?pe.set(Me.x,Me.y,Me.z,Me.w):pe.set(Me,at,rt,mt),Be.scissor(R.copy(pe).multiplyScalar(Q).floor())},this.getScissorTest=function(){return be},this.setScissorTest=function(Me){Be.setScissorTest(be=Me)},this.setOpaqueSort=function(Me){W=Me},this.setTransparentSort=function(Me){te=Me},this.getClearColor=function(){return fe.getClearColor()},this.setClearColor=function(){fe.setClearColor.apply(fe,arguments)},this.getClearAlpha=function(){return fe.getClearAlpha()},this.setClearAlpha=function(){fe.setClearAlpha.apply(fe,arguments)},this.clear=function(Me,at,rt){let mt=0;(Me===void 0||Me)&&(mt|=16384),(at===void 0||at)&&(mt|=256),(rt===void 0||rt)&&(mt|=1024),xe.clear(mt)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){n.removeEventListener("webglcontextlost",lt,!1),n.removeEventListener("webglcontextrestored",Mt,!1),$e.dispose(),Ie.dispose(),U.dispose(),Ye.dispose(),qe.dispose(),He.dispose(),ci.stop()};function lt(Me){Me.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),v=!0}function Mt(){console.log("THREE.WebGLRenderer: Context Restored."),v=!1,tt()}function Rt(Me){const at=Me.target;at.removeEventListener("dispose",Rt),Xt(at)}function Xt(Me){wn(Me),U.remove(Me)}function wn(Me){const at=U.get(Me).program;at!==void 0&&H.releaseProgram(at)}function xn(Me,at){Me.render(function(rt){_.renderBufferImmediate(rt,at)})}this.renderBufferImmediate=function(Me,at){qe.initAttributes();const rt=U.get(Me);Me.hasPositions&&!rt.position&&(rt.position=xe.createBuffer()),Me.hasNormals&&!rt.normal&&(rt.normal=xe.createBuffer()),Me.hasUvs&&!rt.uv&&(rt.uv=xe.createBuffer()),Me.hasColors&&!rt.color&&(rt.color=xe.createBuffer());const mt=at.getAttributes();Me.hasPositions&&(xe.bindBuffer(34962,rt.position),xe.bufferData(34962,Me.positionArray,35048),qe.enableAttribute(mt.position),xe.vertexAttribPointer(mt.position,3,5126,!1,0,0)),Me.hasNormals&&(xe.bindBuffer(34962,rt.normal),xe.bufferData(34962,Me.normalArray,35048),qe.enableAttribute(mt.normal),xe.vertexAttribPointer(mt.normal,3,5126,!1,0,0)),Me.hasUvs&&(xe.bindBuffer(34962,rt.uv),xe.bufferData(34962,Me.uvArray,35048),qe.enableAttribute(mt.uv),xe.vertexAttribPointer(mt.uv,2,5126,!1,0,0)),Me.hasColors&&(xe.bindBuffer(34962,rt.color),xe.bufferData(34962,Me.colorArray,35048),qe.enableAttribute(mt.color),xe.vertexAttribPointer(mt.color,3,5126,!1,0,0)),qe.disableUnusedAttributes(),xe.drawArrays(4,0,Me.count),Me.count=0},this.renderBufferDirect=function(Me,at,rt,mt,_t,an){at===null&&(at=me);const B=_t.isMesh&&_t.matrixWorld.determinant()<0,le=Di(Me,at,mt,_t);Be.setMaterial(mt,B);let J=rt.index;const se=rt.attributes.position;if(J===null){if(se===void 0||se.count===0)return}else if(J.count===0)return;let ge=1;mt.wireframe===!0&&(J=Oe.getWireframeAttribute(rt),ge=2),(mt.morphTargets||mt.morphNormals)&&Qe.update(_t,rt,mt,le),qe.setup(_t,mt,le,rt,J);let Fe,Ke=Ne;J!==null&&(Fe=ze.get(J),Ke=ut,Ke.setIndex(Fe));const pt=J!==null?J.count:se.count,Pt=rt.drawRange.start*ge,Tt=rt.drawRange.count*ge,en=an!==null?an.start*ge:0,Dt=an!==null?an.count*ge:1/0,tn=Math.max(Pt,en),Vt=Math.min(pt,Pt+Tt,en+Dt)-1,nn=Math.max(0,Vt-tn+1);if(nn!==0){if(_t.isMesh)mt.wireframe===!0?(Be.setLineWidth(mt.wireframeLinewidth*we()),Ke.setMode(1)):Ke.setMode(4);else if(_t.isLine){let Tn=mt.linewidth;Tn===void 0&&(Tn=1),Be.setLineWidth(Tn*we()),_t.isLineSegments?Ke.setMode(1):_t.isLineLoop?Ke.setMode(2):Ke.setMode(3)}else _t.isPoints?Ke.setMode(0):_t.isSprite&&Ke.setMode(4);if(_t.isInstancedMesh)Ke.renderInstances(tn,nn,_t.count);else if(rt.isInstancedBufferGeometry){const Tn=Math.min(rt.instanceCount,rt._maxInstanceCount);Ke.renderInstances(tn,nn,Tn)}else Ke.render(tn,nn)}},this.compile=function(Me,at){p=Ie.get(Me,at),p.init(),Me.traverse(function(mt){mt.isLight&&(p.pushLight(mt),mt.castShadow&&p.pushShadow(mt))}),p.setupLights(at);const rt=new WeakMap;Me.traverse(function(mt){let _t=mt.material;if(_t)if(Array.isArray(_t))for(let an=0;an<_t.length;an++){let B=_t[an];rt.has(B)===!1&&(Mn(B,Me,mt),rt.set(B))}else rt.has(_t)===!1&&(Mn(_t,Me,mt),rt.set(_t))})};let cn=null;function jn(Me){He.isPresenting||cn&&cn(Me)}const ci=new Fw;ci.setAnimationLoop(jn),typeof window<"u"&&ci.setContext(window),this.setAnimationLoop=function(Me){cn=Me,He.setAnimationLoop(Me),Me===null?ci.stop():ci.start()},this.render=function(Me,at){let rt,mt;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),rt=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),mt=arguments[3]),at!==void 0&&at.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(v===!0)return;qe.resetDefaultState(),E=-1,A=null,Me.autoUpdate===!0&&Me.updateMatrixWorld(),at.parent===null&&at.updateMatrixWorld(),He.enabled===!0&&He.isPresenting===!0&&(at=He.getCamera(at)),Me.isScene===!0&&Me.onBeforeRender(_,Me,at,rt||T),p=Ie.get(Me,at),p.init(),he.multiplyMatrices(at.projectionMatrix,at.matrixWorldInverse),Ee.setFromProjectionMatrix(he),De=this.localClippingEnabled,_e=Ge.init(this.clippingPlanes,De,at),h=$e.get(Me,at),h.init(),ss(Me,at,0,_.sortObjects),h.finish(),_.sortObjects===!0&&h.sort(W,te),_e===!0&&Ge.beginShadows();const _t=p.state.shadowsArray;je.render(_t,Me,at),p.setupLights(at),_e===!0&&Ge.endShadows(),this.info.autoReset===!0&&this.info.reset(),rt!==void 0&&this.setRenderTarget(rt),fe.render(h,Me,at,mt);const an=h.opaque,B=h.transparent;an.length>0&&Vi(an,Me,at),B.length>0&&Vi(B,Me,at),Me.isScene===!0&&Me.onAfterRender(_,Me,at),T!==null&&(Se.updateRenderTargetMipmap(T),Se.updateMultisampleRenderTarget(T)),Be.buffers.depth.setTest(!0),Be.buffers.depth.setMask(!0),Be.buffers.color.setMask(!0),Be.setPolygonOffset(!1),h=null,p=null};function ss(Me,at,rt,mt){if(Me.visible===!1)return;if(Me.layers.test(at.layers)){if(Me.isGroup)rt=Me.renderOrder;else if(Me.isLOD)Me.autoUpdate===!0&&Me.update(at);else if(Me.isLight)p.pushLight(Me),Me.castShadow&&p.pushShadow(Me);else if(Me.isSprite){if(!Me.frustumCulled||Ee.intersectsSprite(Me)){mt&&Z.setFromMatrixPosition(Me.matrixWorld).applyMatrix4(he);const B=Ye.update(Me),le=Me.material;le.visible&&h.push(Me,B,le,rt,Z.z,null)}}else if(Me.isImmediateRenderObject)mt&&Z.setFromMatrixPosition(Me.matrixWorld).applyMatrix4(he),h.push(Me,null,Me.material,rt,Z.z,null);else if((Me.isMesh||Me.isLine||Me.isPoints)&&(Me.isSkinnedMesh&&Me.skeleton.frame!==ae.render.frame&&(Me.skeleton.update(),Me.skeleton.frame=ae.render.frame),!Me.frustumCulled||Ee.intersectsObject(Me))){mt&&Z.setFromMatrixPosition(Me.matrixWorld).applyMatrix4(he);const B=Ye.update(Me),le=Me.material;if(Array.isArray(le)){const J=B.groups;for(let se=0,ge=J.length;se<ge;se++){const Fe=J[se],Ke=le[Fe.materialIndex];Ke&&Ke.visible&&h.push(Me,B,Ke,rt,Z.z,Fe)}}else le.visible&&h.push(Me,B,le,rt,Z.z,null)}}const an=Me.children;for(let B=0,le=an.length;B<le;B++)ss(an[B],at,rt,mt)}function Vi(Me,at,rt){const mt=at.isScene===!0?at.overrideMaterial:null;for(let _t=0,an=Me.length;_t<an;_t++){const B=Me[_t],le=B.object,J=B.geometry,se=mt===null?B.material:mt,ge=B.group;if(rt.isArrayCamera){L=rt;const Fe=rt.cameras;for(let Ke=0,pt=Fe.length;Ke<pt;Ke++){const Pt=Fe[Ke];le.layers.test(Pt.layers)&&(Be.viewport(I.copy(Pt.viewport)),p.setupLights(Pt),Cn(le,at,Pt,J,se,ge))}}else L=null,Cn(le,at,rt,J,se,ge)}}function Cn(Me,at,rt,mt,_t,an){if(Me.onBeforeRender(_,at,rt,mt,_t,an),p=Ie.get(at,L||rt),Me.modelViewMatrix.multiplyMatrices(rt.matrixWorldInverse,Me.matrixWorld),Me.normalMatrix.getNormalMatrix(Me.modelViewMatrix),Me.isImmediateRenderObject){const B=Di(rt,at,_t,Me);Be.setMaterial(_t),qe.reset(),xn(Me,B)}else _.renderBufferDirect(rt,at,mt,_t,Me,an);Me.onAfterRender(_,at,rt,mt,_t,an),p=Ie.get(at,L||rt)}function Mn(Me,at,rt){at.isScene!==!0&&(at=me);const mt=U.get(Me),_t=p.state.lights,an=p.state.shadowsArray,B=_t.state.version,le=H.getParameters(Me,_t.state,an,at,Ge.numPlanes,Ge.numIntersection,rt),J=H.getProgramCacheKey(le);let se=mt.program,ge=!0;if(se===void 0)Me.addEventListener("dispose",Rt);else if(se.cacheKey!==J)wn(Me);else if(mt.lightsStateVersion!==B)mt.lightsStateVersion=B,ge=!1;else{if(le.shaderID!==void 0)return;ge=!1}ge&&(le.uniforms=H.getUniforms(Me,le),Me.onBeforeCompile(le,_),se=H.acquireProgram(le,J),mt.program=se,mt.uniforms=le.uniforms,mt.outputEncoding=le.outputEncoding);const Fe=se.getAttributes();if(Me.morphTargets){Me.numSupportedMorphTargets=0;for(let Tt=0;Tt<_.maxMorphTargets;Tt++)Fe["morphTarget"+Tt]>=0&&Me.numSupportedMorphTargets++}if(Me.morphNormals){Me.numSupportedMorphNormals=0;for(let Tt=0;Tt<_.maxMorphNormals;Tt++)Fe["morphNormal"+Tt]>=0&&Me.numSupportedMorphNormals++}const Ke=mt.uniforms;(!Me.isShaderMaterial&&!Me.isRawShaderMaterial||Me.clipping===!0)&&(mt.numClippingPlanes=Ge.numPlanes,mt.numIntersection=Ge.numIntersection,Ke.clippingPlanes=Ge.uniform),mt.environment=Me.isMeshStandardMaterial?at.environment:null,mt.fog=at.fog,mt.needsLights=qt(Me),mt.lightsStateVersion=B,mt.needsLights&&(Ke.ambientLightColor.value=_t.state.ambient,Ke.lightProbe.value=_t.state.probe,Ke.directionalLights.value=_t.state.directional,Ke.directionalLightShadows.value=_t.state.directionalShadow,Ke.spotLights.value=_t.state.spot,Ke.spotLightShadows.value=_t.state.spotShadow,Ke.rectAreaLights.value=_t.state.rectArea,Ke.pointLights.value=_t.state.point,Ke.pointLightShadows.value=_t.state.pointShadow,Ke.hemisphereLights.value=_t.state.hemi,Ke.directionalShadowMap.value=_t.state.directionalShadowMap,Ke.directionalShadowMatrix.value=_t.state.directionalShadowMatrix,Ke.spotShadowMap.value=_t.state.spotShadowMap,Ke.spotShadowMatrix.value=_t.state.spotShadowMatrix,Ke.pointShadowMap.value=_t.state.pointShadowMap,Ke.pointShadowMatrix.value=_t.state.pointShadowMatrix);const pt=mt.program.getUniforms(),Pt=Xr.seqWithValue(pt.seq,Ke);mt.uniformsList=Pt}function Di(Me,at,rt,mt){at.isScene!==!0&&(at=me),Se.resetTextureUnits();const _t=at.fog,an=rt.isMeshStandardMaterial?at.environment:null,B=T===null?_.outputEncoding:T.texture.encoding,le=U.get(rt),J=p.state.lights;if(_e===!0&&(De===!0||Me!==A)){const Tt=Me===A&&rt.id===E;Ge.setState(rt.clippingPlanes,rt.clipIntersection,rt.clipShadows,Me,le,Tt)}rt.version===le.__version?(le.program===void 0||rt.fog&&le.fog!==_t||le.environment!==an||le.needsLights&&le.lightsStateVersion!==J.state.version||le.numClippingPlanes!==void 0&&(le.numClippingPlanes!==Ge.numPlanes||le.numIntersection!==Ge.numIntersection)||le.outputEncoding!==B)&&Mn(rt,at,mt):(Mn(rt,at,mt),le.__version=rt.version);let se=!1,ge=!1,Fe=!1;const Ke=le.program,pt=Ke.getUniforms(),Pt=le.uniforms;if(Be.useProgram(Ke.program)&&(se=!0,ge=!0,Fe=!0),rt.id!==E&&(E=rt.id,ge=!0),se||A!==Me){if(pt.setValue(xe,"projectionMatrix",Me.projectionMatrix),nt.logarithmicDepthBuffer&&pt.setValue(xe,"logDepthBufFC",2/(Math.log(Me.far+1)/Math.LN2)),A!==Me&&(A=Me,ge=!0,Fe=!0),rt.isShaderMaterial||rt.isMeshPhongMaterial||rt.isMeshToonMaterial||rt.isMeshStandardMaterial||rt.envMap){const Tt=pt.map.cameraPosition;Tt!==void 0&&Tt.setValue(xe,Z.setFromMatrixPosition(Me.matrixWorld))}(rt.isMeshPhongMaterial||rt.isMeshToonMaterial||rt.isMeshLambertMaterial||rt.isMeshBasicMaterial||rt.isMeshStandardMaterial||rt.isShaderMaterial)&&pt.setValue(xe,"isOrthographic",Me.isOrthographicCamera===!0),(rt.isMeshPhongMaterial||rt.isMeshToonMaterial||rt.isMeshLambertMaterial||rt.isMeshBasicMaterial||rt.isMeshStandardMaterial||rt.isShaderMaterial||rt.isShadowMaterial||rt.skinning)&&pt.setValue(xe,"viewMatrix",Me.matrixWorldInverse)}if(rt.skinning){pt.setOptional(xe,mt,"bindMatrix"),pt.setOptional(xe,mt,"bindMatrixInverse");const Tt=mt.skeleton;if(Tt){const en=Tt.bones;if(nt.floatVertexTextures){if(Tt.boneTexture===void 0){let Dt=Math.sqrt(en.length*4);Dt=ln.ceilPowerOfTwo(Dt),Dt=Math.max(Dt,4);const tn=new Float32Array(Dt*Dt*4);tn.set(Tt.boneMatrices);const Vt=new Ya(tn,Dt,Dt,fs,Nr);Tt.boneMatrices=tn,Tt.boneTexture=Vt,Tt.boneTextureSize=Dt}pt.setValue(xe,"boneTexture",Tt.boneTexture,Se),pt.setValue(xe,"boneTextureSize",Tt.boneTextureSize)}else pt.setOptional(xe,Tt,"boneMatrices")}}return(ge||le.receiveShadow!==mt.receiveShadow)&&(le.receiveShadow=mt.receiveShadow,pt.setValue(xe,"receiveShadow",mt.receiveShadow)),ge&&(pt.setValue(xe,"toneMappingExposure",_.toneMappingExposure),le.needsLights&&bs(Pt,Fe),_t&&rt.fog&&Y.refreshFogUniforms(Pt,_t),Y.refreshMaterialUniforms(Pt,rt,an,Q,ne),Pt.ltc_1!==void 0&&(Pt.ltc_1.value=zt.LTC_1),Pt.ltc_2!==void 0&&(Pt.ltc_2.value=zt.LTC_2),Xr.upload(xe,le.uniformsList,Pt,Se)),rt.isShaderMaterial&&rt.uniformsNeedUpdate===!0&&(Xr.upload(xe,le.uniformsList,Pt,Se),rt.uniformsNeedUpdate=!1),rt.isSpriteMaterial&&pt.setValue(xe,"center",mt.center),pt.setValue(xe,"modelViewMatrix",mt.modelViewMatrix),pt.setValue(xe,"normalMatrix",mt.normalMatrix),pt.setValue(xe,"modelMatrix",mt.matrixWorld),Ke}function bs(Me,at){Me.ambientLightColor.needsUpdate=at,Me.lightProbe.needsUpdate=at,Me.directionalLights.needsUpdate=at,Me.directionalLightShadows.needsUpdate=at,Me.pointLights.needsUpdate=at,Me.pointLightShadows.needsUpdate=at,Me.spotLights.needsUpdate=at,Me.spotLightShadows.needsUpdate=at,Me.rectAreaLights.needsUpdate=at,Me.hemisphereLights.needsUpdate=at}function qt(Me){return Me.isMeshLambertMaterial||Me.isMeshToonMaterial||Me.isMeshPhongMaterial||Me.isMeshStandardMaterial||Me.isShadowMaterial||Me.isShaderMaterial&&Me.lights===!0}this.setFramebuffer=function(Me){S!==Me&&T===null&&xe.bindFramebuffer(36160,Me),S=Me},this.getActiveCubeFace=function(){return D},this.getActiveMipmapLevel=function(){return w},this.getRenderTarget=function(){return T},this.setRenderTarget=function(Me,at,rt){T=Me,D=at,w=rt,Me&&U.get(Me).__webglFramebuffer===void 0&&Se.setupRenderTarget(Me);let mt=S,_t=!1;if(Me){const an=U.get(Me).__webglFramebuffer;Me.isWebGLCubeRenderTarget?(mt=an[at||0],_t=!0):Me.isWebGLMultisampleRenderTarget?mt=U.get(Me).__webglMultisampledFramebuffer:mt=an,I.copy(Me.viewport),R.copy(Me.scissor),N=Me.scissorTest}else I.copy(K).multiplyScalar(Q).floor(),R.copy(pe).multiplyScalar(Q).floor(),N=be;if(F!==mt&&(xe.bindFramebuffer(36160,mt),F=mt),Be.viewport(I),Be.scissor(R),Be.setScissorTest(N),_t){const an=U.get(Me.texture);xe.framebufferTexture2D(36160,36064,34069+(at||0),an.__webglTexture,rt||0)}},this.readRenderTargetPixels=function(Me,at,rt,mt,_t,an,B){if(!(Me&&Me.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let le=U.get(Me).__webglFramebuffer;if(Me.isWebGLCubeRenderTarget&&B!==void 0&&(le=le[B]),le){let J=!1;le!==F&&(xe.bindFramebuffer(36160,le),J=!0);try{const se=Me.texture,ge=se.format,Fe=se.type;if(ge!==fs&&de.convert(ge)!==xe.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(Fe!==Bu&&de.convert(Fe)!==xe.getParameter(35738)&&!(Fe===Nr&&(nt.isWebGL2||Ve.get("OES_texture_float")||Ve.get("WEBGL_color_buffer_float")))&&!(Fe===Eg&&(nt.isWebGL2?Ve.get("EXT_color_buffer_float"):Ve.get("EXT_color_buffer_half_float")))){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}xe.checkFramebufferStatus(36160)===36053?at>=0&&at<=Me.width-mt&&rt>=0&&rt<=Me.height-_t&&xe.readPixels(at,rt,mt,_t,de.convert(ge),de.convert(Fe),an):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{J&&xe.bindFramebuffer(36160,F)}}},this.copyFramebufferToTexture=function(Me,at,rt){rt===void 0&&(rt=0);const mt=Math.pow(2,-rt),_t=Math.floor(at.image.width*mt),an=Math.floor(at.image.height*mt),B=de.convert(at.format);Se.setTexture2D(at,0),xe.copyTexImage2D(3553,rt,B,Me.x,Me.y,_t,an,0),Be.unbindTexture()},this.copyTextureToTexture=function(Me,at,rt,mt){mt===void 0&&(mt=0);const _t=at.image.width,an=at.image.height,B=de.convert(rt.format),le=de.convert(rt.type);Se.setTexture2D(rt,0),xe.pixelStorei(37440,rt.flipY),xe.pixelStorei(37441,rt.premultiplyAlpha),xe.pixelStorei(3317,rt.unpackAlignment),at.isDataTexture?xe.texSubImage2D(3553,mt,Me.x,Me.y,_t,an,B,le,at.image.data):at.isCompressedTexture?xe.compressedTexSubImage2D(3553,mt,Me.x,Me.y,at.mipmaps[0].width,at.mipmaps[0].height,B,at.mipmaps[0].data):xe.texSubImage2D(3553,mt,Me.x,Me.y,B,le,at.image),mt===0&&rt.generateMipmaps&&xe.generateMipmap(3553),Be.unbindTexture()},this.initTexture=function(Me){Se.setTexture2D(Me,0),Be.unbindTexture()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function rx(e){id.call(this,e)}rx.prototype=Object.assign(Object.create(id.prototype),{constructor:rx,isWebGL1Renderer:!0});function Ov(e,n){this.name="",this.color=new jt(e),this.density=n!==void 0?n:25e-5}Object.assign(Ov.prototype,{isFogExp2:!0,clone:function(){return new Ov(this.color,this.density)},toJSON:function(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}});function Fv(e,n,t){this.name="",this.color=new jt(e),this.near=n!==void 0?n:1,this.far=t!==void 0?t:1e3}Object.assign(Fv.prototype,{isFog:!0,clone:function(){return new Fv(this.color,this.near,this.far)},toJSON:function(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}});function _s(e,n){this.array=e,this.stride=n,this.count=e!==void 0?e.length/n:0,this.usage=Ig,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=ln.generateUUID()}Object.defineProperty(_s.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}}),Object.assign(_s.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this},copyAt:function(e,n,t){e*=this.stride,t*=n.stride;for(let i=0,r=this.stride;i<r;i++)this.array[e+i]=n.array[t+i];return this},set:function(e,n){return n===void 0&&(n=0),this.array.set(e,n),this},clone:function(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=ln.generateUUID()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const n=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),t=new _s(n,this.stride);return t.setUsage(this.usage),t},onUpload:function(e){return this.onUploadCallback=e,this},toJSON:function(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=ln.generateUUID()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const Co=new ye;function Io(e,n,t,i){this.name="",this.data=e,this.itemSize=n,this.offset=t,this.normalized=i===!0}Object.defineProperties(Io.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(e){this.data.needsUpdate=e}}}),Object.assign(Io.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(e){for(let n=0,t=this.data.count;n<t;n++)Co.x=this.getX(n),Co.y=this.getY(n),Co.z=this.getZ(n),Co.applyMatrix4(e),this.setXYZ(n,Co.x,Co.y,Co.z);return this},setX:function(e,n){return this.data.array[e*this.data.stride+this.offset]=n,this},setY:function(e,n){return this.data.array[e*this.data.stride+this.offset+1]=n,this},setZ:function(e,n){return this.data.array[e*this.data.stride+this.offset+2]=n,this},setW:function(e,n){return this.data.array[e*this.data.stride+this.offset+3]=n,this},getX:function(e){return this.data.array[e*this.data.stride+this.offset]},getY:function(e){return this.data.array[e*this.data.stride+this.offset+1]},getZ:function(e){return this.data.array[e*this.data.stride+this.offset+2]},getW:function(e){return this.data.array[e*this.data.stride+this.offset+3]},setXY:function(e,n,t){return e=e*this.data.stride+this.offset,this.data.array[e+0]=n,this.data.array[e+1]=t,this},setXYZ:function(e,n,t,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=n,this.data.array[e+1]=t,this.data.array[e+2]=i,this},setXYZW:function(e,n,t,i,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=n,this.data.array[e+1]=t,this.data.array[e+2]=i,this.data.array[e+3]=r,this},clone:function(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const n=[];for(let t=0;t<this.count;t++){const i=t*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)n.push(this.data.array[i+r])}return new Kt(new this.array.constructor(n),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Io(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const n=[];for(let t=0;t<this.count;t++){const i=t*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)n.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:n,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}});function Lo(e){rn.call(this),this.type="SpriteMaterial",this.color=new jt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}Lo.prototype=Object.create(rn.prototype),Lo.prototype.constructor=Lo,Lo.prototype.isSpriteMaterial=!0,Lo.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this};let el;const sd=new ye,tl=new ye,nl=new ye,il=new vt,rd=new vt,ox=new dn,Yg=new ye,od=new ye,Jg=new ye,ax=new vt,Rv=new vt,lx=new vt;function Bv(e){if(Ot.call(this),this.type="Sprite",el===void 0){el=new Ut;const n=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),t=new _s(n,5);el.setIndex([0,1,2,0,2,3]),el.setAttribute("position",new Io(t,3,0,!1)),el.setAttribute("uv",new Io(t,2,3,!1))}this.geometry=el,this.material=e!==void 0?e:new Lo,this.center=new vt(.5,.5)}Bv.prototype=Object.assign(Object.create(Ot.prototype),{constructor:Bv,isSprite:!0,raycast:function(e,n){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),tl.setFromMatrixScale(this.matrixWorld),ox.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),nl.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&tl.multiplyScalar(-nl.z);const t=this.material.rotation;let i,r;t!==0&&(r=Math.cos(t),i=Math.sin(t));const a=this.center;Qg(Yg.set(-.5,-.5,0),nl,a,tl,i,r),Qg(od.set(.5,-.5,0),nl,a,tl,i,r),Qg(Jg.set(.5,.5,0),nl,a,tl,i,r),ax.set(0,0),Rv.set(1,0),lx.set(1,1);let c=e.ray.intersectTriangle(Yg,od,Jg,!1,sd);if(c===null&&(Qg(od.set(-.5,.5,0),nl,a,tl,i,r),Rv.set(0,1),c=e.ray.intersectTriangle(Yg,Jg,od,!1,sd),c===null))return;const u=e.ray.origin.distanceTo(sd);u<e.near||u>e.far||n.push({distance:u,point:sd.clone(),uv:xi.getUV(sd,Yg,od,Jg,ax,Rv,lx,new vt),face:null,object:this})},copy:function(e){return Ot.prototype.copy.call(this,e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}});function Qg(e,n,t,i,r,a){il.subVectors(e,t).addScalar(.5).multiply(i),r!==void 0?(rd.x=a*il.x-r*il.y,rd.y=r*il.x+a*il.y):rd.copy(il),e.copy(n),e.x+=rd.x,e.y+=rd.y,e.applyMatrix4(ox)}const Zg=new ye,cx=new ye;function e_(){Ot.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}e_.prototype=Object.assign(Object.create(Ot.prototype),{constructor:e_,isLOD:!0,copy:function(e){Ot.prototype.copy.call(this,e,!1);const n=e.levels;for(let t=0,i=n.length;t<i;t++){const r=n[t];this.addLevel(r.object.clone(),r.distance)}return this.autoUpdate=e.autoUpdate,this},addLevel:function(e,n){n===void 0&&(n=0),n=Math.abs(n);const t=this.levels;let i;for(i=0;i<t.length&&!(n<t[i].distance);i++);return t.splice(i,0,{distance:n,object:e}),this.add(e),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(e){const n=this.levels;if(n.length>0){let t,i;for(t=1,i=n.length;t<i&&!(e<n[t].distance);t++);return n[t-1].object}return null},raycast:function(e,n){if(this.levels.length>0){Zg.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(Zg);this.getObjectForDistance(i).raycast(e,n)}},update:function(e){const n=this.levels;if(n.length>1){Zg.setFromMatrixPosition(e.matrixWorld),cx.setFromMatrixPosition(this.matrixWorld);const t=Zg.distanceTo(cx)/e.zoom;n[0].object.visible=!0;let i,r;for(i=1,r=n.length;i<r&&t>=n[i].distance;i++)n[i-1].object.visible=!1,n[i].object.visible=!0;for(this._currentLevel=i-1;i<r;i++)n[i].object.visible=!1}},toJSON:function(e){const n=Ot.prototype.toJSON.call(this,e);this.autoUpdate===!1&&(n.object.autoUpdate=!1),n.object.levels=[];const t=this.levels;for(let i=0,r=t.length;i<r;i++){const a=t[i];n.object.levels.push({object:a.object.uuid,distance:a.distance})}return n}});function zv(e,n){e&&e.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),Ln.call(this,e,n),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new dn,this.bindMatrixInverse=new dn}zv.prototype=Object.assign(Object.create(Ln.prototype),{constructor:zv,isSkinnedMesh:!0,copy:function(e){return Ln.prototype.copy.call(this,e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this},bind:function(e,n){this.skeleton=e,n===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),n=this.matrixWorld),this.bindMatrix.copy(n),this.bindMatrixInverse.getInverse(n)},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const e=new An,n=this.geometry.attributes.skinWeight;for(let t=0,i=n.count;t<i;t++){e.x=n.getX(t),e.y=n.getY(t),e.z=n.getZ(t),e.w=n.getW(t);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),n.setXYZW(t,e.x,e.y,e.z,e.w)}},updateMatrixWorld:function(e){Ln.prototype.updateMatrixWorld.call(this,e),this.bindMode==="attached"?this.bindMatrixInverse.getInverse(this.matrixWorld):this.bindMode==="detached"?this.bindMatrixInverse.getInverse(this.bindMatrix):console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(){const e=new ye,n=new An,t=new An,i=new ye,r=new dn;return function(a,c){const u=this.skeleton,l=this.geometry;n.fromBufferAttribute(l.attributes.skinIndex,a),t.fromBufferAttribute(l.attributes.skinWeight,a),e.fromBufferAttribute(l.attributes.position,a).applyMatrix4(this.bindMatrix),c.set(0,0,0);for(let f=0;f<4;f++){const m=t.getComponent(f);if(m!==0){const h=n.getComponent(f);r.multiplyMatrices(u.bones[h].matrixWorld,u.boneInverses[h]),c.addScaledVector(i.copy(e).applyMatrix4(r),m)}}return c.applyMatrix4(this.bindMatrixInverse)}}()});const ux=new dn,AS=new dn;function $v(e,n){if(e=e||[],this.bones=e.slice(0),this.boneMatrices=new Float32Array(this.bones.length*16),this.frame=-1,n===void 0)this.calculateInverses();else if(this.bones.length===n.length)this.boneInverses=n.slice(0);else{console.warn("THREE.Skeleton boneInverses is the wrong length."),this.boneInverses=[];for(let t=0,i=this.bones.length;t<i;t++)this.boneInverses.push(new dn)}}Object.assign($v.prototype,{calculateInverses:function(){this.boneInverses=[];for(let e=0,n=this.bones.length;e<n;e++){const t=new dn;this.bones[e]&&t.getInverse(this.bones[e].matrixWorld),this.boneInverses.push(t)}},pose:function(){for(let e=0,n=this.bones.length;e<n;e++){const t=this.bones[e];t&&t.matrixWorld.getInverse(this.boneInverses[e])}for(let e=0,n=this.bones.length;e<n;e++){const t=this.bones[e];t&&(t.parent&&t.parent.isBone?(t.matrix.getInverse(t.parent.matrixWorld),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}},update:function(){const e=this.bones,n=this.boneInverses,t=this.boneMatrices,i=this.boneTexture;for(let r=0,a=e.length;r<a;r++){const c=e[r]?e[r].matrixWorld:AS;ux.multiplyMatrices(c,n[r]),ux.toArray(t,r*16)}i!==void 0&&(i.needsUpdate=!0)},clone:function(){return new $v(this.bones,this.boneInverses)},getBoneByName:function(e){for(let n=0,t=this.bones.length;n<t;n++){const i=this.bones[n];if(i.name===e)return i}},dispose:function(){this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=void 0)}});function dx(){Ot.call(this),this.type="Bone"}dx.prototype=Object.assign(Object.create(Ot.prototype),{constructor:dx,isBone:!0});const hx=new dn,fx=new dn,t_=[],ad=new Ln;function Nv(e,n,t){Ln.call(this,e,n),this.instanceMatrix=new Kt(new Float32Array(t*16),16),this.count=t,this.frustumCulled=!1}Nv.prototype=Object.assign(Object.create(Ln.prototype),{constructor:Nv,isInstancedMesh:!0,copy:function(e){return Ln.prototype.copy.call(this,e),this.instanceMatrix.copy(e.instanceMatrix),this.count=e.count,this},getMatrixAt:function(e,n){n.fromArray(this.instanceMatrix.array,e*16)},raycast:function(e,n){const t=this.matrixWorld,i=this.count;if(ad.geometry=this.geometry,ad.material=this.material,ad.material!==void 0)for(let r=0;r<i;r++){this.getMatrixAt(r,hx),fx.multiplyMatrices(t,hx),ad.matrixWorld=fx,ad.raycast(e,t_);for(let a=0,c=t_.length;a<c;a++){const u=t_[a];u.instanceId=r,u.object=this,n.push(u)}t_.length=0}},setMatrixAt:function(e,n){n.toArray(this.instanceMatrix.array,e*16)},updateMorphTargets:function(){}});function Yn(e){rn.call(this),this.type="LineBasicMaterial",this.color=new jt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(e)}Yn.prototype=Object.create(rn.prototype),Yn.prototype.constructor=Yn,Yn.prototype.isLineBasicMaterial=!0,Yn.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.morphTargets=e.morphTargets,this};const px=new ye,mx=new ye,gx=new dn,n_=new Na,i_=new xr;function ys(e,n,t){t===1&&console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."),Ot.call(this),this.type="Line",this.geometry=e!==void 0?e:new Ut,this.material=n!==void 0?n:new Yn,this.updateMorphTargets()}ys.prototype=Object.assign(Object.create(Ot.prototype),{constructor:ys,isLine:!0,copy:function(e){return Ot.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const n=e.attributes.position,t=[0];for(let i=1,r=n.count;i<r;i++)px.fromBufferAttribute(n,i-1),mx.fromBufferAttribute(n,i),t[i]=t[i-1],t[i]+=px.distanceTo(mx);e.setAttribute("lineDistance",new Bt(t,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry){const n=e.vertices,t=e.lineDistances;t[0]=0;for(let i=1,r=n.length;i<r;i++)t[i]=t[i-1],t[i]+=n[i-1].distanceTo(n[i])}return this},raycast:function(e,n){const t=this.geometry,i=this.matrixWorld,r=e.params.Line.threshold;if(t.boundingSphere===null&&t.computeBoundingSphere(),i_.copy(t.boundingSphere),i_.applyMatrix4(i),i_.radius+=r,e.ray.intersectsSphere(i_)===!1)return;gx.getInverse(i),n_.copy(e.ray).applyMatrix4(gx);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),c=a*a,u=new ye,l=new ye,f=new ye,m=new ye,h=this&&this.isLineSegments?2:1;if(t.isBufferGeometry){const p=t.index,v=t.attributes.position.array;if(p!==null){const S=p.array;for(let D=0,w=S.length-1;D<w;D+=h){const T=S[D],F=S[D+1];if(u.fromArray(v,T*3),l.fromArray(v,F*3),n_.distanceSqToSegment(u,l,m,f)>c)continue;m.applyMatrix4(this.matrixWorld);const A=e.ray.origin.distanceTo(m);A<e.near||A>e.far||n.push({distance:A,point:f.clone().applyMatrix4(this.matrixWorld),index:D,face:null,faceIndex:null,object:this})}}else for(let S=0,D=v.length/3-1;S<D;S+=h){if(u.fromArray(v,3*S),l.fromArray(v,3*S+3),n_.distanceSqToSegment(u,l,m,f)>c)continue;m.applyMatrix4(this.matrixWorld);const T=e.ray.origin.distanceTo(m);T<e.near||T>e.far||n.push({distance:T,point:f.clone().applyMatrix4(this.matrixWorld),index:S,face:null,faceIndex:null,object:this})}}else if(t.isGeometry){const p=t.vertices,_=p.length;for(let v=0;v<_-1;v+=h){if(n_.distanceSqToSegment(p[v],p[v+1],m,f)>c)continue;m.applyMatrix4(this.matrixWorld);const D=e.ray.origin.distanceTo(m);D<e.near||D>e.far||n.push({distance:D,point:f.clone().applyMatrix4(this.matrixWorld),index:v,face:null,faceIndex:null,object:this})}}},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const n=e.morphAttributes,t=Object.keys(n);if(t.length>0){const i=n[t[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const c=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[c]=r}}}}else{const n=e.morphTargets;n!==void 0&&n.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const s_=new ye,r_=new ye;function si(e,n){ys.call(this,e,n),this.type="LineSegments"}si.prototype=Object.assign(Object.create(ys.prototype),{constructor:si,isLineSegments:!0,computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const n=e.attributes.position,t=[];for(let i=0,r=n.count;i<r;i+=2)s_.fromBufferAttribute(n,i),r_.fromBufferAttribute(n,i+1),t[i]=i===0?0:t[i-1],t[i+1]=t[i]+s_.distanceTo(r_);e.setAttribute("lineDistance",new Bt(t,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry){const n=e.vertices,t=e.lineDistances;for(let i=0,r=n.length;i<r;i+=2)s_.copy(n[i]),r_.copy(n[i+1]),t[i]=i===0?0:t[i-1],t[i+1]=t[i]+s_.distanceTo(r_)}return this}});function Uv(e,n){ys.call(this,e,n),this.type="LineLoop"}Uv.prototype=Object.assign(Object.create(ys.prototype),{constructor:Uv,isLineLoop:!0});function Jr(e){rn.call(this),this.type="PointsMaterial",this.color=new jt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(e)}Jr.prototype=Object.create(rn.prototype),Jr.prototype.constructor=Jr,Jr.prototype.isPointsMaterial=!0,Jr.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.morphTargets=e.morphTargets,this};const _x=new dn,Gv=new Na,o_=new xr,a_=new ye;function l_(e,n){Ot.call(this),this.type="Points",this.geometry=e!==void 0?e:new Ut,this.material=n!==void 0?n:new Jr,this.updateMorphTargets()}l_.prototype=Object.assign(Object.create(Ot.prototype),{constructor:l_,isPoints:!0,copy:function(e){return Ot.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},raycast:function(e,n){const t=this.geometry,i=this.matrixWorld,r=e.params.Points.threshold;if(t.boundingSphere===null&&t.computeBoundingSphere(),o_.copy(t.boundingSphere),o_.applyMatrix4(i),o_.radius+=r,e.ray.intersectsSphere(o_)===!1)return;_x.getInverse(i),Gv.copy(e.ray).applyMatrix4(_x);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),c=a*a;if(t.isBufferGeometry){const u=t.index,f=t.attributes.position.array;if(u!==null){const m=u.array;for(let h=0,p=m.length;h<p;h++){const _=m[h];a_.fromArray(f,_*3),Vv(a_,_,c,i,e,n,this)}}else for(let m=0,h=f.length/3;m<h;m++)a_.fromArray(f,m*3),Vv(a_,m,c,i,e,n,this)}else{const u=t.vertices;for(let l=0,f=u.length;l<f;l++)Vv(u[l],l,c,i,e,n,this)}},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const n=e.morphAttributes,t=Object.keys(n);if(t.length>0){const i=n[t[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const c=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[c]=r}}}}else{const n=e.morphTargets;n!==void 0&&n.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});function Vv(e,n,t,i,r,a,c){const u=Gv.distanceSqToPoint(e);if(u<t){const l=new ye;Gv.closestPointToPoint(e,l),l.applyMatrix4(i);const f=r.ray.origin.distanceTo(l);if(f<r.near||f>r.far)return;a.push({distance:f,distanceToRay:Math.sqrt(u),point:l,index:n,face:null,object:c})}}function yx(e,n,t,i,r,a,c,u,l){Dn.call(this,e,n,t,i,r,a,c,u,l),this.format=c!==void 0?c:bo,this.minFilter=a!==void 0?a:Pi,this.magFilter=r!==void 0?r:Pi,this.generateMipmaps=!1;const f=this;function m(){f.needsUpdate=!0,e.requestVideoFrameCallback(m)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(m)}yx.prototype=Object.assign(Object.create(Dn.prototype),{constructor:yx,isVideoTexture:!0,update:function(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}});function ld(e,n,t,i,r,a,c,u,l,f,m,h){Dn.call(this,null,a,c,u,l,f,i,r,m,h),this.image={width:n,height:t},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}ld.prototype=Object.create(Dn.prototype),ld.prototype.constructor=ld,ld.prototype.isCompressedTexture=!0;function cd(e,n,t,i,r,a,c,u,l){Dn.call(this,e,n,t,i,r,a,c,u,l),this.needsUpdate=!0}cd.prototype=Object.create(Dn.prototype),cd.prototype.constructor=cd,cd.prototype.isCanvasTexture=!0;function c_(e,n,t,i,r,a,c,u,l,f){if(f=f!==void 0?f:Ca,f!==Ca&&f!==$u)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");t===void 0&&f===Ca&&(t=Mg),t===void 0&&f===$u&&(t=zu),Dn.call(this,null,i,r,a,c,u,f,t,l),this.image={width:e,height:n},this.magFilter=c!==void 0?c:fi,this.minFilter=u!==void 0?u:fi,this.flipY=!1,this.generateMipmaps=!1}c_.prototype=Object.create(Dn.prototype),c_.prototype.constructor=c_,c_.prototype.isDepthTexture=!0;function u_(e){Ut.call(this),this.type="WireframeGeometry";const n=[],t=[0,0],i={},r=["a","b","c"];if(e&&e.isGeometry){const a=e.faces;for(let c=0,u=a.length;c<u;c++){const l=a[c];for(let f=0;f<3;f++){const m=l[r[f]],h=l[r[(f+1)%3]];t[0]=Math.min(m,h),t[1]=Math.max(m,h);const p=t[0]+","+t[1];i[p]===void 0&&(i[p]={index1:t[0],index2:t[1]})}}for(const c in i){const u=i[c];let l=e.vertices[u.index1];n.push(l.x,l.y,l.z),l=e.vertices[u.index2],n.push(l.x,l.y,l.z)}}else if(e&&e.isBufferGeometry){let a=new ye;if(e.index!==null){const c=e.attributes.position,u=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:u.count,materialIndex:0}]);for(let f=0,m=l.length;f<m;++f){const h=l[f],p=h.start,_=h.count;for(let v=p,S=p+_;v<S;v+=3)for(let D=0;D<3;D++){const w=u.getX(v+D),T=u.getX(v+(D+1)%3);t[0]=Math.min(w,T),t[1]=Math.max(w,T);const F=t[0]+","+t[1];i[F]===void 0&&(i[F]={index1:t[0],index2:t[1]})}}for(const f in i){const m=i[f];a.fromBufferAttribute(c,m.index1),n.push(a.x,a.y,a.z),a.fromBufferAttribute(c,m.index2),n.push(a.x,a.y,a.z)}}else{const c=e.attributes.position;for(let u=0,l=c.count/3;u<l;u++)for(let f=0;f<3;f++){const m=3*u+f;a.fromBufferAttribute(c,m),n.push(a.x,a.y,a.z);const h=3*u+(f+1)%3;a.fromBufferAttribute(c,h),n.push(a.x,a.y,a.z)}}}this.setAttribute("position",new Bt(n,3))}u_.prototype=Object.create(Ut.prototype),u_.prototype.constructor=u_;function d_(e,n,t){on.call(this),this.type="ParametricGeometry",this.parameters={func:e,slices:n,stacks:t},this.fromBufferGeometry(new ud(e,n,t)),this.mergeVertices()}d_.prototype=Object.create(on.prototype),d_.prototype.constructor=d_;function ud(e,n,t){Ut.call(this),this.type="ParametricBufferGeometry",this.parameters={func:e,slices:n,stacks:t};const i=[],r=[],a=[],c=[],u=1e-5,l=new ye,f=new ye,m=new ye,h=new ye,p=new ye;e.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const _=n+1;for(let v=0;v<=t;v++){const S=v/t;for(let D=0;D<=n;D++){const w=D/n;e(w,S,f),r.push(f.x,f.y,f.z),w-u>=0?(e(w-u,S,m),h.subVectors(f,m)):(e(w+u,S,m),h.subVectors(m,f)),S-u>=0?(e(w,S-u,m),p.subVectors(f,m)):(e(w,S+u,m),p.subVectors(m,f)),l.crossVectors(h,p).normalize(),a.push(l.x,l.y,l.z),c.push(w,S)}}for(let v=0;v<t;v++)for(let S=0;S<n;S++){const D=v*_+S,w=v*_+S+1,T=(v+1)*_+S+1,F=(v+1)*_+S;i.push(D,w,F),i.push(w,T,F)}this.setIndex(i),this.setAttribute("position",new Bt(r,3)),this.setAttribute("normal",new Bt(a,3)),this.setAttribute("uv",new Bt(c,2))}ud.prototype=Object.create(Ut.prototype),ud.prototype.constructor=ud;function h_(e,n,t,i){on.call(this),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:n,radius:t,detail:i},this.fromBufferGeometry(new ts(e,n,t,i)),this.mergeVertices()}h_.prototype=Object.create(on.prototype),h_.prototype.constructor=h_;function ts(e,n,t,i){Ut.call(this),this.type="PolyhedronBufferGeometry",this.parameters={vertices:e,indices:n,radius:t,detail:i},t=t||1,i=i||0;const r=[],a=[];c(i),l(t),f(),this.setAttribute("position",new Bt(r,3)),this.setAttribute("normal",new Bt(r.slice(),3)),this.setAttribute("uv",new Bt(a,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function c(w){const T=new ye,F=new ye,E=new ye;for(let A=0;A<n.length;A+=3)p(n[A+0],T),p(n[A+1],F),p(n[A+2],E),u(T,F,E,w)}function u(w,T,F,E){const A=Math.pow(2,E),L=[];for(let I=0;I<=A;I++){L[I]=[];const R=w.clone().lerp(F,I/A),N=T.clone().lerp(F,I/A),q=A-I;for(let ne=0;ne<=q;ne++)ne===0&&I===A?L[I][ne]=R:L[I][ne]=R.clone().lerp(N,ne/q)}for(let I=0;I<A;I++)for(let R=0;R<2*(A-I)-1;R++){const N=Math.floor(R/2);R%2===0?(h(L[I][N+1]),h(L[I+1][N]),h(L[I][N])):(h(L[I][N+1]),h(L[I+1][N+1]),h(L[I+1][N]))}}function l(w){const T=new ye;for(let F=0;F<r.length;F+=3)T.x=r[F+0],T.y=r[F+1],T.z=r[F+2],T.normalize().multiplyScalar(w),r[F+0]=T.x,r[F+1]=T.y,r[F+2]=T.z}function f(){const w=new ye;for(let T=0;T<r.length;T+=3){w.x=r[T+0],w.y=r[T+1],w.z=r[T+2];const F=S(w)/2/Math.PI+.5,E=D(w)/Math.PI+.5;a.push(F,1-E)}_(),m()}function m(){for(let w=0;w<a.length;w+=6){const T=a[w+0],F=a[w+2],E=a[w+4],A=Math.max(T,F,E),L=Math.min(T,F,E);A>.9&&L<.1&&(T<.2&&(a[w+0]+=1),F<.2&&(a[w+2]+=1),E<.2&&(a[w+4]+=1))}}function h(w){r.push(w.x,w.y,w.z)}function p(w,T){const F=w*3;T.x=e[F+0],T.y=e[F+1],T.z=e[F+2]}function _(){const w=new ye,T=new ye,F=new ye,E=new ye,A=new vt,L=new vt,I=new vt;for(let R=0,N=0;R<r.length;R+=9,N+=6){w.set(r[R+0],r[R+1],r[R+2]),T.set(r[R+3],r[R+4],r[R+5]),F.set(r[R+6],r[R+7],r[R+8]),A.set(a[N+0],a[N+1]),L.set(a[N+2],a[N+3]),I.set(a[N+4],a[N+5]),E.copy(w).add(T).add(F).divideScalar(3);const q=S(E);v(A,N+0,w,q),v(L,N+2,T,q),v(I,N+4,F,q)}}function v(w,T,F,E){E<0&&w.x===1&&(a[T]=w.x-1),F.x===0&&F.z===0&&(a[T]=E/2/Math.PI+.5)}function S(w){return Math.atan2(w.z,-w.x)}function D(w){return Math.atan2(-w.y,Math.sqrt(w.x*w.x+w.z*w.z))}}ts.prototype=Object.create(Ut.prototype),ts.prototype.constructor=ts;function f_(e,n){on.call(this),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:n},this.fromBufferGeometry(new dd(e,n)),this.mergeVertices()}f_.prototype=Object.create(on.prototype),f_.prototype.constructor=f_;function dd(e,n){const t=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];ts.call(this,t,i,e,n),this.type="TetrahedronBufferGeometry",this.parameters={radius:e,detail:n}}dd.prototype=Object.create(ts.prototype),dd.prototype.constructor=dd;function p_(e,n){on.call(this),this.type="OctahedronGeometry",this.parameters={radius:e,detail:n},this.fromBufferGeometry(new sl(e,n)),this.mergeVertices()}p_.prototype=Object.create(on.prototype),p_.prototype.constructor=p_;function sl(e,n){const t=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];ts.call(this,t,i,e,n),this.type="OctahedronBufferGeometry",this.parameters={radius:e,detail:n}}sl.prototype=Object.create(ts.prototype),sl.prototype.constructor=sl;function m_(e,n){on.call(this),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:n},this.fromBufferGeometry(new hd(e,n)),this.mergeVertices()}m_.prototype=Object.create(on.prototype),m_.prototype.constructor=m_;function hd(e,n){const t=(1+Math.sqrt(5))/2,i=[-1,t,0,1,t,0,-1,-t,0,1,-t,0,0,-1,t,0,1,t,0,-1,-t,0,1,-t,t,0,-1,t,0,1,-t,0,-1,-t,0,1],r=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];ts.call(this,i,r,e,n),this.type="IcosahedronBufferGeometry",this.parameters={radius:e,detail:n}}hd.prototype=Object.create(ts.prototype),hd.prototype.constructor=hd;function g_(e,n){on.call(this),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:n},this.fromBufferGeometry(new fd(e,n)),this.mergeVertices()}g_.prototype=Object.create(on.prototype),g_.prototype.constructor=g_;function fd(e,n){const t=(1+Math.sqrt(5))/2,i=1/t,r=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-t,0,-i,t,0,i,-t,0,i,t,-i,-t,0,-i,t,0,i,-t,0,i,t,0,-t,0,-i,t,0,-i,-t,0,i,t,0,i],a=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];ts.call(this,r,a,e,n),this.type="DodecahedronBufferGeometry",this.parameters={radius:e,detail:n}}fd.prototype=Object.create(ts.prototype),fd.prototype.constructor=fd;function __(e,n,t,i,r,a){on.call(this),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:n,radius:t,radialSegments:i,closed:r},a!==void 0&&console.warn("THREE.TubeGeometry: taper has been removed.");const c=new rl(e,n,t,i,r);this.tangents=c.tangents,this.normals=c.normals,this.binormals=c.binormals,this.fromBufferGeometry(c),this.mergeVertices()}__.prototype=Object.create(on.prototype),__.prototype.constructor=__;function rl(e,n,t,i,r){Ut.call(this),this.type="TubeBufferGeometry",this.parameters={path:e,tubularSegments:n,radius:t,radialSegments:i,closed:r},n=n||64,t=t||1,i=i||8,r=r||!1;const a=e.computeFrenetFrames(n,r);this.tangents=a.tangents,this.normals=a.normals,this.binormals=a.binormals;const c=new ye,u=new ye,l=new vt;let f=new ye;const m=[],h=[],p=[],_=[];v(),this.setIndex(_),this.setAttribute("position",new Bt(m,3)),this.setAttribute("normal",new Bt(h,3)),this.setAttribute("uv",new Bt(p,2));function v(){for(let T=0;T<n;T++)S(T);S(r===!1?n:0),w(),D()}function S(T){f=e.getPointAt(T/n,f);const F=a.normals[T],E=a.binormals[T];for(let A=0;A<=i;A++){const L=A/i*Math.PI*2,I=Math.sin(L),R=-Math.cos(L);u.x=R*F.x+I*E.x,u.y=R*F.y+I*E.y,u.z=R*F.z+I*E.z,u.normalize(),h.push(u.x,u.y,u.z),c.x=f.x+t*u.x,c.y=f.y+t*u.y,c.z=f.z+t*u.z,m.push(c.x,c.y,c.z)}}function D(){for(let T=1;T<=n;T++)for(let F=1;F<=i;F++){const E=(i+1)*(T-1)+(F-1),A=(i+1)*T+(F-1),L=(i+1)*T+F,I=(i+1)*(T-1)+F;_.push(E,A,I),_.push(A,L,I)}}function w(){for(let T=0;T<=n;T++)for(let F=0;F<=i;F++)l.x=T/n,l.y=F/i,p.push(l.x,l.y)}}rl.prototype=Object.create(Ut.prototype),rl.prototype.constructor=rl,rl.prototype.toJSON=function(){const e=Ut.prototype.toJSON.call(this);return e.path=this.parameters.path.toJSON(),e};function y_(e,n,t,i,r,a,c){on.call(this),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:n,tubularSegments:t,radialSegments:i,p:r,q:a},c!==void 0&&console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),this.fromBufferGeometry(new pd(e,n,t,i,r,a)),this.mergeVertices()}y_.prototype=Object.create(on.prototype),y_.prototype.constructor=y_;function pd(e,n,t,i,r,a){Ut.call(this),this.type="TorusKnotBufferGeometry",this.parameters={radius:e,tube:n,tubularSegments:t,radialSegments:i,p:r,q:a},e=e||1,n=n||.4,t=Math.floor(t)||64,i=Math.floor(i)||8,r=r||2,a=a||3;const c=[],u=[],l=[],f=[],m=new ye,h=new ye,p=new ye,_=new ye,v=new ye,S=new ye,D=new ye;for(let T=0;T<=t;++T){const F=T/t*r*Math.PI*2;w(F,r,a,e,p),w(F+.01,r,a,e,_),S.subVectors(_,p),D.addVectors(_,p),v.crossVectors(S,D),D.crossVectors(v,S),v.normalize(),D.normalize();for(let E=0;E<=i;++E){const A=E/i*Math.PI*2,L=-n*Math.cos(A),I=n*Math.sin(A);m.x=p.x+(L*D.x+I*v.x),m.y=p.y+(L*D.y+I*v.y),m.z=p.z+(L*D.z+I*v.z),u.push(m.x,m.y,m.z),h.subVectors(m,p).normalize(),l.push(h.x,h.y,h.z),f.push(T/t),f.push(E/i)}}for(let T=1;T<=t;T++)for(let F=1;F<=i;F++){const E=(i+1)*(T-1)+(F-1),A=(i+1)*T+(F-1),L=(i+1)*T+F,I=(i+1)*(T-1)+F;c.push(E,A,I),c.push(A,L,I)}this.setIndex(c),this.setAttribute("position",new Bt(u,3)),this.setAttribute("normal",new Bt(l,3)),this.setAttribute("uv",new Bt(f,2));function w(T,F,E,A,L){const I=Math.cos(T),R=Math.sin(T),N=E/F*T,q=Math.cos(N);L.x=A*(2+q)*.5*I,L.y=A*(2+q)*R*.5,L.z=A*Math.sin(N)*.5}}pd.prototype=Object.create(Ut.prototype),pd.prototype.constructor=pd;function v_(e,n,t,i,r){on.call(this),this.type="TorusGeometry",this.parameters={radius:e,tube:n,radialSegments:t,tubularSegments:i,arc:r},this.fromBufferGeometry(new md(e,n,t,i,r)),this.mergeVertices()}v_.prototype=Object.create(on.prototype),v_.prototype.constructor=v_;function md(e,n,t,i,r){Ut.call(this),this.type="TorusBufferGeometry",this.parameters={radius:e,tube:n,radialSegments:t,tubularSegments:i,arc:r},e=e||1,n=n||.4,t=Math.floor(t)||8,i=Math.floor(i)||6,r=r||Math.PI*2;const a=[],c=[],u=[],l=[],f=new ye,m=new ye,h=new ye;for(let p=0;p<=t;p++)for(let _=0;_<=i;_++){const v=_/i*r,S=p/t*Math.PI*2;m.x=(e+n*Math.cos(S))*Math.cos(v),m.y=(e+n*Math.cos(S))*Math.sin(v),m.z=n*Math.sin(S),c.push(m.x,m.y,m.z),f.x=e*Math.cos(v),f.y=e*Math.sin(v),h.subVectors(m,f).normalize(),u.push(h.x,h.y,h.z),l.push(_/i),l.push(p/t)}for(let p=1;p<=t;p++)for(let _=1;_<=i;_++){const v=(i+1)*p+_-1,S=(i+1)*(p-1)+_-1,D=(i+1)*(p-1)+_,w=(i+1)*p+_;a.push(v,S,w),a.push(S,D,w)}this.setIndex(a),this.setAttribute("position",new Bt(c,3)),this.setAttribute("normal",new Bt(u,3)),this.setAttribute("uv",new Bt(l,2))}md.prototype=Object.create(Ut.prototype),md.prototype.constructor=md;const CS={triangulate:function(e,n,t){t=t||2;let i=n&&n.length,r=i?n[0]*t:e.length,a=vx(e,0,r,t,!0),c=[];if(!a||a.next===a.prev)return c;let u,l,f,m,h,p,_;if(i&&(a=OS(e,n,a,t)),e.length>80*t){u=f=e[0],l=m=e[1];for(let v=t;v<r;v+=t)h=e[v],p=e[v+1],h<u&&(u=h),p<l&&(l=p),h>f&&(f=h),p>m&&(m=p);_=Math.max(f-u,m-l),_=_!==0?1/_:0}return gd(a,c,t,u,l,_),c}};function vx(e,n,t,i,r){let a,c;if(r===WS(e,n,t,i)>0)for(a=n;a<t;a+=i)c=bx(a,e[a],e[a+1],c);else for(a=t-i;a>=n;a-=i)c=bx(a,e[a],e[a+1],c);return c&&w_(c,c.next)&&(yd(c),c=c.next),c}function Qr(e,n){if(!e)return e;n||(n=e);let t=e,i;do if(i=!1,!t.steiner&&(w_(t,t.next)||Gn(t.prev,t,t.next)===0)){if(yd(t),t=n=t.prev,t===t.next)break;i=!0}else t=t.next;while(i||t!==n);return n}function gd(e,n,t,i,r,a,c){if(!e)return;!c&&a&&$S(e,i,r,a);let u=e,l,f;for(;e.prev!==e.next;){if(l=e.prev,f=e.next,a?LS(e,i,r,a):IS(e)){n.push(l.i/t),n.push(e.i/t),n.push(f.i/t),yd(e),e=f.next,u=f.next;continue}if(e=f,e===u){c?c===1?(e=DS(Qr(e),n,t),gd(e,n,t,i,r,a,2)):c===2&&kS(e,n,t,i,r,a):gd(Qr(e),n,t,i,r,a,1);break}}}function IS(e){let n=e.prev,t=e,i=e.next;if(Gn(n,t,i)>=0)return!1;let r=e.next.next;for(;r!==e.prev;){if(ol(n.x,n.y,t.x,t.y,i.x,i.y,r.x,r.y)&&Gn(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function LS(e,n,t,i){let r=e.prev,a=e,c=e.next;if(Gn(r,a,c)>=0)return!1;let u=r.x<a.x?r.x<c.x?r.x:c.x:a.x<c.x?a.x:c.x,l=r.y<a.y?r.y<c.y?r.y:c.y:a.y<c.y?a.y:c.y,f=r.x>a.x?r.x>c.x?r.x:c.x:a.x>c.x?a.x:c.x,m=r.y>a.y?r.y>c.y?r.y:c.y:a.y>c.y?a.y:c.y,h=jv(u,l,n,t,i),p=jv(f,m,n,t,i),_=e.prevZ,v=e.nextZ;for(;_&&_.z>=h&&v&&v.z<=p;){if(_!==e.prev&&_!==e.next&&ol(r.x,r.y,a.x,a.y,c.x,c.y,_.x,_.y)&&Gn(_.prev,_,_.next)>=0||(_=_.prevZ,v!==e.prev&&v!==e.next&&ol(r.x,r.y,a.x,a.y,c.x,c.y,v.x,v.y)&&Gn(v.prev,v,v.next)>=0))return!1;v=v.nextZ}for(;_&&_.z>=h;){if(_!==e.prev&&_!==e.next&&ol(r.x,r.y,a.x,a.y,c.x,c.y,_.x,_.y)&&Gn(_.prev,_,_.next)>=0)return!1;_=_.prevZ}for(;v&&v.z<=p;){if(v!==e.prev&&v!==e.next&&ol(r.x,r.y,a.x,a.y,c.x,c.y,v.x,v.y)&&Gn(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}function DS(e,n,t){let i=e;do{let r=i.prev,a=i.next.next;!w_(r,a)&&wx(r,i,i.next,a)&&_d(r,a)&&_d(a,r)&&(n.push(r.i/t),n.push(i.i/t),n.push(a.i/t),yd(i),yd(i.next),i=e=a),i=i.next}while(i!==e);return Qr(i)}function kS(e,n,t,i,r,a){let c=e;do{let u=c.next.next;for(;u!==c.prev;){if(c.i!==u.i&&GS(c,u)){let l=xx(c,u);c=Qr(c,c.next),l=Qr(l,l.next),gd(c,n,t,i,r,a),gd(l,n,t,i,r,a);return}u=u.next}c=c.next}while(c!==e)}function OS(e,n,t,i){let r=[],a,c,u,l,f;for(a=0,c=n.length;a<c;a++)u=n[a]*i,l=a<c-1?n[a+1]*i:e.length,f=vx(e,u,l,i,!1),f===f.next&&(f.steiner=!0),r.push(US(f));for(r.sort(FS),a=0;a<r.length;a++)RS(r[a],t),t=Qr(t,t.next);return t}function FS(e,n){return e.x-n.x}function RS(e,n){if(n=BS(e,n),n){const t=xx(n,e);Qr(n,n.next),Qr(t,t.next)}}function BS(e,n){let t=n,i=e.x,r=e.y,a=-1/0,c;do{if(r<=t.y&&r>=t.next.y&&t.next.y!==t.y){let p=t.x+(r-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(p<=i&&p>a){if(a=p,p===i){if(r===t.y)return t;if(r===t.next.y)return t.next}c=t.x<t.next.x?t:t.next}}t=t.next}while(t!==n);if(!c)return null;if(i===a)return c;let u=c,l=c.x,f=c.y,m=1/0,h;t=c;do i>=t.x&&t.x>=l&&i!==t.x&&ol(r<f?i:a,r,l,f,r<f?a:i,r,t.x,t.y)&&(h=Math.abs(r-t.y)/(i-t.x),_d(t,e)&&(h<m||h===m&&(t.x>c.x||t.x===c.x&&zS(c,t)))&&(c=t,m=h)),t=t.next;while(t!==u);return c}function zS(e,n){return Gn(e.prev,e,n.prev)<0&&Gn(n.next,e,e.next)<0}function $S(e,n,t,i){let r=e;do r.z===null&&(r.z=jv(r.x,r.y,n,t,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==e);r.prevZ.nextZ=null,r.prevZ=null,NS(r)}function NS(e){let n,t,i,r,a,c,u,l,f=1;do{for(t=e,e=null,a=null,c=0;t;){for(c++,i=t,u=0,n=0;n<f&&(u++,i=i.nextZ,!!i);n++);for(l=f;u>0||l>0&&i;)u!==0&&(l===0||!i||t.z<=i.z)?(r=t,t=t.nextZ,u--):(r=i,i=i.nextZ,l--),a?a.nextZ=r:e=r,r.prevZ=a,a=r;t=i}a.nextZ=null,f*=2}while(c>1);return e}function jv(e,n,t,i,r){return e=32767*(e-t)*r,n=32767*(n-i)*r,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e|n<<1}function US(e){let n=e,t=e;do(n.x<t.x||n.x===t.x&&n.y<t.y)&&(t=n),n=n.next;while(n!==e);return t}function ol(e,n,t,i,r,a,c,u){return(r-c)*(n-u)-(e-c)*(a-u)>=0&&(e-c)*(i-u)-(t-c)*(n-u)>=0&&(t-c)*(a-u)-(r-c)*(i-u)>=0}function GS(e,n){return e.next.i!==n.i&&e.prev.i!==n.i&&!VS(e,n)&&(_d(e,n)&&_d(n,e)&&jS(e,n)&&(Gn(e.prev,e,n.prev)||Gn(e,n.prev,n))||w_(e,n)&&Gn(e.prev,e,e.next)>0&&Gn(n.prev,n,n.next)>0)}function Gn(e,n,t){return(n.y-e.y)*(t.x-n.x)-(n.x-e.x)*(t.y-n.y)}function w_(e,n){return e.x===n.x&&e.y===n.y}function wx(e,n,t,i){const r=b_(Gn(e,n,t)),a=b_(Gn(e,n,i)),c=b_(Gn(t,i,e)),u=b_(Gn(t,i,n));return!!(r!==a&&c!==u||r===0&&x_(e,t,n)||a===0&&x_(e,i,n)||c===0&&x_(t,e,i)||u===0&&x_(t,n,i))}function x_(e,n,t){return n.x<=Math.max(e.x,t.x)&&n.x>=Math.min(e.x,t.x)&&n.y<=Math.max(e.y,t.y)&&n.y>=Math.min(e.y,t.y)}function b_(e){return e>0?1:e<0?-1:0}function VS(e,n){let t=e;do{if(t.i!==e.i&&t.next.i!==e.i&&t.i!==n.i&&t.next.i!==n.i&&wx(t,t.next,e,n))return!0;t=t.next}while(t!==e);return!1}function _d(e,n){return Gn(e.prev,e,e.next)<0?Gn(e,n,e.next)>=0&&Gn(e,e.prev,n)>=0:Gn(e,n,e.prev)<0||Gn(e,e.next,n)<0}function jS(e,n){let t=e,i=!1,r=(e.x+n.x)/2,a=(e.y+n.y)/2;do t.y>a!=t.next.y>a&&t.next.y!==t.y&&r<(t.next.x-t.x)*(a-t.y)/(t.next.y-t.y)+t.x&&(i=!i),t=t.next;while(t!==e);return i}function xx(e,n){let t=new Wv(e.i,e.x,e.y),i=new Wv(n.i,n.x,n.y),r=e.next,a=n.prev;return e.next=n,n.prev=e,t.next=r,r.prev=t,i.next=t,t.prev=i,a.next=i,i.prev=a,i}function bx(e,n,t,i){const r=new Wv(e,n,t);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function yd(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Wv(e,n,t){this.i=e,this.x=n,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function WS(e,n,t,i){let r=0;for(let a=n,c=t-i;a<t;a+=i)r+=(e[c]-e[a])*(e[a+1]+e[c+1]),c=a;return r}const Zr={area:function(e){const n=e.length;let t=0;for(let i=n-1,r=0;r<n;i=r++)t+=e[i].x*e[r].y-e[r].x*e[i].y;return t*.5},isClockWise:function(e){return Zr.area(e)<0},triangulateShape:function(e,n){const t=[],i=[],r=[];Mx(e),Tx(t,e);let a=e.length;n.forEach(Mx);for(let u=0;u<n.length;u++)i.push(a),a+=n[u].length,Tx(t,n[u]);const c=CS.triangulate(t,i);for(let u=0;u<c.length;u+=3)r.push(c.slice(u,u+3));return r}};function Mx(e){const n=e.length;n>2&&e[n-1].equals(e[0])&&e.pop()}function Tx(e,n){for(let t=0;t<n.length;t++)e.push(n[t].x),e.push(n[t].y)}function al(e,n){on.call(this),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:n},this.fromBufferGeometry(new Sr(e,n)),this.mergeVertices()}al.prototype=Object.create(on.prototype),al.prototype.constructor=al,al.prototype.toJSON=function(){const e=on.prototype.toJSON.call(this),n=this.parameters.shapes,t=this.parameters.options;return Ex(n,t,e)};function Sr(e,n){Ut.call(this),this.type="ExtrudeBufferGeometry",this.parameters={shapes:e,options:n},e=Array.isArray(e)?e:[e];const t=this,i=[],r=[];for(let c=0,u=e.length;c<u;c++){const l=e[c];a(l)}this.setAttribute("position",new Bt(i,3)),this.setAttribute("uv",new Bt(r,2)),this.computeVertexNormals();function a(c){const u=[],l=n.curveSegments!==void 0?n.curveSegments:12,f=n.steps!==void 0?n.steps:1;let m=n.depth!==void 0?n.depth:100,h=n.bevelEnabled!==void 0?n.bevelEnabled:!0,p=n.bevelThickness!==void 0?n.bevelThickness:6,_=n.bevelSize!==void 0?n.bevelSize:p-2,v=n.bevelOffset!==void 0?n.bevelOffset:0,S=n.bevelSegments!==void 0?n.bevelSegments:3;const D=n.extrudePath,w=n.UVGenerator!==void 0?n.UVGenerator:HS;n.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),m=n.amount);let T,F=!1,E,A,L,I;D&&(T=D.getSpacedPoints(f),F=!0,h=!1,E=D.computeFrenetFrames(f,!1),A=new ye,L=new ye,I=new ye),h||(S=0,p=0,_=0,v=0);const R=c.extractPoints(l);let N=R.shape;const q=R.holes;if(!Zr.isClockWise(N)){N=N.reverse();for(let ae=0,U=q.length;ae<U;ae++){const Se=q[ae];Zr.isClockWise(Se)&&(q[ae]=Se.reverse())}}const Q=Zr.triangulateShape(N,q),W=N;for(let ae=0,U=q.length;ae<U;ae++){const Se=q[ae];N=N.concat(Se)}function te(ae,U,Se){return U||console.error("THREE.ExtrudeGeometry: vec does not exist"),U.clone().multiplyScalar(Se).add(ae)}const K=N.length,pe=Q.length;function be(ae,U,Se){let ze,Oe,Ye;const H=ae.x-U.x,Y=ae.y-U.y,$e=Se.x-ae.x,Ie=Se.y-ae.y,fe=H*H+Y*Y,Qe=H*Ie-Y*$e;if(Math.abs(Qe)>Number.EPSILON){const Ne=Math.sqrt(fe),ut=Math.sqrt($e*$e+Ie*Ie),de=U.x-Y/Ne,qe=U.y+H/Ne,tt=Se.x-Ie/ut,He=Se.y+$e/ut,je=((tt-de)*Ie-(He-qe)*$e)/(H*Ie-Y*$e);ze=de+H*je-ae.x,Oe=qe+Y*je-ae.y;const lt=ze*ze+Oe*Oe;if(lt<=2)return new vt(ze,Oe);Ye=Math.sqrt(lt/2)}else{let Ne=!1;H>Number.EPSILON?$e>Number.EPSILON&&(Ne=!0):H<-Number.EPSILON?$e<-Number.EPSILON&&(Ne=!0):Math.sign(Y)===Math.sign(Ie)&&(Ne=!0),Ne?(ze=-Y,Oe=H,Ye=Math.sqrt(fe)):(ze=H,Oe=Y,Ye=Math.sqrt(fe/2))}return new vt(ze/Ye,Oe/Ye)}const Ee=[];for(let ae=0,U=W.length,Se=U-1,ze=ae+1;ae<U;ae++,Se++,ze++)Se===U&&(Se=0),ze===U&&(ze=0),Ee[ae]=be(W[ae],W[Se],W[ze]);const Ge=[];let _e,De=Ee.concat();for(let ae=0,U=q.length;ae<U;ae++){const Se=q[ae];_e=[];for(let ze=0,Oe=Se.length,Ye=Oe-1,H=ze+1;ze<Oe;ze++,Ye++,H++)Ye===Oe&&(Ye=0),H===Oe&&(H=0),_e[ze]=be(Se[ze],Se[Ye],Se[H]);Ge.push(_e),De=De.concat(_e)}for(let ae=0;ae<S;ae++){const U=ae/S,Se=p*Math.cos(U*Math.PI/2),ze=_*Math.sin(U*Math.PI/2)+v;for(let Oe=0,Ye=W.length;Oe<Ye;Oe++){const H=te(W[Oe],Ee[Oe],ze);xe(H.x,H.y,-Se)}for(let Oe=0,Ye=q.length;Oe<Ye;Oe++){const H=q[Oe];_e=Ge[Oe];for(let Y=0,$e=H.length;Y<$e;Y++){const Ie=te(H[Y],_e[Y],ze);xe(Ie.x,Ie.y,-Se)}}}const he=_+v;for(let ae=0;ae<K;ae++){const U=h?te(N[ae],De[ae],he):N[ae];F?(L.copy(E.normals[0]).multiplyScalar(U.x),A.copy(E.binormals[0]).multiplyScalar(U.y),I.copy(T[0]).add(L).add(A),xe(I.x,I.y,I.z)):xe(U.x,U.y,0)}for(let ae=1;ae<=f;ae++)for(let U=0;U<K;U++){const Se=h?te(N[U],De[U],he):N[U];F?(L.copy(E.normals[ae]).multiplyScalar(Se.x),A.copy(E.binormals[ae]).multiplyScalar(Se.y),I.copy(T[ae]).add(L).add(A),xe(I.x,I.y,I.z)):xe(Se.x,Se.y,m/f*ae)}for(let ae=S-1;ae>=0;ae--){const U=ae/S,Se=p*Math.cos(U*Math.PI/2),ze=_*Math.sin(U*Math.PI/2)+v;for(let Oe=0,Ye=W.length;Oe<Ye;Oe++){const H=te(W[Oe],Ee[Oe],ze);xe(H.x,H.y,m+Se)}for(let Oe=0,Ye=q.length;Oe<Ye;Oe++){const H=q[Oe];_e=Ge[Oe];for(let Y=0,$e=H.length;Y<$e;Y++){const Ie=te(H[Y],_e[Y],ze);F?xe(Ie.x,Ie.y+T[f-1].y,T[f-1].x+Se):xe(Ie.x,Ie.y,m+Se)}}}Z(),me();function Z(){const ae=i.length/3;if(h){let U=0,Se=K*U;for(let ze=0;ze<pe;ze++){const Oe=Q[ze];et(Oe[2]+Se,Oe[1]+Se,Oe[0]+Se)}U=f+S*2,Se=K*U;for(let ze=0;ze<pe;ze++){const Oe=Q[ze];et(Oe[0]+Se,Oe[1]+Se,Oe[2]+Se)}}else{for(let U=0;U<pe;U++){const Se=Q[U];et(Se[2],Se[1],Se[0])}for(let U=0;U<pe;U++){const Se=Q[U];et(Se[0]+K*f,Se[1]+K*f,Se[2]+K*f)}}t.addGroup(ae,i.length/3-ae,0)}function me(){const ae=i.length/3;let U=0;we(W,U),U+=W.length;for(let Se=0,ze=q.length;Se<ze;Se++){const Oe=q[Se];we(Oe,U),U+=Oe.length}t.addGroup(ae,i.length/3-ae,1)}function we(ae,U){let Se=ae.length;for(;--Se>=0;){const ze=Se;let Oe=Se-1;Oe<0&&(Oe=ae.length-1);for(let Ye=0,H=f+S*2;Ye<H;Ye++){const Y=K*Ye,$e=K*(Ye+1),Ie=U+ze+Y,fe=U+Oe+Y,Qe=U+Oe+$e,Ne=U+ze+$e;Ve(Ie,fe,Qe,Ne)}}}function xe(ae,U,Se){u.push(ae),u.push(U),u.push(Se)}function et(ae,U,Se){nt(ae),nt(U),nt(Se);const ze=i.length/3,Oe=w.generateTopUV(t,i,ze-3,ze-2,ze-1);Be(Oe[0]),Be(Oe[1]),Be(Oe[2])}function Ve(ae,U,Se,ze){nt(ae),nt(U),nt(ze),nt(U),nt(Se),nt(ze);const Oe=i.length/3,Ye=w.generateSideWallUV(t,i,Oe-6,Oe-3,Oe-2,Oe-1);Be(Ye[0]),Be(Ye[1]),Be(Ye[3]),Be(Ye[1]),Be(Ye[2]),Be(Ye[3])}function nt(ae){i.push(u[ae*3+0]),i.push(u[ae*3+1]),i.push(u[ae*3+2])}function Be(ae){r.push(ae.x),r.push(ae.y)}}}Sr.prototype=Object.create(Ut.prototype),Sr.prototype.constructor=Sr,Sr.prototype.toJSON=function(){const e=Ut.prototype.toJSON.call(this),n=this.parameters.shapes,t=this.parameters.options;return Ex(n,t,e)};const HS={generateTopUV:function(e,n,t,i,r){const a=n[t*3],c=n[t*3+1],u=n[i*3],l=n[i*3+1],f=n[r*3],m=n[r*3+1];return[new vt(a,c),new vt(u,l),new vt(f,m)]},generateSideWallUV:function(e,n,t,i,r,a){const c=n[t*3],u=n[t*3+1],l=n[t*3+2],f=n[i*3],m=n[i*3+1],h=n[i*3+2],p=n[r*3],_=n[r*3+1],v=n[r*3+2],S=n[a*3],D=n[a*3+1],w=n[a*3+2];return Math.abs(u-m)<.01?[new vt(c,1-l),new vt(f,1-h),new vt(p,1-v),new vt(S,1-w)]:[new vt(u,1-l),new vt(m,1-h),new vt(_,1-v),new vt(D,1-w)]}};function Ex(e,n,t){if(t.shapes=[],Array.isArray(e))for(let i=0,r=e.length;i<r;i++){const a=e[i];t.shapes.push(a.uuid)}else t.shapes.push(e.uuid);return n.extrudePath!==void 0&&(t.options.extrudePath=n.extrudePath.toJSON()),t}function M_(e,n){on.call(this),this.type="TextGeometry",this.parameters={text:e,parameters:n},this.fromBufferGeometry(new vd(e,n)),this.mergeVertices()}M_.prototype=Object.create(on.prototype),M_.prototype.constructor=M_;function vd(e,n){n=n||{};const t=n.font;if(!(t&&t.isFont))return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new on;const i=t.generateShapes(e,n.size);n.depth=n.height!==void 0?n.height:50,n.bevelThickness===void 0&&(n.bevelThickness=10),n.bevelSize===void 0&&(n.bevelSize=8),n.bevelEnabled===void 0&&(n.bevelEnabled=!1),Sr.call(this,i,n),this.type="TextBufferGeometry"}vd.prototype=Object.create(Sr.prototype),vd.prototype.constructor=vd;function wd(e,n,t,i,r,a,c){on.call(this),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:n,heightSegments:t,phiStart:i,phiLength:r,thetaStart:a,thetaLength:c},this.fromBufferGeometry(new ll(e,n,t,i,r,a,c)),this.mergeVertices()}wd.prototype=Object.create(on.prototype),wd.prototype.constructor=wd;function ll(e,n,t,i,r,a,c){Ut.call(this),this.type="SphereBufferGeometry",this.parameters={radius:e,widthSegments:n,heightSegments:t,phiStart:i,phiLength:r,thetaStart:a,thetaLength:c},e=e||1,n=Math.max(3,Math.floor(n)||8),t=Math.max(2,Math.floor(t)||6),i=i!==void 0?i:0,r=r!==void 0?r:Math.PI*2,a=a!==void 0?a:0,c=c!==void 0?c:Math.PI;const u=Math.min(a+c,Math.PI);let l=0;const f=[],m=new ye,h=new ye,p=[],_=[],v=[],S=[];for(let D=0;D<=t;D++){const w=[],T=D/t;let F=0;D==0&&a==0?F=.5/n:D==t&&u==Math.PI&&(F=-.5/n);for(let E=0;E<=n;E++){const A=E/n;m.x=-e*Math.cos(i+A*r)*Math.sin(a+T*c),m.y=e*Math.cos(a+T*c),m.z=e*Math.sin(i+A*r)*Math.sin(a+T*c),_.push(m.x,m.y,m.z),h.copy(m).normalize(),v.push(h.x,h.y,h.z),S.push(A+F,1-T),w.push(l++)}f.push(w)}for(let D=0;D<t;D++)for(let w=0;w<n;w++){const T=f[D][w+1],F=f[D][w],E=f[D+1][w],A=f[D+1][w+1];(D!==0||a>0)&&p.push(T,F,A),(D!==t-1||u<Math.PI)&&p.push(F,E,A)}this.setIndex(p),this.setAttribute("position",new Bt(_,3)),this.setAttribute("normal",new Bt(v,3)),this.setAttribute("uv",new Bt(S,2))}ll.prototype=Object.create(Ut.prototype),ll.prototype.constructor=ll;function T_(e,n,t,i,r,a){on.call(this),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:n,thetaSegments:t,phiSegments:i,thetaStart:r,thetaLength:a},this.fromBufferGeometry(new xd(e,n,t,i,r,a)),this.mergeVertices()}T_.prototype=Object.create(on.prototype),T_.prototype.constructor=T_;function xd(e,n,t,i,r,a){Ut.call(this),this.type="RingBufferGeometry",this.parameters={innerRadius:e,outerRadius:n,thetaSegments:t,phiSegments:i,thetaStart:r,thetaLength:a},e=e||.5,n=n||1,r=r!==void 0?r:0,a=a!==void 0?a:Math.PI*2,t=t!==void 0?Math.max(3,t):8,i=i!==void 0?Math.max(1,i):1;const c=[],u=[],l=[],f=[];let m=e;const h=(n-e)/i,p=new ye,_=new vt;for(let v=0;v<=i;v++){for(let S=0;S<=t;S++){const D=r+S/t*a;p.x=m*Math.cos(D),p.y=m*Math.sin(D),u.push(p.x,p.y,p.z),l.push(0,0,1),_.x=(p.x/n+1)/2,_.y=(p.y/n+1)/2,f.push(_.x,_.y)}m+=h}for(let v=0;v<i;v++){const S=v*(t+1);for(let D=0;D<t;D++){const w=D+S,T=w,F=w+t+1,E=w+t+2,A=w+1;c.push(T,F,A),c.push(F,E,A)}}this.setIndex(c),this.setAttribute("position",new Bt(u,3)),this.setAttribute("normal",new Bt(l,3)),this.setAttribute("uv",new Bt(f,2))}xd.prototype=Object.create(Ut.prototype),xd.prototype.constructor=xd;function E_(e,n,t,i){on.call(this),this.type="LatheGeometry",this.parameters={points:e,segments:n,phiStart:t,phiLength:i},this.fromBufferGeometry(new bd(e,n,t,i)),this.mergeVertices()}E_.prototype=Object.create(on.prototype),E_.prototype.constructor=E_;function bd(e,n,t,i){Ut.call(this),this.type="LatheBufferGeometry",this.parameters={points:e,segments:n,phiStart:t,phiLength:i},n=Math.floor(n)||12,t=t||0,i=i||Math.PI*2,i=ln.clamp(i,0,Math.PI*2);const r=[],a=[],c=[],u=1/n,l=new ye,f=new vt;for(let m=0;m<=n;m++){const h=t+m*u*i,p=Math.sin(h),_=Math.cos(h);for(let v=0;v<=e.length-1;v++)l.x=e[v].x*p,l.y=e[v].y,l.z=e[v].x*_,a.push(l.x,l.y,l.z),f.x=m/n,f.y=v/(e.length-1),c.push(f.x,f.y)}for(let m=0;m<n;m++)for(let h=0;h<e.length-1;h++){const p=h+m*e.length,_=p,v=p+e.length,S=p+e.length+1,D=p+1;r.push(_,v,D),r.push(v,S,D)}if(this.setIndex(r),this.setAttribute("position",new Bt(a,3)),this.setAttribute("uv",new Bt(c,2)),this.computeVertexNormals(),i===Math.PI*2){const m=this.attributes.normal.array,h=new ye,p=new ye,_=new ye,v=n*e.length*3;for(let S=0,D=0;S<e.length;S++,D+=3)h.x=m[D+0],h.y=m[D+1],h.z=m[D+2],p.x=m[v+D+0],p.y=m[v+D+1],p.z=m[v+D+2],_.addVectors(h,p).normalize(),m[D+0]=m[v+D+0]=_.x,m[D+1]=m[v+D+1]=_.y,m[D+2]=m[v+D+2]=_.z}}bd.prototype=Object.create(Ut.prototype),bd.prototype.constructor=bd;function cl(e,n){on.call(this),this.type="ShapeGeometry",typeof n=="object"&&(console.warn("THREE.ShapeGeometry: Options parameter has been removed."),n=n.curveSegments),this.parameters={shapes:e,curveSegments:n},this.fromBufferGeometry(new ul(e,n)),this.mergeVertices()}cl.prototype=Object.create(on.prototype),cl.prototype.constructor=cl,cl.prototype.toJSON=function(){const e=on.prototype.toJSON.call(this),n=this.parameters.shapes;return Sx(n,e)};function ul(e,n){Ut.call(this),this.type="ShapeBufferGeometry",this.parameters={shapes:e,curveSegments:n},n=n||12;const t=[],i=[],r=[],a=[];let c=0,u=0;if(Array.isArray(e)===!1)l(e);else for(let f=0;f<e.length;f++)l(e[f]),this.addGroup(c,u,f),c+=u,u=0;this.setIndex(t),this.setAttribute("position",new Bt(i,3)),this.setAttribute("normal",new Bt(r,3)),this.setAttribute("uv",new Bt(a,2));function l(f){const m=i.length/3,h=f.extractPoints(n);let p=h.shape;const _=h.holes;Zr.isClockWise(p)===!1&&(p=p.reverse());for(let S=0,D=_.length;S<D;S++){const w=_[S];Zr.isClockWise(w)===!0&&(_[S]=w.reverse())}const v=Zr.triangulateShape(p,_);for(let S=0,D=_.length;S<D;S++){const w=_[S];p=p.concat(w)}for(let S=0,D=p.length;S<D;S++){const w=p[S];i.push(w.x,w.y,0),r.push(0,0,1),a.push(w.x,w.y)}for(let S=0,D=v.length;S<D;S++){const w=v[S],T=w[0]+m,F=w[1]+m,E=w[2]+m;t.push(T,F,E),u+=3}}}ul.prototype=Object.create(Ut.prototype),ul.prototype.constructor=ul,ul.prototype.toJSON=function(){const e=Ut.prototype.toJSON.call(this),n=this.parameters.shapes;return Sx(n,e)};function Sx(e,n){if(n.shapes=[],Array.isArray(e))for(let t=0,i=e.length;t<i;t++){const r=e[t];n.shapes.push(r.uuid)}else n.shapes.push(e.uuid);return n}function S_(e,n){Ut.call(this),this.type="EdgesGeometry",this.parameters={thresholdAngle:n},n=n!==void 0?n:1;const t=[],i=Math.cos(ln.DEG2RAD*n),r=[0,0],a={};let c,u,l;const f=["a","b","c"];let m;e.isBufferGeometry?(m=new on,m.fromBufferGeometry(e)):m=e.clone(),m.mergeVertices(),m.computeFaceNormals();const h=m.vertices,p=m.faces;for(let _=0,v=p.length;_<v;_++){const S=p[_];for(let D=0;D<3;D++)c=S[f[D]],u=S[f[(D+1)%3]],r[0]=Math.min(c,u),r[1]=Math.max(c,u),l=r[0]+","+r[1],a[l]===void 0?a[l]={index1:r[0],index2:r[1],face1:_,face2:void 0}:a[l].face2=_}for(l in a){const _=a[l];if(_.face2===void 0||p[_.face1].normal.dot(p[_.face2].normal)<=i){let v=h[_.index1];t.push(v.x,v.y,v.z),v=h[_.index2],t.push(v.x,v.y,v.z)}}this.setAttribute("position",new Bt(t,3))}S_.prototype=Object.create(Ut.prototype),S_.prototype.constructor=S_;function dl(e,n,t,i,r,a,c,u){on.call(this),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:n,height:t,radialSegments:i,heightSegments:r,openEnded:a,thetaStart:c,thetaLength:u},this.fromBufferGeometry(new eo(e,n,t,i,r,a,c,u)),this.mergeVertices()}dl.prototype=Object.create(on.prototype),dl.prototype.constructor=dl;function eo(e,n,t,i,r,a,c,u){Ut.call(this),this.type="CylinderBufferGeometry",this.parameters={radiusTop:e,radiusBottom:n,height:t,radialSegments:i,heightSegments:r,openEnded:a,thetaStart:c,thetaLength:u};const l=this;e=e!==void 0?e:1,n=n!==void 0?n:1,t=t||1,i=Math.floor(i)||8,r=Math.floor(r)||1,a=a!==void 0?a:!1,c=c!==void 0?c:0,u=u!==void 0?u:Math.PI*2;const f=[],m=[],h=[],p=[];let _=0;const v=[],S=t/2;let D=0;w(),a===!1&&(e>0&&T(!0),n>0&&T(!1)),this.setIndex(f),this.setAttribute("position",new Bt(m,3)),this.setAttribute("normal",new Bt(h,3)),this.setAttribute("uv",new Bt(p,2));function w(){const F=new ye,E=new ye;let A=0;const L=(n-e)/t;for(let I=0;I<=r;I++){const R=[],N=I/r,q=N*(n-e)+e;for(let ne=0;ne<=i;ne++){const Q=ne/i,W=Q*u+c,te=Math.sin(W),K=Math.cos(W);E.x=q*te,E.y=-N*t+S,E.z=q*K,m.push(E.x,E.y,E.z),F.set(te,L,K).normalize(),h.push(F.x,F.y,F.z),p.push(Q,1-N),R.push(_++)}v.push(R)}for(let I=0;I<i;I++)for(let R=0;R<r;R++){const N=v[R][I],q=v[R+1][I],ne=v[R+1][I+1],Q=v[R][I+1];f.push(N,q,Q),f.push(q,ne,Q),A+=6}l.addGroup(D,A,0),D+=A}function T(F){let E,A;const L=new vt,I=new ye;let R=0;const N=F===!0?e:n,q=F===!0?1:-1;E=_;for(let ne=1;ne<=i;ne++)m.push(0,S*q,0),h.push(0,q,0),p.push(.5,.5),_++;A=_;for(let ne=0;ne<=i;ne++){const W=ne/i*u+c,te=Math.cos(W),K=Math.sin(W);I.x=N*K,I.y=S*q,I.z=N*te,m.push(I.x,I.y,I.z),h.push(0,q,0),L.x=te*.5+.5,L.y=K*.5*q+.5,p.push(L.x,L.y),_++}for(let ne=0;ne<i;ne++){const Q=E+ne,W=A+ne;F===!0?f.push(W,W+1,Q):f.push(W+1,W,Q),R+=3}l.addGroup(D,R,F===!0?1:2),D+=R}}eo.prototype=Object.create(Ut.prototype),eo.prototype.constructor=eo;function P_(e,n,t,i,r,a,c){dl.call(this,0,e,n,t,i,r,a,c),this.type="ConeGeometry",this.parameters={radius:e,height:n,radialSegments:t,heightSegments:i,openEnded:r,thetaStart:a,thetaLength:c}}P_.prototype=Object.create(dl.prototype),P_.prototype.constructor=P_;function A_(e,n,t,i,r,a,c){eo.call(this,0,e,n,t,i,r,a,c),this.type="ConeBufferGeometry",this.parameters={radius:e,height:n,radialSegments:t,heightSegments:i,openEnded:r,thetaStart:a,thetaLength:c}}A_.prototype=Object.create(eo.prototype),A_.prototype.constructor=A_;function C_(e,n,t,i){on.call(this),this.type="CircleGeometry",this.parameters={radius:e,segments:n,thetaStart:t,thetaLength:i},this.fromBufferGeometry(new Md(e,n,t,i)),this.mergeVertices()}C_.prototype=Object.create(on.prototype),C_.prototype.constructor=C_;function Md(e,n,t,i){Ut.call(this),this.type="CircleBufferGeometry",this.parameters={radius:e,segments:n,thetaStart:t,thetaLength:i},e=e||1,n=n!==void 0?Math.max(3,n):8,t=t!==void 0?t:0,i=i!==void 0?i:Math.PI*2;const r=[],a=[],c=[],u=[],l=new ye,f=new vt;a.push(0,0,0),c.push(0,0,1),u.push(.5,.5);for(let m=0,h=3;m<=n;m++,h+=3){const p=t+m/n*i;l.x=e*Math.cos(p),l.y=e*Math.sin(p),a.push(l.x,l.y,l.z),c.push(0,0,1),f.x=(a[h]/e+1)/2,f.y=(a[h+1]/e+1)/2,u.push(f.x,f.y)}for(let m=1;m<=n;m++)r.push(m,m+1,0);this.setIndex(r),this.setAttribute("position",new Bt(a,3)),this.setAttribute("normal",new Bt(c,3)),this.setAttribute("uv",new Bt(u,2))}Md.prototype=Object.create(Ut.prototype),Md.prototype.constructor=Md;var Fi=Object.freeze({__proto__:null,WireframeGeometry:u_,ParametricGeometry:d_,ParametricBufferGeometry:ud,TetrahedronGeometry:f_,TetrahedronBufferGeometry:dd,OctahedronGeometry:p_,OctahedronBufferGeometry:sl,IcosahedronGeometry:m_,IcosahedronBufferGeometry:hd,DodecahedronGeometry:g_,DodecahedronBufferGeometry:fd,PolyhedronGeometry:h_,PolyhedronBufferGeometry:ts,TubeGeometry:__,TubeBufferGeometry:rl,TorusKnotGeometry:y_,TorusKnotBufferGeometry:pd,TorusGeometry:v_,TorusBufferGeometry:md,TextGeometry:M_,TextBufferGeometry:vd,SphereGeometry:wd,SphereBufferGeometry:ll,RingGeometry:T_,RingBufferGeometry:xd,PlaneGeometry:Xg,PlaneBufferGeometry:Qa,LatheGeometry:E_,LatheBufferGeometry:bd,ShapeGeometry:cl,ShapeBufferGeometry:ul,ExtrudeGeometry:al,ExtrudeBufferGeometry:Sr,EdgesGeometry:S_,ConeGeometry:P_,ConeBufferGeometry:A_,CylinderGeometry:dl,CylinderBufferGeometry:eo,CircleGeometry:C_,CircleBufferGeometry:Md,BoxGeometry:A1,BoxBufferGeometry:qg});function hl(e){rn.call(this),this.type="ShadowMaterial",this.color=new jt(0),this.transparent=!0,this.setValues(e)}hl.prototype=Object.create(rn.prototype),hl.prototype.constructor=hl,hl.prototype.isShadowMaterial=!0,hl.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.color.copy(e.color),this};function to(e){Gi.call(this,e),this.type="RawShaderMaterial"}to.prototype=Object.create(Gi.prototype),to.prototype.constructor=to,to.prototype.isRawShaderMaterial=!0;function Ds(e){rn.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new jt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new jt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Da,this.normalScale=new vt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(e)}Ds.prototype=Object.create(rn.prototype),Ds.prototype.constructor=Ds,Ds.prototype.isMeshStandardMaterial=!0,Ds.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.vertexTangents=e.vertexTangents,this};function Do(e){Ds.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new vt(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(e)}Do.prototype=Object.create(Ds.prototype),Do.prototype.constructor=Do,Do.prototype.isMeshPhysicalMaterial=!0,Do.prototype.copy=function(e){return Ds.prototype.copy.call(this,e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.reflectivity=e.reflectivity,e.sheen?this.sheen=(this.sheen||new jt).copy(e.sheen):this.sheen=null,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this};function ko(e){rn.call(this),this.type="MeshPhongMaterial",this.color=new jt(16777215),this.specular=new jt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new jt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Da,this.normalScale=new vt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=yg,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}ko.prototype=Object.create(rn.prototype),ko.prototype.constructor=ko,ko.prototype.isMeshPhongMaterial=!0,ko.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this};function fl(e){rn.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new jt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new jt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Da,this.normalScale=new vt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}fl.prototype=Object.create(rn.prototype),fl.prototype.constructor=fl,fl.prototype.isMeshToonMaterial=!0,fl.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this};function pl(e){rn.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Da,this.normalScale=new vt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}pl.prototype=Object.create(rn.prototype),pl.prototype.constructor=pl,pl.prototype.isMeshNormalMaterial=!0,pl.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this};function ml(e){rn.call(this),this.type="MeshLambertMaterial",this.color=new jt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new jt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=yg,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}ml.prototype=Object.create(rn.prototype),ml.prototype.constructor=ml,ml.prototype.isMeshLambertMaterial=!0,ml.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this};function gl(e){rn.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new jt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Da,this.normalScale=new vt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}gl.prototype=Object.create(rn.prototype),gl.prototype.constructor=gl,gl.prototype.isMeshMatcapMaterial=!0,gl.prototype.copy=function(e){return rn.prototype.copy.call(this,e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this};function _l(e){Yn.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}_l.prototype=Object.create(Yn.prototype),_l.prototype.constructor=_l,_l.prototype.isLineDashedMaterial=!0,_l.prototype.copy=function(e){return Yn.prototype.copy.call(this,e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this};var qS=Object.freeze({__proto__:null,ShadowMaterial:hl,SpriteMaterial:Lo,RawShaderMaterial:to,ShaderMaterial:Gi,PointsMaterial:Jr,MeshPhysicalMaterial:Do,MeshStandardMaterial:Ds,MeshPhongMaterial:ko,MeshToonMaterial:fl,MeshNormalMaterial:pl,MeshLambertMaterial:ml,MeshDepthMaterial:Po,MeshDistanceMaterial:Ao,MeshBasicMaterial:ms,MeshMatcapMaterial:gl,LineDashedMaterial:_l,LineBasicMaterial:Yn,Material:rn});const Vn={arraySlice:function(e,n,t){return Vn.isTypedArray(e)?new e.constructor(e.subarray(n,t!==void 0?t:e.length)):e.slice(n,t)},convertArray:function(e,n,t){return!e||!t&&e.constructor===n?e:typeof n.BYTES_PER_ELEMENT=="number"?new n(e):Array.prototype.slice.call(e)},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},getKeyframeOrder:function(e){function n(r,a){return e[r]-e[a]}const t=e.length,i=new Array(t);for(let r=0;r!==t;++r)i[r]=r;return i.sort(n),i},sortedArray:function(e,n,t){const i=e.length,r=new e.constructor(i);for(let a=0,c=0;c!==i;++a){const u=t[a]*n;for(let l=0;l!==n;++l)r[c++]=e[u+l]}return r},flattenJSON:function(e,n,t,i){let r=1,a=e[0];for(;a!==void 0&&a[i]===void 0;)a=e[r++];if(a===void 0)return;let c=a[i];if(c!==void 0)if(Array.isArray(c))do c=a[i],c!==void 0&&(n.push(a.time),t.push.apply(t,c)),a=e[r++];while(a!==void 0);else if(c.toArray!==void 0)do c=a[i],c!==void 0&&(n.push(a.time),c.toArray(t,t.length)),a=e[r++];while(a!==void 0);else do c=a[i],c!==void 0&&(n.push(a.time),t.push(c)),a=e[r++];while(a!==void 0)},subclip:function(e,n,t,i,r){r=r||30;const a=e.clone();a.name=n;const c=[];for(let l=0;l<a.tracks.length;++l){const f=a.tracks[l],m=f.getValueSize(),h=[],p=[];for(let _=0;_<f.times.length;++_){const v=f.times[_]*r;if(!(v<t||v>=i)){h.push(f.times[_]);for(let S=0;S<m;++S)p.push(f.values[_*m+S])}}h.length!==0&&(f.times=Vn.convertArray(h,f.times.constructor),f.values=Vn.convertArray(p,f.values.constructor),c.push(f))}a.tracks=c;let u=1/0;for(let l=0;l<a.tracks.length;++l)u>a.tracks[l].times[0]&&(u=a.tracks[l].times[0]);for(let l=0;l<a.tracks.length;++l)a.tracks[l].shift(-1*u);return a.resetDuration(),a},makeClipAdditive:function(e,n,t,i){n===void 0&&(n=0),t===void 0&&(t=e),(i===void 0||i<=0)&&(i=30);const r=e.tracks.length,a=n/i;for(let c=0;c<r;++c){const u=t.tracks[c],l=u.ValueTypeName;if(l==="bool"||l==="string")continue;const f=e.tracks.find(function(v){return v.name===u.name&&v.ValueTypeName===l});if(f===void 0)continue;const m=u.getValueSize(),h=u.times.length-1;let p;if(a<=u.times[0])p=Vn.arraySlice(u.values,0,u.valueSize);else if(a>=u.times[h]){const v=h*m;p=Vn.arraySlice(u.values,v)}else{const v=u.createInterpolant();v.evaluate(a),p=v.resultBuffer}l==="quaternion"&&new pi(p[0],p[1],p[2],p[3]).normalize().conjugate().toArray(p);const _=f.times.length;for(let v=0;v<_;++v){const S=v*m;if(l==="quaternion")pi.multiplyQuaternionsFlat(f.values,S,p,0,f.values,S);else for(let D=0;D<m;++D)f.values[S+D]-=p[D]}}return e.blendMode=_w,e}};function vs(e,n,t,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new n.constructor(t),this.sampleValues=n,this.valueSize=t}Object.assign(vs.prototype,{evaluate:function(e){let n=this.parameterPositions,t=this._cachedIndex,i=n[t],r=n[t-1];e:{t:{let a;n:{i:if(!(e<i)){for(let c=t+2;;){if(i===void 0){if(e<r)break i;return t=n.length,this._cachedIndex=t,this.afterEnd_(t-1,e,r)}if(t===c)break;if(r=i,i=n[++t],e<i)break t}a=n.length;break n}if(!(e>=r)){const c=n[1];e<c&&(t=2,r=c);for(let u=t-2;;){if(r===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(t===u)break;if(i=r,r=n[--t-1],e>=r)break t}a=t,t=0;break n}break e}for(;t<a;){const c=t+a>>>1;e<n[c]?a=c:t=c+1}if(i=n[t],r=n[t-1],r===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(i===void 0)return t=n.length,this._cachedIndex=t,this.afterEnd_(t-1,r,e)}this._cachedIndex=t,this.intervalChanged_(t,r,i)}return this.interpolate_(t,r,e,i)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(e){const n=this.resultBuffer,t=this.sampleValues,i=this.valueSize,r=e*i;for(let a=0;a!==i;++a)n[a]=t[r+a];return n},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}}),Object.assign(vs.prototype,{beforeStart_:vs.prototype.copySampleValue_,afterEnd_:vs.prototype.copySampleValue_});function Hv(e,n,t,i){vs.call(this,e,n,t,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}Hv.prototype=Object.assign(Object.create(vs.prototype),{constructor:Hv,DefaultSettings_:{endingStart:Ia,endingEnd:Ia},intervalChanged_:function(e,n,t){let i=this.parameterPositions,r=e-2,a=e+1,c=i[r],u=i[a];if(c===void 0)switch(this.getSettings_().endingStart){case La:r=e,c=2*n-t;break;case Ag:r=i.length-2,c=n+i[r]-i[r+1];break;default:r=e,c=t}if(u===void 0)switch(this.getSettings_().endingEnd){case La:a=e,u=2*t-n;break;case Ag:a=1,u=t+i[1]-i[0];break;default:a=e-1,u=n}const l=(t-n)*.5,f=this.valueSize;this._weightPrev=l/(n-c),this._weightNext=l/(u-t),this._offsetPrev=r*f,this._offsetNext=a*f},interpolate_:function(e,n,t,i){const r=this.resultBuffer,a=this.sampleValues,c=this.valueSize,u=e*c,l=u-c,f=this._offsetPrev,m=this._offsetNext,h=this._weightPrev,p=this._weightNext,_=(t-n)/(i-n),v=_*_,S=v*_,D=-h*S+2*h*v-h*_,w=(1+h)*S+(-1.5-2*h)*v+(-.5+h)*_+1,T=(-1-p)*S+(1.5+p)*v+.5*_,F=p*S-p*v;for(let E=0;E!==c;++E)r[E]=D*a[f+E]+w*a[l+E]+T*a[u+E]+F*a[m+E];return r}});function I_(e,n,t,i){vs.call(this,e,n,t,i)}I_.prototype=Object.assign(Object.create(vs.prototype),{constructor:I_,interpolate_:function(e,n,t,i){const r=this.resultBuffer,a=this.sampleValues,c=this.valueSize,u=e*c,l=u-c,f=(t-n)/(i-n),m=1-f;for(let h=0;h!==c;++h)r[h]=a[l+h]*m+a[u+h]*f;return r}});function qv(e,n,t,i){vs.call(this,e,n,t,i)}qv.prototype=Object.assign(Object.create(vs.prototype),{constructor:qv,interpolate_:function(e){return this.copySampleValue_(e-1)}});function Ci(e,n,t,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(n===void 0||n.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Vn.convertArray(n,this.TimeBufferType),this.values=Vn.convertArray(t,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}Object.assign(Ci,{toJSON:function(e){const n=e.constructor;let t;if(n.toJSON!==void 0)t=n.toJSON(e);else{t={name:e.name,times:Vn.convertArray(e.times,Array),values:Vn.convertArray(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(t.interpolation=i)}return t.type=e.ValueTypeName,t}}),Object.assign(Ci.prototype,{constructor:Ci,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:Pg,InterpolantFactoryMethodDiscrete:function(e){return new qv(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodLinear:function(e){return new I_(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:function(e){return new Hv(this.times,this.values,this.getValueSize(),e)},setInterpolation:function(e){let n;switch(e){case Sg:n=this.InterpolantFactoryMethodDiscrete;break;case Pg:n=this.InterpolantFactoryMethodLinear;break;case Zy:n=this.InterpolantFactoryMethodSmooth;break}if(n===void 0){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(t);return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=n,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Sg;case this.InterpolantFactoryMethodLinear:return Pg;case this.InterpolantFactoryMethodSmooth:return Zy}},getValueSize:function(){return this.values.length/this.times.length},shift:function(e){if(e!==0){const n=this.times;for(let t=0,i=n.length;t!==i;++t)n[t]+=e}return this},scale:function(e){if(e!==1){const n=this.times;for(let t=0,i=n.length;t!==i;++t)n[t]*=e}return this},trim:function(e,n){const t=this.times,i=t.length;let r=0,a=i-1;for(;r!==i&&t[r]<e;)++r;for(;a!==-1&&t[a]>n;)--a;if(++a,r!==0||a!==i){r>=a&&(a=Math.max(a,1),r=a-1);const c=this.getValueSize();this.times=Vn.arraySlice(t,r,a),this.values=Vn.arraySlice(this.values,r*c,a*c)}return this},validate:function(){let e=!0;const n=this.getValueSize();n-Math.floor(n)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const t=this.times,i=this.values,r=t.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let c=0;c!==r;c++){const u=t[c];if(typeof u=="number"&&isNaN(u)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,c,u),e=!1;break}if(a!==null&&a>u){console.error("THREE.KeyframeTrack: Out of order keys.",this,c,u,a),e=!1;break}a=u}if(i!==void 0&&Vn.isTypedArray(i))for(let c=0,u=i.length;c!==u;++c){const l=i[c];if(isNaN(l)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,c,l),e=!1;break}}return e},optimize:function(){const e=Vn.arraySlice(this.times),n=Vn.arraySlice(this.values),t=this.getValueSize(),i=this.getInterpolation()===Zy,r=e.length-1;let a=1;for(let c=1;c<r;++c){let u=!1;const l=e[c],f=e[c+1];if(l!==f&&(c!==1||l!==l[0]))if(i)u=!0;else{const m=c*t,h=m-t,p=m+t;for(let _=0;_!==t;++_){const v=n[m+_];if(v!==n[h+_]||v!==n[p+_]){u=!0;break}}}if(u){if(c!==a){e[a]=e[c];const m=c*t,h=a*t;for(let p=0;p!==t;++p)n[h+p]=n[m+p]}++a}}if(r>0){e[a]=e[r];for(let c=r*t,u=a*t,l=0;l!==t;++l)n[u+l]=n[c+l];++a}return a!==e.length?(this.times=Vn.arraySlice(e,0,a),this.values=Vn.arraySlice(n,0,a*t)):(this.times=e,this.values=n),this},clone:function(){const e=Vn.arraySlice(this.times,0),n=Vn.arraySlice(this.values,0),t=this.constructor,i=new t(this.name,e,n);return i.createInterpolant=this.createInterpolant,i}});function Kv(e,n,t){Ci.call(this,e,n,t)}Kv.prototype=Object.assign(Object.create(Ci.prototype),{constructor:Kv,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:Sg,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function Xv(e,n,t,i){Ci.call(this,e,n,t,i)}Xv.prototype=Object.assign(Object.create(Ci.prototype),{constructor:Xv,ValueTypeName:"color"});function Td(e,n,t,i){Ci.call(this,e,n,t,i)}Td.prototype=Object.assign(Object.create(Ci.prototype),{constructor:Td,ValueTypeName:"number"});function Yv(e,n,t,i){vs.call(this,e,n,t,i)}Yv.prototype=Object.assign(Object.create(vs.prototype),{constructor:Yv,interpolate_:function(e,n,t,i){const r=this.resultBuffer,a=this.sampleValues,c=this.valueSize,u=(t-n)/(i-n);let l=e*c;for(let f=l+c;l!==f;l+=4)pi.slerpFlat(r,0,a,l-c,a,l,u);return r}});function L_(e,n,t,i){Ci.call(this,e,n,t,i)}L_.prototype=Object.assign(Object.create(Ci.prototype),{constructor:L_,ValueTypeName:"quaternion",DefaultInterpolation:Pg,InterpolantFactoryMethodLinear:function(e){return new Yv(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:void 0});function Jv(e,n,t,i){Ci.call(this,e,n,t,i)}Jv.prototype=Object.assign(Object.create(Ci.prototype),{constructor:Jv,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:Sg,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function Ed(e,n,t,i){Ci.call(this,e,n,t,i)}Ed.prototype=Object.assign(Object.create(Ci.prototype),{constructor:Ed,ValueTypeName:"vector"});function ks(e,n,t,i){this.name=e,this.tracks=t,this.duration=n!==void 0?n:-1,this.blendMode=i!==void 0?i:ev,this.uuid=ln.generateUUID(),this.duration<0&&this.resetDuration()}function KS(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Td;case"vector":case"vector2":case"vector3":case"vector4":return Ed;case"color":return Xv;case"quaternion":return L_;case"bool":case"boolean":return Kv;case"string":return Jv}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}function XS(e){if(e.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const n=KS(e.type);if(e.times===void 0){const t=[],i=[];Vn.flattenJSON(e.keys,t,i,"value"),e.times=t,e.values=i}return n.parse!==void 0?n.parse(e):new n(e.name,e.times,e.values,e.interpolation)}Object.assign(ks,{parse:function(e){const n=[],t=e.tracks,i=1/(e.fps||1);for(let r=0,a=t.length;r!==a;++r)n.push(XS(t[r]).scale(i));return new ks(e.name,e.duration,n,e.blendMode)},toJSON:function(e){const n=[],t=e.tracks,i={name:e.name,duration:e.duration,tracks:n,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,a=t.length;r!==a;++r)n.push(Ci.toJSON(t[r]));return i},CreateFromMorphTargetSequence:function(e,n,t,i){const r=n.length,a=[];for(let c=0;c<r;c++){let u=[],l=[];u.push((c+r-1)%r,c,(c+1)%r),l.push(0,1,0);const f=Vn.getKeyframeOrder(u);u=Vn.sortedArray(u,1,f),l=Vn.sortedArray(l,1,f),!i&&u[0]===0&&(u.push(r),l.push(l[0])),a.push(new Td(".morphTargetInfluences["+n[c].name+"]",u,l).scale(1/t))}return new ks(e,-1,a)},findByName:function(e,n){let t=e;if(!Array.isArray(e)){const i=e;t=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<t.length;i++)if(t[i].name===n)return t[i];return null},CreateClipsFromMorphTargetSequences:function(e,n,t){const i={},r=/^([\w-]*?)([\d]+)$/;for(let c=0,u=e.length;c<u;c++){const l=e[c],f=l.name.match(r);if(f&&f.length>1){const m=f[1];let h=i[m];h||(i[m]=h=[]),h.push(l)}}const a=[];for(const c in i)a.push(ks.CreateFromMorphTargetSequence(c,i[c],n,t));return a},parseAnimation:function(e,n){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const t=function(m,h,p,_,v){if(p.length!==0){const S=[],D=[];Vn.flattenJSON(p,S,D,_),S.length!==0&&v.push(new m(h,S,D))}},i=[],r=e.name||"default",a=e.fps||30,c=e.blendMode;let u=e.length||-1;const l=e.hierarchy||[];for(let m=0;m<l.length;m++){const h=l[m].keys;if(!(!h||h.length===0))if(h[0].morphTargets){const p={};let _;for(_=0;_<h.length;_++)if(h[_].morphTargets)for(let v=0;v<h[_].morphTargets.length;v++)p[h[_].morphTargets[v]]=-1;for(const v in p){const S=[],D=[];for(let w=0;w!==h[_].morphTargets.length;++w){const T=h[_];S.push(T.time),D.push(T.morphTarget===v?1:0)}i.push(new Td(".morphTargetInfluence["+v+"]",S,D))}u=p.length*(a||1)}else{const p=".bones["+n[m].name+"]";t(Ed,p+".position",h,"pos",i),t(L_,p+".quaternion",h,"rot",i),t(Ed,p+".scale",h,"scl",i)}}return i.length===0?null:new ks(r,u,i,c)}}),Object.assign(ks.prototype,{resetDuration:function(){const e=this.tracks;let n=0;for(let t=0,i=e.length;t!==i;++t){const r=this.tracks[t];n=Math.max(n,r.times[r.times.length-1])}return this.duration=n,this},trim:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this},validate:function(){let e=!0;for(let n=0;n<this.tracks.length;n++)e=e&&this.tracks[n].validate();return e},optimize:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this},clone:function(){const e=[];for(let n=0;n<this.tracks.length;n++)e.push(this.tracks[n].clone());return new ks(this.name,this.duration,e,this.blendMode)}});const Qs={enabled:!1,files:{},add:function(e,n){this.enabled!==!1&&(this.files[e]=n)},get:function(e){if(this.enabled!==!1)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};function Px(e,n,t){const i=this;let r=!1,a=0,c=0,u;const l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=n,this.onError=t,this.itemStart=function(f){c++,r===!1&&i.onStart!==void 0&&i.onStart(f,a,c),r=!0},this.itemEnd=function(f){a++,i.onProgress!==void 0&&i.onProgress(f,a,c),a===c&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(f){i.onError!==void 0&&i.onError(f)},this.resolveURL=function(f){return u?u(f):f},this.setURLModifier=function(f){return u=f,this},this.addHandler=function(f,m){return l.push(f,m),this},this.removeHandler=function(f){const m=l.indexOf(f);return m!==-1&&l.splice(m,2),this},this.getHandler=function(f){for(let m=0,h=l.length;m<h;m+=2){const p=l[m],_=l[m+1];if(p.global&&(p.lastIndex=0),p.test(f))return _}return null}}const YS=new Px;function bn(e){this.manager=e!==void 0?e:YS,this.crossOrigin="anonymous",this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(bn.prototype,{load:function(){},loadAsync:function(e,n){const t=this;return new Promise(function(i,r){t.load(e,i,n,r)})},parse:function(){},setCrossOrigin:function(e){return this.crossOrigin=e,this},setPath:function(e){return this.path=e,this},setResourcePath:function(e){return this.resourcePath=e,this},setRequestHeader:function(e){return this.requestHeader=e,this}});const Os={};function Fs(e){bn.call(this,e)}Fs.prototype=Object.assign(Object.create(bn.prototype),{constructor:Fs,load:function(e,n,t,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=Qs.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){n&&n(a),r.manager.itemEnd(e)},0),a;if(Os[e]!==void 0){Os[e].push({onLoad:n,onProgress:t,onError:i});return}const c=/^data:(.*?)(;base64)?,(.*)$/,u=e.match(c);let l;if(u){const f=u[1],m=!!u[2];let h=u[3];h=decodeURIComponent(h),m&&(h=atob(h));try{let p;const _=(this.responseType||"").toLowerCase();switch(_){case"arraybuffer":case"blob":const v=new Uint8Array(h.length);for(let D=0;D<h.length;D++)v[D]=h.charCodeAt(D);_==="blob"?p=new Blob([v.buffer],{type:f}):p=v.buffer;break;case"document":p=new DOMParser().parseFromString(h,f);break;case"json":p=JSON.parse(h);break;default:p=h;break}setTimeout(function(){n&&n(p),r.manager.itemEnd(e)},0)}catch(p){setTimeout(function(){i&&i(p),r.manager.itemError(e),r.manager.itemEnd(e)},0)}}else{Os[e]=[],Os[e].push({onLoad:n,onProgress:t,onError:i}),l=new XMLHttpRequest,l.open("GET",e,!0),l.addEventListener("load",function(f){const m=this.response,h=Os[e];if(delete Os[e],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Qs.add(e,m);for(let p=0,_=h.length;p<_;p++){const v=h[p];v.onLoad&&v.onLoad(m)}r.manager.itemEnd(e)}else{for(let p=0,_=h.length;p<_;p++){const v=h[p];v.onError&&v.onError(f)}r.manager.itemError(e),r.manager.itemEnd(e)}},!1),l.addEventListener("progress",function(f){const m=Os[e];for(let h=0,p=m.length;h<p;h++){const _=m[h];_.onProgress&&_.onProgress(f)}},!1),l.addEventListener("error",function(f){const m=Os[e];delete Os[e];for(let h=0,p=m.length;h<p;h++){const _=m[h];_.onError&&_.onError(f)}r.manager.itemError(e),r.manager.itemEnd(e)},!1),l.addEventListener("abort",function(f){const m=Os[e];delete Os[e];for(let h=0,p=m.length;h<p;h++){const _=m[h];_.onError&&_.onError(f)}r.manager.itemError(e),r.manager.itemEnd(e)},!1),this.responseType!==void 0&&(l.responseType=this.responseType),this.withCredentials!==void 0&&(l.withCredentials=this.withCredentials),l.overrideMimeType&&l.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const f in this.requestHeader)l.setRequestHeader(f,this.requestHeader[f]);l.send(null)}return r.manager.itemStart(e),l},setResponseType:function(e){return this.responseType=e,this},setWithCredentials:function(e){return this.withCredentials=e,this},setMimeType:function(e){return this.mimeType=e,this}});function Ax(e){bn.call(this,e)}Ax.prototype=Object.assign(Object.create(bn.prototype),{constructor:Ax,load:function(e,n,t,i){const r=this,a=new Fs(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.load(e,function(c){try{n(r.parse(JSON.parse(c)))}catch(u){i?i(u):console.error(u),r.manager.itemError(e)}},t,i)},parse:function(e){const n=[];for(let t=0;t<e.length;t++){const i=ks.parse(e[t]);n.push(i)}return n}});function Cx(e){bn.call(this,e)}Cx.prototype=Object.assign(Object.create(bn.prototype),{constructor:Cx,load:function(e,n,t,i){const r=this,a=[],c=new ld;c.image=a;const u=new Fs(this.manager);u.setPath(this.path),u.setResponseType("arraybuffer"),u.setRequestHeader(this.requestHeader);let l=0;function f(m){u.load(e[m],function(h){const p=r.parse(h,!0);a[m]={width:p.width,height:p.height,format:p.format,mipmaps:p.mipmaps},l+=1,l===6&&(p.mipmapCount===1&&(c.minFilter=Pi),c.format=p.format,c.needsUpdate=!0,n&&n(c))},t,i)}if(Array.isArray(e))for(let m=0,h=e.length;m<h;++m)f(m);else u.load(e,function(m){const h=r.parse(m,!0);if(h.isCubemap){const p=h.mipmaps.length/h.mipmapCount;for(let _=0;_<p;_++){a[_]={mipmaps:[]};for(let v=0;v<h.mipmapCount;v++)a[_].mipmaps.push(h.mipmaps[_*h.mipmapCount+v]),a[_].format=h.format,a[_].width=h.width,a[_].height=h.height}}else c.image.width=h.width,c.image.height=h.height,c.mipmaps=h.mipmaps;h.mipmapCount===1&&(c.minFilter=Pi),c.format=h.format,c.needsUpdate=!0,n&&n(c)},t,i);return c}});function Ix(e){bn.call(this,e)}Ix.prototype=Object.assign(Object.create(bn.prototype),{constructor:Ix,load:function(e,n,t,i){const r=this,a=new Ya,c=new Fs(this.manager);return c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setPath(this.path),c.load(e,function(u){const l=r.parse(u);l&&(l.image!==void 0?a.image=l.image:l.data!==void 0&&(a.image.width=l.width,a.image.height=l.height,a.image.data=l.data),a.wrapS=l.wrapS!==void 0?l.wrapS:Ni,a.wrapT=l.wrapT!==void 0?l.wrapT:Ni,a.magFilter=l.magFilter!==void 0?l.magFilter:Pi,a.minFilter=l.minFilter!==void 0?l.minFilter:Pi,a.anisotropy=l.anisotropy!==void 0?l.anisotropy:1,l.format!==void 0&&(a.format=l.format),l.type!==void 0&&(a.type=l.type),l.mipmaps!==void 0&&(a.mipmaps=l.mipmaps,a.minFilter=bg),l.mipmapCount===1&&(a.minFilter=Pi),a.needsUpdate=!0,n&&n(a,l))},t,i),a}});function Sd(e){bn.call(this,e)}Sd.prototype=Object.assign(Object.create(bn.prototype),{constructor:Sd,load:function(e,n,t,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=Qs.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){n&&n(a),r.manager.itemEnd(e)},0),a;const c=document.createElementNS("http://www.w3.org/1999/xhtml","img");function u(){c.removeEventListener("load",u,!1),c.removeEventListener("error",l,!1),Qs.add(e,this),n&&n(this),r.manager.itemEnd(e)}function l(f){c.removeEventListener("load",u,!1),c.removeEventListener("error",l,!1),i&&i(f),r.manager.itemError(e),r.manager.itemEnd(e)}return c.addEventListener("load",u,!1),c.addEventListener("error",l,!1),e.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(c.crossOrigin=this.crossOrigin),r.manager.itemStart(e),c.src=e,c}});function Qv(e){bn.call(this,e)}Qv.prototype=Object.assign(Object.create(bn.prototype),{constructor:Qv,load:function(e,n,t,i){const r=new Kr,a=new Sd(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let c=0;function u(l){a.load(e[l],function(f){r.images[l]=f,c++,c===6&&(r.needsUpdate=!0,n&&n(r))},void 0,i)}for(let l=0;l<e.length;++l)u(l);return r}});function D_(e){bn.call(this,e)}D_.prototype=Object.assign(Object.create(bn.prototype),{constructor:D_,load:function(e,n,t,i){const r=new Dn,a=new Sd(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,function(c){r.image=c;const u=e.search(/\.jpe?g($|\?)/i)>0||e.search(/^data\:image\/jpeg/)===0;r.format=u?bo:fs,r.needsUpdate=!0,n!==void 0&&n(r)},t,i),r}});function Qt(){this.type="Curve",this.arcLengthDivisions=200}Object.assign(Qt.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(e,n){const t=this.getUtoTmapping(e);return this.getPoint(t,n)},getPoints:function(e){e===void 0&&(e=5);const n=[];for(let t=0;t<=e;t++)n.push(this.getPoint(t/e));return n},getSpacedPoints:function(e){e===void 0&&(e=5);const n=[];for(let t=0;t<=e;t++)n.push(this.getPointAt(t/e));return n},getLength:function(){const e=this.getLengths();return e[e.length-1]},getLengths:function(e){if(e===void 0&&(e=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const n=[];let t,i=this.getPoint(0),r=0;n.push(0);for(let a=1;a<=e;a++)t=this.getPoint(a/e),r+=t.distanceTo(i),n.push(r),i=t;return this.cacheArcLengths=n,n},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(e,n){const t=this.getLengths();let i=0,r=t.length,a;n?a=n:a=e*t[r-1];let c=0,u=r-1,l;for(;c<=u;)if(i=Math.floor(c+(u-c)/2),l=t[i]-a,l<0)c=i+1;else if(l>0)u=i-1;else{u=i;break}if(i=u,t[i]===a)return i/(r-1);const f=t[i],h=t[i+1]-f,p=(a-f)/h;return(i+p)/(r-1)},getTangent:function(e,n){let i=e-1e-4,r=e+1e-4;i<0&&(i=0),r>1&&(r=1);const a=this.getPoint(i),c=this.getPoint(r),u=n||(a.isVector2?new vt:new ye);return u.copy(c).sub(a).normalize(),u},getTangentAt:function(e,n){const t=this.getUtoTmapping(e);return this.getTangent(t,n)},computeFrenetFrames:function(e,n){const t=new ye,i=[],r=[],a=[],c=new ye,u=new dn;for(let p=0;p<=e;p++){const _=p/e;i[p]=this.getTangentAt(_,new ye),i[p].normalize()}r[0]=new ye,a[0]=new ye;let l=Number.MAX_VALUE;const f=Math.abs(i[0].x),m=Math.abs(i[0].y),h=Math.abs(i[0].z);f<=l&&(l=f,t.set(1,0,0)),m<=l&&(l=m,t.set(0,1,0)),h<=l&&t.set(0,0,1),c.crossVectors(i[0],t).normalize(),r[0].crossVectors(i[0],c),a[0].crossVectors(i[0],r[0]);for(let p=1;p<=e;p++){if(r[p]=r[p-1].clone(),a[p]=a[p-1].clone(),c.crossVectors(i[p-1],i[p]),c.length()>Number.EPSILON){c.normalize();const _=Math.acos(ln.clamp(i[p-1].dot(i[p]),-1,1));r[p].applyMatrix4(u.makeRotationAxis(c,_))}a[p].crossVectors(i[p],r[p])}if(n===!0){let p=Math.acos(ln.clamp(r[0].dot(r[e]),-1,1));p/=e,i[0].dot(c.crossVectors(r[0],r[e]))>0&&(p=-p);for(let _=1;_<=e;_++)r[_].applyMatrix4(u.makeRotationAxis(i[_],p*_)),a[_].crossVectors(i[_],r[_])}return{tangents:i,normals:r,binormals:a}},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this},toJSON:function(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e},fromJSON:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}});function ws(e,n,t,i,r,a,c,u){Qt.call(this),this.type="EllipseCurve",this.aX=e||0,this.aY=n||0,this.xRadius=t||1,this.yRadius=i||1,this.aStartAngle=r||0,this.aEndAngle=a||2*Math.PI,this.aClockwise=c||!1,this.aRotation=u||0}ws.prototype=Object.create(Qt.prototype),ws.prototype.constructor=ws,ws.prototype.isEllipseCurve=!0,ws.prototype.getPoint=function(e,n){const t=n||new vt,i=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const a=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(a?r=0:r=i),this.aClockwise===!0&&!a&&(r===i?r=-i:r=r-i);const c=this.aStartAngle+e*r;let u=this.aX+this.xRadius*Math.cos(c),l=this.aY+this.yRadius*Math.sin(c);if(this.aRotation!==0){const f=Math.cos(this.aRotation),m=Math.sin(this.aRotation),h=u-this.aX,p=l-this.aY;u=h*f-p*m+this.aX,l=h*m+p*f+this.aY}return t.set(u,l)},ws.prototype.copy=function(e){return Qt.prototype.copy.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this},ws.prototype.toJSON=function(){const e=Qt.prototype.toJSON.call(this);return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e},ws.prototype.fromJSON=function(e){return Qt.prototype.fromJSON.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this};function Pd(e,n,t,i,r,a){ws.call(this,e,n,t,t,i,r,a),this.type="ArcCurve"}Pd.prototype=Object.create(ws.prototype),Pd.prototype.constructor=Pd,Pd.prototype.isArcCurve=!0;function Zv(){let e=0,n=0,t=0,i=0;function r(a,c,u,l){e=a,n=u,t=-3*a+3*c-2*u-l,i=2*a-2*c+u+l}return{initCatmullRom:function(a,c,u,l,f){r(c,u,f*(u-a),f*(l-c))},initNonuniformCatmullRom:function(a,c,u,l,f,m,h){let p=(c-a)/f-(u-a)/(f+m)+(u-c)/m,_=(u-c)/m-(l-c)/(m+h)+(l-u)/h;p*=m,_*=m,r(c,u,p,_)},calc:function(a){const c=a*a,u=c*a;return e+n*a+t*c+i*u}}}const k_=new ye,e0=new Zv,t0=new Zv,n0=new Zv;function ns(e,n,t,i){Qt.call(this),this.type="CatmullRomCurve3",this.points=e||[],this.closed=n||!1,this.curveType=t||"centripetal",this.tension=i!==void 0?i:.5}ns.prototype=Object.create(Qt.prototype),ns.prototype.constructor=ns,ns.prototype.isCatmullRomCurve3=!0,ns.prototype.getPoint=function(e,n){const t=n||new ye,i=this.points,r=i.length,a=(r-(this.closed?0:1))*e;let c=Math.floor(a),u=a-c;this.closed?c+=c>0?0:(Math.floor(Math.abs(c)/r)+1)*r:u===0&&c===r-1&&(c=r-2,u=1);let l,f,m,h;if(this.closed||c>0?l=i[(c-1)%r]:(k_.subVectors(i[0],i[1]).add(i[0]),l=k_),f=i[c%r],m=i[(c+1)%r],this.closed||c+2<r?h=i[(c+2)%r]:(k_.subVectors(i[r-1],i[r-2]).add(i[r-1]),h=k_),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let _=Math.pow(l.distanceToSquared(f),p),v=Math.pow(f.distanceToSquared(m),p),S=Math.pow(m.distanceToSquared(h),p);v<1e-4&&(v=1),_<1e-4&&(_=v),S<1e-4&&(S=v),e0.initNonuniformCatmullRom(l.x,f.x,m.x,h.x,_,v,S),t0.initNonuniformCatmullRom(l.y,f.y,m.y,h.y,_,v,S),n0.initNonuniformCatmullRom(l.z,f.z,m.z,h.z,_,v,S)}else this.curveType==="catmullrom"&&(e0.initCatmullRom(l.x,f.x,m.x,h.x,this.tension),t0.initCatmullRom(l.y,f.y,m.y,h.y,this.tension),n0.initCatmullRom(l.z,f.z,m.z,h.z,this.tension));return t.set(e0.calc(u),t0.calc(u),n0.calc(u)),t},ns.prototype.copy=function(e){Qt.prototype.copy.call(this,e),this.points=[];for(let n=0,t=e.points.length;n<t;n++){const i=e.points[n];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this},ns.prototype.toJSON=function(){const e=Qt.prototype.toJSON.call(this);e.points=[];for(let n=0,t=this.points.length;n<t;n++){const i=this.points[n];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e},ns.prototype.fromJSON=function(e){Qt.prototype.fromJSON.call(this,e),this.points=[];for(let n=0,t=e.points.length;n<t;n++){const i=e.points[n];this.points.push(new ye().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this};function Lx(e,n,t,i,r){const a=(i-n)*.5,c=(r-t)*.5,u=e*e,l=e*u;return(2*t-2*i+a+c)*l+(-3*t+3*i-2*a-c)*u+a*e+t}function JS(e,n){const t=1-e;return t*t*n}function QS(e,n){return 2*(1-e)*e*n}function ZS(e,n){return e*e*n}function Ad(e,n,t,i){return JS(e,n)+QS(e,t)+ZS(e,i)}function eP(e,n){const t=1-e;return t*t*t*n}function tP(e,n){const t=1-e;return 3*t*t*e*n}function nP(e,n){return 3*(1-e)*e*e*n}function iP(e,n){return e*e*e*n}function Cd(e,n,t,i,r){return eP(e,n)+tP(e,t)+nP(e,i)+iP(e,r)}function Zs(e,n,t,i){Qt.call(this),this.type="CubicBezierCurve",this.v0=e||new vt,this.v1=n||new vt,this.v2=t||new vt,this.v3=i||new vt}Zs.prototype=Object.create(Qt.prototype),Zs.prototype.constructor=Zs,Zs.prototype.isCubicBezierCurve=!0,Zs.prototype.getPoint=function(e,n){const t=n||new vt,i=this.v0,r=this.v1,a=this.v2,c=this.v3;return t.set(Cd(e,i.x,r.x,a.x,c.x),Cd(e,i.y,r.y,a.y,c.y)),t},Zs.prototype.copy=function(e){return Qt.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},Zs.prototype.toJSON=function(){const e=Qt.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},Zs.prototype.fromJSON=function(e){return Qt.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this};function Pr(e,n,t,i){Qt.call(this),this.type="CubicBezierCurve3",this.v0=e||new ye,this.v1=n||new ye,this.v2=t||new ye,this.v3=i||new ye}Pr.prototype=Object.create(Qt.prototype),Pr.prototype.constructor=Pr,Pr.prototype.isCubicBezierCurve3=!0,Pr.prototype.getPoint=function(e,n){const t=n||new ye,i=this.v0,r=this.v1,a=this.v2,c=this.v3;return t.set(Cd(e,i.x,r.x,a.x,c.x),Cd(e,i.y,r.y,a.y,c.y),Cd(e,i.z,r.z,a.z,c.z)),t},Pr.prototype.copy=function(e){return Qt.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},Pr.prototype.toJSON=function(){const e=Qt.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},Pr.prototype.fromJSON=function(e){return Qt.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this};function is(e,n){Qt.call(this),this.type="LineCurve",this.v1=e||new vt,this.v2=n||new vt}is.prototype=Object.create(Qt.prototype),is.prototype.constructor=is,is.prototype.isLineCurve=!0,is.prototype.getPoint=function(e,n){const t=n||new vt;return e===1?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(e).add(this.v1)),t},is.prototype.getPointAt=function(e,n){return this.getPoint(e,n)},is.prototype.getTangent=function(e,n){const t=n||new vt;return t.copy(this.v2).sub(this.v1).normalize(),t},is.prototype.copy=function(e){return Qt.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},is.prototype.toJSON=function(){const e=Qt.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},is.prototype.fromJSON=function(e){return Qt.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this};function er(e,n){Qt.call(this),this.type="LineCurve3",this.v1=e||new ye,this.v2=n||new ye}er.prototype=Object.create(Qt.prototype),er.prototype.constructor=er,er.prototype.isLineCurve3=!0,er.prototype.getPoint=function(e,n){const t=n||new ye;return e===1?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(e).add(this.v1)),t},er.prototype.getPointAt=function(e,n){return this.getPoint(e,n)},er.prototype.copy=function(e){return Qt.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},er.prototype.toJSON=function(){const e=Qt.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},er.prototype.fromJSON=function(e){return Qt.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this};function tr(e,n,t){Qt.call(this),this.type="QuadraticBezierCurve",this.v0=e||new vt,this.v1=n||new vt,this.v2=t||new vt}tr.prototype=Object.create(Qt.prototype),tr.prototype.constructor=tr,tr.prototype.isQuadraticBezierCurve=!0,tr.prototype.getPoint=function(e,n){const t=n||new vt,i=this.v0,r=this.v1,a=this.v2;return t.set(Ad(e,i.x,r.x,a.x),Ad(e,i.y,r.y,a.y)),t},tr.prototype.copy=function(e){return Qt.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},tr.prototype.toJSON=function(){const e=Qt.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},tr.prototype.fromJSON=function(e){return Qt.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this};function Ar(e,n,t){Qt.call(this),this.type="QuadraticBezierCurve3",this.v0=e||new ye,this.v1=n||new ye,this.v2=t||new ye}Ar.prototype=Object.create(Qt.prototype),Ar.prototype.constructor=Ar,Ar.prototype.isQuadraticBezierCurve3=!0,Ar.prototype.getPoint=function(e,n){const t=n||new ye,i=this.v0,r=this.v1,a=this.v2;return t.set(Ad(e,i.x,r.x,a.x),Ad(e,i.y,r.y,a.y),Ad(e,i.z,r.z,a.z)),t},Ar.prototype.copy=function(e){return Qt.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},Ar.prototype.toJSON=function(){const e=Qt.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},Ar.prototype.fromJSON=function(e){return Qt.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this};function nr(e){Qt.call(this),this.type="SplineCurve",this.points=e||[]}nr.prototype=Object.create(Qt.prototype),nr.prototype.constructor=nr,nr.prototype.isSplineCurve=!0,nr.prototype.getPoint=function(e,n){const t=n||new vt,i=this.points,r=(i.length-1)*e,a=Math.floor(r),c=r-a,u=i[a===0?a:a-1],l=i[a],f=i[a>i.length-2?i.length-1:a+1],m=i[a>i.length-3?i.length-1:a+2];return t.set(Lx(c,u.x,l.x,f.x,m.x),Lx(c,u.y,l.y,f.y,m.y)),t},nr.prototype.copy=function(e){Qt.prototype.copy.call(this,e),this.points=[];for(let n=0,t=e.points.length;n<t;n++){const i=e.points[n];this.points.push(i.clone())}return this},nr.prototype.toJSON=function(){const e=Qt.prototype.toJSON.call(this);e.points=[];for(let n=0,t=this.points.length;n<t;n++){const i=this.points[n];e.points.push(i.toArray())}return e},nr.prototype.fromJSON=function(e){Qt.prototype.fromJSON.call(this,e),this.points=[];for(let n=0,t=e.points.length;n<t;n++){const i=e.points[n];this.points.push(new vt().fromArray(i))}return this};var i0=Object.freeze({__proto__:null,ArcCurve:Pd,CatmullRomCurve3:ns,CubicBezierCurve:Zs,CubicBezierCurve3:Pr,EllipseCurve:ws,LineCurve:is,LineCurve3:er,QuadraticBezierCurve:tr,QuadraticBezierCurve3:Ar,SplineCurve:nr});function no(){Qt.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}no.prototype=Object.assign(Object.create(Qt.prototype),{constructor:no,add:function(e){this.curves.push(e)},closePath:function(){const e=this.curves[0].getPoint(0),n=this.curves[this.curves.length-1].getPoint(1);e.equals(n)||this.curves.push(new is(n,e))},getPoint:function(e){const n=e*this.getLength(),t=this.getCurveLengths();let i=0;for(;i<t.length;){if(t[i]>=n){const r=t[i]-n,a=this.curves[i],c=a.getLength(),u=c===0?0:1-r/c;return a.getPointAt(u)}i++}return null},getLength:function(){const e=this.getCurveLengths();return e[e.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let n=0;for(let t=0,i=this.curves.length;t<i;t++)n+=this.curves[t].getLength(),e.push(n);return this.cacheLengths=e,e},getSpacedPoints:function(e){e===void 0&&(e=40);const n=[];for(let t=0;t<=e;t++)n.push(this.getPoint(t/e));return this.autoClose&&n.push(n[0]),n},getPoints:function(e){e=e||12;const n=[];let t;for(let i=0,r=this.curves;i<r.length;i++){const a=r[i],c=a&&a.isEllipseCurve?e*2:a&&(a.isLineCurve||a.isLineCurve3)?1:a&&a.isSplineCurve?e*a.points.length:e,u=a.getPoints(c);for(let l=0;l<u.length;l++){const f=u[l];t&&t.equals(f)||(n.push(f),t=f)}}return this.autoClose&&n.length>1&&!n[n.length-1].equals(n[0])&&n.push(n[0]),n},copy:function(e){Qt.prototype.copy.call(this,e),this.curves=[];for(let n=0,t=e.curves.length;n<t;n++){const i=e.curves[n];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this},toJSON:function(){const e=Qt.prototype.toJSON.call(this);e.autoClose=this.autoClose,e.curves=[];for(let n=0,t=this.curves.length;n<t;n++){const i=this.curves[n];e.curves.push(i.toJSON())}return e},fromJSON:function(e){Qt.prototype.fromJSON.call(this,e),this.autoClose=e.autoClose,this.curves=[];for(let n=0,t=e.curves.length;n<t;n++){const i=e.curves[n];this.curves.push(new i0[i.type]().fromJSON(i))}return this}});function ir(e){no.call(this),this.type="Path",this.currentPoint=new vt,e&&this.setFromPoints(e)}ir.prototype=Object.assign(Object.create(no.prototype),{constructor:ir,setFromPoints:function(e){this.moveTo(e[0].x,e[0].y);for(let n=1,t=e.length;n<t;n++)this.lineTo(e[n].x,e[n].y);return this},moveTo:function(e,n){return this.currentPoint.set(e,n),this},lineTo:function(e,n){const t=new is(this.currentPoint.clone(),new vt(e,n));return this.curves.push(t),this.currentPoint.set(e,n),this},quadraticCurveTo:function(e,n,t,i){const r=new tr(this.currentPoint.clone(),new vt(e,n),new vt(t,i));return this.curves.push(r),this.currentPoint.set(t,i),this},bezierCurveTo:function(e,n,t,i,r,a){const c=new Zs(this.currentPoint.clone(),new vt(e,n),new vt(t,i),new vt(r,a));return this.curves.push(c),this.currentPoint.set(r,a),this},splineThru:function(e){const n=[this.currentPoint.clone()].concat(e),t=new nr(n);return this.curves.push(t),this.currentPoint.copy(e[e.length-1]),this},arc:function(e,n,t,i,r,a){const c=this.currentPoint.x,u=this.currentPoint.y;return this.absarc(e+c,n+u,t,i,r,a),this},absarc:function(e,n,t,i,r,a){return this.absellipse(e,n,t,t,i,r,a),this},ellipse:function(e,n,t,i,r,a,c,u){const l=this.currentPoint.x,f=this.currentPoint.y;return this.absellipse(e+l,n+f,t,i,r,a,c,u),this},absellipse:function(e,n,t,i,r,a,c,u){const l=new ws(e,n,t,i,r,a,c,u);if(this.curves.length>0){const m=l.getPoint(0);m.equals(this.currentPoint)||this.lineTo(m.x,m.y)}this.curves.push(l);const f=l.getPoint(1);return this.currentPoint.copy(f),this},copy:function(e){return no.prototype.copy.call(this,e),this.currentPoint.copy(e.currentPoint),this},toJSON:function(){const e=no.prototype.toJSON.call(this);return e.currentPoint=this.currentPoint.toArray(),e},fromJSON:function(e){return no.prototype.fromJSON.call(this,e),this.currentPoint.fromArray(e.currentPoint),this}});function Oo(e){ir.call(this,e),this.uuid=ln.generateUUID(),this.type="Shape",this.holes=[]}Oo.prototype=Object.assign(Object.create(ir.prototype),{constructor:Oo,getPointsHoles:function(e){const n=[];for(let t=0,i=this.holes.length;t<i;t++)n[t]=this.holes[t].getPoints(e);return n},extractPoints:function(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}},copy:function(e){ir.prototype.copy.call(this,e),this.holes=[];for(let n=0,t=e.holes.length;n<t;n++){const i=e.holes[n];this.holes.push(i.clone())}return this},toJSON:function(){const e=ir.prototype.toJSON.call(this);e.uuid=this.uuid,e.holes=[];for(let n=0,t=this.holes.length;n<t;n++){const i=this.holes[n];e.holes.push(i.toJSON())}return e},fromJSON:function(e){ir.prototype.fromJSON.call(this,e),this.uuid=e.uuid,this.holes=[];for(let n=0,t=e.holes.length;n<t;n++){const i=e.holes[n];this.holes.push(new ir().fromJSON(i))}return this}});function $n(e,n){Ot.call(this),this.type="Light",this.color=new jt(e),this.intensity=n!==void 0?n:1,this.receiveShadow=void 0}$n.prototype=Object.assign(Object.create(Ot.prototype),{constructor:$n,isLight:!0,copy:function(e){return Ot.prototype.copy.call(this,e),this.color.copy(e.color),this.intensity=e.intensity,this},toJSON:function(e){const n=Ot.prototype.toJSON.call(this,e);return n.object.color=this.color.getHex(),n.object.intensity=this.intensity,this.groundColor!==void 0&&(n.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(n.object.distance=this.distance),this.angle!==void 0&&(n.object.angle=this.angle),this.decay!==void 0&&(n.object.decay=this.decay),this.penumbra!==void 0&&(n.object.penumbra=this.penumbra),this.shadow!==void 0&&(n.object.shadow=this.shadow.toJSON()),n}});function s0(e,n,t){$n.call(this,e,t),this.type="HemisphereLight",this.castShadow=void 0,this.position.copy(Ot.DefaultUp),this.updateMatrix(),this.groundColor=new jt(n)}s0.prototype=Object.assign(Object.create($n.prototype),{constructor:s0,isHemisphereLight:!0,copy:function(e){return $n.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}});function Cr(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new vt(512,512),this.map=null,this.mapPass=null,this.matrix=new dn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Ju,this._frameExtents=new vt(1,1),this._viewportCount=1,this._viewports=[new An(0,0,1,1)]}Object.assign(Cr.prototype,{_projScreenMatrix:new dn,_lightPositionWorld:new ye,_lookTarget:new ye,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(e){const n=this.camera,t=this.matrix,i=this._projScreenMatrix,r=this._lookTarget,a=this._lightPositionWorld;a.setFromMatrixPosition(e.matrixWorld),n.position.copy(a),r.setFromMatrixPosition(e.target.matrixWorld),n.lookAt(r),n.updateMatrixWorld(),i.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(i),t.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),t.multiply(n.projectionMatrix),t.multiply(n.matrixWorldInverse)},getViewport:function(e){return this._viewports[e]},getFrameExtents:function(){return this._frameExtents},copy:function(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}});function r0(){Cr.call(this,new ii(50,1,.5,500))}r0.prototype=Object.assign(Object.create(Cr.prototype),{constructor:r0,isSpotLightShadow:!0,updateMatrices:function(e){const n=this.camera,t=ln.RAD2DEG*2*e.angle,i=this.mapSize.width/this.mapSize.height,r=e.distance||n.far;(t!==n.fov||i!==n.aspect||r!==n.far)&&(n.fov=t,n.aspect=i,n.far=r,n.updateProjectionMatrix()),Cr.prototype.updateMatrices.call(this,e)}});function o0(e,n,t,i,r,a){$n.call(this,e,n),this.type="SpotLight",this.position.copy(Ot.DefaultUp),this.updateMatrix(),this.target=new Ot,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(c){this.intensity=c/Math.PI}}),this.distance=t!==void 0?t:0,this.angle=i!==void 0?i:Math.PI/3,this.penumbra=r!==void 0?r:0,this.decay=a!==void 0?a:1,this.shadow=new r0}o0.prototype=Object.assign(Object.create($n.prototype),{constructor:o0,isSpotLight:!0,copy:function(e){return $n.prototype.copy.call(this,e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}});function a0(){Cr.call(this,new ii(90,1,.5,500)),this._frameExtents=new vt(4,2),this._viewportCount=6,this._viewports=[new An(2,1,1,1),new An(0,1,1,1),new An(3,1,1,1),new An(1,1,1,1),new An(3,0,1,1),new An(1,0,1,1)],this._cubeDirections=[new ye(1,0,0),new ye(-1,0,0),new ye(0,0,1),new ye(0,0,-1),new ye(0,1,0),new ye(0,-1,0)],this._cubeUps=[new ye(0,1,0),new ye(0,1,0),new ye(0,1,0),new ye(0,1,0),new ye(0,0,1),new ye(0,0,-1)]}a0.prototype=Object.assign(Object.create(Cr.prototype),{constructor:a0,isPointLightShadow:!0,updateMatrices:function(e,n){n===void 0&&(n=0);const t=this.camera,i=this.matrix,r=this._lightPositionWorld,a=this._lookTarget,c=this._projScreenMatrix;r.setFromMatrixPosition(e.matrixWorld),t.position.copy(r),a.copy(t.position),a.add(this._cubeDirections[n]),t.up.copy(this._cubeUps[n]),t.lookAt(a),t.updateMatrixWorld(),i.makeTranslation(-r.x,-r.y,-r.z),c.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(c)}});function l0(e,n,t,i){$n.call(this,e,n),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return this.intensity*4*Math.PI},set:function(r){this.intensity=r/(4*Math.PI)}}),this.distance=t!==void 0?t:0,this.decay=i!==void 0?i:1,this.shadow=new a0}l0.prototype=Object.assign(Object.create($n.prototype),{constructor:l0,isPointLight:!0,copy:function(e){return $n.prototype.copy.call(this,e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}});function Id(e,n,t,i,r,a){Er.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e!==void 0?e:-1,this.right=n!==void 0?n:1,this.top=t!==void 0?t:1,this.bottom=i!==void 0?i:-1,this.near=r!==void 0?r:.1,this.far=a!==void 0?a:2e3,this.updateProjectionMatrix()}Id.prototype=Object.assign(Object.create(Er.prototype),{constructor:Id,isOrthographicCamera:!0,copy:function(e,n){return Er.prototype.copy.call(this,e,n),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this},setViewOffset:function(e,n,t,i,r,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=n,this.view.offsetX=t,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const e=(this.right-this.left)/(2*this.zoom),n=(this.top-this.bottom)/(2*this.zoom),t=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=t-e,a=t+e,c=i+n,u=i-n;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,f=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=l*this.view.offsetX,a=r+l*this.view.width,c-=f*this.view.offsetY,u=c-f*this.view.height}this.projectionMatrix.makeOrthographic(r,a,c,u,this.near,this.far),this.projectionMatrixInverse.getInverse(this.projectionMatrix)},toJSON:function(e){const n=Ot.prototype.toJSON.call(this,e);return n.object.zoom=this.zoom,n.object.left=this.left,n.object.right=this.right,n.object.top=this.top,n.object.bottom=this.bottom,n.object.near=this.near,n.object.far=this.far,this.view!==null&&(n.object.view=Object.assign({},this.view)),n}});function c0(){Cr.call(this,new Id(-5,5,5,-5,.5,500))}c0.prototype=Object.assign(Object.create(Cr.prototype),{constructor:c0,isDirectionalLightShadow:!0,updateMatrices:function(e){Cr.prototype.updateMatrices.call(this,e)}});function u0(e,n){$n.call(this,e,n),this.type="DirectionalLight",this.position.copy(Ot.DefaultUp),this.updateMatrix(),this.target=new Ot,this.shadow=new c0}u0.prototype=Object.assign(Object.create($n.prototype),{constructor:u0,isDirectionalLight:!0,copy:function(e){return $n.prototype.copy.call(this,e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}});function O_(e,n){$n.call(this,e,n),this.type="AmbientLight",this.castShadow=void 0}O_.prototype=Object.assign(Object.create($n.prototype),{constructor:O_,isAmbientLight:!0});function d0(e,n,t,i){$n.call(this,e,n),this.type="RectAreaLight",this.width=t!==void 0?t:10,this.height=i!==void 0?i:10}d0.prototype=Object.assign(Object.create($n.prototype),{constructor:d0,isRectAreaLight:!0,copy:function(e){return $n.prototype.copy.call(this,e),this.width=e.width,this.height=e.height,this},toJSON:function(e){const n=$n.prototype.toJSON.call(this,e);return n.object.width=this.width,n.object.height=this.height,n}});function h0(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new ye)}Object.assign(h0.prototype,{isSphericalHarmonics3:!0,set:function(e){for(let n=0;n<9;n++)this.coefficients[n].copy(e[n]);return this},zero:function(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this},getAt:function(e,n){const t=e.x,i=e.y,r=e.z,a=this.coefficients;return n.copy(a[0]).multiplyScalar(.282095),n.addScaledVector(a[1],.488603*i),n.addScaledVector(a[2],.488603*r),n.addScaledVector(a[3],.488603*t),n.addScaledVector(a[4],1.092548*(t*i)),n.addScaledVector(a[5],1.092548*(i*r)),n.addScaledVector(a[6],.315392*(3*r*r-1)),n.addScaledVector(a[7],1.092548*(t*r)),n.addScaledVector(a[8],.546274*(t*t-i*i)),n},getIrradianceAt:function(e,n){const t=e.x,i=e.y,r=e.z,a=this.coefficients;return n.copy(a[0]).multiplyScalar(.886227),n.addScaledVector(a[1],2*.511664*i),n.addScaledVector(a[2],2*.511664*r),n.addScaledVector(a[3],2*.511664*t),n.addScaledVector(a[4],2*.429043*t*i),n.addScaledVector(a[5],2*.429043*i*r),n.addScaledVector(a[6],.743125*r*r-.247708),n.addScaledVector(a[7],2*.429043*t*r),n.addScaledVector(a[8],.429043*(t*t-i*i)),n},add:function(e){for(let n=0;n<9;n++)this.coefficients[n].add(e.coefficients[n]);return this},addScaledSH:function(e,n){for(let t=0;t<9;t++)this.coefficients[t].addScaledVector(e.coefficients[t],n);return this},scale:function(e){for(let n=0;n<9;n++)this.coefficients[n].multiplyScalar(e);return this},lerp:function(e,n){for(let t=0;t<9;t++)this.coefficients[t].lerp(e.coefficients[t],n);return this},equals:function(e){for(let n=0;n<9;n++)if(!this.coefficients[n].equals(e.coefficients[n]))return!1;return!0},copy:function(e){return this.set(e.coefficients)},clone:function(){return new this.constructor().copy(this)},fromArray:function(e,n){n===void 0&&(n=0);const t=this.coefficients;for(let i=0;i<9;i++)t[i].fromArray(e,n+i*3);return this},toArray:function(e,n){e===void 0&&(e=[]),n===void 0&&(n=0);const t=this.coefficients;for(let i=0;i<9;i++)t[i].toArray(e,n+i*3);return e}}),Object.assign(h0,{getBasisAt:function(e,n){const t=e.x,i=e.y,r=e.z;n[0]=.282095,n[1]=.488603*i,n[2]=.488603*r,n[3]=.488603*t,n[4]=1.092548*t*i,n[5]=1.092548*i*r,n[6]=.315392*(3*r*r-1),n[7]=1.092548*t*r,n[8]=.546274*(t*t-i*i)}});function Rs(e,n){$n.call(this,void 0,n),this.type="LightProbe",this.sh=e!==void 0?e:new h0}Rs.prototype=Object.assign(Object.create($n.prototype),{constructor:Rs,isLightProbe:!0,copy:function(e){return $n.prototype.copy.call(this,e),this.sh.copy(e.sh),this},fromJSON:function(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this},toJSON:function(e){const n=$n.prototype.toJSON.call(this,e);return n.object.sh=this.sh.toArray(),n}});function F_(e){bn.call(this,e),this.textures={}}F_.prototype=Object.assign(Object.create(bn.prototype),{constructor:F_,load:function(e,n,t,i){const r=this,a=new Fs(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.load(e,function(c){try{n(r.parse(JSON.parse(c)))}catch(u){i?i(u):console.error(u),r.manager.itemError(e)}},t,i)},parse:function(e){const n=this.textures;function t(r){return n[r]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",r),n[r]}const i=new qS[e.type];if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=new jt().setHex(e.sheen)),e.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular.setHex(e.specular),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==1&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.skinning!==void 0&&(i.skinning=e.skinning),e.morphTargets!==void 0&&(i.morphTargets=e.morphTargets),e.morphNormals!==void 0&&(i.morphNormals=e.morphNormals),e.dithering!==void 0&&(i.dithering=e.dithering),e.vertexTangents!==void 0&&(i.vertexTangents=e.vertexTangents),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const r in e.uniforms){const a=e.uniforms[r];switch(i.uniforms[r]={},a.type){case"t":i.uniforms[r].value=t(a.value);break;case"c":i.uniforms[r].value=new jt().setHex(a.value);break;case"v2":i.uniforms[r].value=new vt().fromArray(a.value);break;case"v3":i.uniforms[r].value=new ye().fromArray(a.value);break;case"v4":i.uniforms[r].value=new An().fromArray(a.value);break;case"m3":i.uniforms[r].value=new Oi().fromArray(a.value);case"m4":i.uniforms[r].value=new dn().fromArray(a.value);break;default:i.uniforms[r].value=a.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.extensions!==void 0)for(const r in e.extensions)i.extensions[r]=e.extensions[r];if(e.shading!==void 0&&(i.flatShading=e.shading===1),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=t(e.map)),e.matcap!==void 0&&(i.matcap=t(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=t(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=t(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=t(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let r=e.normalScale;Array.isArray(r)===!1&&(r=[r,r]),i.normalScale=new vt().fromArray(r)}return e.displacementMap!==void 0&&(i.displacementMap=t(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=t(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=t(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=t(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=t(e.specularMap)),e.envMap!==void 0&&(i.envMap=t(e.envMap)),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=t(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=t(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=t(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=t(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=t(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=t(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new vt().fromArray(e.clearcoatNormalScale)),e.transmission!==void 0&&(i.transmission=e.transmission),e.transmissionMap!==void 0&&(i.transmissionMap=t(e.transmissionMap)),i},setTextures:function(e){return this.textures=e,this}});const Dx={decodeText:function(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let n="";for(let t=0,i=e.length;t<i;t++)n+=String.fromCharCode(e[t]);try{return decodeURIComponent(escape(n))}catch{return n}},extractUrlBase:function(e){const n=e.lastIndexOf("/");return n===-1?"./":e.substr(0,n+1)}};function R_(){Ut.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}R_.prototype=Object.assign(Object.create(Ut.prototype),{constructor:R_,isInstancedBufferGeometry:!0,copy:function(e){return Ut.prototype.copy.call(this,e),this.instanceCount=e.instanceCount,this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const e=Ut.prototype.toJSON.call(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}});function f0(e,n,t,i){typeof t=="number"&&(i=t,t=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),Kt.call(this,e,n,t),this.meshPerAttribute=i||1}f0.prototype=Object.assign(Object.create(Kt.prototype),{constructor:f0,isInstancedBufferAttribute:!0,copy:function(e){return Kt.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},toJSON:function(){const e=Kt.prototype.toJSON.call(this);return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}});function p0(e){bn.call(this,e)}p0.prototype=Object.assign(Object.create(bn.prototype),{constructor:p0,load:function(e,n,t,i){const r=this,a=new Fs(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.load(e,function(c){try{n(r.parse(JSON.parse(c)))}catch(u){i?i(u):console.error(u),r.manager.itemError(e)}},t,i)},parse:function(e){const n={},t={};function i(p,_){if(n[_]!==void 0)return n[_];const S=p.interleavedBuffers[_],D=r(p,S.buffer),w=new B_[S.type](D),T=new _s(w,S.stride);return T.uuid=S.uuid,n[_]=T,T}function r(p,_){if(t[_]!==void 0)return t[_];const S=p.arrayBuffers[_],D=new Uint32Array(S).buffer;return t[_]=D,D}const a=e.isInstancedBufferGeometry?new R_:new Ut,c=e.data.index;if(c!==void 0){const p=new B_[c.type](c.array);a.setIndex(new Kt(p,1))}const u=e.data.attributes;for(const p in u){const _=u[p];let v;if(_.isInterleavedBufferAttribute){const S=i(e.data,_.data);v=new Io(S,_.itemSize,_.offset,_.normalized)}else{const S=new B_[_.type](_.array),D=_.isInstancedBufferAttribute?f0:Kt;v=new D(S,_.itemSize,_.normalized)}_.name!==void 0&&(v.name=_.name),a.setAttribute(p,v)}const l=e.data.morphAttributes;if(l)for(const p in l){const _=l[p],v=[];for(let S=0,D=_.length;S<D;S++){const w=_[S];let T;if(w.isInterleavedBufferAttribute){const F=i(e.data,w.data);T=new Io(F,w.itemSize,w.offset,w.normalized)}else{const F=new B_[w.type](w.array);T=new Kt(F,w.itemSize,w.normalized)}w.name!==void 0&&(T.name=w.name),v.push(T)}a.morphAttributes[p]=v}e.data.morphTargetsRelative&&(a.morphTargetsRelative=!0);const m=e.data.groups||e.data.drawcalls||e.data.offsets;if(m!==void 0)for(let p=0,_=m.length;p!==_;++p){const v=m[p];a.addGroup(v.start,v.count,v.materialIndex)}const h=e.data.boundingSphere;if(h!==void 0){const p=new ye;h.center!==void 0&&p.fromArray(h.center),a.boundingSphere=new xr(p,h.radius)}return e.name&&(a.name=e.name),e.userData&&(a.userData=e.userData),a}});const B_={Int8Array,Uint8Array,Uint8ClampedArray:typeof Uint8ClampedArray<"u"?Uint8ClampedArray:Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function m0(e){bn.call(this,e)}m0.prototype=Object.assign(Object.create(bn.prototype),{constructor:m0,load:function(e,n,t,i){const r=this,a=this.path===""?Dx.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||a;const c=new Fs(r.manager);c.setPath(this.path),c.setRequestHeader(this.requestHeader),c.load(e,function(u){let l=null;try{l=JSON.parse(u)}catch(m){i!==void 0&&i(m),console.error("THREE:ObjectLoader: Can't parse "+e+".",m.message);return}const f=l.metadata;if(f===void 0||f.type===void 0||f.type.toLowerCase()==="geometry"){console.error("THREE.ObjectLoader: Can't load "+e);return}r.parse(l,n)},t,i)},parse:function(e,n){const t=this.parseShape(e.shapes),i=this.parseGeometries(e.geometries,t),r=this.parseImages(e.images,function(){n!==void 0&&n(u)}),a=this.parseTextures(e.textures,r),c=this.parseMaterials(e.materials,a),u=this.parseObject(e.object,i,c);return e.animations&&(u.animations=this.parseAnimations(e.animations)),(e.images===void 0||e.images.length===0)&&n!==void 0&&n(u),u},parseShape:function(e){const n={};if(e!==void 0)for(let t=0,i=e.length;t<i;t++){const r=new Oo().fromJSON(e[t]);n[r.uuid]=r}return n},parseGeometries:function(e,n){const t={};let i;if(e!==void 0){const r=new p0;for(let a=0,c=e.length;a<c;a++){let u;const l=e[a];switch(l.type){case"PlaneGeometry":case"PlaneBufferGeometry":u=new Fi[l.type](l.width,l.height,l.widthSegments,l.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":case"CubeGeometry":u=new Fi[l.type](l.width,l.height,l.depth,l.widthSegments,l.heightSegments,l.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":u=new Fi[l.type](l.radius,l.segments,l.thetaStart,l.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":u=new Fi[l.type](l.radiusTop,l.radiusBottom,l.height,l.radialSegments,l.heightSegments,l.openEnded,l.thetaStart,l.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":u=new Fi[l.type](l.radius,l.height,l.radialSegments,l.heightSegments,l.openEnded,l.thetaStart,l.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":u=new Fi[l.type](l.radius,l.widthSegments,l.heightSegments,l.phiStart,l.phiLength,l.thetaStart,l.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":u=new Fi[l.type](l.radius,l.detail);break;case"RingGeometry":case"RingBufferGeometry":u=new Fi[l.type](l.innerRadius,l.outerRadius,l.thetaSegments,l.phiSegments,l.thetaStart,l.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":u=new Fi[l.type](l.radius,l.tube,l.radialSegments,l.tubularSegments,l.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":u=new Fi[l.type](l.radius,l.tube,l.tubularSegments,l.radialSegments,l.p,l.q);break;case"TubeGeometry":case"TubeBufferGeometry":u=new Fi[l.type](new i0[l.path.type]().fromJSON(l.path),l.tubularSegments,l.radius,l.radialSegments,l.closed);break;case"LatheGeometry":case"LatheBufferGeometry":u=new Fi[l.type](l.points,l.segments,l.phiStart,l.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":u=new Fi[l.type](l.vertices,l.indices,l.radius,l.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":i=[];for(let m=0,h=l.shapes.length;m<h;m++){const p=n[l.shapes[m]];i.push(p)}u=new Fi[l.type](i,l.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":i=[];for(let m=0,h=l.shapes.length;m<h;m++){const p=n[l.shapes[m]];i.push(p)}const f=l.options.extrudePath;f!==void 0&&(l.options.extrudePath=new i0[f.type]().fromJSON(f)),u=new Fi[l.type](i,l.options);break;case"BufferGeometry":case"InstancedBufferGeometry":u=r.parse(l);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+l.type+'"');continue}u.uuid=l.uuid,l.name!==void 0&&(u.name=l.name),u.isBufferGeometry===!0&&l.userData!==void 0&&(u.userData=l.userData),t[l.uuid]=u}}return t},parseMaterials:function(e,n){const t={},i={};if(e!==void 0){const r=new F_;r.setTextures(n);for(let a=0,c=e.length;a<c;a++){const u=e[a];if(u.type==="MultiMaterial"){const l=[];for(let f=0;f<u.materials.length;f++){const m=u.materials[f];t[m.uuid]===void 0&&(t[m.uuid]=r.parse(m)),l.push(t[m.uuid])}i[u.uuid]=l}else t[u.uuid]===void 0&&(t[u.uuid]=r.parse(u)),i[u.uuid]=t[u.uuid]}}return i},parseAnimations:function(e){const n=[];for(let t=0;t<e.length;t++){const i=e[t],r=ks.parse(i);i.uuid!==void 0&&(r.uuid=i.uuid),n.push(r)}return n},parseImages:function(e,n){const t=this,i={};let r;function a(c){return t.manager.itemStart(c),r.load(c,function(){t.manager.itemEnd(c)},void 0,function(){t.manager.itemError(c),t.manager.itemEnd(c)})}if(e!==void 0&&e.length>0){const c=new Px(n);r=new Sd(c),r.setCrossOrigin(this.crossOrigin);for(let u=0,l=e.length;u<l;u++){const f=e[u],m=f.url;if(Array.isArray(m)){i[f.uuid]=[];for(let h=0,p=m.length;h<p;h++){const _=m[h],v=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(_)?_:t.resourcePath+_;i[f.uuid].push(a(v))}}else{const h=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(f.url)?f.url:t.resourcePath+f.url;i[f.uuid]=a(h)}}}return i},parseTextures:function(e,n){function t(r,a){return typeof r=="number"?r:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",r),a[r])}const i={};if(e!==void 0)for(let r=0,a=e.length;r<a;r++){const c=e[r];c.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',c.uuid),n[c.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",c.image);let u;Array.isArray(n[c.image])?u=new Kr(n[c.image]):u=new Dn(n[c.image]),u.needsUpdate=!0,u.uuid=c.uuid,c.name!==void 0&&(u.name=c.name),c.mapping!==void 0&&(u.mapping=t(c.mapping,sP)),c.offset!==void 0&&u.offset.fromArray(c.offset),c.repeat!==void 0&&u.repeat.fromArray(c.repeat),c.center!==void 0&&u.center.fromArray(c.center),c.rotation!==void 0&&(u.rotation=c.rotation),c.wrap!==void 0&&(u.wrapS=t(c.wrap[0],kx),u.wrapT=t(c.wrap[1],kx)),c.format!==void 0&&(u.format=c.format),c.type!==void 0&&(u.type=c.type),c.encoding!==void 0&&(u.encoding=c.encoding),c.minFilter!==void 0&&(u.minFilter=t(c.minFilter,Ox)),c.magFilter!==void 0&&(u.magFilter=t(c.magFilter,Ox)),c.anisotropy!==void 0&&(u.anisotropy=c.anisotropy),c.flipY!==void 0&&(u.flipY=c.flipY),c.premultiplyAlpha!==void 0&&(u.premultiplyAlpha=c.premultiplyAlpha),c.unpackAlignment!==void 0&&(u.unpackAlignment=c.unpackAlignment),i[c.uuid]=u}return i},parseObject:function(e,n,t){let i;function r(l){return n[l]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",l),n[l]}function a(l){if(l!==void 0){if(Array.isArray(l)){const f=[];for(let m=0,h=l.length;m<h;m++){const p=l[m];t[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",p),f.push(t[p])}return f}return t[l]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",l),t[l]}}let c,u;switch(e.type){case"Scene":i=new Gu,e.background!==void 0&&Number.isInteger(e.background)&&(i.background=new jt(e.background)),e.fog!==void 0&&(e.fog.type==="Fog"?i.fog=new Fv(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(i.fog=new Ov(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":i=new ii(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(i.focus=e.focus),e.zoom!==void 0&&(i.zoom=e.zoom),e.filmGauge!==void 0&&(i.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(i.filmOffset=e.filmOffset),e.view!==void 0&&(i.view=Object.assign({},e.view));break;case"OrthographicCamera":i=new Id(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(i.zoom=e.zoom),e.view!==void 0&&(i.view=Object.assign({},e.view));break;case"AmbientLight":i=new O_(e.color,e.intensity);break;case"DirectionalLight":i=new u0(e.color,e.intensity);break;case"PointLight":i=new l0(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":i=new d0(e.color,e.intensity,e.width,e.height);break;case"SpotLight":i=new o0(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":i=new s0(e.color,e.groundColor,e.intensity);break;case"LightProbe":i=new Rs().fromJSON(e);break;case"SkinnedMesh":console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");case"Mesh":c=r(e.geometry),u=a(e.material),i=new Ln(c,u);break;case"InstancedMesh":c=r(e.geometry),u=a(e.material);const l=e.count,f=e.instanceMatrix;i=new Nv(c,u,l),i.instanceMatrix=new Kt(new Float32Array(f.array),16);break;case"LOD":i=new e_;break;case"Line":i=new ys(r(e.geometry),a(e.material),e.mode);break;case"LineLoop":i=new Uv(r(e.geometry),a(e.material));break;case"LineSegments":i=new si(r(e.geometry),a(e.material));break;case"PointCloud":case"Points":i=new l_(r(e.geometry),a(e.material));break;case"Sprite":i=new Bv(a(e.material));break;case"Group":i=new Yr;break;default:i=new Ot}if(i.uuid=e.uuid,e.name!==void 0&&(i.name=e.name),e.matrix!==void 0?(i.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(i.matrixAutoUpdate=e.matrixAutoUpdate),i.matrixAutoUpdate&&i.matrix.decompose(i.position,i.quaternion,i.scale)):(e.position!==void 0&&i.position.fromArray(e.position),e.rotation!==void 0&&i.rotation.fromArray(e.rotation),e.quaternion!==void 0&&i.quaternion.fromArray(e.quaternion),e.scale!==void 0&&i.scale.fromArray(e.scale)),e.castShadow!==void 0&&(i.castShadow=e.castShadow),e.receiveShadow!==void 0&&(i.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(i.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(i.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(i.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&i.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(i.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(i.visible=e.visible),e.frustumCulled!==void 0&&(i.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(i.renderOrder=e.renderOrder),e.userData!==void 0&&(i.userData=e.userData),e.layers!==void 0&&(i.layers.mask=e.layers),e.children!==void 0){const l=e.children;for(let f=0;f<l.length;f++)i.add(this.parseObject(l[f],n,t))}if(e.type==="LOD"){e.autoUpdate!==void 0&&(i.autoUpdate=e.autoUpdate);const l=e.levels;for(let f=0;f<l.length;f++){const m=l[f],h=i.getObjectByProperty("uuid",m.object);h!==void 0&&i.addLevel(h,m.distance)}}return i}});const sP={UVMapping:qy,CubeReflectionMapping:Ky,CubeRefractionMapping:Xy,EquirectangularReflectionMapping:rw,EquirectangularRefractionMapping:Yy,CubeUVReflectionMapping:Ru,CubeUVRefractionMapping:vg},kx={RepeatWrapping:wg,ClampToEdgeWrapping:Ni,MirroredRepeatWrapping:xg},Ox={NearestFilter:fi,NearestMipmapNearestFilter:Jy,NearestMipmapLinearFilter:Qy,LinearFilter:Pi,LinearMipmapNearestFilter:ow,LinearMipmapLinearFilter:bg};function Fx(e){typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),bn.call(this,e),this.options={premultiplyAlpha:"none"}}Fx.prototype=Object.assign(Object.create(bn.prototype),{constructor:Fx,isImageBitmapLoader:!0,setOptions:function(n){return this.options=n,this},load:function(e,n,t,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=Qs.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){n&&n(a),r.manager.itemEnd(e)},0),a;fetch(e).then(function(c){return c.blob()}).then(function(c){return createImageBitmap(c,r.options)}).then(function(c){Qs.add(e,c),n&&n(c),r.manager.itemEnd(e)}).catch(function(c){i&&i(c),r.manager.itemError(e),r.manager.itemEnd(e)}),r.manager.itemStart(e)}});function Rx(){this.type="ShapePath",this.color=new jt,this.subPaths=[],this.currentPath=null}Object.assign(Rx.prototype,{moveTo:function(e,n){return this.currentPath=new ir,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,n),this},lineTo:function(e,n){return this.currentPath.lineTo(e,n),this},quadraticCurveTo:function(e,n,t,i){return this.currentPath.quadraticCurveTo(e,n,t,i),this},bezierCurveTo:function(e,n,t,i,r,a){return this.currentPath.bezierCurveTo(e,n,t,i,r,a),this},splineThru:function(e){return this.currentPath.splineThru(e),this},toShapes:function(e,n){function t(w){const T=[];for(let F=0,E=w.length;F<E;F++){const A=w[F],L=new Oo;L.curves=A.curves,T.push(L)}return T}function i(w,T){const F=T.length;let E=!1;for(let A=F-1,L=0;L<F;A=L++){let I=T[A],R=T[L],N=R.x-I.x,q=R.y-I.y;if(Math.abs(q)>Number.EPSILON){if(q<0&&(I=T[L],N=-N,R=T[A],q=-q),w.y<I.y||w.y>R.y)continue;if(w.y===I.y){if(w.x===I.x)return!0}else{const ne=q*(w.x-I.x)-N*(w.y-I.y);if(ne===0)return!0;if(ne<0)continue;E=!E}}else{if(w.y!==I.y)continue;if(R.x<=w.x&&w.x<=I.x||I.x<=w.x&&w.x<=R.x)return!0}}return E}const r=Zr.isClockWise,a=this.subPaths;if(a.length===0)return[];if(n===!0)return t(a);let c,u,l,f=[];if(a.length===1)return u=a[0],l=new Oo,l.curves=u.curves,f.push(l),f;let m=!r(a[0].getPoints());m=e?!m:m;const h=[],p=[];let _=[],v=0,S;p[v]=void 0,_[v]=[];for(let w=0,T=a.length;w<T;w++)u=a[w],S=u.getPoints(),c=r(S),c=e?!c:c,c?(!m&&p[v]&&v++,p[v]={s:new Oo,p:S},p[v].s.curves=u.curves,m&&v++,_[v]=[]):_[v].push({h:u,p:S[0]});if(!p[0])return t(a);if(p.length>1){let w=!1;const T=[];for(let F=0,E=p.length;F<E;F++)h[F]=[];for(let F=0,E=p.length;F<E;F++){const A=_[F];for(let L=0;L<A.length;L++){const I=A[L];let R=!0;for(let N=0;N<p.length;N++)i(I.p,p[N].p)&&(F!==N&&T.push({froms:F,tos:N,hole:L}),R?(R=!1,h[N].push(I)):w=!0);R&&h[F].push(I)}}T.length>0&&(w||(_=h))}let D;for(let w=0,T=p.length;w<T;w++){l=p[w].s,f.push(l),D=_[w];for(let F=0,E=D.length;F<E;F++)l.holes.push(D[F].h)}return f}});function Bx(e){this.type="Font",this.data=e}Object.assign(Bx.prototype,{isFont:!0,generateShapes:function(e,n){n===void 0&&(n=100);const t=[],i=rP(e,n,this.data);for(let r=0,a=i.length;r<a;r++)Array.prototype.push.apply(t,i[r].toShapes());return t}});function rP(e,n,t){const i=Array.from?Array.from(e):String(e).split(""),r=n/t.resolution,a=(t.boundingBox.yMax-t.boundingBox.yMin+t.underlineThickness)*r,c=[];let u=0,l=0;for(let f=0;f<i.length;f++){const m=i[f];if(m===`
`)u=0,l-=a;else{const h=oP(m,r,u,l,t);u+=h.offsetX,c.push(h.path)}}return c}function oP(e,n,t,i,r){const a=r.glyphs[e]||r.glyphs["?"];if(!a){console.error('THREE.Font: character "'+e+'" does not exists in font family '+r.familyName+".");return}const c=new Rx;let u,l,f,m,h,p,_,v;if(a.o){const S=a._cachedOutline||(a._cachedOutline=a.o.split(" "));for(let D=0,w=S.length;D<w;)switch(S[D++]){case"m":u=S[D++]*n+t,l=S[D++]*n+i,c.moveTo(u,l);break;case"l":u=S[D++]*n+t,l=S[D++]*n+i,c.lineTo(u,l);break;case"q":f=S[D++]*n+t,m=S[D++]*n+i,h=S[D++]*n+t,p=S[D++]*n+i,c.quadraticCurveTo(h,p,f,m);break;case"b":f=S[D++]*n+t,m=S[D++]*n+i,h=S[D++]*n+t,p=S[D++]*n+i,_=S[D++]*n+t,v=S[D++]*n+i,c.bezierCurveTo(h,p,_,v,f,m);break}}return{offsetX:a.ha*n,path:c}}function zx(e){bn.call(this,e)}zx.prototype=Object.assign(Object.create(bn.prototype),{constructor:zx,load:function(e,n,t,i){const r=this,a=new Fs(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.load(e,function(c){let u;try{u=JSON.parse(c)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),u=JSON.parse(c.substring(65,c.length-2))}const l=r.parse(u);n&&n(l)},t,i)},parse:function(e){return new Bx(e)}});let z_;const $x={getContext:function(){return z_===void 0&&(z_=new(window.AudioContext||window.webkitAudioContext)),z_},setContext:function(e){z_=e}};function g0(e){bn.call(this,e)}g0.prototype=Object.assign(Object.create(bn.prototype),{constructor:g0,load:function(e,n,t,i){const r=this,a=new Fs(r.manager);a.setResponseType("arraybuffer"),a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.load(e,function(c){try{const u=c.slice(0);$x.getContext().decodeAudioData(u,function(f){n(f)})}catch(u){i?i(u):console.error(u),r.manager.itemError(e)}},t,i)}});function Nx(e,n,t){Rs.call(this,void 0,t);const i=new jt().set(e),r=new jt().set(n),a=new ye(i.r,i.g,i.b),c=new ye(r.r,r.g,r.b),u=Math.sqrt(Math.PI),l=u*Math.sqrt(.75);this.sh.coefficients[0].copy(a).add(c).multiplyScalar(u),this.sh.coefficients[1].copy(a).sub(c).multiplyScalar(l)}Nx.prototype=Object.assign(Object.create(Rs.prototype),{constructor:Nx,isHemisphereLightProbe:!0,copy:function(e){return Rs.prototype.copy.call(this,e),this},toJSON:function(e){return Rs.prototype.toJSON.call(this,e)}});function Ux(e,n){Rs.call(this,void 0,n);const t=new jt().set(e);this.sh.coefficients[0].set(t.r,t.g,t.b).multiplyScalar(2*Math.sqrt(Math.PI))}Ux.prototype=Object.assign(Object.create(Rs.prototype),{constructor:Ux,isAmbientLightProbe:!0,copy:function(e){return Rs.prototype.copy.call(this,e),this},toJSON:function(e){return Rs.prototype.toJSON.call(this,e)}});const Gx=new dn,Vx=new dn;function aP(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new ii,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new ii,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}Object.assign(aP.prototype,{update:function(e){const n=this._cache;if(n.focus!==e.focus||n.fov!==e.fov||n.aspect!==e.aspect*this.aspect||n.near!==e.near||n.far!==e.far||n.zoom!==e.zoom||n.eyeSep!==this.eyeSep){n.focus=e.focus,n.fov=e.fov,n.aspect=e.aspect*this.aspect,n.near=e.near,n.far=e.far,n.zoom=e.zoom,n.eyeSep=this.eyeSep;const i=e.projectionMatrix.clone(),r=n.eyeSep/2,a=r*n.near/n.focus,c=n.near*Math.tan(ln.DEG2RAD*n.fov*.5)/n.zoom;let u,l;Vx.elements[12]=-r,Gx.elements[12]=r,u=-c*n.aspect+a,l=c*n.aspect+a,i.elements[0]=2*n.near/(l-u),i.elements[8]=(l+u)/(l-u),this.cameraL.projectionMatrix.copy(i),u=-c*n.aspect-a,l=c*n.aspect-a,i.elements[0]=2*n.near/(l-u),i.elements[8]=(l+u)/(l-u),this.cameraR.projectionMatrix.copy(i)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Vx),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Gx)}});function jx(e){this.autoStart=e!==void 0?e:!0,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}Object.assign(jx.prototype,{start:function(){this.startTime=(typeof performance>"u"?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0},stop:function(){this.getElapsedTime(),this.running=!1,this.autoStart=!1},getElapsedTime:function(){return this.getDelta(),this.elapsedTime},getDelta:function(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const n=(typeof performance>"u"?Date:performance).now();e=(n-this.oldTime)/1e3,this.oldTime=n,this.elapsedTime+=e}return e}});const Fo=new ye,Wx=new pi,lP=new ye,Ro=new ye;function Hx(){Ot.call(this),this.type="AudioListener",this.context=$x.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new jx}Hx.prototype=Object.assign(Object.create(Ot.prototype),{constructor:Hx,getInput:function(){return this.gain},removeFilter:function(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this},getFilter:function(){return this.filter},setFilter:function(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this},getMasterVolume:function(){return this.gain.gain.value},setMasterVolume:function(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this},updateMatrixWorld:function(e){Ot.prototype.updateMatrixWorld.call(this,e);const n=this.context.listener,t=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Fo,Wx,lP),Ro.set(0,0,-1).applyQuaternion(Wx),n.positionX){const i=this.context.currentTime+this.timeDelta;n.positionX.linearRampToValueAtTime(Fo.x,i),n.positionY.linearRampToValueAtTime(Fo.y,i),n.positionZ.linearRampToValueAtTime(Fo.z,i),n.forwardX.linearRampToValueAtTime(Ro.x,i),n.forwardY.linearRampToValueAtTime(Ro.y,i),n.forwardZ.linearRampToValueAtTime(Ro.z,i),n.upX.linearRampToValueAtTime(t.x,i),n.upY.linearRampToValueAtTime(t.y,i),n.upZ.linearRampToValueAtTime(t.z,i)}else n.setPosition(Fo.x,Fo.y,Fo.z),n.setOrientation(Ro.x,Ro.y,Ro.z,t.x,t.y,t.z)}});function Ld(e){Ot.call(this),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.sourceType="empty",this._startedAt=0,this._progress=0,this.filters=[]}Ld.prototype=Object.assign(Object.create(Ot.prototype),{constructor:Ld,getOutput:function(){return this.gain},setNodeSource:function(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this},setMediaElementSource:function(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this},setMediaStreamSource:function(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this},setBuffer:function(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this},play:function(e){if(e===void 0&&(e=0),this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const n=this.context.createBufferSource();return n.buffer=this.buffer,n.loop=this.loop,n.loopStart=this.loopStart,n.loopEnd=this.loopEnd,n.onended=this.onEnded.bind(this),n.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=n,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()},pause:function(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this},stop:function(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this},connect:function(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,n=this.filters.length;e<n;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this},disconnect:function(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,n=this.filters.length;e<n;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this},getFilters:function(){return this.filters},setFilters:function(e){return e||(e=[]),this.isPlaying===!0?(this.disconnect(),this.filters=e,this.connect()):this.filters=e,this},setDetune:function(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this},getDetune:function(){return this.detune},getFilter:function(){return this.getFilters()[0]},setFilter:function(e){return this.setFilters(e?[e]:[])},setPlaybackRate:function(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this},getPlaybackRate:function(){return this.playbackRate},onEnded:function(){this.isPlaying=!1},getLoop:function(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop},setLoop:function(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this},setLoopStart:function(e){return this.loopStart=e,this},setLoopEnd:function(e){return this.loopEnd=e,this},getVolume:function(){return this.gain.gain.value},setVolume:function(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}});const Bo=new ye,qx=new pi,cP=new ye,zo=new ye;function Kx(e){Ld.call(this,e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}Kx.prototype=Object.assign(Object.create(Ld.prototype),{constructor:Kx,getOutput:function(){return this.panner},getRefDistance:function(){return this.panner.refDistance},setRefDistance:function(e){return this.panner.refDistance=e,this},getRolloffFactor:function(){return this.panner.rolloffFactor},setRolloffFactor:function(e){return this.panner.rolloffFactor=e,this},getDistanceModel:function(){return this.panner.distanceModel},setDistanceModel:function(e){return this.panner.distanceModel=e,this},getMaxDistance:function(){return this.panner.maxDistance},setMaxDistance:function(e){return this.panner.maxDistance=e,this},setDirectionalCone:function(e,n,t){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=n,this.panner.coneOuterGain=t,this},updateMatrixWorld:function(e){if(Ot.prototype.updateMatrixWorld.call(this,e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(Bo,qx,cP),zo.set(0,0,1).applyQuaternion(qx);const n=this.panner;if(n.positionX){const t=this.context.currentTime+this.listener.timeDelta;n.positionX.linearRampToValueAtTime(Bo.x,t),n.positionY.linearRampToValueAtTime(Bo.y,t),n.positionZ.linearRampToValueAtTime(Bo.z,t),n.orientationX.linearRampToValueAtTime(zo.x,t),n.orientationY.linearRampToValueAtTime(zo.y,t),n.orientationZ.linearRampToValueAtTime(zo.z,t)}else n.setPosition(Bo.x,Bo.y,Bo.z),n.setOrientation(zo.x,zo.y,zo.z)}});function Xx(e,n){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=n!==void 0?n:2048,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}Object.assign(Xx.prototype,{getFrequencyData:function(){return this.analyser.getByteFrequencyData(this.data),this.data},getAverageFrequency:function(){let e=0;const n=this.getFrequencyData();for(let t=0;t<n.length;t++)e+=n[t];return e/n.length}});function Yx(e,n,t){this.binding=e,this.valueSize=t;let i,r,a;switch(n){case"quaternion":i=this._slerp,r=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(t*6),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(t*5);break;default:i=this._lerp,r=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(t*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign(Yx.prototype,{accumulate:function(e,n){const t=this.buffer,i=this.valueSize,r=e*i+i;let a=this.cumulativeWeight;if(a===0){for(let c=0;c!==i;++c)t[r+c]=t[c];a=n}else{a+=n;const c=n/a;this._mixBufferRegion(t,r,0,c,i)}this.cumulativeWeight=a},accumulateAdditive:function(e){const n=this.buffer,t=this.valueSize,i=t*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(n,i,0,e,t),this.cumulativeWeightAdditive+=e},apply:function(e){const n=this.valueSize,t=this.buffer,i=e*n+n,r=this.cumulativeWeight,a=this.cumulativeWeightAdditive,c=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const u=n*this._origIndex;this._mixBufferRegion(t,i,u,1-r,n)}a>0&&this._mixBufferRegionAdditive(t,i,this._addIndex*n,1,n);for(let u=n,l=n+n;u!==l;++u)if(t[u]!==t[u+n]){c.setValue(t,i);break}},saveOriginalState:function(){const e=this.binding,n=this.buffer,t=this.valueSize,i=t*this._origIndex;e.getValue(n,i);for(let r=t,a=i;r!==a;++r)n[r]=n[i+r%t];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)},_setAdditiveIdentityNumeric:function(){const e=this._addIndex*this.valueSize,n=e+this.valueSize;for(let t=e;t<n;t++)this.buffer[t]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*4+3]=1},_setAdditiveIdentityOther:function(){const e=this._origIndex*this.valueSize,n=this._addIndex*this.valueSize;for(let t=0;t<this.valueSize;t++)this.buffer[n+t]=this.buffer[e+t]},_select:function(e,n,t,i,r){if(i>=.5)for(let a=0;a!==r;++a)e[n+a]=e[t+a]},_slerp:function(e,n,t,i){pi.slerpFlat(e,n,e,n,e,t,i)},_slerpAdditive:function(e,n,t,i,r){const a=this._workIndex*r;pi.multiplyQuaternionsFlat(e,a,e,n,e,t),pi.slerpFlat(e,n,e,n,e,a,i)},_lerp:function(e,n,t,i,r){const a=1-i;for(let c=0;c!==r;++c){const u=n+c;e[u]=e[u]*a+e[t+c]*i}},_lerpAdditive:function(e,n,t,i,r){for(let a=0;a!==r;++a){const c=n+a;e[c]=e[c]+e[t+a]*i}}});const _0="\\[\\]\\.:\\/",uP=new RegExp("["+_0+"]","g"),y0="[^"+_0+"]",dP="[^"+_0.replace("\\.","")+"]",hP=/((?:WC+[\/:])*)/.source.replace("WC",y0),fP=/(WCOD+)?/.source.replace("WCOD",dP),pP=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",y0),mP=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",y0),gP=new RegExp("^"+hP+fP+pP+mP+"$"),_P=["material","materials","bones"];function Jx(e,n,t){const i=t||Ri.parseTrackName(n);this._targetGroup=e,this._bindings=e.subscribe_(n,i)}Object.assign(Jx.prototype,{getValue:function(e,n){this.bind();const t=this._targetGroup.nCachedObjects_,i=this._bindings[t];i!==void 0&&i.getValue(e,n)},setValue:function(e,n){const t=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=t.length;i!==r;++i)t[i].setValue(e,n)},bind:function(){const e=this._bindings;for(let n=this._targetGroup.nCachedObjects_,t=e.length;n!==t;++n)e[n].bind()},unbind:function(){const e=this._bindings;for(let n=this._targetGroup.nCachedObjects_,t=e.length;n!==t;++n)e[n].unbind()}});function Ri(e,n,t){this.path=n,this.parsedPath=t||Ri.parseTrackName(n),this.node=Ri.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e}Object.assign(Ri,{Composite:Jx,create:function(e,n,t){return e&&e.isAnimationObjectGroup?new Ri.Composite(e,n,t):new Ri(e,n,t)},sanitizeNodeName:function(e){return e.replace(/\s/g,"_").replace(uP,"")},parseTrackName:function(e){const n=gP.exec(e);if(!n)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const t={nodeName:n[2],objectName:n[3],objectIndex:n[4],propertyName:n[5],propertyIndex:n[6]},i=t.nodeName&&t.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=t.nodeName.substring(i+1);_P.indexOf(r)!==-1&&(t.nodeName=t.nodeName.substring(0,i),t.objectName=r)}if(t.propertyName===null||t.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return t},findNode:function(e,n){if(!n||n===""||n==="."||n===-1||n===e.name||n===e.uuid)return e;if(e.skeleton){const t=e.skeleton.getBoneByName(n);if(t!==void 0)return t}if(e.children){const t=function(r){for(let a=0;a<r.length;a++){const c=r[a];if(c.name===n||c.uuid===n)return c;const u=t(c.children);if(u)return u}return null},i=t(e.children);if(i)return i}return null}}),Object.assign(Ri.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(n,t){n[t]=this.node[this.propertyName]},function(n,t){const i=this.resolvedProperty;for(let r=0,a=i.length;r!==a;++r)n[t++]=i[r]},function(n,t){n[t]=this.resolvedProperty[this.propertyIndex]},function(n,t){this.resolvedProperty.toArray(n,t)}],SetterByBindingTypeAndVersioning:[[function(n,t){this.targetObject[this.propertyName]=n[t]},function(n,t){this.targetObject[this.propertyName]=n[t],this.targetObject.needsUpdate=!0},function(n,t){this.targetObject[this.propertyName]=n[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(n,t){const i=this.resolvedProperty;for(let r=0,a=i.length;r!==a;++r)i[r]=n[t++]},function(n,t){const i=this.resolvedProperty;for(let r=0,a=i.length;r!==a;++r)i[r]=n[t++];this.targetObject.needsUpdate=!0},function(n,t){const i=this.resolvedProperty;for(let r=0,a=i.length;r!==a;++r)i[r]=n[t++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(n,t){this.resolvedProperty[this.propertyIndex]=n[t]},function(n,t){this.resolvedProperty[this.propertyIndex]=n[t],this.targetObject.needsUpdate=!0},function(n,t){this.resolvedProperty[this.propertyIndex]=n[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(n,t){this.resolvedProperty.fromArray(n,t)},function(n,t){this.resolvedProperty.fromArray(n,t),this.targetObject.needsUpdate=!0},function(n,t){this.resolvedProperty.fromArray(n,t),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(n,t){this.bind(),this.getValue(n,t)},setValue:function(n,t){this.bind(),this.setValue(n,t)},bind:function(){let e=this.node,n=this.parsedPath,t=n.objectName,i=n.propertyName,r=n.propertyIndex;if(e||(e=Ri.findNode(this.rootNode,n.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(t){let l=n.objectIndex;switch(t){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let f=0;f<e.length;f++)if(e[f].name===l){l=f;break}break;default:if(e[t]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[t]}if(l!==void 0){if(e[l]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[l]}}const a=e[i];if(a===void 0){const l=n.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+l+"."+i+" but it wasn't found.",e);return}let c=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?c=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(c=this.Versioning.MatrixWorldNeedsUpdate);let u=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(e.geometry.isBufferGeometry){if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}u=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=r}else a.fromArray!==void 0&&a.toArray!==void 0?(u=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(u=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[u],this.setValue=this.SetterByBindingTypeAndVersioning[u][c]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}),Object.assign(Ri.prototype,{_getValue_unbound:Ri.prototype.getValue,_setValue_unbound:Ri.prototype.setValue});function yP(){this.uuid=ln.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let t=0,i=arguments.length;t!==i;++t)e[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const n=this;this.stats={objects:{get total(){return n._objects.length},get inUse(){return this.total-n.nCachedObjects_}},get bindingsPerObject(){return n._bindings.length}}}Object.assign(yP.prototype,{isAnimationObjectGroup:!0,add:function(){const e=this._objects,n=this._indicesByUUID,t=this._paths,i=this._parsedPaths,r=this._bindings,a=r.length;let c,u=e.length,l=this.nCachedObjects_;for(let f=0,m=arguments.length;f!==m;++f){const h=arguments[f],p=h.uuid;let _=n[p];if(_===void 0){_=u++,n[p]=_,e.push(h);for(let v=0,S=a;v!==S;++v)r[v].push(new Ri(h,t[v],i[v]))}else if(_<l){c=e[_];const v=--l,S=e[v];n[S.uuid]=_,e[_]=S,n[p]=v,e[v]=h;for(let D=0,w=a;D!==w;++D){const T=r[D],F=T[v];let E=T[_];T[_]=F,E===void 0&&(E=new Ri(h,t[D],i[D])),T[v]=E}}else e[_]!==c&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l},remove:function(){const e=this._objects,n=this._indicesByUUID,t=this._bindings,i=t.length;let r=this.nCachedObjects_;for(let a=0,c=arguments.length;a!==c;++a){const u=arguments[a],l=u.uuid,f=n[l];if(f!==void 0&&f>=r){const m=r++,h=e[m];n[h.uuid]=f,e[f]=h,n[l]=m,e[m]=u;for(let p=0,_=i;p!==_;++p){const v=t[p],S=v[m],D=v[f];v[f]=S,v[m]=D}}}this.nCachedObjects_=r},uncache:function(){const e=this._objects,n=this._indicesByUUID,t=this._bindings,i=t.length;let r=this.nCachedObjects_,a=e.length;for(let c=0,u=arguments.length;c!==u;++c){const l=arguments[c],f=l.uuid,m=n[f];if(m!==void 0)if(delete n[f],m<r){const h=--r,p=e[h],_=--a,v=e[_];n[p.uuid]=m,e[m]=p,n[v.uuid]=h,e[h]=v,e.pop();for(let S=0,D=i;S!==D;++S){const w=t[S],T=w[h],F=w[_];w[m]=T,w[h]=F,w.pop()}}else{const h=--a,p=e[h];n[p.uuid]=m,e[m]=p,e.pop();for(let _=0,v=i;_!==v;++_){const S=t[_];S[m]=S[h],S.pop()}}}this.nCachedObjects_=r},subscribe_:function(e,n){let t=this._bindingsIndicesByPath,i=t[e],r=this._bindings;if(i!==void 0)return r[i];const a=this._paths,c=this._parsedPaths,u=this._objects,l=u.length,f=this.nCachedObjects_,m=new Array(l);i=r.length,t[e]=i,a.push(e),c.push(n),r.push(m);for(let h=f,p=u.length;h!==p;++h){const _=u[h];m[h]=new Ri(_,e,n)}return m},unsubscribe_:function(e){const n=this._bindingsIndicesByPath,t=n[e];if(t!==void 0){const i=this._paths,r=this._parsedPaths,a=this._bindings,c=a.length-1,u=a[c],l=e[c];n[l]=t,a[t]=u,a.pop(),r[t]=r[c],r.pop(),i[t]=i[c],i.pop()}}});function Qx(e,n,t,i){this._mixer=e,this._clip=n,this._localRoot=t||null,this.blendMode=i||n.blendMode;const r=n.tracks,a=r.length,c=new Array(a),u={endingStart:Ia,endingEnd:Ia};for(let l=0;l!==a;++l){const f=r[l].createInterpolant(null);c[l]=f,f.settings=u}this._interpolantSettings=u,this._interpolants=c,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=o1,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}Object.assign(Qx.prototype,{play:function(){return this._mixer._activateAction(this),this},stop:function(){return this._mixer._deactivateAction(this),this.reset()},reset:function(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()},isRunning:function(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)},isScheduled:function(){return this._mixer._isActiveAction(this)},startAt:function(e){return this._startTime=e,this},setLoop:function(e,n){return this.loop=e,this.repetitions=n,this},setEffectiveWeight:function(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()},getEffectiveWeight:function(){return this._effectiveWeight},fadeIn:function(e){return this._scheduleFading(e,0,1)},fadeOut:function(e){return this._scheduleFading(e,1,0)},crossFadeFrom:function(e,n,t){if(e.fadeOut(n),this.fadeIn(n),t){const i=this._clip.duration,r=e._clip.duration,a=r/i,c=i/r;e.warp(1,a,n),this.warp(c,1,n)}return this},crossFadeTo:function(e,n,t){return e.crossFadeFrom(this,n,t)},stopFading:function(){let e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this},setEffectiveTimeScale:function(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()},getEffectiveTimeScale:function(){return this._effectiveTimeScale},setDuration:function(e){return this.timeScale=this._clip.duration/e,this.stopWarping()},syncWith:function(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()},halt:function(e){return this.warp(this._effectiveTimeScale,0,e)},warp:function(e,n,t){const i=this._mixer,r=i.time,a=this.timeScale;let c=this._timeScaleInterpolant;c===null&&(c=i._lendControlInterpolant(),this._timeScaleInterpolant=c);const u=c.parameterPositions,l=c.sampleValues;return u[0]=r,u[1]=r+t,l[0]=e/a,l[1]=n/a,this},stopWarping:function(){let e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this},getMixer:function(){return this._mixer},getClip:function(){return this._clip},getRoot:function(){return this._localRoot||this._mixer._root},_update:function(e,n,t,i){if(!this.enabled){this._updateWeight(e);return}const r=this._startTime;if(r!==null){const u=(e-r)*t;if(u<0||t===0)return;this._startTime=null,n=t*u}n*=this._updateTimeScale(e);const a=this._updateTime(n),c=this._updateWeight(e);if(c>0){const u=this._interpolants,l=this._propertyBindings;switch(this.blendMode){case _w:for(let f=0,m=u.length;f!==m;++f)u[f].evaluate(a),l[f].accumulateAdditive(c);break;case ev:default:for(let f=0,m=u.length;f!==m;++f)u[f].evaluate(a),l[f].accumulate(i,c)}}},_updateWeight:function(e){let n=0;if(this.enabled){n=this.weight;const t=this._weightInterpolant;if(t!==null){const i=t.evaluate(e)[0];n*=i,e>t.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=n,n},_updateTimeScale:function(e){let n=0;if(!this.paused){n=this.timeScale;const t=this._timeScaleInterpolant;if(t!==null){const i=t.evaluate(e)[0];n*=i,e>t.parameterPositions[1]&&(this.stopWarping(),n===0?this.paused=!0:this.timeScale=n)}}return this._effectiveTimeScale=n,n},_updateTime:function(e){const n=this._clip.duration,t=this.loop;let i=this.time+e,r=this._loopCount;const a=t===a1;if(e===0)return r===-1?i:a&&(r&1)===1?n-i:i;if(t===r1){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=n)i=n;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(r===-1&&(e>=0?(r=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),i>=n||i<0){const c=Math.floor(i/n);i-=n*c,r+=Math.abs(c);const u=this.repetitions-r;if(u<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?n:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(u===1){const l=e<0;this._setEndings(l,!l,a)}else this._setEndings(!1,!1,a);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:c})}}else this.time=i;if(a&&(r&1)===1)return n-i}return i},_setEndings:function(e,n,t){const i=this._interpolantSettings;t?(i.endingStart=La,i.endingEnd=La):(e?i.endingStart=this.zeroSlopeAtStart?La:Ia:i.endingStart=Ag,n?i.endingEnd=this.zeroSlopeAtEnd?La:Ia:i.endingEnd=Ag)},_scheduleFading:function(e,n,t){const i=this._mixer,r=i.time;let a=this._weightInterpolant;a===null&&(a=i._lendControlInterpolant(),this._weightInterpolant=a);const c=a.parameterPositions,u=a.sampleValues;return c[0]=r,u[0]=n,c[1]=r+e,u[1]=t,this}});function Zx(e){this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}Zx.prototype=Object.assign(Object.create(yr.prototype),{constructor:Zx,_bindAction:function(e,n){const t=e._localRoot||this._root,i=e._clip.tracks,r=i.length,a=e._propertyBindings,c=e._interpolants,u=t.uuid,l=this._bindingsByRootAndName;let f=l[u];f===void 0&&(f={},l[u]=f);for(let m=0;m!==r;++m){const h=i[m],p=h.name;let _=f[p];if(_!==void 0)a[m]=_;else{if(_=a[m],_!==void 0){_._cacheIndex===null&&(++_.referenceCount,this._addInactiveBinding(_,u,p));continue}const v=n&&n._propertyBindings[m].binding.parsedPath;_=new Yx(Ri.create(t,p,v),h.ValueTypeName,h.getValueSize()),++_.referenceCount,this._addInactiveBinding(_,u,p),a[m]=_}c[m].resultBuffer=_.buffer}},_activateAction:function(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const t=(e._localRoot||this._root).uuid,i=e._clip.uuid,r=this._actionsByClip[i];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,i,t)}const n=e._propertyBindings;for(let t=0,i=n.length;t!==i;++t){const r=n[t];r.useCount++===0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(e)}},_deactivateAction:function(e){if(this._isActiveAction(e)){const n=e._propertyBindings;for(let t=0,i=n.length;t!==i;++t){const r=n[t];--r.useCount===0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(e)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}},_isActiveAction:function(e){const n=e._cacheIndex;return n!==null&&n<this._nActiveActions},_addInactiveAction:function(e,n,t){const i=this._actions,r=this._actionsByClip;let a=r[n];if(a===void 0)a={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,r[n]=a;else{const c=a.knownActions;e._byClipCacheIndex=c.length,c.push(e)}e._cacheIndex=i.length,i.push(e),a.actionByRoot[t]=e},_removeInactiveAction:function(e){const n=this._actions,t=n[n.length-1],i=e._cacheIndex;t._cacheIndex=i,n[i]=t,n.pop(),e._cacheIndex=null;const r=e._clip.uuid,a=this._actionsByClip,c=a[r],u=c.knownActions,l=u[u.length-1],f=e._byClipCacheIndex;l._byClipCacheIndex=f,u[f]=l,u.pop(),e._byClipCacheIndex=null;const m=c.actionByRoot,h=(e._localRoot||this._root).uuid;delete m[h],u.length===0&&delete a[r],this._removeInactiveBindingsForAction(e)},_removeInactiveBindingsForAction:function(e){const n=e._propertyBindings;for(let t=0,i=n.length;t!==i;++t){const r=n[t];--r.referenceCount===0&&this._removeInactiveBinding(r)}},_lendAction:function(e){const n=this._actions,t=e._cacheIndex,i=this._nActiveActions++,r=n[i];e._cacheIndex=i,n[i]=e,r._cacheIndex=t,n[t]=r},_takeBackAction:function(e){const n=this._actions,t=e._cacheIndex,i=--this._nActiveActions,r=n[i];e._cacheIndex=i,n[i]=e,r._cacheIndex=t,n[t]=r},_addInactiveBinding:function(e,n,t){const i=this._bindingsByRootAndName,r=this._bindings;let a=i[n];a===void 0&&(a={},i[n]=a),a[t]=e,e._cacheIndex=r.length,r.push(e)},_removeInactiveBinding:function(e){const n=this._bindings,t=e.binding,i=t.rootNode.uuid,r=t.path,a=this._bindingsByRootAndName,c=a[i],u=n[n.length-1],l=e._cacheIndex;u._cacheIndex=l,n[l]=u,n.pop(),delete c[r],Object.keys(c).length===0&&delete a[i]},_lendBinding:function(e){const n=this._bindings,t=e._cacheIndex,i=this._nActiveBindings++,r=n[i];e._cacheIndex=i,n[i]=e,r._cacheIndex=t,n[t]=r},_takeBackBinding:function(e){const n=this._bindings,t=e._cacheIndex,i=--this._nActiveBindings,r=n[i];e._cacheIndex=i,n[i]=e,r._cacheIndex=t,n[t]=r},_lendControlInterpolant:function(){const e=this._controlInterpolants,n=this._nActiveControlInterpolants++;let t=e[n];return t===void 0&&(t=new I_(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),t.__cacheIndex=n,e[n]=t),t},_takeBackControlInterpolant:function(e){const n=this._controlInterpolants,t=e.__cacheIndex,i=--this._nActiveControlInterpolants,r=n[i];e.__cacheIndex=i,n[i]=e,r.__cacheIndex=t,n[t]=r},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(e,n,t){const i=n||this._root,r=i.uuid;let a=typeof e=="string"?ks.findByName(i,e):e;const c=a!==null?a.uuid:e;let u=this._actionsByClip[c],l=null;if(t===void 0&&(a!==null?t=a.blendMode:t=ev),u!==void 0){const m=u.actionByRoot[r];if(m!==void 0&&m.blendMode===t)return m;l=u.knownActions[0],a===null&&(a=l._clip)}if(a===null)return null;const f=new Qx(this,a,n,t);return this._bindAction(f,l),this._addInactiveAction(f,c,r),f},existingAction:function(e,n){const t=n||this._root,i=t.uuid,r=typeof e=="string"?ks.findByName(t,e):e,a=r?r.uuid:e,c=this._actionsByClip[a];return c!==void 0&&c.actionByRoot[i]||null},stopAllAction:function(){const e=this._actions,n=this._nActiveActions;for(let t=n-1;t>=0;--t)e[t].stop();return this},update:function(e){e*=this.timeScale;const n=this._actions,t=this._nActiveActions,i=this.time+=e,r=Math.sign(e),a=this._accuIndex^=1;for(let l=0;l!==t;++l)n[l]._update(i,e,r,a);const c=this._bindings,u=this._nActiveBindings;for(let l=0;l!==u;++l)c[l].apply(a);return this},setTime:function(e){this.time=0;for(let n=0;n<this._actions.length;n++)this._actions[n].time=0;return this.update(e)},getRoot:function(){return this._root},uncacheClip:function(e){const n=this._actions,t=e.uuid,i=this._actionsByClip,r=i[t];if(r!==void 0){const a=r.knownActions;for(let c=0,u=a.length;c!==u;++c){const l=a[c];this._deactivateAction(l);const f=l._cacheIndex,m=n[n.length-1];l._cacheIndex=null,l._byClipCacheIndex=null,m._cacheIndex=f,n[f]=m,n.pop(),this._removeInactiveBindingsForAction(l)}delete i[t]}},uncacheRoot:function(e){const n=e.uuid,t=this._actionsByClip;for(const a in t){const c=t[a].actionByRoot,u=c[n];u!==void 0&&(this._deactivateAction(u),this._removeInactiveAction(u))}const i=this._bindingsByRootAndName,r=i[n];if(r!==void 0)for(const a in r){const c=r[a];c.restoreOriginalState(),this._removeInactiveBinding(c)}},uncacheAction:function(e,n){const t=this.existingAction(e,n);t!==null&&(this._deactivateAction(t),this._removeInactiveAction(t))}});function v0(e){typeof e=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}v0.prototype.clone=function(){return new v0(this.value.clone===void 0?this.value:this.value.clone())};function eb(e,n,t){_s.call(this,e,n),this.meshPerAttribute=t||1}eb.prototype=Object.assign(Object.create(_s.prototype),{constructor:eb,isInstancedInterleavedBuffer:!0,copy:function(e){return _s.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},clone:function(e){const n=_s.prototype.clone.call(this,e);return n.meshPerAttribute=this.meshPerAttribute,n},toJSON:function(e){const n=_s.prototype.toJSON.call(this,e);return n.isInstancedInterleavedBuffer=!0,n.meshPerAttribute=this.meshPerAttribute,n}});function w0(e,n,t,i){this.ray=new Na(e,n),this.near=t||0,this.far=i||1/0,this.camera=null,this.layers=new rv,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function tb(e,n){return e.distance-n.distance}function x0(e,n,t,i){if(e.layers.test(n.layers)&&e.raycast(n,t),i===!0){const r=e.children;for(let a=0,c=r.length;a<c;a++)x0(r[a],n,t,!0)}}Object.assign(w0.prototype,{set:function(e,n){this.ray.set(e,n)},setFromCamera:function(e,n){n&&n.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(n.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(n).sub(this.ray.origin).normalize(),this.camera=n):n&&n.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(n.near+n.far)/(n.near-n.far)).unproject(n),this.ray.direction.set(0,0,-1).transformDirection(n.matrixWorld),this.camera=n):console.error("THREE.Raycaster: Unsupported camera type.")},intersectObject:function(e,n,t){const i=t||[];return x0(e,this,i,n),i.sort(tb),i},intersectObjects:function(e,n,t){const i=t||[];if(Array.isArray(e)===!1)return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),i;for(let r=0,a=e.length;r<a;r++)x0(e[r],this,i,n);return i.sort(tb),i}});function vP(e,n,t){return this.radius=e!==void 0?e:1,this.theta=n!==void 0?n:0,this.y=t!==void 0?t:0,this}Object.assign(vP.prototype,{set:function(e,n,t){return this.radius=e,this.theta=n,this.y=t,this},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this},setFromVector3:function(e){return this.setFromCartesianCoords(e.x,e.y,e.z)},setFromCartesianCoords:function(e,n,t){return this.radius=Math.sqrt(e*e+t*t),this.theta=Math.atan2(e,t),this.y=n,this}});const nb=new vt;function ib(e,n){this.min=e!==void 0?e:new vt(1/0,1/0),this.max=n!==void 0?n:new vt(-1/0,-1/0)}Object.assign(ib.prototype,{set:function(e,n){return this.min.copy(e),this.max.copy(n),this},setFromPoints:function(e){this.makeEmpty();for(let n=0,t=e.length;n<t;n++)this.expandByPoint(e[n]);return this},setFromCenterAndSize:function(e,n){const t=nb.copy(n).multiplyScalar(.5);return this.min.copy(e).sub(t),this.max.copy(e).add(t),this},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.min.copy(e.min),this.max.copy(e.max),this},makeEmpty:function(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},getCenter:function(e){return e===void 0&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new vt),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(e){return e===void 0&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new vt),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)},expandByPoint:function(e){return this.min.min(e),this.max.max(e),this},expandByVector:function(e){return this.min.sub(e),this.max.add(e),this},expandByScalar:function(e){return this.min.addScalar(-e),this.max.addScalar(e),this},containsPoint:function(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)},containsBox:function(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y},getParameter:function(e,n){return n===void 0&&(console.warn("THREE.Box2: .getParameter() target is now required"),n=new vt),n.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))},intersectsBox:function(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)},clampPoint:function(e,n){return n===void 0&&(console.warn("THREE.Box2: .clampPoint() target is now required"),n=new vt),n.copy(e).clamp(this.min,this.max)},distanceToPoint:function(e){return nb.copy(e).clamp(this.min,this.max).sub(e).length()},intersect:function(e){return this.min.max(e.min),this.max.min(e.max),this},union:function(e){return this.min.min(e.min),this.max.max(e.max),this},translate:function(e){return this.min.add(e),this.max.add(e),this},equals:function(e){return e.min.equals(this.min)&&e.max.equals(this.max)}});const sb=new ye,$_=new ye;function rb(e,n){this.start=e!==void 0?e:new ye,this.end=n!==void 0?n:new ye}Object.assign(rb.prototype,{set:function(e,n){return this.start.copy(e),this.end.copy(n),this},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.start.copy(e.start),this.end.copy(e.end),this},getCenter:function(e){return e===void 0&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new ye),e.addVectors(this.start,this.end).multiplyScalar(.5)},delta:function(e){return e===void 0&&(console.warn("THREE.Line3: .delta() target is now required"),e=new ye),e.subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(e,n){return n===void 0&&(console.warn("THREE.Line3: .at() target is now required"),n=new ye),this.delta(n).multiplyScalar(e).add(this.start)},closestPointToPointParameter:function(e,n){sb.subVectors(e,this.start),$_.subVectors(this.end,this.start);const t=$_.dot($_);let r=$_.dot(sb)/t;return n&&(r=ln.clamp(r,0,1)),r},closestPointToPoint:function(e,n,t){const i=this.closestPointToPointParameter(e,n);return t===void 0&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),t=new ye),this.delta(t).multiplyScalar(i).add(this.start)},applyMatrix4:function(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this},equals:function(e){return e.start.equals(this.start)&&e.end.equals(this.end)}});function N_(e){Ot.call(this),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}N_.prototype=Object.create(Ot.prototype),N_.prototype.constructor=N_,N_.prototype.isImmediateRenderObject=!0;const ob=new ye;function Dd(e,n){Ot.call(this),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const t=new Ut,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let a=0,c=1,u=32;a<u;a++,c++){const l=a/u*Math.PI*2,f=c/u*Math.PI*2;i.push(Math.cos(l),Math.sin(l),1,Math.cos(f),Math.sin(f),1)}t.setAttribute("position",new Bt(i,3));const r=new Yn({fog:!1,toneMapped:!1});this.cone=new si(t,r),this.add(this.cone),this.update()}Dd.prototype=Object.create(Ot.prototype),Dd.prototype.constructor=Dd,Dd.prototype.dispose=function(){this.cone.geometry.dispose(),this.cone.material.dispose()},Dd.prototype.update=function(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,n=e*Math.tan(this.light.angle);this.cone.scale.set(n,n,e),ob.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(ob),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)};const io=new ye,U_=new dn,b0=new dn;function ab(e){const n=[];e&&e.isBone&&n.push(e);for(let t=0;t<e.children.length;t++)n.push.apply(n,ab(e.children[t]));return n}function yl(e){const n=ab(e),t=new Ut,i=[],r=[],a=new jt(0,0,1),c=new jt(0,1,0);for(let l=0;l<n.length;l++){const f=n[l];f.parent&&f.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(a.r,a.g,a.b),r.push(c.r,c.g,c.b))}t.setAttribute("position",new Bt(i,3)),t.setAttribute("color",new Bt(r,3));const u=new Yn({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});si.call(this,t,u),this.type="SkeletonHelper",this.root=e,this.bones=n,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}yl.prototype=Object.create(si.prototype),yl.prototype.constructor=yl,yl.prototype.isSkeletonHelper=!0,yl.prototype.updateMatrixWorld=function(e){const n=this.bones,t=this.geometry,i=t.getAttribute("position");b0.getInverse(this.root.matrixWorld);for(let r=0,a=0;r<n.length;r++){const c=n[r];c.parent&&c.parent.isBone&&(U_.multiplyMatrices(b0,c.matrixWorld),io.setFromMatrixPosition(U_),i.setXYZ(a,io.x,io.y,io.z),U_.multiplyMatrices(b0,c.parent.matrixWorld),io.setFromMatrixPosition(U_),i.setXYZ(a+1,io.x,io.y,io.z),a+=2)}t.getAttribute("position").needsUpdate=!0,Ot.prototype.updateMatrixWorld.call(this,e)};function kd(e,n,t){this.light=e,this.light.updateMatrixWorld(),this.color=t;const i=new ll(n,4,2),r=new ms({wireframe:!0,fog:!1,toneMapped:!1});Ln.call(this,i,r),this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}kd.prototype=Object.create(Ln.prototype),kd.prototype.constructor=kd,kd.prototype.dispose=function(){this.geometry.dispose(),this.material.dispose()},kd.prototype.update=function(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)};const wP=new ye,lb=new jt,cb=new jt;function Od(e,n,t){Ot.call(this),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const i=new sl(n);i.rotateY(Math.PI*.5),this.material=new ms({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const r=i.getAttribute("position"),a=new Float32Array(r.count*3);i.setAttribute("color",new Kt(a,3)),this.add(new Ln(i,this.material)),this.update()}Od.prototype=Object.create(Ot.prototype),Od.prototype.constructor=Od,Od.prototype.dispose=function(){this.children[0].geometry.dispose(),this.children[0].material.dispose()},Od.prototype.update=function(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const n=e.geometry.getAttribute("color");lb.copy(this.light.color),cb.copy(this.light.groundColor);for(let t=0,i=n.count;t<i;t++){const r=t<i/2?lb:cb;n.setXYZ(t,r.r,r.g,r.b)}n.needsUpdate=!0}e.lookAt(wP.setFromMatrixPosition(this.light.matrixWorld).negate())};function G_(e,n,t,i){e=e||10,n=n||10,t=new jt(t!==void 0?t:4473924),i=new jt(i!==void 0?i:8947848);const r=n/2,a=e/n,c=e/2,u=[],l=[];for(let h=0,p=0,_=-c;h<=n;h++,_+=a){u.push(-c,0,_,c,0,_),u.push(_,0,-c,_,0,c);const v=h===r?t:i;v.toArray(l,p),p+=3,v.toArray(l,p),p+=3,v.toArray(l,p),p+=3,v.toArray(l,p),p+=3}const f=new Ut;f.setAttribute("position",new Bt(u,3)),f.setAttribute("color",new Bt(l,3));const m=new Yn({vertexColors:!0,toneMapped:!1});si.call(this,f,m),this.type="GridHelper"}G_.prototype=Object.create(si.prototype),G_.prototype.constructor=G_;function M0(e,n,t,i,r,a){e=e||10,n=n||16,t=t||8,i=i||64,r=new jt(r!==void 0?r:4473924),a=new jt(a!==void 0?a:8947848);const c=[],u=[];for(let m=0;m<=n;m++){const h=m/n*(Math.PI*2),p=Math.sin(h)*e,_=Math.cos(h)*e;c.push(0,0,0),c.push(p,0,_);const v=m&1?r:a;u.push(v.r,v.g,v.b),u.push(v.r,v.g,v.b)}for(let m=0;m<=t;m++){const h=m&1?r:a,p=e-e/t*m;for(let _=0;_<i;_++){let v=_/i*(Math.PI*2),S=Math.sin(v)*p,D=Math.cos(v)*p;c.push(S,0,D),u.push(h.r,h.g,h.b),v=(_+1)/i*(Math.PI*2),S=Math.sin(v)*p,D=Math.cos(v)*p,c.push(S,0,D),u.push(h.r,h.g,h.b)}}const l=new Ut;l.setAttribute("position",new Bt(c,3)),l.setAttribute("color",new Bt(u,3));const f=new Yn({vertexColors:!0,toneMapped:!1});si.call(this,l,f),this.type="PolarGridHelper"}M0.prototype=Object.create(si.prototype),M0.prototype.constructor=M0;const ub=new ye,V_=new ye,db=new ye;function Fd(e,n,t){Ot.call(this),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t,n===void 0&&(n=1);let i=new Ut;i.setAttribute("position",new Bt([-n,n,0,n,n,0,n,-n,0,-n,-n,0,-n,n,0],3));const r=new Yn({fog:!1,toneMapped:!1});this.lightPlane=new ys(i,r),this.add(this.lightPlane),i=new Ut,i.setAttribute("position",new Bt([0,0,0,0,0,1],3)),this.targetLine=new ys(i,r),this.add(this.targetLine),this.update()}Fd.prototype=Object.create(Ot.prototype),Fd.prototype.constructor=Fd,Fd.prototype.dispose=function(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()},Fd.prototype.update=function(){ub.setFromMatrixPosition(this.light.matrixWorld),V_.setFromMatrixPosition(this.light.target.matrixWorld),db.subVectors(V_,ub),this.lightPlane.lookAt(V_),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(V_),this.targetLine.scale.z=db.length()};const j_=new ye,Jn=new Er;function W_(e){const n=new Ut,t=new Yn({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],a={},c=new jt(16755200),u=new jt(16711680),l=new jt(43775),f=new jt(16777215),m=new jt(3355443);h("n1","n2",c),h("n2","n4",c),h("n4","n3",c),h("n3","n1",c),h("f1","f2",c),h("f2","f4",c),h("f4","f3",c),h("f3","f1",c),h("n1","f1",c),h("n2","f2",c),h("n3","f3",c),h("n4","f4",c),h("p","n1",u),h("p","n2",u),h("p","n3",u),h("p","n4",u),h("u1","u2",l),h("u2","u3",l),h("u3","u1",l),h("c","t",f),h("p","c",m),h("cn1","cn2",m),h("cn3","cn4",m),h("cf1","cf2",m),h("cf3","cf4",m);function h(_,v,S){p(_,S),p(v,S)}function p(_,v){i.push(0,0,0),r.push(v.r,v.g,v.b),a[_]===void 0&&(a[_]=[]),a[_].push(i.length/3-1)}n.setAttribute("position",new Bt(i,3)),n.setAttribute("color",new Bt(r,3)),si.call(this,n,t),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=a,this.update()}W_.prototype=Object.create(si.prototype),W_.prototype.constructor=W_,W_.prototype.update=function(){const e=this.geometry,n=this.pointMap,t=1,i=1;Jn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),ei("c",n,e,Jn,0,0,-1),ei("t",n,e,Jn,0,0,1),ei("n1",n,e,Jn,-t,-i,-1),ei("n2",n,e,Jn,t,-i,-1),ei("n3",n,e,Jn,-t,i,-1),ei("n4",n,e,Jn,t,i,-1),ei("f1",n,e,Jn,-t,-i,1),ei("f2",n,e,Jn,t,-i,1),ei("f3",n,e,Jn,-t,i,1),ei("f4",n,e,Jn,t,i,1),ei("u1",n,e,Jn,t*.7,i*1.1,-1),ei("u2",n,e,Jn,-t*.7,i*1.1,-1),ei("u3",n,e,Jn,0,i*2,-1),ei("cf1",n,e,Jn,-t,0,1),ei("cf2",n,e,Jn,t,0,1),ei("cf3",n,e,Jn,0,-i,1),ei("cf4",n,e,Jn,0,i,1),ei("cn1",n,e,Jn,-t,0,-1),ei("cn2",n,e,Jn,t,0,-1),ei("cn3",n,e,Jn,0,-i,-1),ei("cn4",n,e,Jn,0,i,-1),e.getAttribute("position").needsUpdate=!0};function ei(e,n,t,i,r,a,c){j_.set(r,a,c).unproject(i);const u=n[e];if(u!==void 0){const l=t.getAttribute("position");for(let f=0,m=u.length;f<m;f++)l.setXYZ(u[f],j_.x,j_.y,j_.z)}}const H_=new qs;function vl(e,n){this.object=e,n===void 0&&(n=16776960);const t=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(8*3),r=new Ut;r.setIndex(new Kt(t,1)),r.setAttribute("position",new Kt(i,3)),si.call(this,r,new Yn({color:n,toneMapped:!1})),this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}vl.prototype=Object.create(si.prototype),vl.prototype.constructor=vl,vl.prototype.update=function(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&H_.setFromObject(this.object),H_.isEmpty())return;const n=H_.min,t=H_.max,i=this.geometry.attributes.position,r=i.array;r[0]=t.x,r[1]=t.y,r[2]=t.z,r[3]=n.x,r[4]=t.y,r[5]=t.z,r[6]=n.x,r[7]=n.y,r[8]=t.z,r[9]=t.x,r[10]=n.y,r[11]=t.z,r[12]=t.x,r[13]=t.y,r[14]=n.z,r[15]=n.x,r[16]=t.y,r[17]=n.z,r[18]=n.x,r[19]=n.y,r[20]=n.z,r[21]=t.x,r[22]=n.y,r[23]=n.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()},vl.prototype.setFromObject=function(e){return this.object=e,this.update(),this},vl.prototype.copy=function(e){return si.prototype.copy.call(this,e),this.object=e.object,this};function q_(e,n){this.type="Box3Helper",this.box=e,n===void 0&&(n=16776960);const t=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],r=new Ut;r.setIndex(new Kt(t,1)),r.setAttribute("position",new Bt(i,3)),si.call(this,r,new Yn({color:n,toneMapped:!1})),this.type="Box3Helper",this.geometry.computeBoundingSphere()}q_.prototype=Object.create(si.prototype),q_.prototype.constructor=q_,q_.prototype.updateMatrixWorld=function(e){const n=this.box;n.isEmpty()||(n.getCenter(this.position),n.getSize(this.scale),this.scale.multiplyScalar(.5),Ot.prototype.updateMatrixWorld.call(this,e))};function K_(e,n,t){this.plane=e,this.size=n===void 0?1:n;const i=t!==void 0?t:16776960,r=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],a=new Ut;a.setAttribute("position",new Bt(r,3)),a.computeBoundingSphere(),ys.call(this,a,new Yn({color:i,toneMapped:!1})),this.type="PlaneHelper";const c=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],u=new Ut;u.setAttribute("position",new Bt(c,3)),u.computeBoundingSphere(),this.add(new Ln(u,new ms({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}K_.prototype=Object.create(ys.prototype),K_.prototype.constructor=K_,K_.prototype.updateMatrixWorld=function(e){let n=-this.plane.constant;Math.abs(n)<1e-8&&(n=1e-8),this.scale.set(.5*this.size,.5*this.size,n),this.children[0].material.side=n<0?li:Ou,this.lookAt(this.plane.normal),Ot.prototype.updateMatrixWorld.call(this,e)};const hb=new ye;let X_,T0;function $o(e,n,t,i,r,a){Ot.call(this),this.type="ArrowHelper",e===void 0&&(e=new ye(0,0,1)),n===void 0&&(n=new ye(0,0,0)),t===void 0&&(t=1),i===void 0&&(i=16776960),r===void 0&&(r=.2*t),a===void 0&&(a=.2*r),X_===void 0&&(X_=new Ut,X_.setAttribute("position",new Bt([0,0,0,0,1,0],3)),T0=new eo(0,.5,1,5,1),T0.translate(0,-.5,0)),this.position.copy(n),this.line=new ys(X_,new Yn({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Ln(T0,new ms({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(t,r,a)}$o.prototype=Object.create(Ot.prototype),$o.prototype.constructor=$o,$o.prototype.setDirection=function(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{hb.set(e.z,0,-e.x).normalize();const n=Math.acos(e.y);this.quaternion.setFromAxisAngle(hb,n)}},$o.prototype.setLength=function(e,n,t){n===void 0&&(n=.2*e),t===void 0&&(t=.2*n),this.line.scale.set(1,Math.max(1e-4,e-n),1),this.line.updateMatrix(),this.cone.scale.set(t,n,t),this.cone.position.y=e,this.cone.updateMatrix()},$o.prototype.setColor=function(e){this.line.material.color.set(e),this.cone.material.color.set(e)},$o.prototype.copy=function(e){return Ot.prototype.copy.call(this,e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this};function E0(e){e=e||1;const n=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],t=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new Ut;i.setAttribute("position",new Bt(n,3)),i.setAttribute("color",new Bt(t,3));const r=new Yn({vertexColors:!0,toneMapped:!1});si.call(this,i,r),this.type="AxesHelper"}E0.prototype=Object.create(si.prototype),E0.prototype.constructor=E0;const wl=4,so=8,sr=Math.pow(2,so),fb=[.125,.215,.35,.446,.526,.582],pb=so-wl+1+fb.length,xl=20,rr={[Ui]:0,[Cg]:1,[nv]:2,[yw]:3,[vw]:4,[ww]:5,[tv]:6},S0=new Id,{_lodPlanes:Rd,_sizeLods:mb,_sigmas:Y_}=bP();let P0=null;const No=(1+Math.sqrt(5))/2,bl=1/No,gb=[new ye(1,1,1),new ye(-1,1,1),new ye(1,1,-1),new ye(-1,1,-1),new ye(0,No,bl),new ye(0,No,-bl),new ye(bl,0,No),new ye(-bl,0,No),new ye(No,bl,0),new ye(-No,bl,0)];function _b(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=MP(xl),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}_b.prototype={constructor:_b,fromScene:function(e,n=0,t=.1,i=100){P0=this._renderer.getRenderTarget();const r=this._allocateTargets();return this._sceneToCubeUV(e,t,i,r),n>0&&this._blur(r,0,0,n),this._applyPMREM(r),this._cleanup(r),r},fromEquirectangular:function(e){return this._fromTexture(e)},fromCubemap:function(e){return this._fromTexture(e)},compileCubemapShader:function(){this._cubemapShader===null&&(this._cubemapShader=wb(),this._compileMaterial(this._cubemapShader))},compileEquirectangularShader:function(){this._equirectShader===null&&(this._equirectShader=vb(),this._compileMaterial(this._equirectShader))},dispose:function(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<Rd.length;e++)Rd[e].dispose()},_cleanup:function(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(P0),e.scissorTest=!1,J_(e,0,0,e.width,e.height)},_fromTexture:function(e){P0=this._renderer.getRenderTarget();const n=this._allocateTargets(e);return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n},_allocateTargets:function(e){const n={magFilter:fi,minFilter:fi,generateMipmaps:!1,type:Bu,format:bM,encoding:xP(e)?e.encoding:nv,depthBuffer:!1,stencilBuffer:!1},t=yb(n);return t.depthBuffer=!e,this._pingPongRenderTarget=yb(n),t},_compileMaterial:function(e){const n=new Ln(Rd[0],e);this._renderer.compile(n,S0)},_sceneToCubeUV:function(e,n,t,i){const c=new ii(90,1,n,t),u=[1,-1,1,1,1,1],l=[1,1,1,-1,-1,-1],f=this._renderer,m=f.outputEncoding,h=f.toneMapping,p=f.getClearColor(),_=f.getClearAlpha();f.toneMapping=Aa,f.outputEncoding=Ui;let v=e.background;if(v&&v.isColor){v.convertSRGBToLinear();const S=Math.max(v.r,v.g,v.b),D=Math.min(Math.max(Math.ceil(Math.log2(S)),-128),127);v=v.multiplyScalar(Math.pow(2,-D));const w=(D+128)/255;f.setClearColor(v,w),e.background=null}for(let S=0;S<6;S++){const D=S%3;D==0?(c.up.set(0,u[S],0),c.lookAt(l[S],0,0)):D==1?(c.up.set(0,0,u[S]),c.lookAt(0,l[S],0)):(c.up.set(0,u[S],0),c.lookAt(0,0,l[S])),J_(i,D*sr,S>2?sr:0,sr,sr),f.setRenderTarget(i),f.render(e,c)}f.toneMapping=h,f.outputEncoding=m,f.setClearColor(p,_)},_textureToCubeUV:function(e,n){const t=this._renderer;e.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=wb()):this._equirectShader==null&&(this._equirectShader=vb());const i=e.isCubeTexture?this._cubemapShader:this._equirectShader,r=new Ln(Rd[0],i),a=i.uniforms;a.envMap.value=e,e.isCubeTexture||a.texelSize.value.set(1/e.image.width,1/e.image.height),a.inputEncoding.value=rr[e.encoding],a.outputEncoding.value=rr[n.texture.encoding],J_(n,0,0,3*sr,2*sr),t.setRenderTarget(n),t.render(r,S0)},_applyPMREM:function(e){const n=this._renderer,t=n.autoClear;n.autoClear=!1;for(let i=1;i<pb;i++){const r=Math.sqrt(Y_[i]*Y_[i]-Y_[i-1]*Y_[i-1]),a=gb[(i-1)%gb.length];this._blur(e,i-1,i,r,a)}n.autoClear=t},_blur:function(e,n,t,i,r){const a=this._pingPongRenderTarget;this._halfBlur(e,a,n,t,i,"latitudinal",r),this._halfBlur(a,e,t,t,i,"longitudinal",r)},_halfBlur:function(e,n,t,i,r,a,c){const u=this._renderer,l=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const f=3,m=new Ln(Rd[i],l),h=l.uniforms,p=mb[t]-1,_=isFinite(r)?Math.PI/(2*p):2*Math.PI/(2*xl-1),v=r/_,S=isFinite(r)?1+Math.floor(f*v):xl;S>xl&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${S} samples when the maximum is set to ${xl}`);const D=[];let w=0;for(let A=0;A<xl;++A){const L=A/v,I=Math.exp(-L*L/2);D.push(I),A==0?w+=I:A<S&&(w+=2*I)}for(let A=0;A<D.length;A++)D[A]=D[A]/w;h.envMap.value=e.texture,h.samples.value=S,h.weights.value=D,h.latitudinal.value=a==="latitudinal",c&&(h.poleAxis.value=c),h.dTheta.value=_,h.mipInt.value=so-t,h.inputEncoding.value=rr[e.texture.encoding],h.outputEncoding.value=rr[e.texture.encoding];const T=mb[i],F=3*Math.max(0,sr-2*T),E=(i===0?0:2*sr)+2*T*(i>so-wl?i-so+wl:0);J_(n,F,E,3*T,2*T),u.setRenderTarget(n),u.render(m,S0)}};function xP(e){return e===void 0||e.type!==Bu?!1:e.encoding===Ui||e.encoding===Cg||e.encoding===tv}function bP(){const e=[],n=[],t=[];let i=so;for(let r=0;r<pb;r++){const a=Math.pow(2,i);n.push(a);let c=1/a;r>so-wl?c=fb[r-so+wl-1]:r==0&&(c=0),t.push(c);const u=1/(a-1),l=-u/2,f=1+u/2,m=[l,l,f,l,f,f,l,l,f,f,l,f],h=6,p=6,_=3,v=2,S=1,D=new Float32Array(_*p*h),w=new Float32Array(v*p*h),T=new Float32Array(S*p*h);for(let E=0;E<h;E++){const A=E%3*2/3-1,L=E>2?0:-1,I=[A,L,0,A+2/3,L,0,A+2/3,L+1,0,A,L,0,A+2/3,L+1,0,A,L+1,0];D.set(I,_*p*E),w.set(m,v*p*E);const R=[E,E,E,E,E,E];T.set(R,S*p*E)}const F=new Ut;F.setAttribute("position",new Kt(D,_)),F.setAttribute("uv",new Kt(w,v)),F.setAttribute("faceIndex",new Kt(T,S)),e.push(F),i>wl&&i--}return{_lodPlanes:e,_sizeLods:n,_sigmas:t}}function yb(e){const n=new ps(3*sr,3*sr,e);return n.texture.mapping=Ru,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function J_(e,n,t,i,r){e.viewport.set(n,t,i,r),e.scissor.set(n,t,i,r)}function MP(e){const n=new Float32Array(e),t=new ye(0,1,0);return new to({name:"SphericalGaussianBlur",defines:{n:e},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:t},inputEncoding:{value:rr[Ui]},outputEncoding:{value:rr[Ui]}},vertexShader:A0(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${C0()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:$r,depthTest:!1,depthWrite:!1})}function vb(){const e=new vt(1,1);return new to({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:e},inputEncoding:{value:rr[Ui]},outputEncoding:{value:rr[Ui]}},vertexShader:A0(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${C0()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:$r,depthTest:!1,depthWrite:!1})}function wb(){return new to({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:rr[Ui]},outputEncoding:{value:rr[Ui]}},vertexShader:A0(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${C0()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:$r,depthTest:!1,depthWrite:!1})}function A0(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function C0(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}Qt.create=function(e,n){return console.log("THREE.Curve.create() has been deprecated"),e.prototype=Object.create(Qt.prototype),e.prototype.constructor=e,e.prototype.getPoint=n,e},Object.assign(no.prototype,{createPointsGeometry:function(e){console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const n=this.getPoints(e);return this.createGeometry(n)},createSpacedPointsGeometry:function(e){console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const n=this.getSpacedPoints(e);return this.createGeometry(n)},createGeometry:function(e){console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const n=new on;for(let t=0,i=e.length;t<i;t++){const r=e[t];n.vertices.push(new ye(r.x,r.y,r.z||0))}return n}}),Object.assign(ir.prototype,{fromPoints:function(e){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(e)}}),Object.create(ns.prototype),Object.create(ns.prototype);function xb(e){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),ns.call(this,e),this.type="catmullrom"}xb.prototype=Object.create(ns.prototype),Object.assign(xb.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}}),G_.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},yl.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Object.assign(bn.prototype,{extractUrlBase:function(e){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Dx.extractUrlBase(e)}}),bn.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Object.assign(m0.prototype,{setTexturePath:function(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}}),Object.assign(ib.prototype,{center:function(e){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},size:function(e){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(qs.prototype,{center:function(e){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionSphere:function(e){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},size:function(e){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(xr.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}}),Ju.prototype.setFromMatrix=function(e){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(e)},rb.prototype.center=function(e){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(e)},Object.assign(ln,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(e){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),ln.floorPowerOfTwo(e)},nextPowerOfTwo:function(e){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),ln.ceilPowerOfTwo(e)}}),Object.assign(Oi.prototype,{flattenToArrayOffset:function(e,n){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,n)},multiplyVector3:function(e){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")}}),Object.assign(dn.prototype,{extractPosition:function(e){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(e)},flattenToArrayOffset:function(e,n){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,n)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new ye().setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(e){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(e)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(e){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector4:function(e){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(e){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),e.transformDirection(this)},crossVector:function(e){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(e,n,t,i,r,a){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(e,n,i,t,r,a)}}),Ks.prototype.isIntersectionLine=function(e){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(e)},pi.prototype.multiplyVector3=function(e){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),e.applyQuaternion(this)},Object.assign(Na.prototype,{isIntersectionBox:function(e){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionPlane:function(e){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(e)},isIntersectionSphere:function(e){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)}}),Object.assign(xi.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(e,n){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(e,n)},midpoint:function(e){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(e)},normal:function(e){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(e)},plane:function(e){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(e)}}),Object.assign(xi,{barycoordFromPoint:function(e,n,t,i,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),xi.getBarycoord(e,n,t,i,r)},normal:function(e,n,t,i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),xi.getNormal(e,n,t,i)}}),Object.assign(Oo.prototype,{extractAllPoints:function(e){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(e)},extrude:function(e){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new al(this,e)},makeGeometry:function(e){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new cl(this,e)}}),Object.assign(vt.prototype,{fromAttribute:function(e,n,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,n,t)},distanceToManhattan:function(e){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(ye.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(e){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(e)},getScaleFromMatrix:function(e){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(e)},getColumnFromMatrix:function(e,n){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(n,e)},applyProjection:function(e){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(e)},fromAttribute:function(e,n,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,n,t)},distanceToManhattan:function(e){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(An.prototype,{fromAttribute:function(e,n,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,n,t)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(on.prototype,{computeTangents:function(){console.error("THREE.Geometry: .computeTangents() has been removed.")},computeLineDistances:function(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")},applyMatrix:function(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.assign(Ot.prototype,{getChildByName:function(e){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(e)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(e,n){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(n,e)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(e){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(Ot.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(e){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=e}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Object.assign(Ln.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}),Object.defineProperties(Ln.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),l1},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Object.defineProperties(e_.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}}),Object.defineProperty($v.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}}),zv.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Object.defineProperty(Qt.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(e){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=e}}),ii.prototype.setLens=function(e,n){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),n!==void 0&&(this.filmGauge=n),this.setFocalLength(e)},Object.defineProperties($n.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(e){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=e}},shadowCameraLeft:{set:function(e){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=e}},shadowCameraRight:{set:function(e){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=e}},shadowCameraTop:{set:function(e){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=e}},shadowCameraBottom:{set:function(e){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=e}},shadowCameraNear:{set:function(e){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=e}},shadowCameraFar:{set:function(e){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=e}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(e){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=e}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(e){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=e}},shadowMapHeight:{set:function(e){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=e}}}),Object.defineProperties(Kt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Nu},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Nu)}}}),Object.assign(Kt.prototype,{setDynamic:function(e){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(e===!0?Nu:Ig),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(Ut.prototype,{addIndex:function(e){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(e)},addAttribute:function(e,n){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(n&&n.isBufferAttribute)&&!(n&&n.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(e,new Kt(arguments[1],arguments[2]))):e==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(n),this):this.setAttribute(e,n)},addDrawCall:function(e,n,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(e,n)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeTangents:function(){console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(e){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(e)},applyMatrix:function(e){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(Ut.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Object.defineProperties(R_.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(e){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=e}}}),Object.defineProperties(w0.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(e){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=e}}}),Object.defineProperties(_s.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===Nu},set:function(e){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(e)}}}),Object.assign(_s.prototype,{setDynamic:function(e){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(e===!0?Nu:Ig),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(Sr.prototype,{getArrays:function(){console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")}}),Object.defineProperties(v0.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}}),Object.defineProperties(rn.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new jt}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=e===J0}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(e){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=e}}}),Object.defineProperties(ko.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}}),Object.defineProperties(Do.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(e){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=e}}}),Object.defineProperties(Gi.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(e){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=e}}}),Object.assign(id.prototype,{clearTarget:function(e,n,t,i){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(e),this.clear(n,t,i)},animate:function(e){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(e)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(e){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(e)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}}),Object.defineProperties(id.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=e}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=e}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(e){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=e===!0?Cg:Ui}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(ix.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(ps.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=e}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=e}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=e}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=e}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(e){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=e}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(e){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=e}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(e){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=e}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(e){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=e}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(e){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=e}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(e){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=e}}}),Object.defineProperties(Ld.prototype,{load:{value:function(e){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const n=this;return new g0().load(e,function(i){n.setBuffer(i)}),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}}),Xx.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},Xu.prototype.updateCubeMap=function(e,n){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(e,n)},Mo.crossOrigin=void 0,Mo.loadTexture=function(e,n,t,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new D_;r.setCrossOrigin(this.crossOrigin);const a=r.load(e,t,void 0,i);return n&&(a.mapping=n),a},Mo.loadTextureCube=function(e,n,t,i){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new Qv;r.setCrossOrigin(this.crossOrigin);const a=r.load(e,t,void 0,i);return n&&(a.mapping=n),a},Mo.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},Mo.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:xo}}));const Ir=function(){const[e,n]=arguments;/\/1\/601-tinified/.test(n)&&console.log(...arguments)},Ii={};class TP extends bn{constructor(n){super(n)}load(n,t,i,r,a){Ir("load",n),n===void 0&&(n=""),this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const c=Qs.get(n);if(c!==void 0)return Ir("cached",n),this.manager.itemStart(n),setTimeout(()=>{t&&t(c),this.manager.itemEnd(n)},0),c;if(Ii[n]!==void 0){Ii[n].push({onLoad:t,onProgress:i,onError:r}),Ir("return",n,Ii[n]);return}Ii[n]=[],Ii[n].push({onLoad:t,onProgress:i,onError:r}),Ir("push",n,Ii[n]);const u=new Request(n,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),l=this.mimeType,f=this.responseType;Ir("started fetch",n),fetch(u,a).then(m=>{if(m.status===200||m.status===0){if(m.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||m.body===void 0||m.body.getReader===void 0)return m;const h=Ii[n],p=m.body.getReader(),_=m.headers.get("Content-Length"),v=_?parseInt(_):0,S=v!==0;let D=0;const w=new ReadableStream({start(T){F();function F(){p.read().then(({done:E,value:A})=>{if(E)T.close();else{D+=A.byteLength;const L=new ProgressEvent("progress",{lengthComputable:S,loaded:D,total:v});for(let I=0,R=h.length;I<R;I++){const N=h[I];N.onProgress&&N.onProgress(L)}T.enqueue(A),F()}}).catch(E=>{delete Ii[n]})}}});return new Response(w)}else throw Error(`fetch for "${m.url}" responded with ${m.status}: ${m.statusText}`)}).then(m=>{switch(f){case"arraybuffer":return m.arrayBuffer();case"blob":return m.blob();case"document":return m.text().then(h=>new DOMParser().parseFromString(h,l));case"json":return m.json();default:if(l===void 0)return m.text();{const p=/charset="?([^;"\s]*)"?/i.exec(l),_=p&&p[1]?p[1].toLowerCase():void 0,v=new TextDecoder(_);return m.arrayBuffer().then(S=>v.decode(S))}}}).then(m=>{Qs.add(n,m);const h=Ii[n];Ir("then delete",n,Ii[n]),delete Ii[n];for(let p=0,_=h.length;p<_;p++){const v=h[p];v.onLoad&&v.onLoad(m)}}).catch(m=>{const h=Ii[n];if(Ir("err delete",n,Ii[n]),delete Ii[n],h===void 0)throw this.manager.itemError(n),m;for(let p=0,_=h.length;p<_;p++){const v=h[p];v.onError&&v.onError(m)}this.manager.itemError(n)}).finally(()=>{Ir("finally delete",n,Ii[n]),delete Ii[n],this.manager.itemEnd(n)}),this.manager.itemStart(n)}setResponseType(n){return this.responseType=n,this}setMimeType(n){return this.mimeType=n,this}}const EP=function(e){const n=Qs,{signal:t}=e;n.enabled=!0;const i=new D_,r=new TP;r.setResponseType("blob");function a(c,u,l,f,m=1){r.load(c,h,l,v=>{console.error("loader err",v),f()},{signal:t});function h(v){if(Ir("cache image called",c,v),v.tagName!="IMG"){const S=URL.createObjectURL(v),D=document.createElementNS("http://www.w3.org/1999/xhtml","img");D.onload=()=>{n.add(c,D),URL.revokeObjectURL(S),document.body.removeChild(D),m==1?p():_(D)},D.src=S,D.style.visibility="hidden",document.body.appendChild(D)}else m==1?p():_(v)}function p(){i.load(c,u,()=>{},f)}function _(v){const S=document.createElement("canvas"),D=S.getContext("2d");S.width=v.width,S.height=v.height,D.filter=`brightness(${m})`,D.drawImage(v,0,0,v.width,v.height);const w=new cd(S);u(w),S.remove()}}return Object.assign({},i,{load:a})},I0=function(){this.logging={enabled:!1,debug:!1};let e=this;this.callbacks={onProgress:function(n){e._onProgress(n)},onAssetAvailable:function(n){e._onAssetAvailable(n)},onError:function(n){e._onError(n)},onLoad:function(n,t){e._onLoad(n,t)}},this.contentRef=null,this.legacyMode=!1,this.materials={},this.materialPerSmoothingGroup=!1,this.useOAsMesh=!1,this.useIndices=!1,this.disregardNormals=!1,this.vertices=[],this.colors=[],this.normals=[],this.uvs=[],this.rawMesh={objectName:"",groupName:"",activeMtlName:"",mtllibName:"",faceType:-1,subGroups:[],subGroupInUse:null,smoothingGroup:{splitMaterials:!1,normalized:-1,real:-1},counts:{doubleIndicesCount:0,faceCount:0,mtlCount:0,smoothingGroupCount:0}},this.inputObjectCount=1,this.outputObjectCount=1,this.globalCounts={vertices:0,faces:0,doubleIndicesCount:0,lineByte:0,currentByte:0,totalBytes:0}};I0.prototype={constructor:I0,_resetRawMesh:function(){this.rawMesh.subGroups=[],this.rawMesh.subGroupInUse=null,this.rawMesh.smoothingGroup.normalized=-1,this.rawMesh.smoothingGroup.real=-1,this._pushSmoothingGroup(1),this.rawMesh.counts.doubleIndicesCount=0,this.rawMesh.counts.faceCount=0,this.rawMesh.counts.mtlCount=0,this.rawMesh.counts.smoothingGroupCount=0},setMaterialPerSmoothingGroup:function(e){return this.materialPerSmoothingGroup=e===!0,this},setUseOAsMesh:function(e){return this.useOAsMesh=e===!0,this},setUseIndices:function(e){return this.useIndices=e===!0,this},setDisregardNormals:function(e){return this.disregardNormals=e===!0,this},setMaterials:function(e){this.materials=Object.assign({},e)},setCallbackOnAssetAvailable:function(e){return e!=null&&e instanceof Function&&(this.callbacks.onAssetAvailable=e),this},setCallbackOnProgress:function(e){return e!=null&&e instanceof Function&&(this.callbacks.onProgress=e),this},setCallbackOnError:function(e){return e!=null&&e instanceof Function&&(this.callbacks.onError=e),this},setCallbackOnLoad:function(e){return e!=null&&e instanceof Function&&(this.callbacks.onLoad=e),this},_onProgress:function(e){let n=e||"";this.logging.enabled&&this.logging.debug&&console.log(n)},_onError:function(e){this.logging.enabled&&this.logging.debug&&console.error(e)},_onAssetAvailable:function(e){let n="OBJLoader2Parser does not provide implementation for onAssetAvailable. Aborting...";throw this.callbacks.onError(n),n},_onLoad:function(e,n){console.log("You reached parser default onLoad callback: "+n)},setLogging:function(e,n){return this.logging.enabled=e===!0,this.logging.debug=n===!0,this},_configure:function(){if(this._pushSmoothingGroup(1),this.logging.enabled){let e=Object.keys(this.materials),t="OBJLoader.Parser configuration:"+(e.length>0?`
	materialNames:
		- `+e.join(`
		- `):`
	materialNames: None`)+`
	materialPerSmoothingGroup: `+this.materialPerSmoothingGroup+`
	useOAsMesh: `+this.useOAsMesh+`
	useIndices: `+this.useIndices+`
	disregardNormals: `+this.disregardNormals;t+=`
	callbacks.onProgress: `+this.callbacks.onProgress.name,t+=`
	callbacks.onAssetAvailable: `+this.callbacks.onAssetAvailable.name,t+=`
	callbacks.onError: `+this.callbacks.onError.name,console.info(t)}},execute:function(e){this.logging.enabled&&console.time("OBJLoader2Parser.execute"),this._configure();let n=new Uint8Array(e);this.contentRef=n;let t=n.byteLength;this.globalCounts.totalBytes=t;let i=new Array(128),r=0,a=0,c="",u=0;for(let l,f=0;f<t;f++)switch(l=n[f],l){case 32:c.length>0&&(i[r++]=c),c="";break;case 47:c.length>0&&(i[r++]=c),a++,c="";break;case 10:this._processLine(i,r,a,c,f),c="",r=0,a=0;break;case 13:break;default:c+=String.fromCharCode(l);break}this._processLine(i,r,a,c,u),this._finalizeParsing(),this.logging.enabled&&console.timeEnd("OBJLoader2Parser.execute")},executeLegacy:function(e){this.logging.enabled&&console.time("OBJLoader2Parser.executeLegacy"),this._configure(),this.legacyMode=!0,this.contentRef=e;let n=e.length;this.globalCounts.totalBytes=n;let t=new Array(128),i=0,r=0,a="",c=0;for(let u;c<n;c++)switch(u=e[c],u){case" ":a.length>0&&(t[i++]=a),a="";break;case"/":a.length>0&&(t[i++]=a),r++,a="";break;case`
`:this._processLine(t,i,r,a,c),a="",i=0,r=0;break;case"\r":break;default:a+=u}this._processLine(t,i,a,r),this._finalizeParsing(),this.logging.enabled&&console.timeEnd("OBJLoader2Parser.executeLegacy")},_processLine:function(e,n,t,i,r){if(this.globalCounts.lineByte=this.globalCounts.currentByte,this.globalCounts.currentByte=r,n<1)return;i.length>0&&(e[n++]=i);let a=function(m,h,p,_){let v="";if(_>p){let S;if(h)for(S=p;S<_;S++)v+=m[S];else for(S=p;S<_;S++)v+=String.fromCharCode(m[S]);v=v.trim()}return v},c,u,l,f;switch(f=e[0],f){case"v":this.vertices.push(parseFloat(e[1])),this.vertices.push(parseFloat(e[2])),this.vertices.push(parseFloat(e[3])),n>4&&(this.colors.push(parseFloat(e[4])),this.colors.push(parseFloat(e[5])),this.colors.push(parseFloat(e[6])));break;case"vt":this.uvs.push(parseFloat(e[1])),this.uvs.push(parseFloat(e[2]));break;case"vn":this.normals.push(parseFloat(e[1])),this.normals.push(parseFloat(e[2])),this.normals.push(parseFloat(e[3]));break;case"f":if(c=n-1,t===0)for(this._checkFaceType(0),l=2,u=c;l<u;l++)this._buildFace(e[1]),this._buildFace(e[l]),this._buildFace(e[l+1]);else if(c===t*2)for(this._checkFaceType(1),l=3,u=c-2;l<u;l+=2)this._buildFace(e[1],e[2]),this._buildFace(e[l],e[l+1]),this._buildFace(e[l+2],e[l+3]);else if(c*2===t*3)for(this._checkFaceType(2),l=4,u=c-3;l<u;l+=3)this._buildFace(e[1],e[2],e[3]),this._buildFace(e[l],e[l+1],e[l+2]),this._buildFace(e[l+3],e[l+4],e[l+5]);else for(this._checkFaceType(3),l=3,u=c-2;l<u;l+=2)this._buildFace(e[1],void 0,e[2]),this._buildFace(e[l],void 0,e[l+1]),this._buildFace(e[l+2],void 0,e[l+3]);break;case"l":case"p":if(c=n-1,c===t*2)for(this._checkFaceType(4),l=1,u=c+1;l<u;l+=2)this._buildFace(e[l],e[l+1]);else for(this._checkFaceType(f==="l"?5:6),l=1,u=c+1;l<u;l++)this._buildFace(e[l]);break;case"s":this._pushSmoothingGroup(e[1]);break;case"g":this._processCompletedMesh(),this.rawMesh.groupName=a(this.contentRef,this.legacyMode,this.globalCounts.lineByte+2,this.globalCounts.currentByte);break;case"o":this.useOAsMesh&&this._processCompletedMesh(),this.rawMesh.objectName=a(this.contentRef,this.legacyMode,this.globalCounts.lineByte+2,this.globalCounts.currentByte);break;case"mtllib":this.rawMesh.mtllibName=a(this.contentRef,this.legacyMode,this.globalCounts.lineByte+7,this.globalCounts.currentByte);break;case"usemtl":let m=a(this.contentRef,this.legacyMode,this.globalCounts.lineByte+7,this.globalCounts.currentByte);m!==""&&this.rawMesh.activeMtlName!==m&&(this.rawMesh.activeMtlName=m,this.rawMesh.counts.mtlCount++,this._checkSubGroup());break}},_pushSmoothingGroup:function(e){let n=parseInt(e);isNaN(n)&&(n=e==="off"?0:1);let t=this.rawMesh.smoothingGroup.normalized;this.rawMesh.smoothingGroup.normalized=this.rawMesh.smoothingGroup.splitMaterials?n:n===0?0:1,this.rawMesh.smoothingGroup.real=n,t!==n&&(this.rawMesh.counts.smoothingGroupCount++,this._checkSubGroup())},_checkFaceType:function(e){this.rawMesh.faceType!==e&&(this._processCompletedMesh(),this.rawMesh.faceType=e,this._checkSubGroup())},_checkSubGroup:function(){let e=this.rawMesh.activeMtlName+"|"+this.rawMesh.smoothingGroup.normalized;this.rawMesh.subGroupInUse=this.rawMesh.subGroups[e],(this.rawMesh.subGroupInUse===void 0||this.rawMesh.subGroupInUse===null)&&(this.rawMesh.subGroupInUse={index:e,objectName:this.rawMesh.objectName,groupName:this.rawMesh.groupName,materialName:this.rawMesh.activeMtlName,smoothingGroup:this.rawMesh.smoothingGroup.normalized,vertices:[],indexMappingsCount:0,indexMappings:[],indices:[],colors:[],uvs:[],normals:[]},this.rawMesh.subGroups[e]=this.rawMesh.subGroupInUse)},_buildFace:function(e,n,t){let i=this.rawMesh.subGroupInUse,r=this,a=function(){let c=parseInt(e),u=3*(c>0?c-1:c+r.vertices.length/3),l=r.colors.length>0?u:null,f=i.vertices;if(f.push(r.vertices[u++]),f.push(r.vertices[u++]),f.push(r.vertices[u]),l!==null){let m=i.colors;m.push(r.colors[l++]),m.push(r.colors[l++]),m.push(r.colors[l])}if(n){let m=parseInt(n),h=2*(m>0?m-1:m+r.uvs.length/2),p=i.uvs;p.push(r.uvs[h++]),p.push(r.uvs[h])}if(t&&!r.disregardNormals){let m=parseInt(t),h=3*(m>0?m-1:m+r.normals.length/3),p=i.normals;p.push(r.normals[h++]),p.push(r.normals[h++]),p.push(r.normals[h])}};if(this.useIndices){this.disregardNormals&&(t=void 0);let c=e+(n?"_"+n:"_n")+(t?"_"+t:"_n"),u=i.indexMappings[c];u==null?(u=this.rawMesh.subGroupInUse.vertices.length/3,a(),i.indexMappings[c]=u,i.indexMappingsCount++):this.rawMesh.counts.doubleIndicesCount++,i.indices.push(u)}else a();this.rawMesh.counts.faceCount++},_createRawMeshReport:function(e){return"Input Object number: "+e+`
	Object name: `+this.rawMesh.objectName+`
	Group name: `+this.rawMesh.groupName+`
	Mtllib name: `+this.rawMesh.mtllibName+`
	Vertex count: `+this.vertices.length/3+`
	Normal count: `+this.normals.length/3+`
	UV count: `+this.uvs.length/2+`
	SmoothingGroup count: `+this.rawMesh.counts.smoothingGroupCount+`
	Material count: `+this.rawMesh.counts.mtlCount+`
	Real MeshOutputGroup count: `+this.rawMesh.subGroups.length},_finalizeRawMesh:function(){let e=[],n,t=0,i=0,r=0,a=0,c=0,u=0,l;for(let m in this.rawMesh.subGroups)if(n=this.rawMesh.subGroups[m],n.vertices.length>0){if(l=n.indices,l.length>0&&i>0)for(let h=0;h<l.length;h++)l[h]=l[h]+i;e.push(n),t+=n.vertices.length,i+=n.indexMappingsCount,r+=n.indices.length,a+=n.colors.length,u+=n.uvs.length,c+=n.normals.length}let f=null;return e.length>0&&(f={name:this.rawMesh.groupName!==""?this.rawMesh.groupName:this.rawMesh.objectName,subGroups:e,absoluteVertexCount:t,absoluteIndexCount:r,absoluteColorCount:a,absoluteNormalCount:c,absoluteUvCount:u,faceCount:this.rawMesh.counts.faceCount,doubleIndicesCount:this.rawMesh.counts.doubleIndicesCount}),f},_processCompletedMesh:function(){let e=this._finalizeRawMesh(),n=e!==null;if(n){this.colors.length>0&&this.colors.length!==this.vertices.length&&this.callbacks.onError("Vertex Colors were detected, but vertex count and color count do not match!"),this.logging.enabled&&this.logging.debug&&console.debug(this._createRawMeshReport(this.inputObjectCount)),this.inputObjectCount++,this._buildMesh(e);let t=this.globalCounts.currentByte/this.globalCounts.totalBytes;this._onProgress("Completed [o: "+this.rawMesh.objectName+" g:"+this.rawMesh.groupName+"] Total progress: "+(t*100).toFixed(2)+"%"),this._resetRawMesh()}return n},_buildMesh:function(e){let n=e.subGroups,t=new Float32Array(e.absoluteVertexCount);this.globalCounts.vertices+=e.absoluteVertexCount/3,this.globalCounts.faces+=e.faceCount,this.globalCounts.doubleIndicesCount+=e.doubleIndicesCount;let i=e.absoluteIndexCount>0?new Uint32Array(e.absoluteIndexCount):null,r=e.absoluteColorCount>0?new Float32Array(e.absoluteColorCount):null,a=e.absoluteNormalCount>0?new Float32Array(e.absoluteNormalCount):null,c=e.absoluteUvCount>0?new Float32Array(e.absoluteUvCount):null,u=r!==null,l,f=[],m=n.length>1,h=0,p=[],_,v,S=[],D=0,w=0,T=0,F=0,E=0,A=0,L=0,I,R,N,q;for(let ne in n)if(n.hasOwnProperty(ne)){if(l=n[ne],q=l.materialName,this.rawMesh.faceType<4?N=q+(u?"_vertexColor":"")+(l.smoothingGroup===0?"_flat":""):N=this.rawMesh.faceType===6?"defaultPointMaterial":"defaultLineMaterial",I=this.materials[q],R=this.materials[N],I==null&&R==null&&(N=u?"defaultVertexColorMaterial":"defaultMaterial",R=this.materials[N],this.logging.enabled&&console.info('object_group "'+l.objectName+"_"+l.groupName+'" was defined with unresolvable material "'+q+'"! Assigning "'+N+'".')),R==null){let Q={materialNameOrg:q,materialName:N,materialProperties:{vertexColors:u?2:0,flatShading:l.smoothingGroup===0}},W={cmd:"assetAvailable",type:"material",materials:{materialCloneInstructions:Q}};this.callbacks.onAssetAvailable(W);let te=this.materials[N];te==null&&(this.materials[N]=Q)}if(m?(_=p[N],_||(_=h,p[N]=h,f.push(N),h++),L=this.useIndices?l.indices.length:l.vertices.length/3,v={start:A,count:L,index:_},S.push(v),A+=L):f.push(N),t.set(l.vertices,D),D+=l.vertices.length,i&&(i.set(l.indices,w),w+=l.indices.length),r&&(r.set(l.colors,T),T+=l.colors.length),a&&(a.set(l.normals,F),F+=l.normals.length),c&&(c.set(l.uvs,E),E+=l.uvs.length),this.logging.enabled&&this.logging.debug){let Q="";_&&(Q=`
		materialIndex: `+_);let W="	Output Object no.: "+this.outputObjectCount+`
		groupName: `+l.groupName+`
		Index: `+l.index+`
		faceType: `+this.rawMesh.faceType+`
		materialName: `+l.materialName+`
		smoothingGroup: `+l.smoothingGroup+Q+`
		objectName: `+l.objectName+`
		#vertices: `+l.vertices.length/3+`
		#indices: `+l.indices.length+`
		#colors: `+l.colors.length/3+`
		#uvs: `+l.uvs.length/2+`
		#normals: `+l.normals.length/3;console.debug(W)}}this.outputObjectCount++,this.callbacks.onAssetAvailable({cmd:"assetAvailable",type:"mesh",progress:{numericalValue:this.globalCounts.currentByte/this.globalCounts.totalBytes},params:{meshName:e.name},materials:{multiMaterial:m,materialNames:f,materialGroups:S},buffers:{vertices:t,indices:i,colors:r,normals:a,uvs:c},geometryType:this.rawMesh.faceType<4?0:this.rawMesh.faceType===6?2:1},[t.buffer],i!==null?[i.buffer]:null,r!==null?[r.buffer]:null,a!==null?[a.buffer]:null,c!==null?[c.buffer]:null)},_finalizeParsing:function(){if(this.logging.enabled&&console.info("Global output object count: "+this.outputObjectCount),this._processCompletedMesh()&&this.logging.enabled){let e=`Overall counts: 
	Vertices: `+this.globalCounts.vertices+`
	Faces: `+this.globalCounts.faces+`
	Multiple definitions: `+this.globalCounts.doubleIndicesCount;console.info(e)}}};const L0=function(e){this.logging={enabled:!1,debug:!1},this.callbacks={onProgress:null,onMeshAlter:null},this.materialHandler=e};L0.prototype={constructor:L0,setLogging:function(e,n){this.logging.enabled=e===!0,this.logging.debug=n===!0},_setCallbacks:function(e,n){e!=null&&e instanceof Function&&(this.callbacks.onProgress=e),n!=null&&n instanceof Function&&(this.callbacks.onMeshAlter=n)},buildMeshes:function(e){let n=e.params.meshName,t=e.buffers,i=new Ut;t.vertices!==void 0&&t.vertices!==null&&i.setAttribute("position",new Kt(new Float32Array(t.vertices),3)),t.indices!==void 0&&t.indices!==null&&i.setIndex(new Kt(new Uint32Array(t.indices),1)),t.colors!==void 0&&t.colors!==null&&i.setAttribute("color",new Kt(new Float32Array(t.colors),3)),t.normals!==void 0&&t.normals!==null?i.setAttribute("normal",new Kt(new Float32Array(t.normals),3)):i.computeVertexNormals(),t.uvs!==void 0&&t.uvs!==null&&i.setAttribute("uv",new Kt(new Float32Array(t.uvs),2)),t.skinIndex!==void 0&&t.skinIndex!==null&&i.setAttribute("skinIndex",new Kt(new Uint16Array(t.skinIndex),4)),t.skinWeight!==void 0&&t.skinWeight!==null&&i.setAttribute("skinWeight",new Kt(new Float32Array(t.skinWeight),4));let r,a,c,u=e.materials.materialNames,l=e.materials.multiMaterial,f=[];for(c in u)a=u[c],r=this.materialHandler.getMaterial(a),l&&f.push(r);if(l){r=f;let D=e.materials.materialGroups,w;for(c in D)w=D[c],i.addGroup(w.start,w.count,w.index)}let m=[],h,p,_=!0,v=e.geometryType===null?0:e.geometryType;if(this.callbacks.onMeshAlter&&(p=this.callbacks.onMeshAlter({detail:{meshName:n,bufferGeometry:i,material:r,geometryType:v}})),p){if(p.isDisregardMesh())_=!1;else if(p.providesAlteredMeshes()){for(let D in p.meshes)m.push(p.meshes[D]);_=!1}}_&&(e.computeBoundingSphere&&i.computeBoundingSphere(),v===0?h=new Ln(i,r):v===1?h=new si(i,r):h=new l_(i,r),h.name=n,m.push(h));let S=e.params.meshName;if(m.length>0){let D=[];for(let w in m)h=m[w],D[w]=h.name;S+=": Adding mesh(es) ("+D.length+": "+D+") from input mesh: "+n,S+=" ("+(e.progress.numericalValue*100).toFixed(2)+"%)"}else S+=": Not adding mesh: "+n,S+=" ("+(e.progress.numericalValue*100).toFixed(2)+"%)";return this.callbacks.onProgress&&this.callbacks.onProgress("progress",S,e.progress.numericalValue),m}};const bb=function(e,n){this.disregardMesh=e===!0,this.alteredMesh=n===!0,this.meshes=[]};bb.prototype={constructor:bb,addMesh:function(e){this.meshes.push(e),this.alteredMesh=!0},isDisregardMesh:function(){return this.disregardMesh},providesAlteredMeshes:function(){return this.alteredMesh}};const D0=function(){this.logging={enabled:!1,debug:!1},this.callbacks={onLoadMaterials:null},this.materials={}};D0.prototype={constructor:D0,setLogging:function(e,n){this.logging.enabled=e===!0,this.logging.debug=n===!0},_setCallbacks:function(e){e!=null&&e instanceof Function&&(this.callbacks.onLoadMaterials=e)},createDefaultMaterials:function(e){let n=new Ds({color:14479871});n.name="defaultMaterial";let t=new Ds({color:14479871});t.name="defaultVertexColorMaterial",t.vertexColors=!0;let i=new Yn;i.name="defaultLineMaterial";let r=new Jr({size:.1});r.name="defaultPointMaterial";let a={};a[n.name]=n,a[t.name]=t,a[i.name]=i,a[r.name]=r,this.addMaterials(a,e)},addPayloadMaterials:function(e){let n,t,i=e.materials.materialCloneInstructions,r={};if(i!=null){let c=i.materialNameOrg;c=c??"";let u=this.materials[c];u?(n=u.clone(),t=i.materialName,n.name=t,Object.assign(n,i.materialProperties),this.materials[t]=n,r[t]=n):this.logging.enabled&&console.info('Requested material "'+c+'" is not available!')}let a=e.materials.serializedMaterials;if(a!=null&&Object.keys(a).length>0){let c=new F_,u;for(t in a)u=a[t],u!=null&&(n=c.parse(u),this.logging.enabled&&console.info('De-serialized material with name "'+t+'" will be added.'),this.materials[t]=n,r[t]=n)}return a=e.materials.runtimeMaterials,r=this.addMaterials(a,!0,r),r},addMaterials:function(e,n,t){if(t==null&&(t={}),e!=null&&Object.keys(e).length>0){let i,r,a;for(let c in e)i=e[c],a=n===!0,a||(r=this.materials[c],a=r==null),a&&(this.materials[c]=i,t[c]=i),this.logging.enabled&&this.logging.debug&&console.info('Material with name "'+c+'" was added.')}return this.callbacks.onLoadMaterials&&this.callbacks.onLoadMaterials(t),t},getMaterials:function(){return this.materials},getMaterial:function(e){return this.materials[e]},getMaterialsJSON:function(){let e={},n;for(let t in this.materials)n=this.materials[t],e[t]=n.toJSON();return e},clearMaterials:function(){this.materials={}}};const Bd=function(e){bn.call(this,e),this.parser=new I0,this.modelName="",this.instanceNo=0,this.baseObject3d=new Ot,this.materialHandler=new D0,this.meshReceiver=new L0(this.materialHandler);let n=this,t=function(i){n._onAssetAvailable(i)};this.parser.setCallbackOnAssetAvailable(t)};Bd.OBJLOADER2_VERSION="3.2.0",console.info("Using OBJLoader2 version: "+Bd.OBJLOADER2_VERSION),Bd.prototype=Object.assign(Object.create(bn.prototype),{constructor:Bd,setLogging:function(e,n){return this.parser.setLogging(e,n),this},setMaterialPerSmoothingGroup:function(e){return this.parser.setMaterialPerSmoothingGroup(e),this},setUseOAsMesh:function(e){return this.parser.setUseOAsMesh(e),this},setUseIndices:function(e){return this.parser.setUseIndices(e),this},setDisregardNormals:function(e){return this.parser.setDisregardNormals(e),this},setModelName:function(e){return this.modelName=e||this.modelName,this},setBaseObject3d:function(e){return this.baseObject3d=e??this.baseObject3d,this},addMaterials:function(e,n){return this.materialHandler.addMaterials(e,n),this},setCallbackOnAssetAvailable:function(e){return this.parser.setCallbackOnAssetAvailable(e),this},setCallbackOnProgress:function(e){return this.parser.setCallbackOnProgress(e),this},setCallbackOnError:function(e){return this.parser.setCallbackOnError(e),this},setCallbackOnLoad:function(e){return this.parser.setCallbackOnLoad(e),this},setCallbackOnMeshAlter:function(e){return this.meshReceiver._setCallbacks(this.parser.callbacks.onProgress,e),this},setCallbackOnLoadMaterials:function(e){return this.materialHandler._setCallbacks(e),this},load:function(e,n,t,i,r){let a=this;if(n==null||!(n instanceof Function)){let h="onLoad is not a function! Aborting...";throw a.parser.callbacks.onError(h),h}else this.parser.setCallbackOnLoad(n);(i==null||!(i instanceof Function))&&(i=function(h){let p=h;h.currentTarget&&h.currentTarget.statusText!==null&&(p=`Error occurred while downloading!
url: `+h.currentTarget.responseURL+`
status: `+h.currentTarget.statusText),a.parser.callbacks.onError(p)}),e||i("An invalid url was provided. Unable to continue!");let c=new URL(e,window.location.href).href,u=c,l=c.split("/");if(l.length>2&&(u=l[l.length-1],this.path=l.slice(0,l.length-1).join("/")+"/"),t==null||!(t instanceof Function)){let h=0,p=0;t=function(_){if(_.lengthComputable&&(p=_.loaded/_.total,p>h)){h=p;let v='Download of "'+e+'": '+(p*100).toFixed(2)+"%";a.parser.callbacks.onProgress("progressLoad",v,p)}}}this.setCallbackOnMeshAlter(r);let f=function(h){a.parser.callbacks.onLoad(a.parse(h),"OBJLoader2#load: Parsing completed")},m=new Fs(this.manager);m.setPath(this.path||this.resourcePath),m.setResponseType("arraybuffer"),m.load(u,f,t,i)},parse:function(e){if(e==null)throw"Provided content is not a valid ArrayBuffer or String. Unable to continue parsing";return this.parser.logging.enabled&&console.time("OBJLoader parse: "+this.modelName),this.materialHandler.createDefaultMaterials(!1),this.parser.setMaterials(this.materialHandler.getMaterials()),e instanceof ArrayBuffer||e instanceof Uint8Array?(this.parser.logging.enabled&&console.info("Parsing arrayBuffer..."),this.parser.execute(e)):typeof e=="string"||e instanceof String?(this.parser.logging.enabled&&console.info("Parsing text..."),this.parser.executeLegacy(e)):this.parser.callbacks.onError("Provided content was neither of type String nor Uint8Array! Aborting..."),this.parser.logging.enabled&&console.timeEnd("OBJLoader parse: "+this.modelName),this.baseObject3d},_onAssetAvailable:function(e){if(e.cmd==="assetAvailable")if(e.type==="mesh"){let n=this.meshReceiver.buildMeshes(e);for(let t of n)this.baseObject3d.add(t)}else e.type==="material"&&this.materialHandler.addPayloadMaterials(e)}});const SP=function(){let e={};const n=function(t){delete e[t]};this.add=function(t){const i=performance.now()+"";return e[i]=t,t.then(()=>n(i)),t},this.done=function(t){Promise.all(Object.values(e)).then(()=>{t()})}},Lr=(e,n={},t="")=>{const i=document.createElement(e);for(let r in n)i.setAttribute(r,n[r]);return i.innerHTML=t,i},PP=(e,n)=>(document.getElementById(e)||document.getElementsByTagName("head")[0].prepend(Lr("STYLE",{type:"text/css"},n)),!0),Li=function(e){let n=e,t=[];return function(r,a={}){return arguments.length>0?typeof r=="function"?(a.prepend?t.unshift(r):t.push(r),a.dontCallOnRegistration||r(n),()=>{const c=t.indexOf(r);c!==-1&&t.splice(c,1)}):(n!==r&&JSON.stringify(n)!==JSON.stringify(r)&&(n=r,t.forEach(c=>c(n))),n):n}},Mb=function(e,n={}){PP("geocam-viewer",`
    .geocam-viewer {
      position: relative;
      z-index: 1;
    }

    .geocam-viewer-hidden {
      display: none;
    }

    .geocam-viewer-control {
      pointer-events: auto;
    }

    .geocam-viewer-control-button {
      background-color: rgba(255,255,255,0.5);
      border-radius: 4px;
      border: 1px solid #666;
      color: rgba(0,0,0,0);
      width: 32px;
      height: 32px;
      display: block;
      background-size: cover;
      background-position: center;
      cursor: pointer;
    }

    .geocam-viewer-controls {
        position: absolute;
        pointer-events: none;
        display: flex;
        left: 16px;
        top: 16px;
        right: 16px;
        bottom: 16px;
        --gap: 16px;
    }

    .geocam-viewer-controls-left, .geocam-viewer-controls-right {
      display: flex;
      flex-justify: space-between;
      flex-direction: column;
    }

    .geocam-viewer-controls-left-top, .geocam-viewer-controls-right-top {
      display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: var(--gap);
        row-gap: 8px;
    }

    .geocam-viewer-controls-left-bottom,   .geocam-viewer-controls-right-bottom {
      display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: var(--gap);
        row-gap: 8px;
    }

    .geocam-viewer-controls-center {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .geocam-viewer-controls-top,  .geocam-viewer-controls-bottom {
      display: flex;
      justify-content: center;
      gap: var(--gap);
    } 

    .geocam-viewer-controls-mid {
      flex: 1;
    }
  `);const i=.5,r={aspect:2,near:.1,fov:35,far:100,scale:1,xOffset:0,yOffset:0,rotationOffsets:[0,0,0],hemispheres:[()=>K(0),()=>K(1),()=>K(2)]},a=n.plugins,c=new SP,u={shot:Li(),capture:Li(),fov:Li(),yaw:Li(0),rotation:Li([]),brightness:Li([]),facing:Li(0),horizon:Li(0),urls:Li([]),visible:Li(!1),hemispheres:Li([])},l=[Li(1),Li(1),Li(1)],f=Li(window.performance.now());let m=!1,h,p,_,v,S=0,D=0,w=0,T=0,F=[null,null,null],E=null,A=!1,L,I,R=[],N,q,ne,Q=JSON.stringify([]),W=JSON.stringify([]);const te=function(de){return(270-de)*(Math.PI/180)},K=function(de){const qe=new wd(12,32,32,0,2*Math.PI,Math.PI/3*de,Math.PI/3),tt=new ms({}),He=new Ln(qe,tt);return He.material.side=li,He},pe=function(){v.style.top=S+"px",v.style.left=D+"px",v.style.width=w+"px",v.style.height=T+"px"},be=function(de,qe=!1){const tt=de.domElement,He=v.parentNode.clientWidth,je=v.parentNode.clientHeight,lt=qe||Math.abs(tt.clientWidth-He)>1||Math.abs(tt.clientHeight-je)>1;if(lt){console.log("Resizing canvas:",{displayWidth:He,displayHeight:je}),v.style.width=He+"px",v.style.height=je+"px",de.setSize(He,je,!0);const Mt=de.domElement;p.aspect=Mt.clientWidth/Mt.clientHeight,A=!0,console.log("Canvas after resize:",{clientWidth:Mt.clientWidth,clientHeight:Mt.clientHeight,width:Mt.width,height:Mt.height})}return lt},Ee=de=>{if(!Ye)return;be(H);const qe=u.horizon(),tt=u.facing();u.facing((360+tt)%360),u.horizon(Math.max(-85,Math.min(85,qe)));const He=(90-qe)*(Math.PI/180),je=tt*(Math.PI/180),lt=10;{const Mt=lt*Math.sin(He)*Math.sin(je),Rt=-lt*Math.cos(He),Xt=lt*Math.sin(He)*Math.cos(je);p.up.set(0,0,1),p.lookAt(Mt,Xt,Rt)}A&&(p.updateProjectionMatrix(),A=!1),H.render(Y,p),L=requestAnimationFrame(Mt=>Ee())},Ge=function(de){return new Promise((qe,tt)=>{typeof de=="function"?qe(de()):new Bd().load(de,je=>{je.traverse(function(lt){lt instanceof Ln&&(lt.material.side=2,lt.material.flatShading=!0,lt.material.transparent=!0,lt.rotation.set(0,0,0),qe(lt))})})})},_e=function(de){return console.log("loadMeshes"),c.add(new Promise((qe,tt)=>{let He=F.length;de.forEach((je,lt)=>{Ge(je).then(Mt=>{F[lt]=Mt,He-=1,He<=0&&qe()})})}))},De=function(){F.forEach((de,qe)=>de?E.remove(de):null),Y.remove(E),H.renderLists.dispose(),F=[null,null,null],E=null},he=function(){N&&(N(),N=null)},Z=function(){ne&&(ne(),ne=null)},me=function(de,...qe){return Object.assign(de,...qe)},we=async function(de){let qe;de&&de.length>0&&Q!==(qe=JSON.stringify(de))&&(Q=qe,he(),E&&De(),await _e(de),E=new Yr,F.forEach((tt,He)=>{E.add(tt),tt.name=`${He}`}),Y.add(E),N=u.urls(tt=>{const He=JSON.stringify(tt);He!==W&&tt.length>0&&(W=He,U(tt,u.brightness()))}))},xe=async function(de={}){Z(),De(),_=me(r,de);const qe=u.fov()||_.fov;return u.fov(qe),p=new ii(qe,_.aspect,_.near,_.far),ne=u.hemispheres(we),be(H,!0),this},et=function(){F.forEach((de,qe)=>{de&&de.material&&(de.material.opacity=i)}),l.forEach(de=>de(0))},Ve=function(de,qe,tt,He,je,lt){de.material.opacity=i;const Mt=parseInt(de.name);l[Mt](0),new EP(I).load(qe,Rt=>{window.tex=Rt,de.material.map=Rt,window.mat=de.material,de.material.opacity=1,Rt.repeat.set(_.scale,_.scale),Rt.offset.set(_.yOffset,_.xOffset),Rt.rotation=_.rotationOffsets[Mt],de.material.needsUpdate=!0,l[Mt](1),tt&&tt(de,qe)},Rt=>{const Xt=Rt.loaded/Rt.total;He&&He(de,qe,Xt)},Rt=>{je?je(de,qe,Rt):console.error("error loading image",Rt,Mt,qe)},lt)},nt=function(de,qe,tt,He,je){const lt=function(Rt,Xt,wn,xn){const cn=parseInt(Rt.name);let jn=Xt.length-wn;const ci=Xt[wn];Ve(Rt,ci,()=>{l[cn]((wn+1)/Xt.length),He&&jn==Xt.length&&He(Rt,ci),tt&&jn<=1&&tt(Rt,ci),wn+=1,wn<Xt.length&&lt(Rt,Xt,wn)},(Vi,Cn,Mn)=>{l[cn]((wn+Mn)/Xt.length)},null,1)},Mt=parseInt(de.name);if(Array.isArray(qe))lt(de,qe,0);else{const Rt=qe;Ve(de,Rt,()=>{l[Mt](1),He&&He(de,Rt),tt&&tt(de,qe)},(Xt,wn,xn)=>{l[Mt](xn)},null,je)}},Be=function(de){a.push(de),m&&de.init.apply(de,[this])},ae=function(){const de=u.rotation();var qe=new dn;de.length==9?qe.set(de[0],de[1],de[2],0,de[3],de[4],de[5],0,de[6],de[7],de[8],0,0,0,0,1):qe.makeRotationY(te(u.yaw()-90));{var tt=new dn;tt.makeRotationX(Math.PI/2),qe.premultiply(tt)}E.setRotationFromMatrix(qe)},U=async function(de,qe=[1,1,1]){I&&I.abort(),I=new AbortController;let tt=F.length;F.length,ae(),F.forEach((He,je)=>{const lt=de[je];nt(He,lt,(Mt,Rt)=>{if(tt-=1,tt<=0)return!0},(Mt,Rt)=>{},qe[je])}),Ee()},Se=function(de,qe,tt,He,je){const lt=je?JSON.parse(je):[1,1,1];tt&&tt.length>0&&u.hemispheres(tt);const Mt=typeof He=="string"?JSON.parse(He):He;u.rotation(Mt||[]),u.brightness(lt),u.yaw(parseFloat(qe||0)),u.urls(de),u.visible(!0),be(H,!0)},ze=function(de){const qe=u.urls();qe&&qe.length>=F.length&&(de&&u.brightness(JSON.parse(de)),U(qe,u.brightness())),be(H,!0)},Oe=function(){u.visible(!1),u.shot(null)};let Ye=!1,H=new id({preserveDrawingBuffer:!0});H.setPixelRatio(Math.min(window.devicePixelRatio||1,2));let Y=new Gu,$e=new O_(16777215,1);Y.add($e);const Ie=e.getBoundingClientRect();v=Lr("DIV",{class:"geocam-viewer"}),h=Lr("DIV",{class:"geocam-viewer-controls"}),h.append(Lr("DIV",{class:"geocam-viewer-controls-left"},'<div class="geocam-viewer-controls-left-top"></div><div class="geocam-viewer-controls-left-bottom"></div>'));const fe=Lr("DIV",{class:"geocam-viewer-controls-center"},'<div class="geocam-viewer-controls-top"></div><div class="geocam-viewer-controls-mid"></div><div class="geocam-viewer-controls-bottom"></div>');fe.append(Lr("DIV")),fe.append(Lr("DIV")),fe.append(Lr("DIV")),h.append(fe),h.append(Lr("DIV",{class:"geocam-viewer-controls-right"},'<div class="geocam-viewer-controls-right-top"></div><div class="geocam-viewer-controls-right-bottom"></div>')),v.appendChild(h),w=Ie.width,T=Ie.height,pe(),v.appendChild(H.domElement),q=u.visible(de=>{de?v.classList.remove("geocam-viewer-hidden"):v.classList.add("geocam-viewer-hidden"),Ye=de}),e.appendChild(v),R.push(u.fov(de=>{p&&de!==null&&(p.fov=de,A=!0)}));const Qe=function(){if(L&&(cancelAnimationFrame(L),L=null),Ye=!1,I&&(I.abort(),I=null),R.forEach(de=>de()),R=[],q&&(q(),q=null),he(),Z(),a.forEach(de=>{"destroy"in de&&de.destroy.apply(de)}),F&&(F.forEach(de=>{de&&(de.geometry&&de.geometry.dispose(),de.material&&(de.material.map&&de.material.map.dispose(),de.material.dispose()),E&&E.remove(de))}),F=[null,null,null]),E&&(Y.remove(E),E=null),$e&&(Y.remove($e),$e=null),Y){for(Y.traverse(de=>{de.geometry&&de.geometry.dispose(),de.material&&(Array.isArray(de.material)?de.material.forEach(qe=>{qe.map&&qe.map.dispose(),qe.dispose()}):(de.material.map&&de.material.map.dispose(),de.material.dispose()))});Y.children.length>0;)Y.remove(Y.children[0]);Y=null}if(H){H.renderLists.dispose(),H.dispose();const de=H.getContext();if(de&&de.getExtension){const qe=de.getExtension("WEBGL_lose_context");qe&&qe.loseContext()}H.domElement&&v&&v.removeChild(H.domElement),H=null}Qs.clear(),v&&e&&(e.removeChild(v),v=null),p=null,h=null,_=null,Object.keys(u).forEach(de=>{if(u[de]&&typeof u[de]=="function")try{u[de](null)}catch{}})},Ne=function(de,qe=null){return u[de]||this[de]?(console.info("geocam viewer attempt to add store that already exists",de),u[de]()===null&&qe!==null&&u[de](qe)):(u[de]=Li(qe),this[de]=u[de],f(window.performance.now())),u[de]},ut=function(de,qe,tt={}){const He=document.getElementsByClassName(`geocam-viewer-controls-${qe}`)[0];He?(de.classList.add("geocam-viewer-control"),tt.after?tt.after.parentNode.insertBefore(de,tt.after.nextSibling):tt.prepend?He.prepend(de):He.appendChild(de)):console.error("geocam viewer unable to add control no matching location",de,qe)};this.setup=xe,this.show=Se,this.reload=ze,this.hide=Oe,this.resetProgress=et,this.plugin=Be,this.destroy=Qe,Object.defineProperty(this,"camera",{get:function(){return p},enumerable:!0,configurable:!0}),Object.defineProperty(this,"meshGroup",{get:function(){return E},enumerable:!0,configurable:!0}),this.renderer=H,this.element=e,this.wrapper=v,this.done=c.done,this.progress=l,this.newstoreadded=f,this.stores=u;for(let de in u)this[de]=u[de];this.store=Ne,this.addControl=ut,a.forEach(de=>{"init"in de&&de.init.apply(de,[this])}),xe(n.config),Ee(),m=!0},Q_=new Map,Uo=[],AP=(e,n,t)=>{if(n&&typeof n.init=="function"&&typeof n.createInferenceSessionHandler=="function"){const i=Q_.get(e);if(i===void 0)Q_.set(e,{backend:n,priority:t});else{if(i.priority>t)return;if(i.priority===t&&i.backend!==n)throw new Error(`cannot register backend "${e}" using priority ${t}`)}if(t>=0){const r=Uo.indexOf(e);r!==-1&&Uo.splice(r,1);for(let a=0;a<Uo.length;a++)if(Q_.get(Uo[a]).priority<=t){Uo.splice(a,0,e);return}Uo.push(e)}return}throw new TypeError("not a valid backend")},CP=async e=>{const n=Q_.get(e);if(!n)return"backend not found.";if(n.initialized)return n.backend;if(n.aborted)return n.error;{const t=!!n.initPromise;try{return t||(n.initPromise=n.backend.init(e)),await n.initPromise,n.initialized=!0,n.backend}catch(i){return t||(n.error=`${i}`,n.aborted=!0),n.error}finally{delete n.initPromise}}},IP=async e=>{const n=e.executionProviders||[],t=n.map(l=>typeof l=="string"?l:l.name),i=t.length===0?Uo:t;let r;const a=[],c=new Set;for(const l of i){const f=await CP(l);typeof f=="string"?a.push({name:l,err:f}):(r||(r=f),r===f&&c.add(l))}if(!r)throw new Error(`no available backend found. ERR: ${a.map(l=>`[${l.name}] ${l.err}`).join(", ")}`);for(const{name:l,err:f}of a)t.includes(l)&&console.warn(`removing requested execution provider "${l}" from session options because it is not available: ${f}`);const u=n.filter(l=>c.has(typeof l=="string"?l:l.name));return[r,new Proxy(e,{get:(l,f)=>f==="executionProviders"?u:Reflect.get(l,f)})]},LP="1.21.0";let Tb="warning";const Bs={wasm:{},webgl:{},webgpu:{},versions:{common:LP},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Tb=e}},get logLevel(){return Tb}};Object.defineProperty(Bs,"logLevel",{enumerable:!0});const DP=Bs,kP=(e,n)=>{const t=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);t.width=e.dims[3],t.height=e.dims[2];const i=t.getContext("2d");if(i!=null){let r,a;(n==null?void 0:n.tensorLayout)!==void 0&&n.tensorLayout==="NHWC"?(r=e.dims[2],a=e.dims[3]):(r=e.dims[3],a=e.dims[2]);const c=(n==null?void 0:n.format)!==void 0?n.format:"RGB",u=n==null?void 0:n.norm;let l,f;u===void 0||u.mean===void 0?l=[255,255,255,255]:typeof u.mean=="number"?l=[u.mean,u.mean,u.mean,u.mean]:(l=[u.mean[0],u.mean[1],u.mean[2],0],u.mean[3]!==void 0&&(l[3]=u.mean[3])),u===void 0||u.bias===void 0?f=[0,0,0,0]:typeof u.bias=="number"?f=[u.bias,u.bias,u.bias,u.bias]:(f=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(f[3]=u.bias[3]));const m=a*r;let h=0,p=m,_=m*2,v=-1;c==="RGBA"?(h=0,p=m,_=m*2,v=m*3):c==="RGB"?(h=0,p=m,_=m*2):c==="RBG"&&(h=0,_=m,p=m*2);for(let S=0;S<a;S++)for(let D=0;D<r;D++){const w=(e.data[h++]-f[0])*l[0],T=(e.data[p++]-f[1])*l[1],F=(e.data[_++]-f[2])*l[2],E=v===-1?255:(e.data[v++]-f[3])*l[3];i.fillStyle="rgba("+w+","+T+","+F+","+E+")",i.fillRect(D,S,1,1)}if("toDataURL"in t)return t.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},OP=(e,n)=>{const t=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let i;if(t!=null){let r,a,c;(n==null?void 0:n.tensorLayout)!==void 0&&n.tensorLayout==="NHWC"?(r=e.dims[2],a=e.dims[1],c=e.dims[3]):(r=e.dims[3],a=e.dims[2],c=e.dims[1]);const u=n!==void 0&&n.format!==void 0?n.format:"RGB",l=n==null?void 0:n.norm;let f,m;l===void 0||l.mean===void 0?f=[255,255,255,255]:typeof l.mean=="number"?f=[l.mean,l.mean,l.mean,l.mean]:(f=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(f[3]=l.mean[3])),l===void 0||l.bias===void 0?m=[0,0,0,0]:typeof l.bias=="number"?m=[l.bias,l.bias,l.bias,l.bias]:(m=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(m[3]=l.bias[3]));const h=a*r;if(n!==void 0&&(n.format!==void 0&&c===4&&n.format!=="RGBA"||c===3&&n.format!=="RGB"&&n.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const p=4;let _=0,v=1,S=2,D=3,w=0,T=h,F=h*2,E=-1;u==="RGBA"?(w=0,T=h,F=h*2,E=h*3):u==="RGB"?(w=0,T=h,F=h*2):u==="RBG"&&(w=0,F=h,T=h*2),i=t.createImageData(r,a);for(let A=0;A<a*r;_+=p,v+=p,S+=p,D+=p,A++)i.data[_]=(e.data[w++]-m[0])*f[0],i.data[v]=(e.data[T++]-m[1])*f[1],i.data[S]=(e.data[F++]-m[2])*f[2],i.data[D]=E===-1?255:(e.data[E++]-m[3])*f[3]}else throw new Error("Can not access image data");return i},k0=(e,n)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(n.height===void 0||n.width===void 0)throw new Error("Image height and width must be defined");if(n.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:t,width:i}=n,r=n.norm??{mean:255,bias:0};let a,c;typeof r.mean=="number"?a=[r.mean,r.mean,r.mean,r.mean]:a=[r.mean[0],r.mean[1],r.mean[2],r.mean[3]??255],typeof r.bias=="number"?c=[r.bias,r.bias,r.bias,r.bias]:c=[r.bias[0],r.bias[1],r.bias[2],r.bias[3]??0];const u=n.format!==void 0?n.format:"RGBA",l=n.tensorFormat!==void 0&&n.tensorFormat!==void 0?n.tensorFormat:"RGB",f=t*i,m=l==="RGBA"?new Float32Array(f*4):new Float32Array(f*3);let h=4,p=0,_=1,v=2,S=3,D=0,w=f,T=f*2,F=-1;u==="RGB"&&(h=3,p=0,_=1,v=2,S=-1),l==="RGBA"?F=f*3:l==="RBG"?(D=0,T=f,w=f*2):l==="BGR"&&(T=0,w=f,D=f*2);for(let A=0;A<f;A++,p+=h,v+=h,_+=h,S+=h)m[D++]=(e[p]+c[0])/a[0],m[w++]=(e[_]+c[1])/a[1],m[T++]=(e[v]+c[2])/a[2],F!==-1&&S!==-1&&(m[F++]=(e[S]+c[3])/a[3]);return l==="RGBA"?new xs("float32",m,[1,4,t,i]):new xs("float32",m,[1,3,t,i])},FP=async(e,n)=>{const t=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,i=typeof ImageData<"u"&&e instanceof ImageData,r=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,a=typeof e=="string";let c,u=n??{};const l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},f=m=>typeof HTMLCanvasElement<"u"&&m instanceof HTMLCanvasElement||m instanceof OffscreenCanvas?m.getContext("2d"):null;if(t){const m=l();m.width=e.width,m.height=e.height;const h=f(m);if(h!=null){let p=e.height,_=e.width;if(n!==void 0&&n.resizedHeight!==void 0&&n.resizedWidth!==void 0&&(p=n.resizedHeight,_=n.resizedWidth),n!==void 0){if(u=n,n.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");u.tensorFormat="RGBA",u.height=p,u.width=_}else u.tensorFormat="RGBA",u.height=p,u.width=_;h.drawImage(e,0,0),c=h.getImageData(0,0,_,p).data}else throw new Error("Can not access image data")}else if(i){let m,h;if(n!==void 0&&n.resizedWidth!==void 0&&n.resizedHeight!==void 0?(m=n.resizedHeight,h=n.resizedWidth):(m=e.height,h=e.width),n!==void 0&&(u=n),u.format="RGBA",u.height=m,u.width=h,n!==void 0){const p=l();p.width=h,p.height=m;const _=f(p);if(_!=null)_.putImageData(e,0,0),c=_.getImageData(0,0,h,m).data;else throw new Error("Can not access image data")}else c=e.data}else if(r){if(n===void 0)throw new Error("Please provide image config with format for Imagebitmap");const m=l();m.width=e.width,m.height=e.height;const h=f(m);if(h!=null){const p=e.height,_=e.width;return h.drawImage(e,0,0,_,p),c=h.getImageData(0,0,_,p).data,u.height=p,u.width=_,k0(c,u)}else throw new Error("Can not access image data")}else{if(a)return new Promise((m,h)=>{const p=l(),_=f(p);if(!e||!_)return h();const v=new Image;v.crossOrigin="Anonymous",v.src=e,v.onload=()=>{p.width=v.width,p.height=v.height,_.drawImage(v,0,0,p.width,p.height);const S=_.getImageData(0,0,p.width,p.height);u.height=p.height,u.width=p.width,m(k0(S.data,u))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(c!==void 0)return k0(c,u);throw new Error("Input data provided is not supported - aborted tensor creation")},RP=(e,n)=>{const{width:t,height:i,download:r,dispose:a}=n,c=[1,i,t,4];return new xs({location:"texture",type:"float32",texture:e,dims:c,download:r,dispose:a})},BP=(e,n)=>{const{dataType:t,dims:i,download:r,dispose:a}=n;return new xs({location:"gpu-buffer",type:t??"float32",gpuBuffer:e,dims:i,download:r,dispose:a})},zP=(e,n)=>{const{dataType:t,dims:i,download:r,dispose:a}=n;return new xs({location:"ml-tensor",type:t??"float32",mlTensor:e,dims:i,download:r,dispose:a})},$P=(e,n,t)=>new xs({location:"cpu-pinned",type:e,data:n,dims:t??[n.length]}),Ml=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Z_=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let Eb=!1;const NP=()=>{if(!Eb){Eb=!0;const e=typeof BigInt64Array<"u"&&BigInt64Array.from,n=typeof BigUint64Array<"u"&&BigUint64Array.from,t=globalThis.Float16Array,i=typeof t<"u"&&t.from;e&&(Ml.set("int64",BigInt64Array),Z_.set(BigInt64Array,"int64")),n&&(Ml.set("uint64",BigUint64Array),Z_.set(BigUint64Array,"uint64")),i?(Ml.set("float16",t),Z_.set(t,"float16")):Ml.set("float16",Uint16Array)}},UP=e=>{let n=1;for(let t=0;t<e.length;t++){const i=e[t];if(typeof i!="number"||!Number.isSafeInteger(i))throw new TypeError(`dims[${t}] must be an integer, got: ${i}`);if(i<0)throw new RangeError(`dims[${t}] must be a non-negative integer, got: ${i}`);n*=i}return n},GP=(e,n)=>{switch(e.location){case"cpu":return new xs(e.type,e.data,n);case"cpu-pinned":return new xs({location:"cpu-pinned",data:e.data,type:e.type,dims:n});case"texture":return new xs({location:"texture",texture:e.texture,type:e.type,dims:n});case"gpu-buffer":return new xs({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:n});case"ml-tensor":return new xs({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:n});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}};let xs=class{constructor(n,t,i){NP();let r,a;if(typeof n=="object"&&"location"in n)switch(this.dataLocation=n.location,r=n.type,a=n.dims,n.location){case"cpu-pinned":{const u=Ml.get(r);if(!u)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(n.data instanceof u))throw new TypeError(`buffer should be of type ${u.name}`);this.cpuData=n.data;break}case"texture":{if(r!=="float32")throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=n.texture,this.downloader=n.download,this.disposer=n.dispose;break}case"gpu-buffer":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=n.gpuBuffer,this.downloader=n.download,this.disposer=n.dispose;break}case"ml-tensor":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint64"&&r!=="int8"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=n.mlTensor,this.downloader=n.download,this.disposer=n.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let u,l;if(typeof n=="string")if(r=n,l=i,n==="string"){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");u=t}else{const f=Ml.get(n);if(f===void 0)throw new TypeError(`Unsupported tensor type: ${n}.`);if(Array.isArray(t)){if(n==="float16"&&f===Uint16Array||n==="uint4"||n==="int4")throw new TypeError(`Creating a ${n} tensor from number array is not supported. Please use ${f.name} as data.`);n==="uint64"||n==="int64"?u=f.from(t,BigInt):u=f.from(t)}else if(t instanceof f)u=t;else if(t instanceof Uint8ClampedArray)if(n==="uint8")u=Uint8Array.from(t);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(n==="float16"&&t instanceof Uint16Array&&f!==Uint16Array)u=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw new TypeError(`A ${r} tensor's data must be type of ${f}`)}else if(l=t,Array.isArray(n)){if(n.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const f=typeof n[0];if(f==="string")r="string",u=n;else if(f==="boolean")r="bool",u=Uint8Array.from(n);else throw new TypeError(`Invalid element type of data array: ${f}.`)}else if(n instanceof Uint8ClampedArray)r="uint8",u=Uint8Array.from(n);else{const f=Z_.get(n.constructor);if(f===void 0)throw new TypeError(`Unsupported type for tensor data: ${n.constructor}.`);r=f,u=n}if(l===void 0)l=[u.length];else if(!Array.isArray(l))throw new TypeError("A tensor's dims must be a number array");a=l,this.cpuData=u,this.dataLocation="cpu"}const c=UP(a);if(this.cpuData&&c!==this.cpuData.length&&!((r==="uint4"||r==="int4")&&Math.ceil(c/2)===this.cpuData.length))throw new Error(`Tensor's size(${c}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=a,this.size=c}static async fromImage(n,t){return FP(n,t)}static fromTexture(n,t){return RP(n,t)}static fromGpuBuffer(n,t){return BP(n,t)}static fromMLTensor(n,t){return zP(n,t)}static fromPinnedBuffer(n,t,i){return $P(n,t,i)}toDataURL(n){return kP(this,n)}toImageData(n){return OP(this,n)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(n){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,n&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(n){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return GP(this,n)}};const Tl=xs,Sb=(e,n)=>{(typeof Bs.trace>"u"?!Bs.wasm.trace:!Bs.trace)||console.timeStamp(`${e}::ORT::${n}`)},Pb=(e,n)=>{var r;const t=((r=new Error().stack)==null?void 0:r.split(/\r\n|\r|\n/g))||[];let i=!1;for(let a=0;a<t.length;a++){if(i&&!t[a].includes("TRACE_FUNC")){let c=`FUNC_${e}::${t[a].trim().split(" ")[1]}`;n&&(c+=`::${n}`),Sb("CPU",c);return}t[a].includes("TRACE_FUNC")&&(i=!0)}},O0=e=>{(typeof Bs.trace>"u"?!Bs.wasm.trace:!Bs.trace)||Pb("BEGIN",e)},F0=e=>{(typeof Bs.trace>"u"?!Bs.wasm.trace:!Bs.trace)||Pb("END",e)},VP=Object.freeze(Object.defineProperty({__proto__:null,InferenceSession:class Fb{constructor(n){this.handler=n}async run(n,t,i){O0();const r={};let a={};if(typeof n!="object"||n===null||n instanceof Tl||Array.isArray(n))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let c=!0;if(typeof t=="object"){if(t===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Tl)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(t.length===0)throw new TypeError("'fetches' cannot be an empty array.");c=!1;for(const f of t){if(typeof f!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(f)===-1)throw new RangeError(`'fetches' contains invalid output name: ${f}.`);r[f]=null}if(typeof i=="object"&&i!==null)a=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let f=!1;const m=Object.getOwnPropertyNames(t);for(const h of this.outputNames)if(m.indexOf(h)!==-1){const p=t[h];(p===null||p instanceof Tl)&&(f=!0,c=!1,r[h]=p)}if(f){if(typeof i=="object"&&i!==null)a=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else a=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const f of this.inputNames)if(typeof n[f]>"u")throw new Error(`input '${f}' is missing in 'feeds'.`);if(c)for(const f of this.outputNames)r[f]=null;const u=await this.handler.run(n,r,a),l={};for(const f in u)if(Object.hasOwnProperty.call(u,f)){const m=u[f];m instanceof Tl?l[f]=m:l[f]=new Tl(m.type,m.data,m.dims)}return F0(),l}async release(){return this.handler.dispose()}static async create(n,t,i,r){O0();let a,c={};if(typeof n=="string"){if(a=n,typeof t=="object"&&t!==null)c=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(n instanceof Uint8Array){if(a=n,typeof t=="object"&&t!==null)c=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(n instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&n instanceof SharedArrayBuffer){const m=n;let h=0,p=n.byteLength;if(typeof t=="object"&&t!==null)c=t;else if(typeof t=="number"){if(h=t,!Number.isSafeInteger(h))throw new RangeError("'byteOffset' must be an integer.");if(h<0||h>=m.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${m.byteLength}).`);if(p=n.byteLength-h,typeof i=="number"){if(p=i,!Number.isSafeInteger(p))throw new RangeError("'byteLength' must be an integer.");if(p<=0||h+p>m.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${m.byteLength-h}].`);if(typeof r=="object"&&r!==null)c=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof i<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof t<"u")throw new TypeError("'options' must be an object.");a=new Uint8Array(m,h,p)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[u,l]=await IP(c),f=await u.createInferenceSessionHandler(a,l);return F0(),new Fb(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}},TRACE:Sb,TRACE_FUNC_BEGIN:O0,TRACE_FUNC_END:F0,Tensor:Tl,env:DP,registerBackend:AP},Symbol.toStringTag,{value:"Module"}));function jP(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function El(e){throw new Error('Could not dynamically require "'+e+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var Ab={exports:{}};/*!
 * ONNX Runtime Web v1.22.0-dev.20250409-89f8206ba4
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */(function(e,n){var t=(()=>{var i=Object.defineProperty,r=Object.getOwnPropertyDescriptor,a=Object.getOwnPropertyNames,c=Object.prototype.hasOwnProperty,u=(s=>typeof El<"u"?El:typeof Proxy<"u"?new Proxy(s,{get:(o,d)=>(typeof El<"u"?El:o)[d]}):s)(function(s){if(typeof El<"u")return El.apply(this,arguments);throw Error('Dynamic require of "'+s+'" is not supported')}),l=(s,o)=>()=>(s&&(o=s(s=0)),o),f=(s,o)=>{for(var d in o)i(s,d,{get:o[d],enumerable:!0})},m=(s,o,d,g)=>{if(o&&typeof o=="object"||typeof o=="function")for(let y of a(o))!c.call(s,y)&&y!==d&&i(s,y,{get:()=>o[y],enumerable:!(g=r(o,y))||g.enumerable});return s},h=s=>m(i({},"__esModule",{value:!0}),s),p,_,v,S,D,w=l(()=>{p=new Map,_=[],v=(s,o,d)=>{if(o&&typeof o.init=="function"&&typeof o.createInferenceSessionHandler=="function"){let g=p.get(s);if(g===void 0)p.set(s,{backend:o,priority:d});else{if(g.priority>d)return;if(g.priority===d&&g.backend!==o)throw new Error(`cannot register backend "${s}" using priority ${d}`)}if(d>=0){let y=_.indexOf(s);y!==-1&&_.splice(y,1);for(let x=0;x<_.length;x++)if(p.get(_[x]).priority<=d){_.splice(x,0,s);return}_.push(s)}return}throw new TypeError("not a valid backend")},S=async s=>{let o=p.get(s);if(!o)return"backend not found.";if(o.initialized)return o.backend;if(o.aborted)return o.error;{let d=!!o.initPromise;try{return d||(o.initPromise=o.backend.init(s)),await o.initPromise,o.initialized=!0,o.backend}catch(g){return d||(o.error=`${g}`,o.aborted=!0),o.error}finally{delete o.initPromise}}},D=async s=>{let o=s.executionProviders||[],d=o.map(k=>typeof k=="string"?k:k.name),g=d.length===0?_:d,y,x=[],b=new Set;for(let k of g){let O=await S(k);typeof O=="string"?x.push({name:k,err:O}):(y||(y=O),y===O&&b.add(k))}if(!y)throw new Error(`no available backend found. ERR: ${x.map(k=>`[${k.name}] ${k.err}`).join(", ")}`);for(let{name:k,err:O}of x)d.includes(k)&&console.warn(`removing requested execution provider "${k}" from session options because it is not available: ${O}`);let P=o.filter(k=>b.has(typeof k=="string"?k:k.name));return[y,new Proxy(s,{get:(k,O)=>O==="executionProviders"?P:Reflect.get(k,O)})]}}),T=l(()=>{w()}),F,E=l(()=>{F="1.22.0-dev.20250409-89f8206ba4"}),A,L,I=l(()=>{E(),A="warning",L={wasm:{},webgl:{},webgpu:{},versions:{common:F},set logLevel(s){if(s!==void 0){if(typeof s!="string"||["verbose","info","warning","error","fatal"].indexOf(s)===-1)throw new Error(`Unsupported logging level: ${s}`);A=s}},get logLevel(){return A}},Object.defineProperty(L,"logLevel",{enumerable:!0})}),R,N=l(()=>{I(),R=L}),q,ne,Q=l(()=>{q=(s,o)=>{let d=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);d.width=s.dims[3],d.height=s.dims[2];let g=d.getContext("2d");if(g!=null){let y,x;(o==null?void 0:o.tensorLayout)!==void 0&&o.tensorLayout==="NHWC"?(y=s.dims[2],x=s.dims[3]):(y=s.dims[3],x=s.dims[2]);let b=(o==null?void 0:o.format)!==void 0?o.format:"RGB",P=o==null?void 0:o.norm,k,O;P===void 0||P.mean===void 0?k=[255,255,255,255]:typeof P.mean=="number"?k=[P.mean,P.mean,P.mean,P.mean]:(k=[P.mean[0],P.mean[1],P.mean[2],0],P.mean[3]!==void 0&&(k[3]=P.mean[3])),P===void 0||P.bias===void 0?O=[0,0,0,0]:typeof P.bias=="number"?O=[P.bias,P.bias,P.bias,P.bias]:(O=[P.bias[0],P.bias[1],P.bias[2],0],P.bias[3]!==void 0&&(O[3]=P.bias[3]));let $=x*y,V=0,G=$,ee=$*2,X=-1;b==="RGBA"?(V=0,G=$,ee=$*2,X=$*3):b==="RGB"?(V=0,G=$,ee=$*2):b==="RBG"&&(V=0,ee=$,G=$*2);for(let re=0;re<x;re++)for(let Te=0;Te<y;Te++){let ue=(s.data[V++]-O[0])*k[0],ce=(s.data[G++]-O[1])*k[1],ke=(s.data[ee++]-O[2])*k[2],Le=X===-1?255:(s.data[X++]-O[3])*k[3];g.fillStyle="rgba("+ue+","+ce+","+ke+","+Le+")",g.fillRect(Te,re,1,1)}if("toDataURL"in d)return d.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},ne=(s,o)=>{let d=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),g;if(d!=null){let y,x,b;(o==null?void 0:o.tensorLayout)!==void 0&&o.tensorLayout==="NHWC"?(y=s.dims[2],x=s.dims[1],b=s.dims[3]):(y=s.dims[3],x=s.dims[2],b=s.dims[1]);let P=o!==void 0&&o.format!==void 0?o.format:"RGB",k=o==null?void 0:o.norm,O,$;k===void 0||k.mean===void 0?O=[255,255,255,255]:typeof k.mean=="number"?O=[k.mean,k.mean,k.mean,k.mean]:(O=[k.mean[0],k.mean[1],k.mean[2],255],k.mean[3]!==void 0&&(O[3]=k.mean[3])),k===void 0||k.bias===void 0?$=[0,0,0,0]:typeof k.bias=="number"?$=[k.bias,k.bias,k.bias,k.bias]:($=[k.bias[0],k.bias[1],k.bias[2],0],k.bias[3]!==void 0&&($[3]=k.bias[3]));let V=x*y;if(o!==void 0&&(o.format!==void 0&&b===4&&o.format!=="RGBA"||b===3&&o.format!=="RGB"&&o.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let G=4,ee=0,X=1,re=2,Te=3,ue=0,ce=V,ke=V*2,Le=-1;P==="RGBA"?(ue=0,ce=V,ke=V*2,Le=V*3):P==="RGB"?(ue=0,ce=V,ke=V*2):P==="RBG"&&(ue=0,ke=V,ce=V*2),g=d.createImageData(y,x);for(let M=0;M<x*y;ee+=G,X+=G,re+=G,Te+=G,M++)g.data[ee]=(s.data[ue++]-$[0])*O[0],g.data[X]=(s.data[ce++]-$[1])*O[1],g.data[re]=(s.data[ke++]-$[2])*O[2],g.data[Te]=Le===-1?255:(s.data[Le++]-$[3])*O[3]}else throw new Error("Can not access image data");return g}}),W,te,K,pe,be,Ee,Ge=l(()=>{nt(),W=(s,o)=>{if(s===void 0)throw new Error("Image buffer must be defined");if(o.height===void 0||o.width===void 0)throw new Error("Image height and width must be defined");if(o.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:d,width:g}=o,y=o.norm??{mean:255,bias:0},x,b;typeof y.mean=="number"?x=[y.mean,y.mean,y.mean,y.mean]:x=[y.mean[0],y.mean[1],y.mean[2],y.mean[3]??255],typeof y.bias=="number"?b=[y.bias,y.bias,y.bias,y.bias]:b=[y.bias[0],y.bias[1],y.bias[2],y.bias[3]??0];let P=o.format!==void 0?o.format:"RGBA",k=o.tensorFormat!==void 0&&o.tensorFormat!==void 0?o.tensorFormat:"RGB",O=d*g,$=k==="RGBA"?new Float32Array(O*4):new Float32Array(O*3),V=4,G=0,ee=1,X=2,re=3,Te=0,ue=O,ce=O*2,ke=-1;P==="RGB"&&(V=3,G=0,ee=1,X=2,re=-1),k==="RGBA"?ke=O*3:k==="RBG"?(Te=0,ce=O,ue=O*2):k==="BGR"&&(ce=0,ue=O,Te=O*2);for(let Le=0;Le<O;Le++,G+=V,X+=V,ee+=V,re+=V)$[Te++]=(s[G]+b[0])/x[0],$[ue++]=(s[ee]+b[1])/x[1],$[ce++]=(s[X]+b[2])/x[2],ke!==-1&&re!==-1&&($[ke++]=(s[re]+b[3])/x[3]);return k==="RGBA"?new Ve("float32",$,[1,4,d,g]):new Ve("float32",$,[1,3,d,g])},te=async(s,o)=>{let d=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,g=typeof ImageData<"u"&&s instanceof ImageData,y=typeof ImageBitmap<"u"&&s instanceof ImageBitmap,x=typeof s=="string",b,P=o??{},k=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},O=$=>typeof HTMLCanvasElement<"u"&&$ instanceof HTMLCanvasElement||$ instanceof OffscreenCanvas?$.getContext("2d"):null;if(d){let $=k();$.width=s.width,$.height=s.height;let V=O($);if(V!=null){let G=s.height,ee=s.width;if(o!==void 0&&o.resizedHeight!==void 0&&o.resizedWidth!==void 0&&(G=o.resizedHeight,ee=o.resizedWidth),o!==void 0){if(P=o,o.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");P.tensorFormat="RGBA",P.height=G,P.width=ee}else P.tensorFormat="RGBA",P.height=G,P.width=ee;V.drawImage(s,0,0),b=V.getImageData(0,0,ee,G).data}else throw new Error("Can not access image data")}else if(g){let $,V;if(o!==void 0&&o.resizedWidth!==void 0&&o.resizedHeight!==void 0?($=o.resizedHeight,V=o.resizedWidth):($=s.height,V=s.width),o!==void 0&&(P=o),P.format="RGBA",P.height=$,P.width=V,o!==void 0){let G=k();G.width=V,G.height=$;let ee=O(G);if(ee!=null)ee.putImageData(s,0,0),b=ee.getImageData(0,0,V,$).data;else throw new Error("Can not access image data")}else b=s.data}else if(y){if(o===void 0)throw new Error("Please provide image config with format for Imagebitmap");let $=k();$.width=s.width,$.height=s.height;let V=O($);if(V!=null){let G=s.height,ee=s.width;return V.drawImage(s,0,0,ee,G),b=V.getImageData(0,0,ee,G).data,P.height=G,P.width=ee,W(b,P)}else throw new Error("Can not access image data")}else{if(x)return new Promise(($,V)=>{let G=k(),ee=O(G);if(!s||!ee)return V();let X=new Image;X.crossOrigin="Anonymous",X.src=s,X.onload=()=>{G.width=X.width,G.height=X.height,ee.drawImage(X,0,0,G.width,G.height);let re=ee.getImageData(0,0,G.width,G.height);P.height=G.height,P.width=G.width,$(W(re.data,P))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(b!==void 0)return W(b,P);throw new Error("Input data provided is not supported - aborted tensor creation")},K=(s,o)=>{let{width:d,height:g,download:y,dispose:x}=o,b=[1,g,d,4];return new Ve({location:"texture",type:"float32",texture:s,dims:b,download:y,dispose:x})},pe=(s,o)=>{let{dataType:d,dims:g,download:y,dispose:x}=o;return new Ve({location:"gpu-buffer",type:d??"float32",gpuBuffer:s,dims:g,download:y,dispose:x})},be=(s,o)=>{let{dataType:d,dims:g,download:y,dispose:x}=o;return new Ve({location:"ml-tensor",type:d??"float32",mlTensor:s,dims:g,download:y,dispose:x})},Ee=(s,o,d)=>new Ve({location:"cpu-pinned",type:s,data:o,dims:d??[o.length]})}),_e,De,he,Z,me=l(()=>{_e=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),De=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),he=!1,Z=()=>{if(!he){he=!0;let s=typeof BigInt64Array<"u"&&BigInt64Array.from,o=typeof BigUint64Array<"u"&&BigUint64Array.from,d=globalThis.Float16Array,g=typeof d<"u"&&d.from;s&&(_e.set("int64",BigInt64Array),De.set(BigInt64Array,"int64")),o&&(_e.set("uint64",BigUint64Array),De.set(BigUint64Array,"uint64")),g?(_e.set("float16",d),De.set(d,"float16")):_e.set("float16",Uint16Array)}}}),we,xe,et=l(()=>{nt(),we=s=>{let o=1;for(let d=0;d<s.length;d++){let g=s[d];if(typeof g!="number"||!Number.isSafeInteger(g))throw new TypeError(`dims[${d}] must be an integer, got: ${g}`);if(g<0)throw new RangeError(`dims[${d}] must be a non-negative integer, got: ${g}`);o*=g}return o},xe=(s,o)=>{switch(s.location){case"cpu":return new Ve(s.type,s.data,o);case"cpu-pinned":return new Ve({location:"cpu-pinned",data:s.data,type:s.type,dims:o});case"texture":return new Ve({location:"texture",texture:s.texture,type:s.type,dims:o});case"gpu-buffer":return new Ve({location:"gpu-buffer",gpuBuffer:s.gpuBuffer,type:s.type,dims:o});case"ml-tensor":return new Ve({location:"ml-tensor",mlTensor:s.mlTensor,type:s.type,dims:o});default:throw new Error(`tensorReshape: tensor location ${s.location} is not supported`)}}}),Ve,nt=l(()=>{Q(),Ge(),me(),et(),Ve=class{constructor(s,o,d){Z();let g,y;if(typeof s=="object"&&"location"in s)switch(this.dataLocation=s.location,g=s.type,y=s.dims,s.location){case"cpu-pinned":{let b=_e.get(g);if(!b)throw new TypeError(`unsupported type "${g}" to create tensor from pinned buffer`);if(!(s.data instanceof b))throw new TypeError(`buffer should be of type ${b.name}`);this.cpuData=s.data;break}case"texture":{if(g!=="float32")throw new TypeError(`unsupported type "${g}" to create tensor from texture`);this.gpuTextureData=s.texture,this.downloader=s.download,this.disposer=s.dispose;break}case"gpu-buffer":{if(g!=="float32"&&g!=="float16"&&g!=="int32"&&g!=="int64"&&g!=="uint32"&&g!=="uint8"&&g!=="bool"&&g!=="uint4"&&g!=="int4")throw new TypeError(`unsupported type "${g}" to create tensor from gpu buffer`);this.gpuBufferData=s.gpuBuffer,this.downloader=s.download,this.disposer=s.dispose;break}case"ml-tensor":{if(g!=="float32"&&g!=="float16"&&g!=="int32"&&g!=="int64"&&g!=="uint32"&&g!=="uint64"&&g!=="int8"&&g!=="uint8"&&g!=="bool"&&g!=="uint4"&&g!=="int4")throw new TypeError(`unsupported type "${g}" to create tensor from MLTensor`);this.mlTensorData=s.mlTensor,this.downloader=s.download,this.disposer=s.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let b,P;if(typeof s=="string")if(g=s,P=d,s==="string"){if(!Array.isArray(o))throw new TypeError("A string tensor's data must be a string array.");b=o}else{let k=_e.get(s);if(k===void 0)throw new TypeError(`Unsupported tensor type: ${s}.`);if(Array.isArray(o)){if(s==="float16"&&k===Uint16Array||s==="uint4"||s==="int4")throw new TypeError(`Creating a ${s} tensor from number array is not supported. Please use ${k.name} as data.`);s==="uint64"||s==="int64"?b=k.from(o,BigInt):b=k.from(o)}else if(o instanceof k)b=o;else if(o instanceof Uint8ClampedArray)if(s==="uint8")b=Uint8Array.from(o);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(s==="float16"&&o instanceof Uint16Array&&k!==Uint16Array)b=new globalThis.Float16Array(o.buffer,o.byteOffset,o.length);else throw new TypeError(`A ${g} tensor's data must be type of ${k}`)}else if(P=o,Array.isArray(s)){if(s.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let k=typeof s[0];if(k==="string")g="string",b=s;else if(k==="boolean")g="bool",b=Uint8Array.from(s);else throw new TypeError(`Invalid element type of data array: ${k}.`)}else if(s instanceof Uint8ClampedArray)g="uint8",b=Uint8Array.from(s);else{let k=De.get(s.constructor);if(k===void 0)throw new TypeError(`Unsupported type for tensor data: ${s.constructor}.`);g=k,b=s}if(P===void 0)P=[b.length];else if(!Array.isArray(P))throw new TypeError("A tensor's dims must be a number array");y=P,this.cpuData=b,this.dataLocation="cpu"}let x=we(y);if(this.cpuData&&x!==this.cpuData.length&&!((g==="uint4"||g==="int4")&&Math.ceil(x/2)===this.cpuData.length))throw new Error(`Tensor's size(${x}) does not match data length(${this.cpuData.length}).`);this.type=g,this.dims=y,this.size=x}static async fromImage(s,o){return te(s,o)}static fromTexture(s,o){return K(s,o)}static fromGpuBuffer(s,o){return pe(s,o)}static fromMLTensor(s,o){return be(s,o)}static fromPinnedBuffer(s,o,d){return Ee(s,o,d)}toDataURL(s){return q(this,s)}toImageData(s){return ne(this,s)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(s){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let o=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=o,s&&this.disposer&&(this.disposer(),this.disposer=void 0),o}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(s){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return xe(this,s)}}}),Be,ae=l(()=>{nt(),Be=Ve}),U,Se,ze,Oe,Ye=l(()=>{I(),U=(s,o)=>{(typeof L.trace>"u"?!L.wasm.trace:!L.trace)||console.timeStamp(`${s}::ORT::${o}`)},Se=(s,o)=>{var y;let d=((y=new Error().stack)==null?void 0:y.split(/\r\n|\r|\n/g))||[],g=!1;for(let x=0;x<d.length;x++){if(g&&!d[x].includes("TRACE_FUNC")){let b=`FUNC_${s}::${d[x].trim().split(" ")[1]}`;o&&(b+=`::${o}`),U("CPU",b);return}d[x].includes("TRACE_FUNC")&&(g=!0)}},ze=s=>{(typeof L.trace>"u"?!L.wasm.trace:!L.trace)||Se("BEGIN",s)},Oe=s=>{(typeof L.trace>"u"?!L.wasm.trace:!L.trace)||Se("END",s)}}),H,Y=l(()=>{w(),ae(),Ye(),H=class Rb{constructor(o){this.handler=o}async run(o,d,g){ze();let y={},x={};if(typeof o!="object"||o===null||o instanceof Be||Array.isArray(o))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let b=!0;if(typeof d=="object"){if(d===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(d instanceof Be)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(d)){if(d.length===0)throw new TypeError("'fetches' cannot be an empty array.");b=!1;for(let O of d){if(typeof O!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(O)===-1)throw new RangeError(`'fetches' contains invalid output name: ${O}.`);y[O]=null}if(typeof g=="object"&&g!==null)x=g;else if(typeof g<"u")throw new TypeError("'options' must be an object.")}else{let O=!1,$=Object.getOwnPropertyNames(d);for(let V of this.outputNames)if($.indexOf(V)!==-1){let G=d[V];(G===null||G instanceof Be)&&(O=!0,b=!1,y[V]=G)}if(O){if(typeof g=="object"&&g!==null)x=g;else if(typeof g<"u")throw new TypeError("'options' must be an object.")}else x=d}}else if(typeof d<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let O of this.inputNames)if(typeof o[O]>"u")throw new Error(`input '${O}' is missing in 'feeds'.`);if(b)for(let O of this.outputNames)y[O]=null;let P=await this.handler.run(o,y,x),k={};for(let O in P)if(Object.hasOwnProperty.call(P,O)){let $=P[O];$ instanceof Be?k[O]=$:k[O]=new Be($.type,$.data,$.dims)}return Oe(),k}async release(){return this.handler.dispose()}static async create(o,d,g,y){ze();let x,b={};if(typeof o=="string"){if(x=o,typeof d=="object"&&d!==null)b=d;else if(typeof d<"u")throw new TypeError("'options' must be an object.")}else if(o instanceof Uint8Array){if(x=o,typeof d=="object"&&d!==null)b=d;else if(typeof d<"u")throw new TypeError("'options' must be an object.")}else if(o instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&o instanceof SharedArrayBuffer){let $=o,V=0,G=o.byteLength;if(typeof d=="object"&&d!==null)b=d;else if(typeof d=="number"){if(V=d,!Number.isSafeInteger(V))throw new RangeError("'byteOffset' must be an integer.");if(V<0||V>=$.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${$.byteLength}).`);if(G=o.byteLength-V,typeof g=="number"){if(G=g,!Number.isSafeInteger(G))throw new RangeError("'byteLength' must be an integer.");if(G<=0||V+G>$.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${$.byteLength-V}].`);if(typeof y=="object"&&y!==null)b=y;else if(typeof y<"u")throw new TypeError("'options' must be an object.")}else if(typeof g<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof d<"u")throw new TypeError("'options' must be an object.");x=new Uint8Array($,V,G)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[P,k]=await D(b),O=await P.createInferenceSessionHandler(x,k);return Oe(),new Rb(O)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),$e,Ie=l(()=>{Y(),$e=H}),fe=l(()=>{}),Qe=l(()=>{}),Ne=l(()=>{}),ut=l(()=>{}),de={};f(de,{InferenceSession:()=>$e,TRACE:()=>U,TRACE_FUNC_BEGIN:()=>ze,TRACE_FUNC_END:()=>Oe,Tensor:()=>Be,env:()=>R,registerBackend:()=>v});var qe=l(()=>{T(),N(),Ie(),ae(),fe(),Qe(),Ye(),Ne(),ut()}),tt=l(()=>{}),He={};f(He,{default:()=>Mt});var je,lt,Mt,Rt=l(()=>{var s;ng(),ge(),Me(),je="ort-wasm-proxy-worker",lt=((s=globalThis.self)==null?void 0:s.name)===je,lt&&(self.onmessage=o=>{let{type:d,in:g}=o.data;try{switch(d){case"init-wasm":J(g.wasm).then(()=>{yu(g).then(()=>{postMessage({type:d})},y=>{postMessage({type:d,err:y})})},y=>{postMessage({type:d,err:y})});break;case"init-ep":{let{epName:y,env:x}=g;vu(x,y).then(()=>{postMessage({type:d})},b=>{postMessage({type:d,err:b})});break}case"copy-from":{let{buffer:y}=g,x=xa(y);postMessage({type:d,out:x});break}case"create":{let{model:y,options:x}=g;gr(y,x).then(b=>{postMessage({type:d,out:b})},b=>{postMessage({type:d,err:b})});break}case"release":xu(g),postMessage({type:d});break;case"run":{let{sessionId:y,inputIndices:x,inputs:b,outputIndices:P,options:k}=g;Mu(y,x,b,P,new Array(P.length).fill(null),k).then(O=>{O.some($=>$[3]!=="cpu")?postMessage({type:d,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:d,out:O},Eu([...b,...O]))},O=>{postMessage({type:d,err:O})});break}case"end-profiling":Tu(g),postMessage({type:d});break;default:}}catch(y){postMessage({type:d,err:y})}}),Mt=lt?null:o=>new Worker(o??xn,{type:"classic",name:je})}),Xt,wn,xn,cn,jn,ci,ss,Vi,Cn,Mn,Di,bs,qt,Me=l(()=>{tt(),Xt=typeof location>"u"?void 0:location.origin,wn=()=>{var s,o;return typeof document<"u"?(s=document.currentScript)==null?void 0:s.src:typeof self<"u"?(o=self.location)==null?void 0:o.href:void 0},xn=wn(),cn=()=>{if(xn&&!xn.startsWith("blob:"))return xn.substring(0,xn.lastIndexOf("/")+1)},jn=(s,o)=>{try{let d=o??xn;return(d?new URL(s,d):new URL(s)).origin===Xt}catch{return!1}},ci=(s,o)=>{let d=o??xn;try{return(d?new URL(s,d):new URL(s)).href}catch{return}},ss=(s,o)=>`${o??"./"}${s}`,Vi=async s=>{let o=await(await fetch(s,{credentials:"same-origin"})).blob();return URL.createObjectURL(o)},Cn=async s=>(await import(s)).default,Mn=(Rt(),h(He)).default,Di=async()=>{if(!xn)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(jn(xn))return[void 0,Mn()];let s=await Vi(xn);return[s,Mn(s)]},bs=void 0,qt=async(s,o,d)=>{if(!s&&!o&&bs&&xn&&jn(xn))return[void 0,bs];{let g="ort-wasm-simd-threaded.jsep.mjs",y=s??ci(g,o),x=d&&y&&!jn(y,o),b=x?await Vi(y):y??ss(g,o);return[x?b:void 0,await Cn(b)]}}}),at,rt,mt,_t,an,B,le,J,se,ge=l(()=>{Me(),rt=!1,mt=!1,_t=!1,an=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},B=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},le=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},J=async s=>{if(rt)return Promise.resolve();if(mt)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(_t)throw new Error("previous call to 'initializeWebAssembly()' failed.");mt=!0;let o=s.initTimeout,d=s.numThreads;if(s.simd!==!1){if(s.simd==="relaxed"){if(!le())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!B())throw new Error("WebAssembly SIMD is not supported in the current environment.")}let g=an();d>1&&!g&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+d+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),s.numThreads=d=1);let y=s.wasmPaths,x=typeof y=="string"?y:void 0,b=y==null?void 0:y.mjs,P=(b==null?void 0:b.href)??b,k=y==null?void 0:y.wasm,O=(k==null?void 0:k.href)??k,$=s.wasmBinary,[V,G]=await qt(P,x,d>1),ee=!1,X=[];if(o>0&&X.push(new Promise(re=>{setTimeout(()=>{ee=!0,re()},o)})),X.push(new Promise((re,Te)=>{let ue={numThreads:d};if($)ue.wasmBinary=$;else if(O||x)ue.locateFile=ce=>O??x+ce;else if(P&&P.indexOf("blob:")!==0)ue.locateFile=ce=>new URL(ce,P).href;else if(V){let ce=cn();ce&&(ue.locateFile=ke=>ce+ke)}G(ue).then(ce=>{mt=!1,rt=!0,at=ce,re(),V&&URL.revokeObjectURL(V)},ce=>{mt=!1,_t=!0,Te(ce)})})),await Promise.race(X),ee)throw new Error(`WebAssembly backend initializing failed due to timeout: ${o}ms`)},se=()=>{if(rt&&at)return at;throw new Error("WebAssembly is not initialized yet.")}}),Fe,Ke,pt,Pt=l(()=>{ge(),Fe=(s,o)=>{let d=se(),g=d.lengthBytesUTF8(s)+1,y=d._malloc(g);return d.stringToUTF8(s,y,g),o.push(y),y},Ke=(s,o,d,g)=>{if(typeof s=="object"&&s!==null){if(d.has(s))throw new Error("Circular reference in options");d.add(s)}Object.entries(s).forEach(([y,x])=>{let b=o?o+y:y;if(typeof x=="object")Ke(x,b+".",d,g);else if(typeof x=="string"||typeof x=="number")g(b,x.toString());else if(typeof x=="boolean")g(b,x?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof x}`)})},pt=s=>{let o=se(),d=o.stackSave();try{let g=o.PTR_SIZE,y=o.stackAlloc(2*g);o._OrtGetLastError(y,y+g);let x=Number(o.getValue(y,g===4?"i32":"i64")),b=o.getValue(y+g,"*"),P=b?o.UTF8ToString(b):"";throw new Error(`${s} ERROR_CODE: ${x}, ERROR_MESSAGE: ${P}`)}finally{o.stackRestore(d)}}}),Tt,en=l(()=>{ge(),Pt(),Tt=s=>{let o=se(),d=0,g=[],y=s||{};try{if((s==null?void 0:s.logSeverityLevel)===void 0)y.logSeverityLevel=2;else if(typeof s.logSeverityLevel!="number"||!Number.isInteger(s.logSeverityLevel)||s.logSeverityLevel<0||s.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${s.logSeverityLevel}`);if((s==null?void 0:s.logVerbosityLevel)===void 0)y.logVerbosityLevel=0;else if(typeof s.logVerbosityLevel!="number"||!Number.isInteger(s.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${s.logVerbosityLevel}`);(s==null?void 0:s.terminate)===void 0&&(y.terminate=!1);let x=0;return(s==null?void 0:s.tag)!==void 0&&(x=Fe(s.tag,g)),d=o._OrtCreateRunOptions(y.logSeverityLevel,y.logVerbosityLevel,!!y.terminate,x),d===0&&pt("Can't create run options."),(s==null?void 0:s.extra)!==void 0&&Ke(s.extra,"",new WeakSet,(b,P)=>{let k=Fe(b,g),O=Fe(P,g);o._OrtAddRunConfigEntry(d,k,O)!==0&&pt(`Can't set a run config entry: ${b} - ${P}.`)}),[d,g]}catch(x){throw d!==0&&o._OrtReleaseRunOptions(d),g.forEach(b=>o._free(b)),x}}}),Dt,tn,Vt,nn,Tn,bi,ui=l(()=>{ge(),Pt(),Dt=s=>{switch(s){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${s}`)}},tn=s=>{switch(s){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${s}`)}},Vt=s=>{s.extra||(s.extra={}),s.extra.session||(s.extra.session={});let o=s.extra.session;o.use_ort_model_bytes_directly||(o.use_ort_model_bytes_directly="1"),s.executionProviders&&s.executionProviders.some(d=>(typeof d=="string"?d:d.name)==="webgpu")&&(s.enableMemPattern=!1)},nn=(s,o,d,g)=>{let y=Fe(o,g),x=Fe(d,g);se()._OrtAddSessionConfigEntry(s,y,x)!==0&&pt(`Can't set a session config entry: ${o} - ${d}.`)},Tn=async(s,o,d)=>{for(let g of o){let y=typeof g=="string"?g:g.name,x=[];switch(y){case"webnn":if(y="WEBNN",typeof g!="string"){let $=g==null?void 0:g.deviceType;$&&nn(s,"deviceType",$,d)}break;case"webgpu":if(y="JS",typeof g!="string"){let $=g;if($!=null&&$.preferredLayout){if($.preferredLayout!=="NCHW"&&$.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${$.preferredLayout}`);nn(s,"preferredLayout",$.preferredLayout,d)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${y}`)}let b=Fe(y,d),P=x.length,k=0,O=0;if(P>0){k=se()._malloc(P*se().PTR_SIZE),d.push(k),O=se()._malloc(P*se().PTR_SIZE),d.push(O);for(let $=0;$<P;$++)se().setValue(k+$*se().PTR_SIZE,x[$][0],"*"),se().setValue(O+$*se().PTR_SIZE,x[$][1],"*")}await se()._OrtAppendExecutionProvider(s,b,k,O,P)!==0&&pt(`Can't append execution provider: ${y}.`)}},bi=async s=>{let o=se(),d=0,g=[],y=s||{};Vt(y);try{let x=Dt(y.graphOptimizationLevel??"all"),b=tn(y.executionMode??"sequential"),P=typeof y.logId=="string"?Fe(y.logId,g):0,k=y.logSeverityLevel??2;if(!Number.isInteger(k)||k<0||k>4)throw new Error(`log serverity level is not valid: ${k}`);let O=y.logVerbosityLevel??0;if(!Number.isInteger(O)||O<0||O>4)throw new Error(`log verbosity level is not valid: ${O}`);let $=typeof y.optimizedModelFilePath=="string"?Fe(y.optimizedModelFilePath,g):0;if(d=o._OrtCreateSessionOptions(x,!!y.enableCpuMemArena,!!y.enableMemPattern,b,!!y.enableProfiling,0,P,k,O,$),d===0&&pt("Can't create session options."),y.executionProviders&&await Tn(d,y.executionProviders,g),y.enableGraphCapture!==void 0){if(typeof y.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${y.enableGraphCapture}`);nn(d,"enableGraphCapture",y.enableGraphCapture.toString(),g)}if(y.freeDimensionOverrides)for(let[V,G]of Object.entries(y.freeDimensionOverrides)){if(typeof V!="string")throw new Error(`free dimension override name must be a string: ${V}`);if(typeof G!="number"||!Number.isInteger(G)||G<0)throw new Error(`free dimension override value must be a non-negative integer: ${G}`);let ee=Fe(V,g);o._OrtAddFreeDimensionOverride(d,ee,G)!==0&&pt(`Can't set a free dimension override: ${V} - ${G}.`)}return y.extra!==void 0&&Ke(y.extra,"",new WeakSet,(V,G)=>{nn(d,V,G,g)}),[d,g]}catch(x){throw d!==0&&o._OrtReleaseSessionOptions(d)!==0&&pt("Can't release session options."),g.forEach(b=>o._free(b)),x}}}),Bi,gi,ki,Mi,Ms,Ts,zs,zi,Wt=l(()=>{Bi=s=>{switch(s){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${s}`)}},gi=s=>{switch(s){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${s}`)}},ki=(s,o)=>{let d=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][s],g=typeof o=="number"?o:o.reduce((y,x)=>y*x,1);return d>0?Math.ceil(g*d):void 0},Mi=s=>{switch(s){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${s}`)}},Ms=s=>{switch(s){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${s}`)}},Ts=s=>s==="float32"||s==="float16"||s==="int32"||s==="int64"||s==="uint32"||s==="uint8"||s==="bool"||s==="uint4"||s==="int4",zs=s=>s==="float32"||s==="float16"||s==="int32"||s==="int64"||s==="uint32"||s==="uint64"||s==="int8"||s==="uint8"||s==="bool"||s==="uint4"||s==="int4",zi=s=>{switch(s){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${s}`)}}}),ji,or=l(()=>{tt(),ji=async s=>{if(typeof s=="string"){let o=await fetch(s);if(!o.ok)throw new Error(`failed to load external data file: ${s}`);let d=o.headers.get("Content-Length"),g=d?parseInt(d,10):0;if(g<1073741824)return new Uint8Array(await o.arrayBuffer());{if(!o.body)throw new Error(`failed to load external data file: ${s}, no response body.`);let y=o.body.getReader(),x;try{x=new ArrayBuffer(g)}catch(P){if(P instanceof RangeError){let k=Math.ceil(g/65536);x=new WebAssembly.Memory({initial:k,maximum:k}).buffer}else throw P}let b=0;for(;;){let{done:P,value:k}=await y.read();if(P)break;let O=k.byteLength;new Uint8Array(x,b,O).set(k),b+=O}return new Uint8Array(x,0,g)}}else return s instanceof Blob?new Uint8Array(await s.arrayBuffer()):s instanceof Uint8Array?s:new Uint8Array(s)}}),$s,Ns,Us,rs,_i,bt,ct,Lt=l(()=>{Wt(),$s=["V","I","W","E","F"],Ns=(s,o)=>{console.log(`[${$s[s]},${new Date().toISOString()}]${o}`)},_i=(s,o)=>{Us=s,rs=o},bt=(s,o)=>{let d=Ms(s),g=Ms(Us);d>=g&&Ns(d,typeof o=="function"?o():o)},ct=(...s)=>{rs&&bt(...s)}}),yn,Wi,it,Es,ro,Xe,j,ie=l(()=>{yn=class{static calcMatMulShape(s,o){return s[1]!==o[0]?void 0:[s[0],o[1]]}},Wi=class{static calcShape(s,o,d=!1){let g=s.length,y=o.length;if(g===0)return o;if(y===0)return s;let x=Math.max(s.length,o.length),b=new Array(x);if(d){if(g<2||y<2)return;let P=yn.calcMatMulShape([s[g-2],s[g-1]],[o[y-2],o[y-1]]);if(P===void 0)return;[b[x-2],b[x-1]]=P}for(let P=d?3:1;P<=x;P++){let k=g-P<0?1:s[g-P],O=y-P<0?1:o[y-P];if(k!==O&&k>1&&O>1)return;let $=Math.max(k,O);if(k&&O)b[x-P]=Math.max(k,O);else{if($>1)return;b[x-P]=0}}return b}static isValidBroadcast(s,o){let d=s.length,g=o.length;if(d>g)return!1;for(let y=1;y<=d;y++)if(s[d-y]!==1&&s[d-y]!==o[g-y])return!1;return!0}},it=class Wy{static size(o){return Wy.getSizeFromDimensionRange(o,0,o.length)}static convertShape(o,d=4){let g=o.length;if(g===0)return[];let y=new Array(g),x=g-1;for(;x>=0;){if(o[x]%d===0){y[x]=o[x]/d;break}if(d%o[x]!==0)throw new Error("cannot convert shape");y[x]=1,d/=o[x],x--}for(x--;x>=0;x--)y[x]=o[x];return y}static sizeFromDimension(o,d){if(d<0||d>o.length)throw new Error(`invalid dimension of ${d} for sizeFromDimension as Tensor has ${o.length} dimensions.`);return Wy.getSizeFromDimensionRange(o,d,o.length)}static sizeToDimension(o,d){if(d<0||d>o.length)throw new Error(`invalid dimension of ${d} for sizeToDimension as Tensor has ${o.length} dimensions.`);return Wy.getSizeFromDimensionRange(o,0,d)}static getSizeFromDimensionRange(o,d,g){let y=1;for(let x=d;x<g;x++){if(o[x]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");y*=Number(o[x])}return y}static computeStrides(o){let d=o.length;if(d===0)return[];if(d===1)return[1];let g=new Array(d);g[d-1]=1,g[d-2]=o[d-1];for(let y=d-3;y>=0;--y)g[y]=g[y+1]*o[y+1];return g}static normalizeAxis(o,d){if(o<-d&&o>=d)throw new Error("unsupported axis for this operation.");return o<0?o+d:o}static normalizeAxes(o,d){return o.map(g=>this.normalizeAxis(g,d??o.length))}static sortBasedOnPerm(o,d){return d?d.map(g=>o[g]):o.slice().reverse()}static padShape(o,d){let g=o.length;return o.map((y,x)=>y+d[x]+d[x+g])}static areEqual(o,d){return o.length!==d.length?!1:o.every((g,y)=>g===d[y])}},Es=class gg{static adjustPoolAttributes(o,d,g,y,x,b){if(!o&&g.length!==d.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(o)for(let P=0;P<d.length-2;P++)P>=g.length?g.push(d[P+2]):g[P]=d[P+2];for(let P=0;P<g.length;P++)if(P<y.length){if(y[P]<0)throw new Error("strides should be greater than or equal to 1")}else y.push(1);for(let P=0;P<g.length;P++)if(P<x.length){if(x[P]<0)throw new Error("dilations should be greater than or equal to 1")}else x.push(1);for(let P=0;P<g.length*2;P++)if(P<b.length){if(b[P]<0)throw new Error("pad should be greater than or equal to 1")}else b.push(0);for(let P=0;P<g.length;P++){if(g[P]<=0)throw new Error("kernel shapes need to be greater than 0");if(b[P]>=g[P]||b[P+g.length]>=g[P])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(o,d,g,y,x,b,P){if(P){if(x.length!==2*(o.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(d.length!==o.length-2)throw new Error("length of strides should be the length of data dimensions");if(y.length!==o.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let k=0;k<o.length-2;k++)gg.adjustPadAndReturnShape(o[k+(b?1:2)],d[k],g[k],y[k],x,k,k+o.length-2,P)}}static computePoolOutputShape(o,d,g,y,x,b,P){if(d.length<=0)throw new Error("input shape must be of size greater than 0");let k=[d[0],d[1]];return gg.computeShapeHelper(o,d,k,g,y,x,b,P),k}static computeConvOutputShape(o,d,g,y,x,b,P){if(o.length<=0||d.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let k=[o[0],d[0]];return gg.computeShapeHelper(!1,o,k,g,y,x,b,P),k}static computeShapeHelper(o,d,g,y,x,b,P,k){if(o)for(let O=0;O<d.length-2;O++)g.push(1);else for(let O=0;O<d.length-2;O++)g.push(gg.adjustPadAndReturnShape(d[O+2],y[O],x[O],b[O],P,O,O+d.length-2,k))}static adjustPadAndReturnShape(o,d,g,y,x,b,P,k){let O=g*(y-1)+1;if(k&&k!=="NOTSET")switch(k){case"VALID":return x[b]=0,x[P]=0,Math.floor((o-O)/d+1);case"SAME_LOWER":case"SAME_UPPER":if(g!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let $=((o+d-1)/d-1)*d+y-o;return x[b]=Math.floor(k==="SAME_LOWER"?($+1)/2:$/2),x[P]=$-x[b],Math.floor((o+$-y)/d+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((o+x[b]+x[P]-O)/d+1)}},ro=class{static getShapeOfGemmResult(s,o,d,g,y){if(s.length!==2||d.length!==2)throw new Error("shape need to be of size 2");let x,b,P;o?(x=s[1],b=s[0]):(x=s[0],b=s[1]);let k=-1;if(g?(P=d[0],k=1):(P=d[1],k=0),d[k]!==b)throw new Error("dimension mismatch");if(x<=0||P<=0||b<=0)throw new Error("invalid shape specified");if(y&&!Wi.isValidBroadcast(y,[x,P]))throw new Error("gemm: invalid bias shape for broadcast");return[x,P,b]}},Xe=-34028234663852886e22,j=34028234663852886e22}),Ae,Re=l(()=>{Wt(),Ae=(s,o)=>new(Mi(o))(s)}),We,ot,Et,It,At,kt,Yt,pn,_n,Bn,En=l(()=>{Lt(),We=(s,o=!0)=>{if(s.byteLength%8!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 8 (BigInt).");let d=s.byteLength/8,g=new BigInt64Array(s.buffer,s.byteOffset,d),y=new Int32Array(d);for(let x=0;x<d;x++){let b=g[x];if(b>2147483647n||b<-2147483648n)throw new Error(`Overflow occurred when converting BigInt to Int32 at index ${x}: ${b}`);y[x]=Number(b)}return o?new Uint8Array(y.buffer):y},ot=(s,o=!0)=>{if(s.byteLength%4!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (Int32).");let d=s.byteLength/4,g=new Int32Array(s.buffer,s.byteOffset,d),y=BigInt64Array.from(g,BigInt);return o?new Uint8Array(y.buffer):y},Et=1,It=()=>Et++,At=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),kt=(s,o)=>{let d=At.get(s);if(!d)throw new Error("Unsupported data type.");return o.length>0?Math.ceil(o.reduce((g,y)=>g*y)*d/8):0},Yt=class{constructor(s){this.shouldConvertInt64toInt32=!1,this.isInt64ToInt32Converted=!1;let{sessionId:o,context:d,tensor:g,dataType:y,shape:x,shouldConvertInt64toInt32:b=!1}=s;this.sessionId=o,this.mlContext=d,this.mlTensor=g,this.dataType=y,this.tensorShape=x,this.shouldConvertInt64toInt32=b}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return kt(this.dataType,this.tensorShape)}destroy(){ct("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(s){this.mlContext.writeTensor(this.mlTensor,s)}async read(s,o){if(s){let d=await this.mlContext.readTensor(this.mlTensor),g=ot(new Uint8Array(d));if(o){(o instanceof ArrayBuffer?new Uint8Array(o):new Uint8Array(o.buffer,o.byteOffset,o.byteLength)).set(g);return}else return g.buffer}else return o?this.mlContext.readTensor(this.mlTensor,o):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(s,o,d){return this.mlContext===s&&this.dataType===o&&this.tensorShape.length===d.length&&this.tensorShape.every((g,y)=>g===d[y])}setIsInt64ToInt32Converted(s){this.isInt64ToInt32Converted=s}},pn=class{constructor(s,o){this.tensorManager=s,this.wrapper=o}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(s,o,d,g){let y=o,x=this.tensorManager.getMLContext(s),b=y==="int64"&&!x.opSupportLimits().input.dataTypes.includes("int64");if(b&&(y="int32",ct("verbose",()=>"[WebNN] TensorIdTracker.ensureTensor: convert dataType from int64 to int32")),this.wrapper){if(this.wrapper.canReuseTensor(x,y,d))return this.wrapper.tensor;if(g){if(this.wrapper.byteLength!==kt(y,d))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let P=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(s,y,d,P,!0,!0,b),g&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(s){let o=s;if(this.wrapper)if(this.wrapper.shouldConvertInt64toInt32&&(o=We(s,!0),this.wrapper.setIsInt64ToInt32Converted(!0)),o.byteLength===this.wrapper.byteLength){this.wrapper.write(o);return}else ct("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor();this.activeUpload?this.activeUpload.set(o):this.activeUpload=new Uint8Array(o)}async download(s){var o,d,g;if(this.activeUpload){let y=(o=this.wrapper)!=null&&o.isInt64ToInt32Converted?ot(this.activeUpload):this.activeUpload;if(s){s instanceof ArrayBuffer?new Uint8Array(s).set(y):new Uint8Array(s.buffer,s.byteOffset,s.byteLength).set(y);return}else return y.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return s?this.wrapper.read((d=this.wrapper)==null?void 0:d.shouldConvertInt64toInt32,s):this.wrapper.read((g=this.wrapper)==null?void 0:g.shouldConvertInt64toInt32)}},_n=class{constructor(s){this.backend=s,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(s){let o=this.backend.getMLContext(s);if(!o)throw new Error("MLContext not found for session.");return o}reserveTensorId(){let s=It();return this.tensorTrackersById.set(s,new pn(this)),s}releaseTensorId(s){let o=this.tensorTrackersById.get(s);o&&(this.tensorTrackersById.delete(s),o.tensorWrapper&&this.releaseTensor(o.tensorWrapper))}async ensureTensor(s,o,d,g,y){ct("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${o}, dataType: ${d}, shape: ${g}, copyOld: ${y}}`);let x=this.tensorTrackersById.get(o);if(!x)throw new Error("Tensor not found.");return x.ensureTensor(s,d,g,y)}upload(s,o){let d=this.tensorTrackersById.get(s);if(!d)throw new Error("Tensor not found.");d.upload(o)}async download(s,o){ct("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${s}, dstBuffer: ${o==null?void 0:o.byteLength}}`);let d=this.tensorTrackersById.get(s);if(!d)throw new Error("Tensor not found.");return d.download(o)}releaseTensorsForSession(s){for(let o of this.freeTensors)o.sessionId===s&&o.destroy();this.freeTensors=this.freeTensors.filter(o=>o.sessionId!==s)}registerTensor(s,o,d,g){let y=this.getMLContext(s),x=It(),b=new Yt({sessionId:s,context:y,tensor:o,dataType:d,shape:g});return this.tensorTrackersById.set(x,new pn(this,b)),this.externalTensors.add(b),x}async getCachedTensor(s,o,d,g,y,x,b=!1){let P=this.getMLContext(s);for(let[O,$]of this.freeTensors.entries())if($.canReuseTensor(P,o,d)){ct("verbose",()=>`[WebNN] Reusing tensor {dataType: ${o}, shape: ${d}}`);let V=this.freeTensors.splice(O,1)[0];return V.sessionId=s,V}ct("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${o}, shape: ${d}}`);let k=await P.createTensor({dataType:o,shape:d,dimensions:d,usage:g,writable:y,readable:x});return new Yt({sessionId:s,context:P,tensor:k,dataType:o,shape:d,shouldConvertInt64toInt32:b})}releaseTensor(s){this.externalTensors.has(s)&&this.externalTensors.delete(s),this.freeTensors.push(s)}},Bn=(...s)=>new _n(...s)}),Un,di,Ti,Ss=l(()=>{Wt(),ge(),Re(),En(),Lt(),Un=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),di=(s,o)=>{if(s===o)return!0;if(s===void 0||o===void 0)return!1;let d=Object.keys(s).sort(),g=Object.keys(o).sort();return d.length===g.length&&d.every((y,x)=>y===g[x]&&s[y]===o[y])},Ti=class{constructor(s){this.tensorManager=Bn(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,_i(s.logLevel,!!s.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(s){ct("verbose",()=>`[WebNN] onRunStart {sessionId: ${s}}`),this.activeSessionId=s}onRunEnd(s){ct("verbose",()=>`[WebNN] onRunEnd {sessionId: ${s}}`);let o=this.temporarySessionTensorIds.get(s);if(o){for(let d of o)ct("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${d}}`),this.tensorManager.releaseTensorId(d);this.temporarySessionTensorIds.delete(s),this.activeSessionId=void 0}}async createMLContext(s){if(s instanceof GPUDevice){let d=this.mlContextCache.findIndex(g=>g.gpuDevice===s);if(d!==-1)return this.mlContextCache[d].mlContext;{let g=await navigator.ml.createContext(s);return this.mlContextCache.push({gpuDevice:s,mlContext:g}),g}}else if(s===void 0){let d=this.mlContextCache.findIndex(g=>g.options===void 0&&g.gpuDevice===void 0);if(d!==-1)return this.mlContextCache[d].mlContext;{let g=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:g}),g}}let o=this.mlContextCache.findIndex(d=>di(d.options,s));if(o!==-1)return this.mlContextCache[o].mlContext;{let d=await navigator.ml.createContext(s);return this.mlContextCache.push({options:s,mlContext:d}),d}}registerMLContext(s,o){this.mlContextBySessionId.set(s,o);let d=this.sessionIdsByMLContext.get(o);d||(d=new Set,this.sessionIdsByMLContext.set(o,d)),d.add(s),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(s,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(s){this.sessionGraphInputs.delete(s);let o=this.mlContextBySessionId.get(s);if(!o)return;this.tensorManager.releaseTensorsForSession(s),this.mlContextBySessionId.delete(s);let d=this.sessionIdsByMLContext.get(o);if(d.delete(s),d.size===0){this.sessionIdsByMLContext.delete(o);let g=this.mlContextCache.findIndex(y=>y.mlContext===o);g!==-1&&this.mlContextCache.splice(g,1)}}getMLContext(s){return this.mlContextBySessionId.get(s)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(s){ct("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${s}}`),this.tensorManager.releaseTensorId(s)}async ensureTensor(s,o,d,g,y){let x=Un.get(d);if(!x)throw new Error(`Unsupported ONNX data type: ${d}`);return this.tensorManager.ensureTensor(s??this.currentSessionId,o,x,g,y)}async createTemporaryTensor(s,o,d){ct("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${o}, shape: ${d}}`);let g=Un.get(o);if(!g)throw new Error(`Unsupported ONNX data type: ${o}`);let y=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(s,y,g,d,!1);let x=this.temporarySessionTensorIds.get(s);return x?x.push(y):this.temporarySessionTensorIds.set(s,[y]),y}uploadTensor(s,o){if(!se().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");ct("verbose",()=>`[WebNN] uploadTensor {tensorId: ${s}, data: ${o.byteLength}}`),this.tensorManager.upload(s,o)}async downloadTensor(s,o){return this.tensorManager.download(s,o)}createMLTensorDownloader(s,o){return async()=>{let d=await this.tensorManager.download(s);return Ae(d,o)}}registerMLTensor(s,o,d,g){let y=Un.get(d);if(!y)throw new Error(`Unsupported ONNX data type: ${d}`);let x=this.tensorManager.registerTensor(s,o,y,g);return ct("verbose",()=>`[WebNN] registerMLTensor {tensor: ${o}, dataType: ${y}, dimensions: ${g}} -> {tensorId: ${x}}`),x}registerMLConstant(s,o,d,g,y,x,b=!1){if(!x)throw new Error("External mounted files are not available.");let P=s;s.startsWith("./")&&(P=s.substring(2));let k=x.get(P);if(!k)throw new Error(`File with name ${P} not found in preloaded files.`);if(o+d>k.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let O=k.slice(o,o+d).buffer,$;switch(y.dataType){case"float32":$=new Float32Array(O);break;case"float16":$=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(O):new Uint16Array(O);break;case"int32":$=new Int32Array(O);break;case"uint32":$=new Uint32Array(O);break;case"int64":b?($=We(new Uint8Array(O),!1),y.dataType="int32"):$=new BigInt64Array(O);break;case"uint64":$=new BigUint64Array(O);break;case"int8":$=new Int8Array(O);break;case"int4":case"uint4":case"uint8":$=new Uint8Array(O);break;default:throw new Error(`Unsupported data type: ${y.dataType} in creating WebNN Constant from external data.`)}return ct("verbose",()=>`[WebNN] registerMLConstant {dataType: ${y.dataType}, shape: ${y.shape}}} ${b?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),g.constant(y,$)}registerGraphInput(s){this.temporaryGraphInputs.push(s)}isGraphInput(s,o){let d=this.sessionGraphInputs.get(s);return d?d.includes(o):!1}isInt64Supported(s){var o;return!!((o=this.mlContextBySessionId.get(s))!=null&&o.opSupportLimits().input.dataTypes.includes("int64"))}flush(){}}}),ti=l(()=>{}),Ps,In,Wn,ri,os,as,oi,ls,Qn,Hn=l(()=>{Lt(),ti(),Ps=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),In=[],Wn=s=>Math.ceil(Number(s)/16)*16,ri=s=>{for(let o=0;o<In.length;o++){let d=In[o];if(s<=d)return d}return Math.ceil(s/16)*16},os=1,as=()=>os++,oi=async(s,o,d,g)=>{let y=Wn(d),x=s.device.createBuffer({size:y,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let b=s.getCommandEncoder();s.endComputePass(),b.copyBufferToBuffer(o,0,x,0,y),s.flush(),await x.mapAsync(GPUMapMode.READ);let P=x.getMappedRange();if(g){let k=g();return k.set(new Uint8Array(P,0,d)),k}else return new Uint8Array(P.slice(0,d))}finally{x.destroy()}},ls=class{constructor(s){this.backend=s,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[o]of Ps)In.push(o),this.freeBuffers.set(o,[]),this.freeUniformBuffers.set(o,[]);this.sessionCount=0}upload(s,o){let d=o.buffer,g=o.byteOffset,y=o.byteLength,x=Wn(y),b=this.storageCache.get(s);if(!b)throw new Error("gpu data for uploading does not exist");if(Number(b.originalSize)!==y)throw new Error(`inconsistent data size. gpu data size=${b.originalSize}, data size=${y}`);let P=this.backend.device.createBuffer({mappedAtCreation:!0,size:x,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),k=P.getMappedRange();new Uint8Array(k).set(new Uint8Array(d,g,y)),P.unmap();let O=this.backend.device.createCommandEncoder();O.copyBufferToBuffer(P,0,b.gpuData.buffer,0,x),this.backend.device.queue.submit([O.finish()]),P.destroy(),ct("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${s})`)}memcpy(s,o){let d=this.storageCache.get(s);if(!d)throw new Error("source gpu data for memcpy does not exist");let g=this.storageCache.get(o);if(!g)throw new Error("destination gpu data for memcpy does not exist");if(d.originalSize!==g.originalSize)throw new Error("inconsistent source and destination gpu data size");let y=Wn(d.originalSize),x=this.backend.getCommandEncoder();this.backend.endComputePass(),x.copyBufferToBuffer(d.gpuData.buffer,0,g.gpuData.buffer,0,y)}registerExternalBuffer(s,o,d){let g;if(d){if(g=d[0],s===d[1])return ct("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${o}) => id=${g}, buffer is the same, skip.`),g;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else g=as();return this.storageCache.set(g,{gpuData:{id:g,type:0,buffer:s},originalSize:o}),ct("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${o}) => id=${g}, registered.`),g}unregisterExternalBuffer(s){s!==void 0&&(this.storageCache.delete(s),ct("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${s}`))}create(s,o=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let d=ri(s),g,y=(o&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,x=(o&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(y||x){let P=(y?this.freeBuffers:this.freeUniformBuffers).get(d);P?P.length>0?g=P.pop():g=this.backend.device.createBuffer({size:d,usage:o}):g=this.backend.device.createBuffer({size:d,usage:o})}else g=this.backend.device.createBuffer({size:d,usage:o});let b={id:as(),type:0,buffer:g};return this.storageCache.set(b.id,{gpuData:b,originalSize:Number(s)}),ct("verbose",()=>`[WebGPU] GpuDataManager.create(size=${s}) => id=${b.id}`),b}get(s){var o;return(o=this.storageCache.get(s))==null?void 0:o.gpuData}release(s){let o=typeof s=="bigint"?Number(s):s,d=this.storageCache.get(o);if(!d){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return ct("verbose",()=>`[WebGPU] GpuDataManager.release(id=${o}), gpuDataId=${d.gpuData.id}`),this.storageCache.delete(o),this.buffersPending.push(d.gpuData.buffer),d.originalSize}async download(s,o){let d=this.storageCache.get(Number(s));if(!d)throw new Error("data does not exist");await oi(this.backend,d.gpuData.buffer,d.originalSize,o)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let s of this.buffersPending){let o=Ps.get(s.size);if((s.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let d=this.freeBuffers.get(s.size)||[];o===void 0||d.length>=o?s.destroy():d.push(s)}else if((s.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let d=this.freeUniformBuffers.get(s.size)||[];o===void 0||d.length>=o?s.destroy():d.push(s)}else s.destroy()}this.buffersPending=[]}else{let s=this.capturedPendingBuffers.get(this.backend.currentSessionId);s||(s=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,s));for(let o of this.buffersPending)s.push(o);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(s=>{s.forEach(o=>{o.destroy()})}),this.freeUniformBuffers.forEach(s=>{s.forEach(o=>{o.destroy()})}),this.storageCache.forEach(s=>{s.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(s=>{s.forEach(o=>{o.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(s){let o=this.capturedPendingBuffers.get(s);o&&(o.forEach(d=>{d.destroy()}),this.capturedPendingBuffers.delete(s)),this.sessionCount-=1,this.sessionCount===0&&(ct("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(d=>{d.gpuData.buffer.destroy()}),this.storageCache=new Map)}},Qn=(...s)=>new ls(...s)}),qn,Jt,mn=l(()=>{qn=class{constructor(s){Object.assign(this,s)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(s=>`${this[s]}`).join(";")),this.key}},Jt=s=>new qn(s)}),cs,us,Zn,hi,Gt,kn,Sl,ds,Gs,Nt,oo,dt,$t,Dr,Pl,zd,$d,sn=l(()=>{Wt(),ie(),cs=64,us=(s,o)=>{if(o===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(s)){case 10:return o>1?`vec${o}<f16>`:"f16";case 1:return o>1?`vec${o}<f32>`:"f32";case 6:return o>1?`vec${o}<i32>`:"i32";case 12:return o>1?`vec${o}<u32>`:"u32";case 7:if(o>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(o>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(o!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${s}`)}},Zn=(s,o=1)=>{let d=us(s,o);return typeof d=="string"?d:d[0]},hi=(s,o=1)=>{let d=us(s,o);return typeof d=="string"?d:d[1]},Gt=(...s)=>{let o=[];return s.forEach(d=>{d.length!==0&&o.push({type:12,data:d},{type:12,data:it.computeStrides(d)})}),o},kn=s=>s%4===0?4:s%2===0?2:1,Sl=(s="f32",o,d="0")=>!o||o===1?`${s}(${d})`:`vec${o}<${s}>(${d})`,ds=(s,o,d)=>s==="f32"?d:o===1?`f32(${d})`:`vec${o}<f32>(${d})`,Gs=(s,o)=>o===4?`(${s}.x + ${s}.y + ${s}.z + ${s}.w)`:o===2?`(${s}.x + ${s}.y)`:o===3?`(${s}.x + ${s}.y + ${s}.z)`:s,Nt=(s,o,d,g)=>s.startsWith("uniforms.")&&d>4?typeof o=="string"?g==="f16"?`${s}[(${o}) / 8][(${o}) % 8 / 4][(${o}) % 8 % 4]`:`${s}[(${o}) / 4][(${o}) % 4]`:g==="f16"?`${s}[${Math.floor(o/8)}][${Math.floor(o%8/4)}][${o%8%4}]`:`${s}[${Math.floor(o/4)}][${o%4}]`:d>1?`${s}[${o}]`:s,oo=(s,o,d,g,y)=>{let x=typeof d=="number",b=x?d:d.length,P=[...new Array(b).keys()],k=b<2?"u32":b<=4?`vec${b}<u32>`:`array<u32, ${b}>`,O=us(o,y),$=typeof O=="string"?O:O[1],V=typeof O=="string"?O:O[0],G={indices:k,value:$,storage:V,tensor:o},ee=Ze=>typeof Ze=="string"?Ze:`${Ze}u`,X={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},re=x?"uniforms.":"",Te=`${re}${s}_shape`,ue=`${re}${s}_strides`,ce="";for(let Ze=0;Ze<b-1;Ze++)ce+=`
    let dim${Ze} = current / ${Nt(ue,Ze,b)};
    let rest${Ze} = current % ${Nt(ue,Ze,b)};
    indices[${Ze}] = dim${Ze};
    current = rest${Ze};
    `;ce+=`indices[${b-1}] = current;`;let ke=b<2?"":`
  fn o2i_${s}(offset: u32) -> ${G.indices} {
    var indices: ${G.indices};
    var current = offset;
    ${ce}
    return indices;
  }`,Le=Ze=>(X.offsetToIndices=!0,b<2?Ze:`o2i_${s}(${Ze})`),M=[];if(b>=2)for(let Ze=b-1;Ze>=0;Ze--)M.push(`${Nt(ue,Ze,b)} * (indices[${Ze}])`);let C=b<2?"":`
  fn i2o_${s}(indices: ${G.indices}) -> u32 {
    return ${M.join("+")};
  }`,z=Ze=>(X.indicesToOffset=!0,b<2?Ze:`i2o_${s}(${Ze})`),oe=(...Ze)=>b===0?"0u":`${G.indices}(${Ze.map(ee).join(",")})`,ve=(Ze,ft)=>b<2?`${Ze}`:`${Nt(Ze,ft,b)}`,Pe=(Ze,ft,St)=>b<2?`${Ze}=${St};`:`${Nt(Ze,ft,b)}=${St};`,Ue={},Je=(Ze,ft)=>{X.broadcastedIndicesToOffset=!0;let St=`${ft.name}broadcastedIndicesTo${s}Offset`;if(St in Ue)return`${St}(${Ze})`;let Ht=[];for(let un=b-1;un>=0;un--){let Sn=ft.indicesGet("outputIndices",un+ft.rank-b);Ht.push(`${ve(ue,un)} * (${Sn} % ${ve(Te,un)})`)}return Ue[St]=`fn ${St}(outputIndices: ${ft.type.indices}) -> u32 {
             return ${Ht.length>0?Ht.join("+"):"0u"};
           }`,`${St}(${Ze})`},st=(Ze,ft)=>(()=>{if(G.storage===G.value)return`${s}[${Ze}]=${ft};`;if(G.storage==="vec2<u32>"&&G.value==="i32")return`${s}[${Ze}]=vec2<u32>(u32(${ft}), select(0u, 0xFFFFFFFFu, ${ft} < 0));`;if(G.storage==="vec2<u32>"&&G.value==="u32")return`${s}[${Ze}]=vec2<u32>(u32(${ft}), 0u);`;if(G.storage==="u32"&&G.value==="vec4<bool>")return`${s}[${Ze}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${ft}));`;throw new Error(`not supported combination of storage type ${G.storage} and value type ${G.value} yet`)})(),gt=Ze=>(()=>{if(G.storage===G.value)return`${s}[${Ze}]`;if(G.storage==="vec2<u32>"&&G.value==="i32")return`i32(${s}[${Ze}].x)`;if(G.storage==="vec2<u32>"&&G.value==="u32")return`u32(${s}[${Ze}].x)`;if(G.storage==="u32"&&G.value==="vec4<bool>")return`vec4<bool>(bool(${s}[${Ze}] & 0xFFu), bool(${s}[${Ze}] & 0xFF00u), bool(${s}[${Ze}] & 0xFF0000u), bool(${s}[${Ze}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${G.storage} and value type ${G.value} yet`)})(),wt=b<2?"":`
  fn get_${s}ByIndices(indices: ${G.indices}) -> ${$} {
    return ${gt(`i2o_${s}(indices)`)};
  }`,yt=b<2?"":(()=>{let Ze=P.map(St=>`d${St}: u32`).join(", "),ft=P.map(St=>`d${St}`).join(", ");return`
  fn get_${s}(${Ze}) -> ${$} {
    return get_${s}ByIndices(${oe(ft)});
  }`})(),ht=(...Ze)=>{if(Ze.length!==b)throw new Error(`indices length must be ${b}`);let ft=Ze.map(ee).join(",");return b===0?gt("0u"):b===1?gt(ft[0]):(X.get=!0,X.getByIndices=!0,X.indicesToOffset=!0,`get_${s}(${ft})`)},Ft=Ze=>b<2?gt(Ze):(X.getByIndices=!0,X.indicesToOffset=!0,`get_${s}ByIndices(${Ze})`),xt=b<2?"":`
  fn set_${s}ByIndices(indices: ${G.indices}, value: ${$}) {
    ${st(`i2o_${s}(indices)`,"value")}
  }`,Ct=b<2?"":(()=>{let Ze=P.map(St=>`d${St}: u32`).join(", "),ft=P.map(St=>`d${St}`).join(", ");return`
  fn set_${s}(${Ze}, value: ${$}) {
    set_${s}ByIndices(${oe(ft)}, value);
  }`})();return{impl:()=>{let Ze=[],ft=!1;return X.offsetToIndices&&(Ze.push(ke),ft=!0),X.indicesToOffset&&(Ze.push(C),ft=!0),X.broadcastedIndicesToOffset&&(Object.values(Ue).forEach(St=>Ze.push(St)),ft=!0),X.set&&(Ze.push(Ct),ft=!0),X.setByIndices&&(Ze.push(xt),ft=!0),X.get&&(Ze.push(yt),ft=!0),X.getByIndices&&(Ze.push(wt),ft=!0),!x&&ft&&Ze.unshift(`const ${Te} = ${G.indices}(${d.join(",")});`,`const ${ue} = ${G.indices}(${it.computeStrides(d).join(",")});`),Ze.join(`
`)},type:G,offsetToIndices:Le,indicesToOffset:z,broadcastedIndicesToOffset:Je,indices:oe,indicesGet:ve,indicesSet:Pe,set:(...Ze)=>{if(Ze.length!==b+1)throw new Error(`indices length must be ${b}`);let ft=Ze[b];if(typeof ft!="string")throw new Error("value must be string");let St=Ze.slice(0,b).map(ee).join(",");return b===0?st("0u",ft):b===1?st(St[0],ft):(X.set=!0,X.setByIndices=!0,X.indicesToOffset=!0,`set_${s}(${St}, ${ft})`)},setByOffset:st,setByIndices:(Ze,ft)=>b<2?st(Ze,ft):(X.setByIndices=!0,X.indicesToOffset=!0,`set_${s}ByIndices(${Ze}, ${ft});`),get:ht,getByOffset:gt,getByIndices:Ft,usage:g,name:s,strides:ue,shape:Te,rank:b}},dt=(s,o,d,g=1)=>oo(s,o,d,"input",g),$t=(s,o,d,g=1)=>oo(s,o,d,"output",g),Dr=(s,o,d)=>oo(s,o,d,"atomicOutput",1),Pl=(s,o,d,g=1)=>oo(s,o,d,"internal",g),zd=class{constructor(s,o){this.normalizedDispatchGroup=s,this.limits=o,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(s){return`if (global_idx >= ${typeof s=="number"?`${s}u`:s}) { return; }`}mainStart(s=cs){let o=typeof s=="number"?s:s[0],d=typeof s=="number"?1:s[1],g=typeof s=="number"?1:s[2];if(o>this.limits.maxComputeWorkgroupSizeX||d>this.limits.maxComputeWorkgroupSizeY||g>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${o}, ${d}, ${g}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(o*d*g>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${o}, ${d}, ${g}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let y=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,x=y?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,b=y?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${o*d*g}u + local_idx;`;return`@compute @workgroup_size(${o}, ${d}, ${g})
  fn main(${x}) {
    ${b}
  `}appendVariableUniforms(s){s.rank!==0&&(s.shape.startsWith("uniforms.")&&this.uniforms.push({name:s.shape.replace("uniforms.",""),type:"u32",length:s.rank}),s.strides.startsWith("uniforms.")&&this.uniforms.push({name:s.strides.replace("uniforms.",""),type:"u32",length:s.rank}))}declareVariable(s,o){if(s.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(s),this.appendVariableUniforms(s);let d=s.usage==="input"?"read":"read_write",g=s.usage==="atomicOutput"?"atomic<i32>":s.type.storage;return`@group(0) @binding(${o}) var<storage, ${d}> ${s.name}: array<${g}>;`}declareVariables(...s){return s.map(o=>this.declareVariable(o,this.variableIndex++)).join(`
`)}registerInternalVariable(s){if(s.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(s),this.appendVariableUniforms(s)}registerInternalVariables(...s){return s.forEach(o=>this.registerInternalVariable(o)),this}registerUniform(s,o,d=1){return this.uniforms.push({name:s,type:o,length:d}),this}registerUniforms(s){return this.uniforms=this.uniforms.concat(s),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let s=[];for(let{name:o,type:d,length:g}of this.uniforms)if(g&&g>4)d==="f16"?s.push(`@align(16) ${o}:array<mat2x4<${d}>, ${Math.ceil(g/8)}>`):s.push(`${o}:array<vec4<${d}>, ${Math.ceil(g/4)}>`);else{let y=g==null||g===1?d:`vec${g}<${d}>`;s.push(`${o}:${y}`)}return`
      struct Uniforms { ${s.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(s=>s.impl()).join(`
`)+this.internalVariables.map(s=>s.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let s=o=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(o)];return this.uniforms.map(o=>[s(o.type),o.length??1])}},$d=(s,o)=>new zd(s,o)}),Nd,Go,Ud,Gd,Al,Vd,Ei,jd,Cl,ar=l(()=>{Wt(),ie(),mn(),sn(),Nd=(s,o)=>{if(!s||s.length!==1)throw new Error("Transpose requires 1 input.");if(o.length!==0&&o.length!==s[0].dims.length)throw new Error(`perm size ${o.length} does not match input rank ${s[0].dims.length}`)},Go=(s,o)=>o.length!==0?o:[...new Array(s).keys()].reverse(),Ud=(s,o)=>it.sortBasedOnPerm(s,Go(s.length,o)),Gd=(s,o,d,g)=>{let y=`fn perm(i: ${g.type.indices}) -> ${d.type.indices} {
    var a: ${d.type.indices};`;for(let x=0;x<o;++x)y+=`a[${s[x]}]=i[${x}];`;return y+="return a;}"},Al=(s,o)=>{let d=[],g=[];for(let y=0;y<s.length;++y)s[y]!==1&&d.push(s[y]),s[o[y]]!==1&&g.push(o[y]);return{newShape:d,newPerm:g}},Vd=(s,o)=>{let d=0;for(let g=0;g<s.length;++g)if(o[s[g]]!==1){if(s[g]<d)return!1;d=s[g]}return!0},Ei=(s,o)=>{let d=s.dataType,g=s.dims.length,y=Go(g,o),x=Ud(s.dims,y),b=s.dims,P=x,k=g<2||Vd(y,s.dims),O;if(k)return O=X=>{let re=dt("input",d,b,4),Te=$t("output",d,P,4);return`
  ${X.registerUniform("output_size","u32").declareVariables(re,Te)}
  ${X.mainStart()}
    ${X.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let X=it.size(x);return{outputs:[{dims:x,dataType:s.dataType}],dispatchGroup:{x:Math.ceil(X/64/4)},programUniforms:[{type:12,data:Math.ceil(X/4)}]}},getShaderSource:O};let{newShape:$,newPerm:V}=Al(s.dims,y),G=it.areEqual(V,[2,3,1]),ee=it.areEqual(V,[3,1,2]);if($.length===2||G||ee){b=G?[$[0],$[1]*$[2]]:ee?[$[0]*$[1],$[2]]:$,P=[b[1],b[0]];let X=16;return O=re=>{let Te=dt("a",d,b.length),ue=$t("output",d,P.length);return`
  ${re.registerUniform("output_size","u32").declareVariables(Te,ue)}
  var<workgroup> tile : array<array<${ue.type.value}, ${X+1}>, ${X}>;
  ${re.mainStart([X,X,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${X} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${X}u + local_id.x;
    let input_row = workgroup_id_x * ${X}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${Te.getByIndices(`${Te.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${X}u + local_id.x;
    let output_row = workgroup_id_y * ${X}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${ue.setByIndices(`${ue.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let re=it.size(x);return{outputs:[{dims:x,dataType:s.dataType}],dispatchGroup:{x:Math.ceil(P[1]/X),y:Math.ceil(P[0]/X)},programUniforms:[{type:12,data:re},...Gt(b,P)]}},getShaderSource:O}}return O=X=>{let re=dt("a",d,b.length),Te=$t("output",d,P.length);return`
  ${X.registerUniform("output_size","u32").declareVariables(re,Te)}

  ${Gd(y,g,re,Te)}

  ${X.mainStart()}
    ${X.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${Te.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${Te.setByOffset("global_idx",re.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${o}`,inputDependencies:["rank"]},getRunData:()=>{let X=it.size(x);return{outputs:[{dims:x,dataType:s.dataType}],dispatchGroup:{x:Math.ceil(X/64)},programUniforms:[{type:12,data:X},...Gt(b,P)]}},getShaderSource:O}},jd=(s,o)=>{Nd(s.inputs,o.perm),s.compute(Ei(s.inputs[0],o.perm))},Cl=s=>Jt({perm:s.perm})}),Wd,Il,Ll,Vo,Hd,qd,Kd,Xd,Yd,Jd,$i,Qd,Zd,Dl,eh,jo,kl,th,Ol,lr,nh,z0=l(()=>{Wt(),ie(),sn(),Nl(),ar(),Wd={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Il={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Ll={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Vo={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Hd=(s,o)=>{let d=[];for(let g=o-s;g<o;++g)d.push(g);return d},qd=(s,o)=>{let d=[],g=s.length;for(let x=0;x<g;x++)o.indexOf(x)===-1&&d.push(s[x]);let y=o.map(x=>s[x]);return[d,y]},Kd=(s,o)=>{let d=s.length+o.length,g=[],y=0;for(let x=0;x<d;x++)o.indexOf(x)===-1?g.push(s[y++]):g.push(1);return g},Xd=(s,o)=>{for(let d=0;d<s.length;++d)if(s[s.length-d-1]!==o-1-d)return!1;return!0},Yd=(s,o)=>{let d=[];if(!Xd(s,o)){for(let g=0;g<o;++g)s.indexOf(g)===-1&&d.push(g);s.forEach(g=>d.push(g))}return d},Jd=(s,o,d,g,y,x,b)=>{let P=d[0].dims,k=it.size(x),O=it.size(b),$=dt("_A",d[0].dataType,P),V=$t("output",y,x),G=64;k===1&&(G=256);let ee=`
          var<workgroup> aBestValues : array<f32, ${G}>;
       `,X=re=>`
        ${re.registerUniform("reduceSize","u32").declareVariables($,V)}
        ${ee}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${re.mainStart(G)}

          let outputIndex = global_idx / ${G};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${Ll[g]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${G}) {
           let candidate = f32(${$.getByOffset("offset + k")});
           bestValue = ${Wd[g]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${G}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${Il[g]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${V.setByOffset("outputIndex",`${g==="mean"?`${V.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${V.type.storage}(${Vo[g]})`}`)};
         }
        }`;return{name:s,shaderCache:{hint:`${o};${G}`,inputDependencies:["type"]},getShaderSource:X,getRunData:()=>({outputs:[{dims:x,dataType:y}],dispatchGroup:{x:k},programUniforms:[{type:12,data:O}]})}},$i=(s,o,d,g)=>{let y=s.inputs.length===1?d:Ho(s.inputs,d),x=y.axes;x.length===0&&!y.noopWithEmptyAxes&&(x=s.inputs[0].dims.map((ee,X)=>X));let b=it.normalizeAxes(x,s.inputs[0].dims.length),P=b,k=s.inputs[0],O=Yd(P,s.inputs[0].dims.length);O.length>0&&(k=s.compute(Ei(s.inputs[0],O),{inputs:[0],outputs:[-1]})[0],P=Hd(P.length,k.dims.length));let[$,V]=qd(k.dims,P),G=$;y.keepDims&&(G=Kd($,b)),s.compute(Jd(o,y.cacheKey,[k],g,s.inputs[0].dataType,G,V),{inputs:[k]})},Qd=(s,o)=>{$i(s,"ReduceMeanShared",o,"mean")},Zd=(s,o)=>{$i(s,"ReduceL1Shared",o,"l1")},Dl=(s,o)=>{$i(s,"ReduceL2Shared",o,"l2")},eh=(s,o)=>{$i(s,"ReduceLogSumExpShared",o,"logSumExp")},jo=(s,o)=>{$i(s,"ReduceMaxShared",o,"max")},kl=(s,o)=>{$i(s,"ReduceMinShared",o,"min")},th=(s,o)=>{$i(s,"ReduceProdShared",o,"prod")},Ol=(s,o)=>{$i(s,"ReduceSumShared",o,"sum")},lr=(s,o)=>{$i(s,"ReduceSumSquareShared",o,"sumSquare")},nh=(s,o)=>{$i(s,"ReduceLogSumShared",o,"logSum")}}),Hi,ty,Wo,Ho,qi,ih,sh,rh,oh,qo,ah,lh,ch,Fl,uh,Ki,Rl,dh,hh,Bl,fh,ph,zl,mh,gh,$l,Nl=l(()=>{Wt(),ie(),mn(),sn(),z0(),Hi=s=>{if(!s||s.length===0||s.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(s.length===2&&s[1].dims.length!==1)throw new Error("Invalid axes input dims.")},ty=s=>["","",`var value = ${s.getByIndices("input_indices")};`,""],Wo=(s,o,d,g,y,x,b=!1,P=!1)=>{let k=[],O=d[0].dims,$=O.length,V=it.normalizeAxes(y,$),G=!P&&V.length===0;O.forEach((re,Te)=>{G||V.indexOf(Te)>=0?b&&k.push(1):k.push(re)});let ee=k.length,X=it.size(k);return{name:s,shaderCache:o,getShaderSource:re=>{let Te=[],ue=dt("_A",d[0].dataType,$),ce=$t("output",x,ee),ke=g(ue,ce,V),Le=ke[2];for(let M=0,C=0;M<$;M++)G||V.indexOf(M)>=0?(b&&C++,Le=`for(var j${M}: u32 = 0; j${M} < ${O[M]}; j${M}++) {
                  ${ke[2].includes("last_index")?`let last_index = j${M};`:""}
                  ${ue.indicesSet("input_indices",M,`j${M}`)}
                  ${Le}
                }`):(Te.push(`${ue.indicesSet("input_indices",M,ce.indicesGet("output_indices",C))};`),C++);return`

        ${re.registerUniform("output_size","u32").declareVariables(ue,ce)}

        ${re.mainStart()}
          ${re.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${ue.type.indices};
          let output_indices = ${ce.offsetToIndices("global_idx")};

          ${Te.join(`
`)}
          ${ke[0]}       // init ops for reduce max/min
          ${ke[1]}
          ${Le}
          ${ke[3]}
          ${ke.length===4?ce.setByOffset("global_idx","value"):ke.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:k,dataType:x}],dispatchGroup:{x:Math.ceil(X/64)},programUniforms:[{type:12,data:X},...Gt(O,k)]})}},Ho=(s,o)=>{let d=[];return s[1].dims[0]>0&&s[1].getBigInt64Array().forEach(g=>d.push(Number(g))),Jt({axes:d,keepDims:o.keepDims,noopWithEmptyAxes:o.noopWithEmptyAxes})},qi=(s,o,d,g)=>{let y=s.inputs,x=y.length===1?d:Ho(y,d);s.compute(Wo(o,{hint:x.cacheKey,inputDependencies:["rank"]},[y[0]],x.noopWithEmptyAxes&&x.axes.length===0?ty:g,x.axes,y[0].dataType,x.keepDims,x.noopWithEmptyAxes),{inputs:[0]})},ih=(s,o)=>{Hi(s.inputs),qi(s,"ReduceLogSum",o,(d,g)=>[`var value = ${g.type.storage}(0);`,"",`value += ${d.getByIndices("input_indices")};`,"value = log(value);"])},sh=(s,o)=>{Hi(s.inputs),qi(s,"ReduceL1",o,(d,g)=>[`var value = ${g.type.storage}(0);`,"",`value += abs(${d.getByIndices("input_indices")});`,""])},rh=(s,o)=>{Hi(s.inputs),qi(s,"ReduceL2",o,(d,g)=>[`var t = ${g.type.value}(0); var value = ${g.type.value}(0);`,"",`t = ${d.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},oh=(s,o)=>{Hi(s.inputs),qi(s,"ReduceLogSumExp",o,(d,g)=>[`var value = ${g.type.storage}(0);`,"",`value += exp(${d.getByIndices("input_indices")});`,"value = log(value);"])},qo=(s,o)=>{Hi(s.inputs),qi(s,"ReduceMax",o,(d,g,y)=>{let x=[];for(let b=0;b<d.rank;b++)(y.indexOf(b)>=0||y.length===0)&&x.push(d.indicesSet("input_indices",b,0));return[`${x.join(`
`)}`,`var value = ${d.getByIndices("input_indices")};`,`value = max(value, ${d.getByIndices("input_indices")});`,""]})},ah=(s,o)=>{Hi(s.inputs),qi(s,"ReduceMean",o,(d,g,y)=>{let x=1;for(let b=0;b<d.rank;b++)(y.indexOf(b)>=0||y.length===0)&&(x*=s.inputs[0].dims[b]);return["var sum = f32(0);","",`sum += f32(${d.getByIndices("input_indices")});`,`let value = ${g.type.value}(sum / ${x});`]})},lh=(s,o)=>{Hi(s.inputs),qi(s,"ReduceMin",o,(d,g,y)=>{let x=[];for(let b=0;b<d.rank;b++)(y.indexOf(b)>=0||y.length===0)&&x.push(`input_indices[${b}] = 0;`);return[`${x.join(`
`)}`,`var value = ${d.getByIndices("input_indices")};`,`value = min(value, ${d.getByIndices("input_indices")});`,""]})},ch=(s,o)=>{Hi(s.inputs),qi(s,"ReduceProd",o,(d,g)=>[`var value = ${g.type.storage}(1);`,"",`value *= ${d.getByIndices("input_indices")};`,""])},Fl=(s,o)=>{Hi(s.inputs),qi(s,"ReduceSum",o,(d,g)=>[`var value = ${g.type.storage}(0);`,"",`value += ${d.getByIndices("input_indices")};`,""])},uh=(s,o)=>{Hi(s.inputs),qi(s,"ReduceSumSquare",o,(d,g)=>[`var t = ${g.type.value}(0); var value = ${g.type.value}(0);`,"",`t = ${d.getByIndices("input_indices")}; value += t * t;`,""])},Ki=(s,o,d)=>{if(o.length===0)return d;let g=1,y=1;for(let x=0;x<o.length;x++)o.indexOf(x)===-1?g*=s[x]:y*=s[x];return y<32&&g>1024},Rl=(s,o)=>{Ki(s.inputs[0].dims,o.axes,o.noopWithEmptyAxes)?ah(s,o):Qd(s,o)},dh=(s,o)=>{Ki(s.inputs[0].dims,o.axes,o.noopWithEmptyAxes)?sh(s,o):Zd(s,o)},hh=(s,o)=>{Ki(s.inputs[0].dims,o.axes,o.noopWithEmptyAxes)?rh(s,o):Dl(s,o)},Bl=(s,o)=>{Ki(s.inputs[0].dims,o.axes,o.noopWithEmptyAxes)?oh(s,o):eh(s,o)},fh=(s,o)=>{Ki(s.inputs[0].dims,o.axes,o.noopWithEmptyAxes)?qo(s,o):jo(s,o)},ph=(s,o)=>{Ki(s.inputs[0].dims,o.axes,o.noopWithEmptyAxes)?lh(s,o):kl(s,o)},zl=(s,o)=>{Ki(s.inputs[0].dims,o.axes,o.noopWithEmptyAxes)?ch(s,o):th(s,o)},mh=(s,o)=>{Ki(s.inputs[0].dims,o.axes,o.noopWithEmptyAxes)?Fl(s,o):Ol(s,o)},gh=(s,o)=>{Ki(s.inputs[0].dims,o.axes,o.noopWithEmptyAxes)?uh(s,o):lr(s,o)},$l=(s,o)=>{Ki(s.inputs[0].dims,o.axes,o.noopWithEmptyAxes)?ih(s,o):nh(s,o)}}),Ul,Gl,_h,Vl,yh=l(()=>{Wt(),mn(),Nl(),Ul=s=>{if(!s||s.length===0||s.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(s[0].dataType!==1)throw new Error("Invalid input type.")},Gl=(s,o)=>{Ul(s.inputs);let d=(g,y,x)=>{let b=[];for(let P=0;P<g.rank;P++)(x.indexOf(P)>=0||x.length===0)&&b.push(`input_indices[${P}] = 0;`);return[`${b.join(`
`)}`,`var value = ${g.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${g.getByIndices("input_indices")} ${o.selectLastIndex>0?"<=":"<"} value) {
         value = ${g.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",y.setByOffset("global_idx","best_index")]};s.compute(Wo("ArgMin",{hint:o.cacheKey,inputDependencies:["rank"]},[s.inputs[0]],d,[o.axis],7,o.keepDims),{inputs:[0]})},_h=(s,o)=>{Ul(s.inputs);let d=(g,y,x)=>{let b=[];for(let P=0;P<g.rank;P++)(x.indexOf(P)>=0||x.length===0)&&b.push(`input_indices[${P}] = 0;`);return[`${b.join(`
`)}`,`var value = ${g.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${g.getByIndices("input_indices")} ${o.selectLastIndex>0?">=":">"} value) {
         value = ${g.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",y.setByOffset("global_idx","best_index")]};s.compute(Wo("argMax",{hint:o.cacheKey,inputDependencies:["rank"]},[s.inputs[0]],d,[o.axis],7,o.keepDims),{inputs:[0]})},Vl=s=>Jt(s)}),vh,Ko,jl,wh,xh,kr,bh,Mh,Wl=l(()=>{Wt(),ie(),ti(),sn(),vh=(s,o)=>{let d=s[0],g=s[1],y=s[2],x=s[3],b=s[4],P=s[5];if(b&&P)throw new Error("Attention cannot have both past and attention_bias");if(d.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let k=d.dims[0],O=d.dims[1],$=d.dims[2];if(y.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(g.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(g.dims[0]!==$)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(y.dims[0]!==g.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let V=y.dims[0]/3,G=V,ee=G;if(o.qkvHiddenSizes.length>0){if(o.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let ke of o.qkvHiddenSizes)if(ke%o.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");V=o.qkvHiddenSizes[0],G=o.qkvHiddenSizes[1],ee=o.qkvHiddenSizes[2]}let X=O;if(V!==G)throw new Error("qkv_hidden_sizes first element should be same as the second");if(y.dims[0]!==V+G+ee)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let re=0;if(b){if(G!==ee)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(b.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(b.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(b.dims[1]!==k)throw new Error('Input "past" second dimension must be batch_size');if(b.dims[2]!==o.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(b.dims[4]!==G/o.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');o.pastPresentShareBuffer||(re=b.dims[3])}let Te=X+re,ue=-1,ce=0;if(x)throw new Error("Mask not supported");if(b)throw new Error("past is not supported");if(P){if(P.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(P.dims[0]!==k||P.dims[1]!==o.numHeads||P.dims[2]!==O||P.dims[3]!==Te)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:k,sequenceLength:O,pastSequenceLength:re,kvSequenceLength:X,totalSequenceLength:Te,maxSequenceLength:ue,inputHiddenSize:$,hiddenSize:V,vHiddenSize:ee,headSize:Math.floor(V/o.numHeads),vHeadSize:Math.floor(ee/o.numHeads),numHeads:o.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:o.maskFilterValue,maskType:ce,scale:o.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Ko=(s,o,d)=>o&&s?`
      let total_sequence_length_input = u32(${o.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${s==null?void 0:s.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${d?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,jl=(s,o,d,g,y,x,b,P)=>{let k=kn(b?1:x),O=64,$=x/k;$<O&&(O=32);let V=Math.ceil(x/k/O),G=[{type:12,data:o},{type:12,data:d},{type:12,data:g},{type:12,data:y},{type:12,data:$},{type:12,data:V}],ee=Zn(s.dataType,k),X=hi(1,k),re=["type"];b&&re.push("type"),P&&re.push("type");let Te=ue=>{let ce=$t("x",s.dataType,s.dims,k),ke=[ce],Le=b?dt("seq_lens",b.dataType,b.dims):void 0;Le&&ke.push(Le);let M=P?dt("total_sequence_length_input",P.dataType,P.dims):void 0;M&&ke.push(M);let C=hi(s.dataType),z=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${O}>;
  var<workgroup> thread_sum: array<f32, ${O}>;
  ${ue.registerUniforms(z).declareVariables(...ke)}
  ${ue.mainStart([O,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${Ko(Le,M,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${O}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${b?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${X}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${X}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(k){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${k}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${O}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${X}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${X}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(k){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${k}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${O}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${ce.type.value}(${C}(1.0) / ${C}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${X}(x[offset + i]);
        x[offset + i] = ${ce.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${b?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${ce.type.value}(${C}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${O};${ee};${k}`,inputDependencies:re},getShaderSource:Te,getRunData:()=>({outputs:[],dispatchGroup:{x:1,y,z:o*d},programUniforms:G})}},wh=(s,o,d,g,y,x,b,P,k)=>{let O=b+x.kvSequenceLength,$=[x.batchSize,x.numHeads,x.sequenceLength,O],V=s>1&&g,G=x.kvNumHeads?x.kvNumHeads:x.numHeads,ee=V?[x.batchSize,G,O,x.headSize]:void 0,X=x.nReps?x.nReps:1,re=x.scale===0?1/Math.sqrt(x.headSize):x.scale,Te=kn(x.headSize),ue=x.headSize/Te,ce=12,ke={x:Math.ceil(O/ce),y:Math.ceil(x.sequenceLength/ce),z:x.batchSize*x.numHeads},Le=[{type:12,data:x.sequenceLength},{type:12,data:ue},{type:12,data:O},{type:12,data:x.numHeads},{type:12,data:x.headSize},{type:1,data:re},{type:12,data:b},{type:12,data:x.kvSequenceLength},{type:12,data:X}],M=V&&g&&it.size(g.dims)>0,C=["type","type"];M&&C.push("type"),y&&C.push("type"),P&&C.push("type"),k&&C.push("type");let z=[{dims:$,dataType:o.dataType,gpuDataType:0}];V&&z.push({dims:ee,dataType:o.dataType,gpuDataType:0});let oe=ve=>{let Pe=dt("q",o.dataType,o.dims,Te),Ue=dt("key",d.dataType,d.dims,Te),Je=[Pe,Ue];if(M){let xt=dt("past_key",g.dataType,g.dims,Te);Je.push(xt)}y&&Je.push(dt("attention_bias",y.dataType,y.dims));let st=P?dt("seq_lens",P.dataType,P.dims):void 0;st&&Je.push(st);let gt=k?dt("total_sequence_length_input",k.dataType,k.dims):void 0;gt&&Je.push(gt);let wt=$t("output",o.dataType,$),yt=[wt];V&&yt.push($t("present_key",o.dataType,ee,Te));let ht=hi(1,Te),Ft=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${ce}u;

  var<workgroup> tileQ: array<${Pe.type.storage}, ${ce*ce}>;
  var<workgroup> tileK: array<${Pe.type.storage}, ${ce*ce}>;
  ${ve.registerUniforms(Ft).declareVariables(...Je,...yt)}
  ${ve.mainStart([ce,ce,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${X===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${X===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${Ko(st,gt,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${M&&V?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${V?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${ht}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${M&&V?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${V?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${ht}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(Te){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${Te}`)}})()};
        output[outputIdx] = ${wt.type.value} (sum * uniforms.alpha) + ${y?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${Te};${y!==void 0};${g!==void 0};${s}`,inputDependencies:C},getRunData:()=>({outputs:z,dispatchGroup:ke,programUniforms:Le}),getShaderSource:oe}},xh=(s,o,d,g,y,x,b=void 0,P=void 0)=>{let k=x+y.kvSequenceLength,O=y.nReps?y.nReps:1,$=y.vHiddenSize*O,V=s>1&&g,G=y.kvNumHeads?y.kvNumHeads:y.numHeads,ee=V?[y.batchSize,G,k,y.headSize]:void 0,X=[y.batchSize,y.sequenceLength,$],re=12,Te={x:Math.ceil(y.vHeadSize/re),y:Math.ceil(y.sequenceLength/re),z:y.batchSize*y.numHeads},ue=[{type:12,data:y.sequenceLength},{type:12,data:k},{type:12,data:y.vHeadSize},{type:12,data:y.numHeads},{type:12,data:y.headSize},{type:12,data:$},{type:12,data:x},{type:12,data:y.kvSequenceLength},{type:12,data:O}],ce=V&&g&&it.size(g.dims)>0,ke=["type","type"];ce&&ke.push("type"),b&&ke.push("type"),P&&ke.push("type");let Le=[{dims:X,dataType:o.dataType,gpuDataType:0}];V&&Le.push({dims:ee,dataType:o.dataType,gpuDataType:0});let M=C=>{let z=dt("probs",o.dataType,o.dims),oe=dt("v",d.dataType,d.dims),ve=[z,oe];ce&&ve.push(dt("past_value",g.dataType,g.dims));let Pe=b?dt("seq_lens",b.dataType,b.dims):void 0;b&&ve.push(Pe);let Ue=P?dt("total_sequence_length_input",P.dataType,P.dims):void 0;P&&ve.push(Ue);let Je=[$t("output",o.dataType,X)];V&&Je.push($t("present_value",o.dataType,ee));let st=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${re}u;
  var<workgroup> tileQ: array<${z.type.value}, ${re*re}>;
  var<workgroup> tileV: array<${z.type.value}, ${re*re}>;
  ${C.registerUniforms(st).declareVariables(...ve,...Je)}
  ${C.mainStart([re,re,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${O===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${O===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${Ko(Pe,Ue,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${ce&&V?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${V?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${z.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${ce&&V?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${V?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${g!==void 0};${s}`,inputDependencies:ke},getRunData:()=>({outputs:Le,dispatchGroup:Te,programUniforms:ue}),getShaderSource:M}},kr=(s,o,d,g,y,x,b,P,k,O,$=void 0,V=void 0)=>{let G=Math.min(s.outputCount,1+(b?1:0)+(P?1:0)),ee=G>1?O.pastSequenceLength:0,X=ee+O.kvSequenceLength,re=k&&it.size(k.dims)>0?k:void 0,Te=[o,d];G>1&&b&&it.size(b.dims)>0&&Te.push(b),re&&Te.push(re),$&&Te.push($),V&&Te.push(V);let ue=s.compute(wh(G,o,d,b,re,O,ee,$,V),{inputs:Te,outputs:G>1?[-1,1]:[-1]})[0];s.compute(jl(ue,O.batchSize,O.numHeads,ee,O.sequenceLength,X,$,V),{inputs:$&&V?[ue,$,V]:[ue],outputs:[]});let ce=[ue,g];G>1&&P&&it.size(P.dims)>0&&ce.push(P),$&&ce.push($),V&&ce.push(V),s.compute(xh(G,ue,g,P,O,ee,$,V),{inputs:ce,outputs:G>1?[0,2]:[0]})},bh=(s,o)=>{let d=[o.batchSize,o.numHeads,o.sequenceLength,o.headSize],g=o.sequenceLength,y=o.inputHiddenSize,x=o.headSize,b=12,P={x:Math.ceil(o.headSize/b),y:Math.ceil(o.sequenceLength/b),z:o.batchSize*o.numHeads},k=[s.inputs[0],s.inputs[1],s.inputs[2]],O=[{type:12,data:g},{type:12,data:y},{type:12,data:x},{type:12,data:o.numHeads},{type:12,data:o.headSize},{type:12,data:o.hiddenSize},{type:12,data:o.hiddenSize+o.hiddenSize+o.vHiddenSize}],$=V=>{let G=$t("output_q",k[0].dataType,d),ee=$t("output_k",k[0].dataType,d),X=$t("output_v",k[0].dataType,d),re=dt("input",k[0].dataType,k[0].dims),Te=dt("weight",k[1].dataType,k[1].dims),ue=dt("bias",k[2].dataType,k[2].dims),ce=re.type.storage,ke=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${b}u;
  var<workgroup> tileInput: array<${ce}, ${b*b}>;
  var<workgroup> tileWeightQ: array<${ce}, ${b*b}>;
  var<workgroup> tileWeightK: array<${ce}, ${b*b}>;
  var<workgroup> tileWeightV: array<${ce}, ${b*b}>;
  ${V.registerUniforms(ke).declareVariables(re,Te,ue,G,ee,X)}
  ${V.mainStart([b,b,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${ce}(0);
    var valueK = ${ce}(0);
    var valueV = ${ce}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return s.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:d,dataType:s.inputs[0].dataType,gpuDataType:0},{dims:d,dataType:s.inputs[0].dataType,gpuDataType:0},{dims:d,dataType:s.inputs[0].dataType,gpuDataType:0}],dispatchGroup:P,programUniforms:O}),getShaderSource:$},{inputs:k,outputs:[-1,-1,-1]})},Mh=(s,o)=>{let d=vh(s.inputs,o),[g,y,x]=bh(s,d);return kr(s,g,y,x,s.inputs[4],void 0,void 0,void 0,s.inputs[5],d)}}),Th,Hl,Eh,Sh,Ph=l(()=>{qe(),Wt(),ie(),mn(),sn(),Th=(s,o)=>{if(!s||s.length!==5)throw new Error("BatchNormalization requires 5 inputs");let d=(g,y,x)=>{let b=y.length;if(b!==g.length)throw new Error(`${x}: num dimensions != ${b}`);y.forEach((P,k)=>{if(P!==g[k])throw new Error(`${x}: dim[${k}] do not match`)})};if(s[0].dims.length>1){let g=o.format==="NHWC"?o.spatial?s[0].dims.slice(-1):s[0].dims.slice(-1).concat(s[0].dims.slice(1,s[0].dims.length-1)):s[0].dims.slice(1,o.spatial?2:void 0);d(s[1].dims,g,"Invalid input scale"),d(s[2].dims,g,"Invalid input B"),d(s[3].dims,g,"Invalid input mean"),d(s[4].dims,g,"Invalid input var")}else d(s[1].dims,[1],"Invalid input scale"),d(s[2].dims,[1],"Invalid input B"),d(s[3].dims,[1],"Invalid input mean"),d(s[4].dims,[1],"Invalid input var")},Hl=(s,o)=>{let{epsilon:d,spatial:g,format:y}=o,x=s[0].dims,b=g?kn(x[x.length-1]):1,P=y==="NHWC"&&x.length>1?b:1,k=it.size(x)/b,O=g,$=O?x.length:x,V=dt("x",s[0].dataType,s[0].dims,b),G=dt("scale",s[1].dataType,s[1].dims,P),ee=dt("bias",s[2].dataType,s[2].dims,P),X=dt("inputMean",s[3].dataType,s[3].dims,P),re=dt("inputVar",s[4].dataType,s[4].dims,P),Te=$t("y",s[0].dataType,$,b),ue=()=>{let ke="";if(g)ke=`let cOffset = ${x.length===1?"0u":y==="NHWC"?`outputIndices[${x.length-1}] / ${b}`:"outputIndices[1]"};`;else if(y==="NCHW")ke=`
            ${Te.indicesSet("outputIndices","0","0")}
            let cOffset = ${Te.indicesToOffset("outputIndices")};`;else{ke=`var cIndices = ${G.type.indices}(0);
                       cIndices[0] = outputIndices[${x.length-1}];`;for(let Le=1;Le<G.rank;Le++)ke+=`cIndices[${Le}] = outputIndices[${Le}];`;ke+=`let cOffset = ${G.indicesToOffset("cIndices")};`}return ke},ce=ke=>`
  const epsilon = ${d};
  ${ke.registerUniform("outputSize","u32").declareVariables(V,G,ee,X,re,Te)}
  ${ke.mainStart()}
  ${ke.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${Te.offsetToIndices(`global_idx * ${b}`)};
    ${ue()}
    let scale = ${G.getByOffset("cOffset")};
    let bias = ${ee.getByOffset("cOffset")};
    let inputMean = ${X.getByOffset("cOffset")};
    let inputVar = ${re.getByOffset("cOffset")};
    let x = ${V.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${Te.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${o.epsilon}_${o.format}_${g}_${b}`,inputDependencies:O?["rank","type","type","type","type"]:void 0},getShaderSource:ce,getRunData:()=>({outputs:[{dims:s[0].dims,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(k/64)},programUniforms:O?[{type:12,data:k},...Gt(x)]:[{type:12,data:k}]})}},Eh=s=>Jt(s),Sh=(s,o)=>{let{inputs:d,outputCount:g}=s,y=Eh({...o,outputCount:g});if(R.webgpu.validateInputContent&&Th(d,y),o.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");s.compute(Hl(d,y))}}),Ah,Ch,ql,ny=l(()=>{ie(),sn(),Ah=s=>{if(s[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(s[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(s[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(s[0].dims[2]!==s[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Ch=s=>{let o=s[0].dims,d=s[0].dims[2],g=it.size(o)/4,y=s[0].dataType,x=dt("input",y,o,4),b=dt("bias",y,[d],4),P=dt("residual",y,o,4),k=$t("output",y,o,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:o,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)}}),getShaderSource:O=>`
  const channels = ${d}u / 4;
  ${O.declareVariables(x,b,P,k)}

  ${O.mainStart()}
    ${O.guardAgainstOutOfBoundsWorkgroupSizes(g)}
    let value = ${x.getByOffset("global_idx")}
      + ${b.getByOffset("global_idx % channels")} + ${P.getByOffset("global_idx")};
    ${k.setByOffset("global_idx","value")}
  }`}},ql=s=>{Ah(s.inputs),s.compute(Ch(s.inputs))}}),Ih,hn,Lh,Dh,Kl,kh,Oh,Xl,Fh,Rh,Yl,Bh,zh,Jl,$h,Nh,Or,Uh,Xo,Ql,Gh,Vh,Zl,jh,Wh,ec,Hh,qh,tc,Kh,Xh,nc,Yh,Jh,ic,sc,Qh,Yo,rc,Zh,oc,ef,tf,ac,nf,lc=l(()=>{Wt(),ie(),mn(),sn(),Ih=(s,o,d,g,y,x,b)=>{let P=Math.ceil(o/4),k="";typeof y=="string"?k=`${y}(a)`:k=y("a");let O=dt("inputData",d,[P],4),$=$t("outputData",g,[P],4),V=[{name:"vec_size",type:"u32"}];return b&&V.push(...b),`
      ${s.registerUniforms(V).declareVariables(O,$)}

  ${x??""}

  ${s.mainStart()}
    ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${O.getByOffset("global_idx")};
    ${$.setByOffset("global_idx",k)}
  }`},hn=(s,o,d,g,y,x=s.dataType,b,P)=>{let k=[{type:12,data:Math.ceil(it.size(s.dims)/4)}];return b&&k.push(...b),{name:o,shaderCache:{hint:y,inputDependencies:["type"]},getShaderSource:O=>Ih(O,it.size(s.dims),s.dataType,x,d,g,P),getRunData:O=>({outputs:[{dims:s.dims,dataType:x}],dispatchGroup:{x:Math.ceil(it.size(O[0].dims)/64/4)},programUniforms:k})}},Lh=s=>{s.compute(hn(s.inputs[0],"Abs","abs"))},Dh=s=>{s.compute(hn(s.inputs[0],"Acos","acos"))},Kl=s=>{s.compute(hn(s.inputs[0],"Acosh","acosh"))},kh=s=>{s.compute(hn(s.inputs[0],"Asin","asin"))},Oh=s=>{s.compute(hn(s.inputs[0],"Asinh","asinh"))},Xl=s=>{s.compute(hn(s.inputs[0],"Atan","atan"))},Fh=s=>{s.compute(hn(s.inputs[0],"Atanh","atanh"))},Rh=s=>Jt(s),Yl=(s,o)=>{let d;switch(o.to){case 10:d="vec4<f16>";break;case 1:d="vec4<f32>";break;case 12:d="vec4<u32>";break;case 6:d="vec4<i32>";break;case 9:d="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${o.to}`)}s.compute(hn(s.inputs[0],"Cast",d,void 0,o.cacheKey,o.to))},Bh=s=>{let o,d,g=s.length>=2&&s[1].data!==0,y=s.length>=3&&s[2].data!==0;switch(s[0].dataType){case 1:o=g?s[1].getFloat32Array()[0]:-34028234663852886e22,d=y?s[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:o=g?s[1].getUint16Array()[0]:64511,d=y?s[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return Jt({min:o,max:d})},zh=(s,o)=>{let d=o||Bh(s.inputs),g=hi(s.inputs[0].dataType);s.compute(hn(s.inputs[0],"Clip",y=>`clamp(${y}, vec4<${g}>(uniforms.min), vec4<${g}>(uniforms.max))`,void 0,d.cacheKey,void 0,[{type:s.inputs[0].dataType,data:d.min},{type:s.inputs[0].dataType,data:d.max}],[{name:"min",type:g},{name:"max",type:g}]),{inputs:[0]})},Jl=s=>{s.compute(hn(s.inputs[0],"Ceil","ceil"))},$h=s=>{s.compute(hn(s.inputs[0],"Cos","cos"))},Nh=s=>{s.compute(hn(s.inputs[0],"Cosh","cosh"))},Or=s=>Jt(s),Uh=(s,o)=>{let d=hi(s.inputs[0].dataType);s.compute(hn(s.inputs[0],"Elu",g=>`elu_vf32(${g})`,`
  const elu_alpha_ = ${d}(${o.alpha});

  fn elu_f32(a: ${d}) -> ${d} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${d}>) -> vec4<${d}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,o.cacheKey))},Xo=(s="f32")=>`
const r0: ${s} = 0.3275911;
const r1: ${s} = 0.254829592;
const r2: ${s} = -0.284496736;
const r3: ${s} = 1.421413741;
const r4: ${s} = -1.453152027;
const r5: ${s} = 1.061405429;

fn erf_vf32(v: vec4<${s}>) -> vec4<${s}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Ql=s=>{let o=hi(s.inputs[0].dataType);s.compute(hn(s.inputs[0],"Erf",d=>`erf_vf32(${d})`,Xo(o)))},Gh=s=>{s.compute(hn(s.inputs[0],"Exp","exp"))},Vh=s=>{s.compute(hn(s.inputs[0],"Floor","floor"))},Zl=s=>{let o=hi(s.inputs[0].dataType);s.compute(hn(s.inputs[0],"Gelu",d=>`0.5 * ${d} * (1.0 + erf_vf32(${d} * 0.7071067811865475))`,Xo(o)))},jh=(s,o)=>{let d=hi(s.inputs[0].dataType);s.compute(hn(s.inputs[0],"LeakyRelu",g=>`select(leaky_relu_alpha_ * ${g}, ${g}, ${g} >= vec4<${d}>(0.0))`,`const leaky_relu_alpha_ = ${d}(${o.alpha});`,o.cacheKey))},Wh=s=>{s.compute(hn(s.inputs[0],"Not",o=>`!${o}`))},ec=s=>{s.compute(hn(s.inputs[0],"Neg",o=>`-${o}`))},Hh=s=>{s.compute(hn(s.inputs[0],"Reciprocal",o=>`1.0/${o}`))},qh=s=>{let o=hi(s.inputs[0].dataType);s.compute(hn(s.inputs[0],"Relu",d=>`select(vec4<${o}>(0.0), ${d}, ${d} > vec4<${o}>(0.0))`))},tc=s=>{s.compute(hn(s.inputs[0],"Sigmoid",o=>`(1.0 / (1.0 + exp(-${o})))`))},Kh=s=>Jt(s),Xh=(s,o)=>{let d=hi(s.inputs[0].dataType);s.compute(hn(s.inputs[0],"HardSigmoid",g=>`max(vec4<${d}>(0.0), min(vec4<${d}>(1.0), ${o.alpha} * ${g} + vec4<${d}>(${o.beta})))`,void 0,o.cacheKey))},nc=s=>{s.compute(hn(s.inputs[0],"Sin","sin"))},Yh=s=>{s.compute(hn(s.inputs[0],"Sinh","sinh"))},Jh=s=>{s.compute(hn(s.inputs[0],"Sqrt","sqrt"))},ic=s=>{s.compute(hn(s.inputs[0],"Tan","tan"))},sc=s=>`sign(${s}) * (1 - exp(-2 * abs(${s}))) / (1 + exp(-2 * abs(${s})))`,Qh=s=>{s.compute(hn(s.inputs[0],"Tanh",sc))},Yo=(s="f32")=>`
const fast_gelu_a: ${s} = 0.5;
const fast_gelu_b: ${s} = 0.7978845608028654;
const fast_gelu_c: ${s} = 0.035677408136300125;

fn tanh_v(v: vec4<${s}>) -> vec4<${s}> {
  return ${sc("v")};
}
`,rc=s=>`(fast_gelu_a + fast_gelu_a * tanh_v(${s} * (fast_gelu_c * ${s} * ${s} + fast_gelu_b))) * ${s}`,Zh=s=>{let o=hi(s.inputs[0].dataType);s.compute(hn(s.inputs[0],"FastGelu",rc,Yo(o),void 0,s.inputs[0].dataType))},oc=(s,o)=>{let d=hi(s.inputs[0].dataType);return s.compute(hn(s.inputs[0],"ThresholdedRelu",g=>`select(vec4<${d}>(0.0), ${g}, ${g} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${d}>(${o.alpha});`,o.cacheKey)),0},ef=s=>{s.compute(hn(s.inputs[0],"Log","log"))},tf=(s,o)=>`
const alpha = vec4<${s}>(${o});
const one = ${s}(1.0);
const zero = ${s}(0.0);

fn quick_gelu_impl(x: vec4<${s}>) -> vec4<${s}> {
  let v = x *alpha;
  var x1 : vec4<${s}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,ac=s=>`quick_gelu_impl(${s})`,nf=(s,o)=>{let d=hi(s.inputs[0].dataType);s.compute(hn(s.inputs[0],"QuickGelu",ac,tf(d,o.alpha),o.cacheKey,s.inputs[0].dataType))}}),cc,sf,rf,of=l(()=>{ie(),sn(),lc(),cc=s=>{if(s[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(s[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(s[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(s[0].dims[2]!==s[1].dims[0])throw new Error("last dimension of input and bias are not the same")},sf=s=>{let o=s[0].dims.slice();o[2]=o[2]/2;let d=dt("input",s[0].dataType,s[0].dims,4),g=dt("bias",s[0].dataType,[s[0].dims[2]],4),y=$t("output",s[0].dataType,o,4),x=it.size(o)/4,b=Zn(s[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:o,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(x/64)}}),getShaderSource:P=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${s[0].dims[2]/4/2}u;

  ${P.declareVariables(d,g,y)}

  ${Xo(b)}

  ${P.mainStart()}
    ${P.guardAgainstOutOfBoundsWorkgroupSizes(x)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${y.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},rf=s=>{cc(s.inputs),s.compute(sf(s.inputs))}}),af,lf,Xi,cf,uc,uf,df,dc,hf,ff,hc,pf,mf,gf=l(()=>{Wt(),ie(),sn(),af=(s,o,d,g,y,x,b,P,k,O,$,V)=>{let G,ee;typeof P=="string"?G=ee=(ce,ke)=>`${P}((${ce}),(${ke}))`:typeof P=="function"?G=ee=P:(G=P.scalar,ee=P.vector);let X=$t("outputData",$,g.length,4),re=dt("aData",k,o.length,4),Te=dt("bData",O,d.length,4),ue;if(y)if(x){let ce=it.size(o)===1,ke=it.size(d)===1,Le=o.length>0&&o[o.length-1]%4===0,M=d.length>0&&d[d.length-1]%4===0;ce||ke?ue=X.setByOffset("global_idx",ee(ce?`${re.type.value}(${re.getByOffset("0")}.x)`:re.getByOffset("global_idx"),ke?`${Te.type.value}(${Te.getByOffset("0")}.x)`:Te.getByOffset("global_idx"))):ue=`
            let outputIndices = ${X.offsetToIndices("global_idx * 4u")};
            let offsetA = ${re.broadcastedIndicesToOffset("outputIndices",X)};
            let offsetB = ${Te.broadcastedIndicesToOffset("outputIndices",X)};
            ${X.setByOffset("global_idx",ee(b||Le?re.getByOffset("offsetA / 4u"):`${re.type.value}(${re.getByOffset("offsetA / 4u")}[offsetA % 4u])`,b||M?Te.getByOffset("offsetB / 4u"):`${Te.type.value}(${Te.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else ue=X.setByOffset("global_idx",ee(re.getByOffset("global_idx"),Te.getByOffset("global_idx")));else{if(!x)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let ce=(ke,Le,M="")=>{let C=`aData[indexA${Le}][componentA${Le}]`,z=`bData[indexB${Le}][componentB${Le}]`;return`
            let outputIndices${Le} = ${X.offsetToIndices(`global_idx * 4u + ${Le}u`)};
            let offsetA${Le} = ${re.broadcastedIndicesToOffset(`outputIndices${Le}`,X)};
            let offsetB${Le} = ${Te.broadcastedIndicesToOffset(`outputIndices${Le}`,X)};
            let indexA${Le} = offsetA${Le} / 4u;
            let indexB${Le} = offsetB${Le} / 4u;
            let componentA${Le} = offsetA${Le} % 4u;
            let componentB${Le} = offsetB${Le} % 4u;
            ${ke}[${Le}] = ${M}(${G(C,z)});
          `};$===9?ue=`
            var data = vec4<u32>(0);
            ${ce("data",0,"u32")}
            ${ce("data",1,"u32")}
            ${ce("data",2,"u32")}
            ${ce("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:ue=`
            ${ce("outputData[global_idx]",0)}
            ${ce("outputData[global_idx]",1)}
            ${ce("outputData[global_idx]",2)}
            ${ce("outputData[global_idx]",3)}
          `}return`
        ${s.registerUniform("vec_size","u32").declareVariables(re,Te,X)}

        ${V??""}

        ${s.mainStart()}
        ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${ue}
      }`},lf=(s,o,d,g,y,x,b=d.dataType)=>{let P=d.dims.map(re=>Number(re)??1),k=g.dims.map(re=>Number(re)??1),O=!it.areEqual(P,k),$=P,V=it.size(P),G=!1,ee=!1,X=[O];if(O){let re=Wi.calcShape(P,k,!1);if(!re)throw new Error("Can't perform binary op on the given tensors");$=re.slice(),V=it.size($);let Te=it.size(P)===1,ue=it.size(k)===1,ce=P.length>0&&P[P.length-1]%4===0,ke=k.length>0&&k[k.length-1]%4===0;X.push(Te),X.push(ue),X.push(ce),X.push(ke);let Le=1;for(let M=1;M<$.length;M++){let C=P[P.length-M],z=k[k.length-M];if(C===z)Le*=C;else break}Le%4===0?(ee=!0,G=!0):(Te||ue||ce||ke)&&(G=!0)}else G=!0;return X.push(G),{name:s,shaderCache:{hint:o+X.map(re=>re.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:re=>af(re,P,k,$,G,O,ee,y,d.dataType,g.dataType,b,x),getRunData:()=>({outputs:[{dims:$,dataType:b}],dispatchGroup:{x:Math.ceil(V/64/4)},programUniforms:[{type:12,data:Math.ceil(it.size($)/4)},...Gt(P,k,$)]})}},Xi=(s,o,d,g,y,x)=>{s.compute(lf(o,y??"",s.inputs[0],s.inputs[1],d,g,x))},cf=s=>{Xi(s,"Add",(o,d)=>`${o}+${d}`)},uc=s=>{Xi(s,"Div",(o,d)=>`${o}/${d}`)},uf=s=>{Xi(s,"Equal",{scalar:(o,d)=>`u32(${o}==${d})`,vector:(o,d)=>`vec4<u32>(${o}==${d})`},void 0,void 0,9)},df=s=>{Xi(s,"Mul",(o,d)=>`${o}*${d}`)},dc=s=>{let o=dt("input",s.inputs[0].dataType,s.inputs[0].dims).type.value;Xi(s,"Pow",{scalar:(d,g)=>`pow_custom(${d},${g})`,vector:(d,g)=>`pow_vector_custom(${d},${g})`},`
    fn pow_custom(a : ${o}, b : ${o}) -> ${o} {
      if (b == ${o}(0.0)) {
        return ${o}(1.0);
      } else if (a < ${o}(0.0) && f32(b) != floor(f32(b))) {
        return ${o}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${o}(1.0), round(f32(abs(b) % ${o}(2.0))) != 1.0) * ${o}(${o==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${o}>, b : vec4<${o}>) -> vec4<${o}> {
      // TODO: implement vectorized pow
      return vec4<${o}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},hf=s=>{Xi(s,"Sub",(o,d)=>`${o}-${d}`)},ff=s=>{Xi(s,"Greater",{scalar:(o,d)=>`u32(${o}>${d})`,vector:(o,d)=>`vec4<u32>(${o}>${d})`},void 0,void 0,9)},hc=s=>{Xi(s,"Less",{scalar:(o,d)=>`u32(${o}<${d})`,vector:(o,d)=>`vec4<u32>(${o}<${d})`},void 0,void 0,9)},pf=s=>{Xi(s,"GreaterOrEqual",{scalar:(o,d)=>`u32(${o}>=${d})`,vector:(o,d)=>`vec4<u32>(${o}>=${d})`},void 0,void 0,9)},mf=s=>{Xi(s,"LessOrEqual",{scalar:(o,d)=>`u32(${o}<=${d})`,vector:(o,d)=>`vec4<u32>(${o}<=${d})`},void 0,void 0,9)}}),_f,yf,fc,vf,wf,pc,iy=l(()=>{Wt(),ie(),mn(),sn(),_f=(s,o)=>{if(!s||s.length<1)throw new Error("too few inputs");let d=0,g=s[d],y=g.dataType,x=g.dims.length;s.forEach((b,P)=>{if(P!==d){if(b.dataType!==y)throw new Error("input tensors should be one type");if(b.dims.length!==x)throw new Error("input tensors should have the same shape");b.dims.forEach((k,O)=>{if(O!==o&&k!==g.dims[O])throw new Error("non concat dimensions must match")})}})},yf=(s,o)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${s}u>(${o});
    for (var i: u32 = 0u; i < ${s}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${s}u;
  }`,fc=(s,o)=>{let d=s.length,g=[];for(let y=0;y<d;++y){let x=o.setByOffset("global_idx",s[y].getByIndices("indices"));d===1?g.push(x):y===0?g.push(`if (inputIndex == ${y}u) { ${x} }`):y===d-1?g.push(`else { ${x} }`):g.push(`else if (inputIndex == ${y}) { ${x} }`)}return g.join(`
`)},vf=(s,o,d,g)=>{let y=it.size(d),x=new Array(s.length),b=new Array(s.length),P=0,k=[],O=[],$=[{type:12,data:y}];for(let re=0;re<s.length;++re)P+=s[re].dims[o],x[re]=P,O.push(s[re].dims.length),b[re]=dt(`input${re}`,g,O[re]),k.push("rank"),$.push({type:12,data:x[re]});for(let re=0;re<s.length;++re)$.push(...Gt(s[re].dims));$.push(...Gt(d));let V=$t("output",g,d.length),G=V.indicesGet("indices",o),ee=Array.from(Array(x.length).keys()).map(re=>`uniforms.sizeInConcatAxis${re}`).join(","),X=re=>`

  ${(()=>{re.registerUniform("outputSize","u32");for(let Te=0;Te<s.length;Te++)re.registerUniform(`sizeInConcatAxis${Te}`,"u32");return re.declareVariables(...b,V)})()}

  ${yf(x.length,ee)}

  ${re.mainStart()}
    ${re.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${V.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${G});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${x.length}u>(${ee});
      ${G} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${fc(b,V)}
  }`;return{name:"Concat",shaderCache:{hint:`${o}`,inputDependencies:k},getRunData:()=>({outputs:[{dims:d,dataType:g}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:$}),getShaderSource:X}},wf=(s,o)=>{let d=s.inputs,g=d[0].dims,y=it.normalizeAxis(o.axis,g.length);_f(d,y);let x=g.slice();x[y]=d.reduce((P,k)=>P+(k.dims.length>y?k.dims[y]:0),0);let b=d.filter(P=>it.size(P.dims)>0);s.compute(vf(b,y,x,d[0].dataType),{inputs:b})},pc=s=>Jt({axis:s.axis})}),cr,Vs,ur,mc,dr=l(()=>{Wt(),ie(),cr=(s,o,d="f32")=>{switch(s.activation){case"Relu":return`value = max(value, ${o}(0.0));`;case"Sigmoid":return`value = (${o}(1.0) / (${o}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${o}(${d}(uniforms.clip_min)), ${o}(${d}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${o}(0.0), min(${o}(1.0), ${d}(uniforms.alpha) * value + ${d}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${d}(uniforms.alpha) * value, value, value >= ${o}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${s.activation}`)}},Vs=(s,o)=>{s.activation==="Clip"?o.push({type:1,data:s.clipMax},{type:1,data:s.clipMin}):s.activation==="HardSigmoid"?o.push({type:1,data:s.alpha},{type:1,data:s.beta}):s.activation==="LeakyRelu"&&o.push({type:1,data:s.alpha})},ur=(s,o)=>{s.activation==="Clip"?o.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):s.activation==="HardSigmoid"?o.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):s.activation==="LeakyRelu"&&o.push({name:"alpha",type:"f32"})},mc=s=>{let o=(s==null?void 0:s.activation)||"";if(o==="HardSigmoid"){let[d,g]=(s==null?void 0:s.activation_params)||[.2,.5];return{activation:o,alpha:d,beta:g}}else if(o==="Clip"){let[d,g]=(s==null?void 0:s.activation_params)||[Xe,j];return{activation:o,clipMax:g,clipMin:d}}else if(o==="LeakyRelu"){let[d]=(s==null?void 0:s.activation_params)||[.01];return{activation:o,alpha:d}}return{activation:o}}}),ni,gc,_c=l(()=>{ni=(s,o)=>{switch(s){case 1:return o;case 2:return`vec2<${o}>`;case 3:return`vec3<${o}>`;case 4:return`vec4<${o}>`;default:throw new Error(`${s}-component is not supported.`)}},gc=s=>`
      ${s?"value = value + getBiasByOutputCoords(coords);":""}
      `}),xf,sy=l(()=>{xf=s=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${s}.x), i32(${s}.y), i32(${s}.z), 1));
}
`}),ao,Jo,yc=l(()=>{Wt(),ie(),sn(),dr(),ao=(s,o,d,g,y)=>{let x=g-d;return`
      ${Array.from({length:d}).map((b,P)=>`
      if (${Nt(o.shape,P,o.rank)} != 1) {
        ${o.indicesSet(s,P,Nt(y,P+x,g))}
      } else {
        ${o.indicesSet(s,P,0)}
      }`).join("")}
`},Jo=(s,o,d,g,y=!1,x)=>{let b=s[0].dims,P=s[1].dims,k=b[b.length-2],O=P[P.length-1],$=b[b.length-1],V=kn(O),G=kn($),ee=kn(k),X=it.size(d)/V/ee,re=s.length>2,Te=g?g.slice(0,-2):d.slice(0,-2),ue=[it.size(Te),k,O],ce=[{type:12,data:X},{type:12,data:k},{type:12,data:O},{type:12,data:$}];Vs(o,ce),ce.push(...Gt(Te,b,P)),re&&ce.push(...Gt(s[2].dims)),ce.push(...Gt(ue));let ke=Le=>{let M=Pl("batch_dims",s[0].dataType,Te.length),C=dt("a",s[0].dataType,b.length,G),z=dt("b",s[1].dataType,P.length,V),oe=$t("output",s[0].dataType,ue.length,V),ve=Zn(oe.type.tensor),Pe=cr(o,oe.type.value,ve),Ue=[C,z],Je="";if(re){let wt=y?V:1;Ue.push(dt("bias",s[2].dataType,s[2].dims.length,wt)),Je=`${y?`value += bias[col / ${wt}];`:`value += ${oe.type.value}(bias[row + i]);`}`}let st=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];ur(o,st);let gt=()=>{let wt=`var a_data: ${C.type.value};`;for(let yt=0;yt<G;yt++)wt+=`
              let b_data${yt} = b[(b_offset + (k + ${yt}) * uniforms.N + col) / ${V}];`;for(let yt=0;yt<ee;yt++){wt+=`a_data = a[(a_offset + (row + ${yt}) * uniforms.K + k) / ${G}];`;for(let ht=0;ht<G;ht++)wt+=`
            values[${yt}] = fma(${z.type.value}(a_data${G===1?"":`[${ht}]`}), b_data${ht}, values[${yt}]);
`}return wt};return`
  ${Le.registerUniforms(st).registerInternalVariables(M).declareVariables(...Ue,oe)}
  ${Le.mainStart()}
    ${Le.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${V})) * ${V};
    var index1 = global_idx / (uniforms.N / ${V});
    let stride1 = uniforms.M / ${ee};
    let row = (index1 % stride1) * ${ee};
    let batch = index1 / stride1;

    ${d.length===2?"":`let batch_indices = ${M.offsetToIndices("batch")};`}

    var a_indices: ${C.type.indices};
    ${ao("a_indices",C,C.rank-2,M.rank,"batch_indices")}
    ${C.indicesSet("a_indices",C.rank-2,0)}
    ${C.indicesSet("a_indices",C.rank-1,0)}
    let a_offset = ${C.indicesToOffset("a_indices")};

    var b_indices: ${z.type.indices};
    ${ao("b_indices",z,z.rank-2,M.rank,"batch_indices")}
    ${z.indicesSet("b_indices",z.rank-2,0)}
    ${z.indicesSet("b_indices",z.rank-1,0)}
    let b_offset = ${z.indicesToOffset("b_indices")};
    var values: array<${oe.type.value}, ${ee}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${G}) {
      ${gt()}
    }
    for (var i = 0u; i < ${ee}u; i++) {
      var value = values[i];
      ${Je}
      ${Pe}
      let cur_indices = ${oe.type.indices}(batch, row + i, col);
      let offset = ${oe.indicesToOffset("cur_indices")};
      ${oe.setByOffset(`offset / ${V}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${o.activation};${V};${G};${ee};${y}`,inputDependencies:re?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:x?x(d):d,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(X/64)},programUniforms:ce}),getShaderSource:ke}}}),bf,Mf,vc,Qo,Tf,wc,Ef,Zo,ea=l(()=>{Wt(),ie(),sn(),dr(),yc(),_c(),bf=(s,o)=>s?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${o?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${o?", batchIndices":""});
        `,Mf=(s,o)=>s?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${o===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${o===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${o===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,vc=(s,o,d="f32",g,y=!1,x=32,b=!1,P=32)=>{let k=o[1]*s[1],O=o[0]*s[0],$=y?k:x,V=y?x:k,G=$/o[0],ee=x/o[1];if(!((y&&G===4&&s[1]===4||!y&&(G===3||G===4))&&$%o[0]===0&&x%o[1]===0&&s[0]===4))throw new Error(`If transposeA ${y} is true, innerElementSize ${G} and workPerThread[1] ${s[1]} must be 4.
      Otherwise, innerElementSize ${G} must be 3 or 4.
  tileAWidth ${$} must be divisible by workgroupSize[0]${o[0]}. tileInner ${x} must be divisible by workgroupSize[1] ${o[1]}. colPerThread ${s[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${G}<${d}>, ${$/G}>, ${V}>;
var<workgroup> mm_Bsub: array<array<vec4<${d}>, ${O/s[0]}>, ${x}>;

const rowPerThread = ${s[1]};
const colPerThread = ${s[0]};
const innerElementSize = ${G};
const tileInner = ${x};

@compute @workgroup_size(${o[0]}, ${o[1]}, ${o[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${b?"0":"i32(globalId.z)"};
  ${g?`let batchIndices = ${g.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${k};

  let num_tiles = ${b?`${Math.ceil(P/x)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${b?`i32(globalId.z) * ${P}`:"0"};

  var acc: array<vec4<${d}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${ee};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${bf(y,g)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${ee}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${g?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${G===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${Mf(y,G)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Qo=(s,o)=>s?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${o?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${o?", batchIndices":""});
            `,Tf=s=>s?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",wc=(s,o,d="f32",g,y=!1,x=32,b=!1,P=32,k=!1)=>{let O=s[1]*o[1],$=s[0]*o[0],V=y?O:x,G=y?x:O;if(!(G%o[1]===0&&V%o[0]===0&&x%o[1]===0))throw new Error(`tileAHight ${G} must be divisible by workgroupSize[1]${o[1]}, tileAWidth ${V} must be divisible by workgroupSize[0]${o[0]}, tileInner ${x} must be divisible by workgroupSize[1]${o[1]}`);let ee=G/o[1],X=V/o[0],re=x/o[1],Te=k?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${O};
    let globalColStart = i32(workgroupId.x) * ${$};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${G}; inputRow = inputRow + ${o[1]}) {
        for (var inputCol = localCol; inputCol < ${V}; inputCol = inputCol + ${o[0]}) {
          ${Qo(y,g)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${x}; inputRow = inputRow + ${o[1]}) {
            for (var inputCol = localCol; inputCol < ${$}; inputCol = inputCol + ${o[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${g?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${d}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${o[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${y?`mm_Asub[k][localRow + innerRow * ${o[1]}];`:`mm_Asub[localRow + innerRow * ${o[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${o[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${o[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${O};

let tileRowA = i32(localId.y) * ${ee};
let tileColA = i32(localId.x) * ${X};
let tileRowB = i32(localId.y) * ${re};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${ee}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${X}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Qo(y,g)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${re}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${g?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${d}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${Tf(y)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${d}, ${V}>, ${G}>;
  var<workgroup> mm_Bsub : array<array<${d}, ${$}>, ${x}>;
  const rowPerThread = ${s[1]};
  const colPerThread = ${s[0]};
  const tileInner = ${x};

@compute @workgroup_size(${o[0]}, ${o[1]}, ${o[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${b?"0":"i32(globalId.z)"};
    ${g?`let batchIndices = ${g.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${b?`${Math.ceil(P/x)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${b?`i32(globalId.z) * ${P}`:"0"};

    var acc : array<array<${d}, colPerThread>, rowPerThread>;
    ${Te}
  }
`},Ef=(s,o,d,g,y=!1)=>{let[x,b,P,k]=g,O=Zn(g[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${x.type.indices}) -> ${ni(s,O)} {
      var value = ${ni(s,O)}(0.0);
      let col = colIn * ${s};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${b.type.indices};
        ${ao("aIndices",b,b.rank-2,x.rank,"batchIndices")}
        ${b.indicesSet("aIndices",b.rank-2,"u32(row)")}
        ${b.indicesSet("aIndices",b.rank-1,"u32(colIn)")}
        value = ${b.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${x.type.indices}) -> ${ni(s,O)} {
      var value = ${ni(s,O)}(0.0);
      let col = colIn * ${s};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${P.type.indices};
        ${ao("bIndices",P,P.rank-2,x.rank,"batchIndices")}
        ${P.indicesSet("bIndices",P.rank-2,"u32(row)")}
        ${P.indicesSet("bIndices",P.rank-1,"u32(colIn)")}
        value = ${P.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${ni(s,O)}) {
      let col = colIn * ${s};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${o?`value = value + ${y?"bias[colIn]":`${ni(s,O)}(bias[row])`};`:""}
        ${d}
        ${k.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},Zo=(s,o,d,g,y=!1,x)=>{let b=s[0].dims,P=s[1].dims,k=b.slice(0,-2),O=P.slice(0,-2),$=g?g.slice(0,-2):d.slice(0,-2),V=it.size($),G=b[b.length-2],ee=b[b.length-1],X=P[P.length-1],re=ee%4===0&&X%4===0,Te=G<=8?[4,1,1]:[4,4,1],ue=[8,8,1],ce=[Math.ceil(X/ue[0]/Te[0]),Math.ceil(G/ue[1]/Te[1]),Math.ceil(V/ue[2]/Te[2])],ke=re?4:1,Le=[...k,G,ee/ke],M=Le.length,C=[...O,ee,X/ke],z=C.length,oe=[V,G,X/ke],ve=[{type:6,data:G},{type:6,data:X},{type:6,data:ee}];Vs(o,ve),ve.push(...Gt($,Le,C));let Pe=["rank","rank"],Ue=s.length>2;Ue&&(ve.push(...Gt(s[2].dims)),Pe.push("rank")),ve.push(...Gt(oe));let Je=st=>{let gt=$.length,wt=Pl("batchDims",s[0].dataType,gt,1),yt=Zn(s[0].dataType),ht=dt("a",s[0].dataType,M,ke),Ft=dt("b",s[1].dataType,z,ke),xt=$t("result",s[0].dataType,oe.length,ke),Ct=[ht,Ft];if(Ue){let un=y?ke:1;Ct.push(dt("bias",s[2].dataType,s[2].dims.length,un))}let Ze=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];ur(o,Ze);let ft=Zn(xt.type.tensor),St=cr(o,xt.type.value,ft),Ht=Ef(ke,Ue,St,[wt,ht,Ft,xt],y);return`
  ${st.registerUniforms(Ze).registerInternalVariables(wt).declareVariables(...Ct,xt)}
  ${Ht}
  ${re?vc(Te,ue,yt,wt):wc(Te,ue,yt,wt)}
                   `};return{name:"MatMul",shaderCache:{hint:`${Te};${o.activation};${re};${y}`,inputDependencies:Pe},getRunData:()=>({outputs:[{dims:x?x(d):d,dataType:s[0].dataType}],dispatchGroup:{x:ce[0],y:ce[1],z:ce[2]},programUniforms:ve}),getShaderSource:Je}}}),Sf,Pf,Af=l(()=>{Wt(),Lt(),sn(),dr(),_c(),sy(),ea(),Sf=(s,o,d,g,y=!1,x,b=4,P=4,k=4,O="f32")=>{let $=ve=>{switch(ve){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${O}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${ve} is not supported.`)}},V=ve=>{switch(ve){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${ve} is not supported.`)}},G=s?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,ee=s?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,X=s?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",re=s?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",Te=s?"row":"col",ue=s?"col":"row",ce=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${s?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${Te} / outWidth;
    let outCol = ${Te} % outWidth;

    let WRow = ${ue} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${ue} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${ue} % inChannels;
    var resData = ${ni(b,O)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${X} && xCol >= 0 && xCol < ${re}) {
      ${G}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${$(b)}
    }
    return resData;`,ke=s?o&&g?`
    let col = colIn * ${b};
    ${ce}`:`
    let col = colIn * ${b};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${ce}
    }
    return ${ni(b,O)}(0.0);`:g&&d?`
    let col = colIn * ${b};
    ${ce}`:`
    let col = colIn * ${b};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${ce}
    }
    return ${ni(b,O)}(0.0);`,Le=s?g&&d?V(P):`
    let col = colIn * ${P};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${V(P)}
    }
    return ${ni(P,O)}(0.0);`:`
    let col = colIn * ${P};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${V(P)}
    }
    return ${ni(P,O)}(0.0);`,M=ni(k,O),C=ni(s?b:P,O),z=ni(s?P:b,O),oe=cr(x,M,O);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${C} {
      ${s?ke:Le}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${z} {
      ${s?Le:ke}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${M}) {
      let col = colIn * ${k};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${s?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${ee}
      ${gc(y)}
      ${oe}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Pf=(s,o,d,g,y,x,b,P,k)=>{let O=o.format==="NHWC",$=O?s[0].dims[3]:s[0].dims[1],V=d[0],G=O?d[2]:d[3],ee=O?d[1]:d[2],X=O?d[3]:d[1],re=O&&($%4===0||$%3===0)&&X%4===0,Te=O?X:G*ee,ue=O?G*ee:X,ce=[8,8,1],ke=g<=8?[4,1,1]:[4,4,1],Le=[Math.ceil(Te/ce[0]/ke[0]),Math.ceil(ue/ce[1]/ke[1]),Math.ceil(V/ce[2]/ke[2])];ct("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${Le}`);let M=re?O&&$%4!==0?3:4:1,C=ce[1]*ke[1],z=ce[0]*ke[0],oe=Math.max(ce[0]*M,ce[1]),ve=g%C===0,Pe=y%z===0,Ue=x%oe===0,Je=re?[M,4,4]:[1,1,1],st=[{type:6,data:g},{type:6,data:y},{type:6,data:x},{type:6,data:[o.pads[0],o.pads[1]]},{type:6,data:o.strides},{type:6,data:o.dilations}];Vs(o,st),st.push(...Gt(s[0].dims,s[1].dims));let gt=["rank","rank"];b&&(st.push(...Gt(s[2].dims)),gt.push("rank")),st.push(...Gt(d));let wt=yt=>{let ht=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];ur(o,ht);let Ft=re?4:1,xt=Zn(s[0].dataType),Ct=`
      fn setOutputAtIndex(flatIndex : i32, value : ${re?`vec4<${xt}>`:xt}) {
        result[flatIndex] = ${re?`vec4<${xt}>`:xt}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${re?`vec4<${xt}>`:xt}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${re?"/ 4":""}, value);
      }`,Ze=dt("x",s[0].dataType,s[0].dims.length,M===3?1:M),ft=dt("w",s[1].dataType,s[1].dims.length,Ft),St=[Ze,ft],Ht=$t("result",s[0].dataType,d.length,Ft);if(b){let un=dt("bias",s[2].dataType,s[2].dims.length,Ft);St.push(un),Ct+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${re?`vec4<${xt}>`:xt} {
          return bias[coords.${O?"w":"y"}${re?"/ 4":""}];
        }`}return`
        ${xf("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${yt.registerUniforms(ht).declareVariables(...St,Ht)}
        ${Ct}
        ${Sf(O,ve,Pe,Ue,b,o,Je[0],Je[1],Je[2],xt)}
        ${re?vc(ke,ce,xt,void 0,!O,oe):wc(ke,ce,xt,void 0,!O,oe,!1,void 0,P)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${o.cacheKey};${M};${re};${ve};${Pe};${Ue};${C};${z};${oe}`,inputDependencies:gt},getRunData:()=>({outputs:[{dims:k?k(d):d,dataType:s[0].dataType}],dispatchGroup:{x:Le[0],y:Le[1],z:Le[2]},programUniforms:st}),getShaderSource:wt}}}),Cf,xc,Fr,If,bc,Mc,Lf,Df,kf=l(()=>{Wt(),Lt(),ie(),sn(),dr(),_c(),Cf=s=>{let o=1;for(let d=0;d<s.length;d++)o*=s[d];return o},xc=s=>typeof s=="number"?[s,s,s]:s,Fr=(s,o)=>o<=1?s:s+(s-1)*(o-1),If=(s,o,d,g=1)=>{let y=Fr(o,g);return Math.floor((s[0]*(d-1)-d+y)/2)},bc=(s,o,d,g,y)=>{y==null&&(y=If(s,o[0],g[0]));let x=[0,0,0,d];for(let b=0;b<3;b++)s[b]+2*y>=o[b]&&(x[b]=Math.trunc((s[b]-o[b]+2*y)/g[b]+1));return x},Mc=(s,o,d,g,y,x,b,P,k,O)=>{let $,V,G,ee;if(s==="VALID"&&(s=0),typeof s=="number"){$={top:s,bottom:s,left:s,right:s,front:s,back:s};let X=bc([o,d,g,1],[P,k,O],1,[y,x,b],s);V=X[0],G=X[1],ee=X[2]}else if(Array.isArray(s)){if(!s.every((re,Te,ue)=>re===ue[0]))throw Error(`Unsupported padding parameter: ${s}`);$={top:s[0],bottom:s[1],left:s[2],right:s[3],front:s[4],back:s[5]};let X=bc([o,d,g,1],[P,k,O],1,[y,x,b],s[0]);V=X[0],G=X[1],ee=X[2]}else if(s==="SAME_UPPER"){V=Math.ceil(o/y),G=Math.ceil(d/x),ee=Math.ceil(g/b);let X=(V-1)*y+P-o,re=(G-1)*x+k-d,Te=(ee-1)*b+O-g,ue=Math.floor(X/2),ce=X-ue,ke=Math.floor(re/2),Le=re-ke,M=Math.floor(Te/2),C=Te-M;$={top:ke,bottom:Le,left:M,right:C,front:ue,back:ce}}else throw Error(`Unknown padding parameter: ${s}`);return{padInfo:$,outDepth:V,outHeight:G,outWidth:ee}},Lf=(s,o,d,g,y,x=!1,b="channelsLast")=>{let P,k,O,$,V;if(b==="channelsLast")[P,k,O,$,V]=s;else if(b==="channelsFirst")[P,V,k,O,$]=s;else throw new Error(`Unknown dataFormat ${b}`);let[G,,ee,X,re]=o,[Te,ue,ce]=xc(d),[ke,Le,M]=xc(g),C=Fr(ee,ke),z=Fr(X,Le),oe=Fr(re,M),{padInfo:ve,outDepth:Pe,outHeight:Ue,outWidth:Je}=Mc(y,k,O,$,Te,ue,ce,C,z,oe),st=x?G*V:G,gt=[0,0,0,0,0];return b==="channelsFirst"?gt=[P,st,Pe,Ue,Je]:b==="channelsLast"&&(gt=[P,Pe,Ue,Je,st]),{batchSize:P,dataFormat:b,inDepth:k,inHeight:O,inWidth:$,inChannels:V,outDepth:Pe,outHeight:Ue,outWidth:Je,outChannels:st,padInfo:ve,strideDepth:Te,strideHeight:ue,strideWidth:ce,filterDepth:ee,filterHeight:X,filterWidth:re,effectiveFilterDepth:C,effectiveFilterHeight:z,effectiveFilterWidth:oe,dilationDepth:ke,dilationHeight:Le,dilationWidth:M,inShape:s,outShape:gt,filterShape:o}},Df=(s,o,d,g,y,x)=>{let b=x==="channelsLast";b?s[0].dims[3]:s[0].dims[1];let P=[64,1,1],k={x:d.map((Te,ue)=>ue)},O=[Math.ceil(Cf(k.x.map(Te=>d[Te]))/P[0]),1,1];ct("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${O}`);let $=1,V=it.size(d),G=[{type:12,data:V},{type:12,data:g},{type:12,data:y},{type:12,data:o.strides},{type:12,data:o.dilations}];Vs(o,G),G.push(...Gt(s[0].dims,s[1].dims));let ee=["rank","rank"],X=s.length===3;X&&(G.push(...Gt(s[2].dims)),ee.push("rank")),G.push(...Gt(d));let re=Te=>{let ue=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:g.length},{name:"pads",type:"u32",length:y.length},{name:"strides",type:"u32",length:o.strides.length},{name:"dilations",type:"u32",length:o.dilations.length}];ur(o,ue);let ce=1,ke=Zn(s[0].dataType),Le=dt("x",s[0].dataType,s[0].dims.length,$),M=dt("W",s[1].dataType,s[1].dims.length,ce),C=[Le,M],z=$t("result",s[0].dataType,d.length,ce),oe="";if(X){let Ue=dt("bias",s[2].dataType,s[2].dims.length,ce);C.push(Ue),oe+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${ke} {
          return bias[${b?Nt("coords",4,5):Nt("coords",1,5)}];
        }`}let ve=ni($,ke),Pe=cr(o,ve,ke);return`
            ${oe}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${Le.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${M.getByIndices("aIndices")};
            }
          ${Te.registerUniforms(ue).declareVariables(...C,z)}
          ${Te.mainStart()}
          ${Te.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${z.offsetToIndices("global_idx")};
              let batch = ${Nt("coords",0,Le.rank)};
              let d2 = ${b?Nt("coords",Le.rank-1,Le.rank):Nt("coords",1,Le.rank)};
              let xFRCCorner = vec3<u32>(${b?Nt("coords",1,Le.rank):Nt("coords",2,Le.rank)},
              ${b?Nt("coords",2,Le.rank):Nt("coords",3,Le.rank)},
              ${b?Nt("coords",3,Le.rank):Nt("coords",4,Le.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${b?Nt("uniforms.x_shape",1,Le.rank):Nt("uniforms.x_shape",2,Le.rank)};
              let xShapeZ = ${b?Nt("uniforms.x_shape",2,Le.rank):Nt("uniforms.x_shape",3,Le.rank)};
              let xShapeW = ${b?Nt("uniforms.x_shape",3,Le.rank):Nt("uniforms.x_shape",4,Le.rank)};
              let xShapeU = ${b?Nt("uniforms.x_shape",4,Le.rank):Nt("uniforms.x_shape",1,Le.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${b?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${b?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${b?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${b?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${X?"value = value + getBiasByOutputCoords(coords)":""};
              ${Pe}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${o.cacheKey};${b};${$};${X}`,inputDependencies:ee},getRunData:()=>({outputs:[{dims:d,dataType:s[0].dataType}],dispatchGroup:{x:O[0],y:O[1],z:O[2]},programUniforms:G}),getShaderSource:re}}}),Of,Ff,Tc=l(()=>{Wt(),ie(),sn(),dr(),Of=(s,o,d,g)=>{let y=s.length>2,x=y?"value += b[output_channel];":"",b=s[0].dims,P=s[1].dims,k=o.format==="NHWC",O=k?d[3]:d[1],$=O/o.group,V=k&&$>=4?kn(O):1,G=it.size(d)/V,ee=[{type:12,data:G},{type:12,data:o.dilations},{type:12,data:[o.strides[0],o.strides[1]]},{type:12,data:[o.pads[0],o.pads[1]]},{type:12,data:$}];Vs(o,ee),ee.push(...Gt(b,[P[0],P[1],P[2],P[3]/V]));let X=y?["rank","rank","rank"]:["rank","rank"];ee.push(...Gt([d[0],d[1],d[2],d[3]/V]));let re=Te=>{let ue=$t("output",s[0].dataType,d.length,V),ce=Zn(ue.type.tensor),ke=cr(o,ue.type.value,ce),Le=dt("x",s[0].dataType,b.length),M=dt("w",s[1].dataType,P.length,V),C=[Le,M];y&&C.push(dt("b",s[2].dataType,s[2].dims,V));let z=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:o.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];ur(o,z);let oe=k?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${Le.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${M.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${Le.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${M.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${Te.registerUniforms(z).declareVariables(...C,ue)}

  ${Te.mainStart()}
    ${Te.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${ue.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${k?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${k?1:2}], outputIndices[${k?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${V} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${k?2:1}];

    var value: ${ue.type.value} = ${ue.type.value}(0);
    ${oe}
    ${x}
    ${ke}
    ${ue.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${o.cacheKey}_${V}`,inputDependencies:X},getRunData:()=>({outputs:[{dims:g?g(d):d,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(G/64)},programUniforms:ee}),getShaderSource:re}},Ff=(s,o,d,g)=>{let y=s.length>2,x=kn(d[3]),b=kn(d[2]),P=it.size(d)/x/b,k=[s[0].dims[0],s[0].dims[1],s[0].dims[2],s[0].dims[3]/x],O=[s[1].dims[0],s[1].dims[1],s[1].dims[2],s[1].dims[3]/x],$=[d[0],d[1],d[2],d[3]/x],V=[{type:12,data:P},{type:6,data:[o.strides[0],o.strides[1]]},{type:6,data:[o.pads[0],o.pads[1]]}];Vs(o,V),V.push(...Gt(k,O,$));let G=(b-1)*o.strides[1]+O[1],ee=X=>{let re=$t("output",s[0].dataType,$.length,x),Te=Zn(re.type.tensor),ue=cr(o,re.type.value,Te),ce=dt("x",s[0].dataType,k.length,x),ke=dt("w",s[1].dataType,O.length,x),Le=[ce,ke];y&&Le.push(dt("b",s[2].dataType,s[2].dims,x));let M=y?"value += b[output_channel];":"",C=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return ur(o,C),`
  ${X.registerUniforms(C).declareVariables(...Le,re)}
  ${X.mainStart()}
    ${X.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${b}u;
    let col = (index1 % width1) * ${b}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${ce.type.value}, ${G}>;
    var values: array<${re.type.value}, ${b}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${O[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${G}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${ce.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${ce.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${O[1]}; w_width++) {
          let w_val = ${ke.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${b}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${b}u; i++) {
      var value = values[i];
      ${M}
      ${ue}
      ${re.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${o.cacheKey};${x};${b};${G};${O[0]};${O[1]}`,inputDependencies:y?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:g?g(d):d,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(P/64)},programUniforms:V}),getShaderSource:ee}}}),Rf,ta,Ec,lo,Sc,na,Bf,zf,Rr,$f=l(()=>{ie(),Af(),kf(),ea(),Tc(),dr(),yc(),ar(),Rf=(s,o,d,g,y,x)=>{let b=s[0],P=s.slice(x?1:2,x?3:4),k=P.length,O=o[0],$=o.slice(2).map((G,ee)=>G+(G-1)*(d[ee]-1)),V=P.map((G,ee)=>G+g[ee]+g[ee+k]).map((G,ee)=>Math.floor((G-$[ee]+y[ee])/y[ee]));return V.splice(0,0,b),V.splice(x?3:1,0,O),V},ta=[2,3,1,0],Ec=(s,o)=>{if(!s||s.length!==2&&s.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(s[0].dims.length>5)throw new Error("greater than 5D is not supported");if(s[0].dims.length!==s[1].dims.length)throw new Error("filter does not have same dimension as input");let d=s[0].dims[o.format==="NHWC"?s[0].dims.length-1:1],g=s[1].dims[1]*o.group;if(d!==g)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(s.length===3&&(s[2].dims.length!==1||s[1].dims[0]!==s[2].dims[0]))throw new Error("invalid bias");let y=s[0].dims.length-2;if(o.dilations.length!==y)throw new Error(`dilations should be ${y}D`);if(o.strides.length!==y)throw new Error(`strides should be ${y}D`);if(o.pads.length!==y*2)throw new Error(`pads should be ${y*2}D`);if(o.kernelShape.length!==0&&o.kernelShape.length!==s[1].dims.length-2)throw new Error("invalid kernel shape")},lo=(s,o)=>{let d=s.kernelShape.slice();d.length<o[1].dims.length-2&&d.push(...Array(o[1].dims.length-2-d.length).fill(0));for(let x=2;x<o[1].dims.length;++x)d[x-2]===0&&(d[x-2]=o[1].dims[x]);let g=s.pads.slice();Es.adjustPadsBasedOnAutoPad(o[0].dims,s.strides,s.dilations,d,g,s.format==="NHWC",s.autoPad);let y=Object.assign({},s);return Object.assign(y,{kernelShape:d,pads:g}),y},Sc=s=>{let o=mc(s),d=s.format,g=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][s.auto_pad],y=s.dilations,x=s.group,b=s.kernel_shape,P=s.pads,k=s.strides,O=s.w_is_const();return{autoPad:g,format:d,dilations:y,group:x,kernelShape:b,pads:P,strides:k,wIsConst:O,...o,cacheKey:`${s.format};${o.activation};`}},na=(s,o,d,g)=>{let y=d.format==="NHWC",x=Rf(o[0].dims,o[1].dims,d.dilations,d.pads,d.strides,y);if(d.group!==1){let C=[o[0]];if(y){let z=s.kernelCustomData.wT??s.compute(Ei(o[1],ta),{inputs:[1],outputs:[d.wIsConst?-2:-1]})[0];d.wIsConst&&!s.kernelCustomData.wT&&(s.kernelCustomData.wT=z),C.push(z)}else C.push(o[1]);o.length===3&&C.push(o[2]),!s.adapterInfo.isArchitecture("ampere")&&y&&o[1].dims[0]===d.group&&o[1].dims[1]===1&&d.dilations[0]===1&&d.dilations[1]===1?s.compute(Ff(C,d,x,g),{inputs:C}):s.compute(Of(C,d,x,g),{inputs:C});return}let b=o.length===3,P=o[0].dims[y?1:2],k=o[0].dims[y?2:3],O=o[0].dims[y?3:1],$=o[1].dims[2],V=o[1].dims[3],G=x[y?1:2],ee=x[y?2:3],X=x[y?3:1],re=y&&$===P&&V===k&&d.pads[0]===0&&d.pads[1]===0;if(re||$===1&&V===1&&d.dilations[0]===1&&d.dilations[1]===1&&d.strides[0]===1&&d.strides[1]===1&&d.pads[0]===0&&d.pads[1]===0){let C=x[0],z,oe,ve,Pe=[];if(y){let st=s.kernelCustomData.wT??s.compute(Ei(o[1],ta),{inputs:[1],outputs:[d.wIsConst?-2:-1]})[0];if(d.wIsConst&&!s.kernelCustomData.wT&&(s.kernelCustomData.wT=st),re){let gt=P*k*O;z=o[0].reshape([1,C,gt]),oe=st.reshape([1,gt,X]),ve=[1,C,X]}else z=o[0].reshape([C,P*k,O]),oe=st.reshape([1,O,X]),ve=[C,G*ee,X];Pe.push(z),Pe.push(oe)}else z=o[0].reshape([C,O,P*k]),oe=o[1].reshape([1,X,O]),ve=[C,X,G*ee],Pe.push(oe),Pe.push(z);b&&Pe.push(o[2]);let Ue=ve[2],Je=Pe[0].dims[Pe[0].dims.length-1];Ue<8&&Je<8?s.compute(Jo(Pe,d,x,ve,y,g),{inputs:Pe}):s.compute(Zo(Pe,d,x,ve,y,g),{inputs:Pe});return}let Te=!0,ue=s.kernelCustomData.wT??s.compute(Ei(o[1],ta),{inputs:[1],outputs:[d.wIsConst?-2:-1]})[0];d.wIsConst&&!s.kernelCustomData.wT&&(s.kernelCustomData.wT=ue);let ce=[o[0],ue];b&&ce.push(o[2]);let ke=y?G*ee:X,Le=y?X:G*ee,M=$*V*O;s.compute(Pf(ce,d,x,ke,Le,M,b,Te,g),{inputs:ce})},Bf=(s,o)=>{let d=o.format==="NHWC",g=[s.inputs[0].reshape(d?[s.inputs[0].dims[0],1,s.inputs[0].dims[1],s.inputs[0].dims[2]]:[s.inputs[0].dims[0],s.inputs[0].dims[1],1,s.inputs[0].dims[2]]),s.inputs[1].reshape([s.inputs[1].dims[0],s.inputs[1].dims[1],1,s.inputs[1].dims[2]])];s.inputs.length===3&&g.push(s.inputs[2]);let y=[0,o.pads[0],0,o.pads[1]],x=[1].concat(o.strides),b=[1].concat(o.dilations),P=[1].concat(o.kernelShape),k=lo({...o,pads:y,strides:x,dilations:b,kernelShape:P},g);na(s,g,k,O=>d?[O[0],O[2],O[3]]:[O[0],O[1],O[3]])},zf=(s,o,d)=>{let g=d.format==="NHWC"?"channelsLast":"channelsFirst",y=lo(d,o),x=d.autoPad==="NOTSET"?d.pads:d.autoPad,b=Lf(o[0].dims,o[1].dims,d.strides,d.dilations,x,!1,g);s.compute(Df(o,y,b.outShape,[b.filterDepth,b.filterHeight,b.filterWidth],[b.padInfo.front,b.padInfo.top,b.padInfo.left],g))},Rr=(s,o)=>{if(Ec(s.inputs,o),s.inputs[0].dims.length===3)Bf(s,o);else if(s.inputs[0].dims.length===5)zf(s,s.inputs,o);else{let d=lo(o,s.inputs);na(s,s.inputs,d)}}}),Nf,ry=l(()=>{Wt(),Lt(),ie(),sn(),Nf=(s,o,d)=>{let g=s.length>2,y=o.outputShape,x=o.format==="NHWC",b=o.group,P=s[1].dims,k=P[2]/b,O=P[3],$=x?kn(k):1,V=x&&O===1&&k>=4,G=V?Math.floor(k/4)*4:Math.floor(k/$)*$,ee=k-G,X=x?kn(O):1,re=x?O===1?$:X:1,Te=it.size(y)/X,ue=[Math.ceil(Te/64),1,1];ct("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${ue}`);let ce=["rank","rank"],ke=[o.strides[0],o.strides[1]],Le=[o.kernelShape[x?1:2],o.kernelShape[x?2:3]],M=[o.dilations[0],o.dilations[1]],C=[Le[0]+(o.dilations[0]<=1?0:(o.kernelShape[x?1:2]-1)*(o.dilations[0]-1)),Le[1]+(o.dilations[1]<=1?0:(o.kernelShape[x?2:3]-1)*(o.dilations[1]-1))],z=[C[0]-1-Math.floor((o.pads[0]+o.pads[2])/2),C[1]-1-Math.floor((o.pads[1]+o.pads[3])/2)],oe=[{type:12,data:Te},{type:12,data:ke},{type:12,data:Le},{type:12,data:M},{type:12,data:C},{type:6,data:z},{type:12,data:G},{type:12,data:k},{type:12,data:O},...Gt(s[0].dims,s[1].dims)];g&&(oe.push(...Gt(s[2].dims)),ce.push("rank")),oe.push(...Gt(y));let ve=Pe=>{let Ue=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:ke.length},{name:"filter_dims",type:"u32",length:Le.length},{name:"dilations",type:"u32",length:Le.length},{name:"effective_filter_dims",type:"u32",length:C.length},{name:"pads",type:"i32",length:z.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],Je=Zn(s[0].dataType),st=x?1:2,gt=x?2:3,wt=x?3:1,yt=dt("W",s[1].dataType,s[1].dims.length,re),ht=dt("Dy",s[0].dataType,s[0].dims.length,$),Ft=[ht,yt];g&&Ft.push(dt("bias",s[2].dataType,[y[wt]].length,X));let xt=$t("result",s[0].dataType,y.length,X),Ct=()=>{let St="";if(V)$===4?St+=`
        let xValue = ${ht.getByOffset("x_offset")};
        let wValue = ${yt.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`:$===2?St+=`
          dotProd = dotProd + dot(vec4<${Je}>(${ht.getByOffset("x_offset")}, ${ht.getByOffset("x_offset + 1u")}), vec4<${Je}>(${yt.getByOffset("w_offset")}, ${yt.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`:$===1&&(St+=`
          dotProd = dotProd + dot(vec4<${Je}>(${ht.getByOffset("x_offset")}, ${ht.getByOffset("x_offset + 1u")}, ${ht.getByOffset("x_offset + 2u")}, ${ht.getByOffset("x_offset + 3u")}), vec4<${Je}>(${yt.getByOffset("w_offset")}, ${yt.getByOffset("w_offset + 1u")}, ${yt.getByOffset("w_offset + 2u")}, ${yt.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`);else if(St+=`
                  let xValue = ${x?ht.getByOffset(`${ht.indicesToOffset(`${ht.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${$}`):ht.get("batch","inputChannel","idyR","idyC")};
        `,$===1)St+=`
          let w_offset = ${yt.indicesToOffset(`${yt.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${yt.getByOffset(`w_offset / ${re}`)};
          dotProd = dotProd + xValue * wValue;`;else for(let Ht=0;Ht<$;Ht++)St+=`
            let wValue${Ht} = ${yt.getByOffset(`${yt.indicesToOffset(`${yt.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${Ht}, wOutChannel)`)} / ${re}`)};
            dotProd = dotProd + xValue[${Ht}] * wValue${Ht};`;return St},Ze=()=>{if(ee===0)return"";if(!V)throw new Error(`packInputAs4 ${V} is not true.`);let St="";if($===1){St+="dotProd = dotProd";for(let Ht=0;Ht<ee;Ht++)St+=`
            + ${ht.getByOffset(`x_offset + ${Ht}`)} * ${yt.getByOffset(`w_offset + ${Ht}`)}`;St+=";"}else if($===2){if(ee!==2)throw new Error(`Invalid inputChannelsRemainder ${ee}.`);St+=`
          let xValue = ${ht.getByOffset("x_offset")};
          let wValue = ${yt.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`}return St},ft=`
            let outputIndices = ${xt.offsetToIndices(`global_idx * ${X}`)};
            let batch = ${xt.indicesGet("outputIndices",0)};
            let d1 = ${xt.indicesGet("outputIndices",wt)};
            let r = ${xt.indicesGet("outputIndices",st)};
            let c = ${xt.indicesGet("outputIndices",gt)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${xt.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${Je}(dyRCorner) + ${Je}(wR)) / ${Je}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${Je}(uniforms.Dy_shape[${st}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${Je}(dyCCorner) + ${Je}(wC)) / ${Je}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${Je}(uniforms.Dy_shape[${gt}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${V?`
                var x_offset = ${ht.indicesToOffset(`${ht.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${$};
                var w_offset = ${yt.indicesToOffset(`${yt.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${re};
                  `:""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${V?4:$}) {
                  ${Ct()}
                  inputChannel = inputChannel + ${V?4:$};
                }
                ${Ze()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${g?` + bias[d1 / ${X}]`:""};
            ${xt.setByOffset("global_idx","value")};
          `;return`
    ${Pe.registerUniforms(Ue).declareVariables(...Ft,xt)}
      ${Pe.mainStart()}
      ${Pe.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${ft}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${o.cacheKey};${$}${re}${X}${V}${ee}`,inputDependencies:ce},getRunData:()=>({dispatchGroup:{x:ue[0],y:ue[1],z:ue[2]},outputs:[{dims:d?d(y):y,dataType:s[0].dataType}],programUniforms:oe}),getShaderSource:ve}}}),Uf,Pc,Gf,Ac,Vf,Cc,Ic,jf,Lc,oy=l(()=>{ry(),dr(),ar(),Uf=(s,o,d,g,y,x)=>(s-1)*o+d+(g-1)*y+1-x,Pc=(s,o,d,g,y)=>{let x=Math.floor(s/2);o==="SAME_UPPER"?(d[g]=x,d[y]=s-x):o==="SAME_LOWER"&&(d[g]=s-x,d[y]=x)},Gf=(s,o,d,g,y,x,b,P,k,O)=>{let $=s.length-2,V=O.length===0;k.length<$&&k.push(...Array($-k.length).fill(0));let G=s[0],ee=o[P?3:1]*y;for(let X=0,re=s.length-$-(P?1:0);X<$;++X,++re){let Te=s[re],ue=V?Te*b[X]:O[X],ce=Uf(Te,b[X],x[X],o[re],d[X],ue);Pc(ce,g,x,X,X+$),V&&O.push(b[X]*(Te-1)+k[X]+(o[re]-1)*d[X]+1-x[X]-x[X+$])}O.splice(0,0,G),O.splice(P?3:1,0,ee)},Ac=(s,o)=>{let d=s.kernelShape.slice();if(s.kernelShape.length===0||s.kernelShape.reduce((V,G)=>V*G,1)===0){d.length=0;for(let V=2;V<o[1].dims.length;++V)d.push(o[1].dims[V])}let g=s.format==="NHWC";d.splice(0,0,o[1].dims[0]),d.splice(g?3:1,0,o[1].dims[1]);let y=s.pads.slice(),x=s.outputShape.slice(),b=s.outputPadding.slice(),P=o[0].dims,k=s.dilations.slice();if(k.reduce((V,G)=>V+G,0)===0){let V=o[0].dims.length-2;k=new Array(V).fill(1)}let O=s.strides.slice();if(O.reduce((V,G)=>V+G,0)===0){let V=o[0].dims.length-2;O=new Array(V).fill(1)}Gf(P,d,k,s.autoPad,s.group,y,O,g,b,x);let $=Object.assign({},s);return Object.assign($,{kernelShape:d,pads:y,outputPadding:b,outputShape:x,dilations:k,strides:O}),$},Vf=s=>{let o=mc(s),d=s.format,g=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof s.autoPad>"u"?0:s.autoPad],y=s.dilations,x=s.group,b=s.kernelShape,P=s.pads,k=s.strides,O=s.wIsConst(),$=s.outputPadding,V=s.outputShape;return{autoPad:g,format:d,dilations:y,group:x,kernelShape:b,outputPadding:$,outputShape:V,pads:P,strides:k,wIsConst:O,...o,cacheKey:`${s.format};${o.activation};`}},Cc=(s,o)=>{if(!s||s.length!==2&&s.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(s[0].dims.length!==4&&s[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(s[0].dims.length!==s[1].dims.length)throw new Error("filter does not have same dimension as input");let d=s[0].dims[o.format==="NHWC"?s[0].dims.length-1:1],g=s[1].dims[0];if(d!==g)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let y=s[1].dims[1]*o.group;if(s.length===3&&(s[2].dims.length!==1||s[2].dims[0]!==y))throw new Error("invalid bias");let x=s[0].dims.length-2;if(o.dilations.reduce((b,P)=>b+P,0)>0&&o.dilations.length!==x)throw new Error(`dilations should be ${x}D`);if(o.strides.reduce((b,P)=>b+P,0)>0&&o.strides.length!==x)throw new Error(`strides should be ${x}D`);if(o.pads.reduce((b,P)=>b+P,0)>0&&o.pads.length!==x*2)throw new Error(`pads should be ${x*2}D`);if(o.outputPadding.length!==x&&o.outputPadding.length!==0)throw new Error(`output_padding should be ${x}D`);if(o.kernelShape.reduce((b,P)=>b+P,0)>0&&o.kernelShape.length!==0&&o.kernelShape.length!==s[1].dims.length-2)throw new Error("invalid kernel shape");if(o.outputShape.length!==0&&o.outputShape.length!==s[0].dims.length-2)throw new Error("invalid output shape")},Ic=(s,o,d,g)=>{let y=s.kernelCustomData.wT??s.compute(Ei(o[1],[2,3,0,1]),{inputs:[1],outputs:[d.wIsConst?-2:-1]})[0];d.wIsConst&&!s.kernelCustomData.wT&&(s.kernelCustomData.wT=y);let x=[o[0],y];o.length===3&&x.push(o[2]),s.compute(Nf(x,d,g),{inputs:x})},jf=(s,o)=>{let d=o.format==="NHWC",g=[s.inputs[0].reshape(d?[s.inputs[0].dims[0],1,s.inputs[0].dims[1],s.inputs[0].dims[2]]:[s.inputs[0].dims[0],s.inputs[0].dims[1],1,s.inputs[0].dims[2]]),s.inputs[1].reshape([s.inputs[1].dims[0],s.inputs[1].dims[1],1,s.inputs[1].dims[2]])];s.inputs.length===3&&g.push(s.inputs[2]);let y=o.kernelShape;(y.length===0||y[0]===0)&&(y=[s.inputs[1].dims[2]]);let x=o.dilations;(x.length===0||x[0]===0)&&(x=[1]);let b=o.strides;(b.length===0||b[0]===0)&&(b=[1]);let P=o.pads;P.length===0&&(P=[0,0]),P=[0,P[0],0,P[1]],b=[1].concat(b),x=[1].concat(x),y=[1].concat(y);let k=o.outputPadding;k=[0].concat(k);let O=Ac({...o,pads:P,strides:b,dilations:x,kernelShape:y,outputPadding:k},g);Ic(s,g,O,$=>d?[$[0],$[2],$[3]]:[$[0],$[1],$[3]])},Lc=(s,o)=>{if(Cc(s.inputs,o),s.inputs[0].dims.length===3)jf(s,o);else{let d=Ac(o,s.inputs);Ic(s,s.inputs,d)}}}),Wf,Hf,Dc,ay=l(()=>{Wt(),ie(),mn(),sn(),Wf=(s,o,d,g)=>{let y=it.size(o),x=o.length,b=dt("input",s,x),P=$t("output",s,x),k=d.dataType===6?d.getInt32Array()[0]:Number(d.getBigInt64Array()[0]),O=it.normalizeAxis(k,x),$=V=>{let G=` i32(${b.indicesGet("inputIndices","uniforms.axis")}) `,ee=Nt("uniforms.input_shape","uniforms.axis",x),X=g.reverse?G+(g.exclusive?" + 1":""):"0",re=g.reverse?ee:G+(g.exclusive?"":" + 1");return`
                ${V.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(b,P)}
                ${V.mainStart()}
                  ${V.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${P.offsetToIndices("global_idx")};
                  var sum = ${P.type.value}(0);
                  let first : i32 = ${X};
                  let last : i32 = ${re};
                  for (var i : i32 = first; i < last; i++) {
                    ${b.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${b.getByIndices("inputIndices")};
                  }
                  ${P.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:g.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:o,dataType:s}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},{type:12,data:O},...Gt(o,o)]}),getShaderSource:$}},Hf=(s,o)=>{let d=s.inputs[0].dims,g=s.inputs[0].dataType,y=s.inputs[1];s.compute(Wf(g,d,y,o),{inputs:[0]})},Dc=s=>{let o=s.exclusive===1,d=s.reverse===1;return Jt({exclusive:o,reverse:d})}}),qf,kc,Kf,Xf,Oc,ly=l(()=>{Wt(),ie(),mn(),sn(),qf=s=>{if(!s||s.length!==1)throw new Error("DepthToSpace requires 1 input.");if(s[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},kc=(s,o,d,g)=>{let y=[];y.push(`fn perm(i: ${g.type.indices}) -> ${d.type.indices} {
    var a: ${d.type.indices};`);for(let x=0;x<o;++x)y.push(d.indicesSet("a",s[x],`i[${x}]`));return y.push("return a;}"),y.join(`
`)},Kf=(s,o)=>{let d,g,y,x,b,P,k=o.format==="NHWC",O=o.blocksize,$=o.mode==="DCR";k?([d,g,y,x]=s.dims,b=$?[d,g,y,O,O,x/O**2]:[d,g,y,x/O**2,O,O],P=$?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([d,g,y,x]=[s.dims[0],s.dims[2],s.dims[3],s.dims[1]],b=$?[d,O,O,x/O**2,g,y]:[d,x/O**2,O,O,g,y],P=$?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let V=s.reshape(b),G=V.dims.length,ee=s.dataType,X=dt("a",ee,G),re=$t("output",ee,G),Te=ue=>`
  ${ue.registerUniform("output_size","u32").declareVariables(X,re)}

  ${kc(P,G,X,re)}

  ${ue.mainStart()}
    ${ue.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${re.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${re.setByOffset("global_idx",X.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${s.dims};${o.blocksize};${o.mode}`,inputDependencies:["rank"]},getRunData:ue=>{let ce=k?[d,g*O,y*O,x/O**2]:[d,x/O**2,g*O,y*O],ke=it.size(ce),Le=V.dims,M=it.sortBasedOnPerm(Le,P);return{outputs:[{dims:ce,dataType:ue[0].dataType}],dispatchGroup:{x:Math.ceil(ke/64)},programUniforms:[{type:12,data:ke},...Gt(Le,M)]}},getShaderSource:Te}},Xf=(s,o)=>{qf(s.inputs),s.compute(Kf(s.inputs[0],o))},Oc=s=>Jt({blocksize:s.blocksize,mode:s.mode,format:s.format})}),ia,hr,Fc,Yf,Jf,Rc,Qf,Bc,zc,Zf,ep,cy=l(()=>{Wt(),ie(),mn(),sn(),ia="[a-zA-Z]|\\.\\.\\.",hr="("+ia+")+",Fc="^"+hr+"$",Yf="("+hr+",)*"+hr,Jf="^"+Yf+"$",Rc=class{constructor(s=-1){this.symbolToIndices=new Map,this.inputIndex=s}addSymbol(s,o){let d=this.symbolToIndices.get(s);d===void 0?d=[o]:d.push(o),this.symbolToIndices.set(s,d)}},Qf=class{constructor(s,o){var y;this.equation=o,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[d,g]=o.includes("->")?o.split("->",2):[o,""];if(!d.match(RegExp(Jf)))throw new Error("Invalid LHS term");if(d.split(",").forEach((x,b)=>{let P=s[b].dims.slice();if(!x.match(RegExp(Fc)))throw new Error("Invalid LHS term");let k=this.processTerm(x,!0,P,b);this.lhs.push(k)}),g==="")g+=[...this.symbolToInfo.entries()].filter(([x,b])=>b.count===1||x==="...").map(([x])=>x).join("");else if(!g.match(RegExp(hr)))throw new Error("Invalid RHS");(y=g.match(RegExp(ia,"g")))==null||y.forEach(x=>{if(x==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let b=this.symbolToInfo.get(x);if(b===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(b.dimValue)}}),this.rhs=this.processTerm(g,!1,this.outputDims)}addSymbol(s,o,d){let g=this.symbolToInfo.get(s);if(g!==void 0){if(g.dimValue!==o&&g.count!==1)throw new Error("Dimension mismatch");g.count++,g.inputIndices.push(d)}else g={count:1,dimValue:o,inputIndices:[d]};this.symbolToInfo.set(s,g)}processTerm(s,o,d,g=-1){let y=d.length,x=!1,b=[],P=0;if(!s.match(RegExp(Fc))&&!o&&s!=="")throw new Error("Invalid LHS term");let k=s.match(RegExp(ia,"g")),O=new Rc(g);return k==null||k.forEach(($,V)=>{if($==="..."){if(x)throw new Error("Only one ellipsis is allowed per input term");x=!0;let G=y-k.length+1;if(G<0)throw new Error("Ellipsis out of bounds");if(b=d.slice(P,P+G),this.hasEllipsis){if(this.ellipsisDims.length!==b.length||this.ellipsisDims.toString()!==b.toString())throw new Error("Ellipsis dimensions mismatch")}else if(o)this.hasEllipsis=!0,this.ellipsisDims=b;else throw new Error("Ellipsis must be specified in the LHS");for(let ee=0;ee<b.length;ee++){let X=String.fromCharCode(48+ee);O.addSymbol(X,V+ee),this.addSymbol(X,d[P++],g)}}else O.addSymbol($,V+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol($,d[P++],g)}),O}},Bc=s=>s+"_max",zc=(s,o,d,g)=>{let y=s.map(O=>O.length).map((O,$)=>dt(`input${$}`,o,O)),x=it.size(g),b=$t("output",o,g.length),P=[...d.symbolToInfo.keys()].filter(O=>!d.rhs.symbolToIndices.has(O)),k=O=>{let $=[],V="var prod = 1.0;",G="var sum = 0.0;",ee="sum += prod;",X=[],re=[],Te=[],ue=[],ce=d.symbolToInfo.size===d.rhs.symbolToIndices.size;d.symbolToInfo.forEach((Le,M)=>{var C;if(d.rhs.symbolToIndices.has(M)){let z=(C=d.rhs.symbolToIndices.get(M))==null?void 0:C[0];z!==void 0&&d.lhs.forEach((oe,ve)=>{if(Le.inputIndices.includes(ve)){let Pe=oe.symbolToIndices.get(M);if(Pe===void 0)throw new Error("Invalid symbol error");Pe.forEach(Ue=>{$.push(`${y[ve].indicesSet(`input${ve}Indices`,Ue,b.indicesGet("outputIndices",z))}`)})}})}else d.lhs.forEach((z,oe)=>{if(Le.inputIndices.includes(oe)){let ve=z.symbolToIndices.get(M);if(ve===void 0)throw new Error("Invalid symbol error");ve.forEach(Pe=>{X.push(`${y[oe].indicesSet(`input${oe}Indices`,Pe,`${M}`)}`)}),ue.push(`prod *= ${y[oe].getByIndices(`input${oe}Indices`)};`)}}),re.push(`for(var ${M}: u32 = 0; ${M} < uniforms.${Bc(M)}; ${M}++) {`),Te.push("}")});let ke=ce?[...$,`let sum = ${y.map((Le,M)=>Le.getByIndices(`input${M}Indices`)).join(" * ")};`]:[...$,G,...re,...X,V,...ue,ee,...Te];return`
            ${O.registerUniforms(P.map(Le=>({name:`${Bc(Le)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...y,b)}

            ${O.mainStart()}
            ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${b.offsetToIndices("global_idx")};
            ${y.map((Le,M)=>`var input${M}Indices: ${y[M].type.indices};`).join(`
`)}
            ${ke.join(`
`)};
            ${b.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:d.equation,inputDependencies:s.map(()=>"rank")},getRunData:()=>{let O=P.filter(V=>d.symbolToInfo.has(V)).map(V=>{var G;return{type:12,data:((G=d.symbolToInfo.get(V))==null?void 0:G.dimValue)||0}});O.push({type:12,data:x});let $=s.map((V,G)=>[...Gt(V)]).reduce((V,G)=>V.concat(G),O);return $.push(...Gt(g)),{outputs:[{dims:g,dataType:o}],dispatchGroup:{x:Math.ceil(x/64)},programUniforms:$}},getShaderSource:k}},Zf=(s,o)=>{let d=new Qf(s.inputs,o.equation),g=d.outputDims,y=s.inputs.map((x,b)=>x.dims);s.compute(zc(y,s.inputs[0].dataType,d,g))},ep=s=>{let o=s.equation.replace(/\s+/g,"");return Jt({equation:o})}}),tp,co,np,ip,sp,uy=l(()=>{Wt(),ie(),sn(),tp=s=>{if(!s||s.length!==2)throw new Error("Expand requires 2 input.");let o=s[0].dims,d=Array.from(s[1].getBigInt64Array(),Number),g=d.length<o.length?0:d.length-o.length,y=o.length<d.length?0:o.length-d.length;for(;g<d.length&&y<o.length;++g,++y)if(d[g]!==o[y]&&d[g]!==1&&o[y]!==1)throw new Error("Expand requires shape to be broadcastable to input")},co=(s,o)=>{let d=s.length-o.length,g=[];for(let y=0;y<d;++y)g.push(s[y]);for(let y=0;y<o.length;++y)g.push(o[y]===1?s[y+d]:o[y]);return g},np=(s,o)=>s.length>o.length?co(s,o):co(o,s),ip=s=>{let o=s[0].dims,d=Array.from(s[1].getBigInt64Array(),Number),g=np(o,d),y=s[0].dataType,x=y===9||it.size(o)===1,b=y===9||o.length>0&&o[o.length-1]%4===0?4:1,P=x||g.length>0&&g[g.length-1]%4===0?4:1,k=Math.ceil(it.size(g)/P),O=V=>{let G=dt("input",y,o.length,b),ee=$t("output",y,g.length,P),X;if(y===9){let re=(Te,ue,ce="")=>`
          let outputIndices${ue} = ${ee.offsetToIndices(`outputOffset + ${ue}u`)};
          let offset${ue} = ${G.broadcastedIndicesToOffset(`outputIndices${ue}`,ee)};
          let index${ue} = offset${ue} / 4u;
          let component${ue} = offset${ue} % 4u;
          ${Te}[${ue}] = ${ce}(${G.getByOffset(`index${ue}`)}[component${ue}]);
        `;X=`
        let outputOffset = global_idx * ${P};
        var data = vec4<u32>(0);
        ${re("data",0,"u32")}
        ${re("data",1,"u32")}
        ${re("data",2,"u32")}
        ${re("data",3,"u32")}
        ${ee.setByOffset("global_idx","data")}
      }`}else X=`
        let outputIndices = ${ee.offsetToIndices(`global_idx * ${P}`)};
        let inputOffset = ${G.broadcastedIndicesToOffset("outputIndices",ee)};
        let data = ${ee.type.value}(${G.getByOffset(`inputOffset / ${b}`)});
        ${ee.setByOffset("global_idx","data")}
      }`;return`
    ${V.registerUniform("vec_size","u32").declareVariables(G,ee)}
    ${V.mainStart()}
    ${V.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${X}`},$=[{type:12,data:k},...Gt(o,g)];return{name:"Expand",shaderCache:{hint:`${g.length};${b}${P}`,inputDependencies:["rank"]},getShaderSource:O,getRunData:()=>({outputs:[{dims:g,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(k/64)},programUniforms:$})}},sp=s=>{tp(s.inputs),s.compute(ip(s.inputs),{inputs:[0]})}}),rp,op,dy=l(()=>{Wt(),ie(),sn(),lc(),rp=s=>{let o=s[0].dataType,d=it.size(s[0].dims),g=it.size(s[1].dims),y=g%4===0,x=b=>{let P=dt("x",o,[1],4),k=dt("bias",o,[1],4),O=$t("y",o,[1],4),$=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],V=ee=>`
      let bias${ee}_offset: u32 = (global_idx * 4 + ${ee}) % uniforms.bias_size;
      let bias${ee} = ${k.getByOffset(`bias${ee}_offset / 4`)}[bias${ee}_offset % 4];`,G=y?`
      let bias = ${k.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${V(0)}${V(1)}${V(2)}${V(3)}
      let bias = ${P.type.value}(bias0, bias1, bias2, bias3);`;return`${b.registerUniforms($).declareVariables(P,k,O)}

    ${Yo(hi(o))}

    ${b.mainStart(cs)}
      ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${P.getByOffset("global_idx")};
      ${G}
      let x_in = x + bias;
      ${O.setByOffset("global_idx",rc("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${y}`,inputDependencies:["type","type"]},getShaderSource:x,getRunData:b=>({outputs:[{dims:b[0].dims,dataType:b[0].dataType}],programUniforms:[{type:12,data:Math.ceil(d/4)},{type:12,data:g}],dispatchGroup:{x:Math.ceil(d/cs/4)}})}},op=s=>{s.inputs.length<2||it.size(s.inputs[1].dims)===0?Zh(s):s.compute(rp(s.inputs))}}),ap,lp,$c,cp,hy=l(()=>{Wt(),ie(),mn(),sn(),ap=s=>{if(!s||s.length!==2)throw new Error("Gather requires 2 inputs.")},lp=(s,o)=>{let d=s[0].dims,g=s[1].dims,y=d.length,x=it.normalizeAxis(o.axis,y),b=d.slice(0);b.splice(x,1,...g);let P=d[x],k=s[0].dataType===9?4:1,O=Math.ceil(it.size(b)/k),$=[{type:12,data:O},{type:6,data:P},{type:12,data:x},...Gt(s[0].dims,s[1].dims,b)],V=G=>{let ee=dt("data",s[0].dataType,s[0].dims.length,k),X=dt("inputIndices",s[1].dataType,s[1].dims.length),re=$t("output",s[0].dataType,b.length,k),Te=ce=>{let ke=g.length,Le=`var indicesIndices${ce}  = ${X.type.indices}(0);`;for(let M=0;M<ke;M++)Le+=`${ke>1?`indicesIndices${ce}[${M}]`:`indicesIndices${ce}`} = ${b.length>1?`outputIndices${ce}[uniforms.axis + ${M}]`:`outputIndices${ce}`};`;Le+=`
          var idx${ce} = ${X.getByIndices(`indicesIndices${ce}`)};
          if (idx${ce} < 0) {
            idx${ce} = idx${ce} + uniforms.axisDimLimit;
          }
          var dataIndices${ce} : ${ee.type.indices};
        `;for(let M=0,C=0;M<y;M++)M===x?(Le+=`${y>1?`dataIndices${ce}[${M}]`:`dataIndices${ce}`} = u32(idx${ce});`,C+=ke):(Le+=`${y>1?`dataIndices${ce}[${M}]`:`dataIndices${ce}`} = ${b.length>1?`outputIndices${ce}[${C}]`:`outputIndices${ce}`};`,C++);return Le},ue;if(s[0].dataType===9){let ce=(ke,Le,M="")=>`
          let outputIndices${Le} = ${re.offsetToIndices(`outputOffset + ${Le}u`)};
          ${Te(Le)};
          let offset${Le} = ${ee.indicesToOffset(`dataIndices${Le}`)};
          let index${Le} = offset${Le} / 4u;
          let component${Le} = offset${Le} % 4u;
          ${ke}[${Le}] = ${M}(${ee.getByOffset(`index${Le}`)}[component${Le}]);
        `;ue=`
        let outputOffset = global_idx * ${k};
        var value = vec4<u32>(0);
        ${ce("value",0,"u32")}
        ${ce("value",1,"u32")}
        ${ce("value",2,"u32")}
        ${ce("value",3,"u32")}
        ${re.setByOffset("global_idx","value")}
      `}else ue=`
      let outputIndices = ${re.offsetToIndices("global_idx")};
      ${Te("")};
      let value = ${ee.getByIndices("dataIndices")};
      ${re.setByOffset("global_idx","value")};
      `;return`
      ${G.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(ee,X,re)}
      ${G.mainStart()}
        ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${ue}
      }`};return{name:"Gather",shaderCache:{hint:o.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:b,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(O/64)},programUniforms:$}),getShaderSource:V}},$c=s=>Jt({axis:s.axis}),cp=(s,o)=>{let d=s.inputs;ap(d),s.compute(lp(s.inputs,o))}}),Nc,up,dp,fy=l(()=>{Wt(),ie(),sn(),Nc=(s,o,d,g,y,x,b,P,k)=>{let O=[{type:12,data:x},{type:12,data:g},{type:12,data:y},{type:12,data:d},{type:12,data:b},{type:12,data:P},{type:12,data:k}],$=[x];O.push(...Gt(o.dims,$));let V=G=>{let ee=dt("indices_data",o.dataType,o.dims.length),X=$t("input_slice_offsets_data",12,1,1),re=[ee,X],Te=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:y.length},{name:"sizes_from_slice_dims_data",type:"u32",length:d.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${G.registerUniforms(Te).declareVariables(...re)}
  ${G.mainStart()}
    ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${y.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${d.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return s.compute({name:"computeSliceOffsets",shaderCache:{hint:`${y.length}_${d.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:$,dataType:s.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(x/64)},programUniforms:O}),getShaderSource:V},{inputs:[o],outputs:[-1]})[0]},up=(s,o)=>{let d=s.inputs,g=d[0].dims,y=d[0].dataType,x=d[1].dims,b=x[x.length-1],P=it.sizeToDimension(x,x.length-1),k=it.sizeFromDimension(g,o.batchDims+b),O=it.sizeToDimension(g,o.batchDims),$=it.sizeFromDimension(g,o.batchDims),V=P/O,G=new Array(b),ee=k;for(let Le=0;Le<b;++Le)G[b-1-Le]=ee,ee*=g[o.batchDims+b-1-Le];let X=Nc(s,d[1],G,o.batchDims,g,P,V,$,b),re=o.batchDims+b;if(re>g.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let Te=x.slice(0,-1).concat(g.slice(re)),ue=it.size(Te),ce=[{type:12,data:ue},{type:12,data:k},...Gt(d[0].dims,X.dims,Te)],ke=Le=>{let M=dt("data",d[0].dataType,d[0].dims.length),C=dt("slice_offsets",12,X.dims.length),z=$t("output",d[0].dataType,Te.length);return`
          ${Le.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(M,C,z)}
            ${Le.mainStart()}
            ${Le.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};s.compute({name:"GatherND",shaderCache:{hint:o.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:Te,dataType:y}],dispatchGroup:{x:Math.ceil(ue/64)},programUniforms:ce}),getShaderSource:ke},{inputs:[d[0],X]})},dp=s=>({batchDims:s.batch_dims,cacheKey:""})}),hp,Uc,fp,pp,mp=l(()=>{Wt(),ie(),mn(),sn(),hp=(s,o)=>{if(s.length<3||s.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let d=it.normalizeAxis(o.quantizeAxis,s[0].dims.length),g=o.blockSize,y=s[0],x=s[2],b=s.length===4?s[3]:void 0;if(x.dims.length!==y.dims.length||!y.dims.map((P,k)=>k===d?Math.ceil(P/g)===x.dims[k]:P===x.dims[k]).reduce((P,k)=>P&&k,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(b){if(b.dataType!==y.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(b.dims.length!==x.dims.length||!b.dims.map((P,k)=>P===x.dims[k]).reduce((P,k)=>P&&k,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},Uc=(s,o)=>{let d=s[0].dims,g=s[1].dims,y=d.length,x=it.normalizeAxis(o.gatherAxis,y),b=it.normalizeAxis(o.quantizeAxis,y),P=d.slice(0);P.splice(x,1,...g);let k=it.size(P),O=s[2].dataType,$=s[0].dataType===22,V=[{type:12,data:k},{type:12,data:b},{type:12,data:x},{type:12,data:o.blockSize},...Gt(...s.map((ee,X)=>ee.dims),P)],G=ee=>{let X=dt("data",s[0].dataType,s[0].dims.length),re=dt("inputIndices",s[1].dataType,s[1].dims.length),Te=dt("scales",s[2].dataType,s[2].dims.length),ue=s.length>3?dt("zeroPoint",s[3].dataType,s[3].dims.length):void 0,ce=$t("output",O,P.length),ke=[X,re,Te];ue&&ke.push(ue);let Le=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${ee.registerUniforms(Le).declareVariables(...ke,ce)}
        ${ee.mainStart()}
        let output_indices = ${ce.offsetToIndices("global_idx")};
        var indices_indices = ${re.type.indices}(0);
        ${g.length>1?`
          for (var i: u32 = 0; i < ${g.length}; i++) {
            let index = ${ce.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${re.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${ce.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${X.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${ce.indicesGet("output_indices","i")};
          ${X.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${re.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${d[x]};
        }
        ${X.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${P.length}; i++) {
          let index = ${ce.indicesGet("output_indices",`i + ${g.length} - 1`)};
          ${X.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${X.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${X.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${$?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${Te.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${Te.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${Te.getByIndices("scale_indices")};
        ${ue?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${ue.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${ue.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${$?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${hi(O)}(quantized_data - zero_point) * scale;
        ${ce.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${o.cacheKey};${s.filter((ee,X)=>X!==1).map(ee=>ee.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:s.length},(ee,X)=>"rank")},getRunData:()=>({outputs:[{dims:P,dataType:O}],dispatchGroup:{x:Math.ceil(k/64)},programUniforms:V}),getShaderSource:G}},fp=(s,o)=>{let d=s.inputs;hp(d,o),s.compute(Uc(s.inputs,o))},pp=s=>Jt({blockSize:s.blockSize,gatherAxis:s.gatherAxis,quantizeAxis:s.quantizeAxis})}),gp,_p,Gc,yp,py=l(()=>{Wt(),ie(),mn(),sn(),gp=s=>{if(!s||s.length!==2)throw new Error("GatherElements requires 2 inputs.");if(s[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(s[0].dims.length!==s[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},_p=(s,o)=>{let d=s[0].dims,g=s[0].dataType,y=d.length,x=s[1].dims,b=s[1].dataType,P=it.normalizeAxis(o.axis,y),k=d[P],O=x.slice(0),$=it.size(O),V=dt("input",g,y),G=dt("indicesInput",b,x.length),ee=$t("output",g,O.length),X=[{type:12,data:$},{type:6,data:k},{type:12,data:P}];return X.push(...Gt(d,x,O)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:O,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:X}),getShaderSource:re=>`
      ${re.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(V,G,ee)}
      ${re.mainStart()}
      ${re.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${ee.offsetToIndices("global_idx")};

      var idx = ${G.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${V.type.indices}(outputIndices);
      ${V.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${V.getByIndices("inputIndices")};

      ${ee.setByOffset("global_idx","value")};
  }`}},Gc=s=>Jt({axis:s.axis}),yp=(s,o)=>{let d=s.inputs;gp(d),s.compute(_p(s.inputs,o))}}),Vc,vp,wp,xp,my=l(()=>{Wt(),ie(),sn(),Vc=s=>{if(!s)throw new Error("Input is missing");if(s.length<2||s.length>3)throw new Error("Invaid input number.");if(s.length===3&&s[2].dims.length>2)throw new Error("Invalid input shape of C");if(s[0].dataType!==s[1].dataType||s.length===3&&s[0].dataType!==s[2].dataType)throw new Error("Input types are mismatched")},vp=(s,o)=>{let d=s[0].dims.slice(),g=s[1].dims.slice(),[y,x,b]=ro.getShapeOfGemmResult(d,o.transA,g,o.transB,s.length===3?s[2].dims:void 0),P=[y,x];if(!P)throw new Error("Can't use gemm on the given tensors");let k=16,O=Math.ceil(x/k),$=Math.ceil(y/k),V=!0,G=it.size(P),ee=[{type:12,data:V?O:G},{type:12,data:y},{type:12,data:x},{type:12,data:b},{type:1,data:o.alpha},{type:1,data:o.beta}],X=["type","type"];s.length===3&&(ee.push(...Gt(s[2].dims)),X.push("rank")),ee.push(...Gt(P));let re=ue=>{let ce="";o.transA&&o.transB?ce="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":o.transA&&!o.transB?ce="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!o.transA&&o.transB?ce="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!o.transA&&!o.transB&&(ce="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let ke=o.alpha===1?"":"value *= uniforms.alpha;",Le=dt("a",s[0].dataType,s[0].dims),M=dt("b",s[1].dataType,s[1].dims),C=Le.type.value,z=null,oe=[Le,M];s.length===3&&(z=dt("c",s[2].dataType,s[2].dims.length),oe.push(z));let ve=$t("output",s[0].dataType,P.length);oe.push(ve);let Pe=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${ue.registerUniforms(Pe).declareVariables(...oe)}

  ${ue.mainStart()}
    ${ue.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${C}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${ce}
    }

    ${ke}
    ${z!=null?`let cOffset = ${z.broadcastedIndicesToOffset("vec2(m, n)",ve)}; value += ${C}(uniforms.beta) * ${z.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},Te=ue=>{let ce=dt("a",s[0].dataType,s[0].dims),ke=dt("b",s[1].dataType,s[1].dims),Le=null,M=[ce,ke];s.length===3&&(Le=dt("c",s[2].dataType,s[2].dims.length),M.push(Le));let C=$t("output",s[0].dataType,P.length);M.push(C);let z=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],oe="",ve="";o.transA&&o.transB?(ve=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${ce.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${ke.type.value}(0);
      }
      `,oe="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):o.transA&&!o.transB?(ve=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${ce.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${ke.type.value}(0);
      }
      `,oe="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!o.transA&&o.transB?(ve=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${ce.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${ke.type.value}(0);
      }
      `,oe="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!o.transA&&!o.transB&&(ve=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${ce.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${ke.type.value}(0);
      }
      `,oe="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let Pe=o.alpha===1?"":"value *= uniforms.alpha;";return`
  ${ue.registerUniforms(z).declareVariables(...M)}
  var<workgroup> tile_a: array<array<${ce.type.storage}, ${k}>, ${k}>;
  var<workgroup> tile_b: array<array<${ke.type.storage}, ${k}>, ${k}>;
  ${ue.mainStart([k,k,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${k};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${k};
    let num_tiles = (uniforms.K - 1) / ${k} + 1;
    var k_start = 0u;
    var value = ${C.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${ve}
      k_start = k_start + ${k};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${k}; k++) {
        ${oe}
      }
      workgroupBarrier();
    }

    ${Pe}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${Le!=null?`let cOffset = ${Le.broadcastedIndicesToOffset("vec2(m, n)",C)}; value += ${C.type.value}(uniforms.beta) * ${Le.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return V?{name:"GemmShared",shaderCache:{hint:`${o.cacheKey}`,inputDependencies:X},getRunData:()=>({outputs:[{dims:P,dataType:s[0].dataType}],dispatchGroup:{x:O*$},programUniforms:ee}),getShaderSource:Te}:{name:"Gemm",shaderCache:{hint:`${o.cacheKey}`,inputDependencies:X},getRunData:()=>({outputs:[{dims:P,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(G/64)},programUniforms:ee}),getShaderSource:re}},wp=s=>{let o=s.transA,d=s.transB,g=s.alpha,y=s.beta;return{transA:o,transB:d,alpha:g,beta:y,cacheKey:`${s.transA};${s.transB};${s.alpha===1}`}},xp=(s,o)=>{Vc(s.inputs),s.compute(vp(s.inputs,o))}}),hs,As,fr,pr,jc,bp,Mp,Tp,Ep,Sp,Pp,Ap,Cp,sa,gy=l(()=>{Wt(),ie(),mn(),sn(),[hs,As,fr,pr]=[0,1,2,3],jc=s=>{if(s[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(s[0].dims.length!==s[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(s[0].dims.length-2!==s[1].dims[s[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${s[0].dims.length-2}`);if(s[0].dims[0]!==s[1].dims[0])throw new Error("grid batch size must match input batch size")},bp=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,Mp=s=>`
  fn gs_bicubic_interpolate(p: mat4x4<${s}>, x: f32, y: f32) -> ${s} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${s}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,Tp=s=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${s.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,Ep=s=>`
  ${s.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,Sp=(s,o,d)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${o} {
     var pixel = ${o}(0);
     var indices = vec4<u32>(0);
     indices[${hs}] = batch;
     indices[${As}] = channel;`+(()=>{switch(d.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${fr}] = u32(r);
            indices[${pr}] = u32(c);
          } else {
            return ${o}(0);
          }
        `;case"border":return`
          indices[${fr}] = u32(clamp(r, 0, H - 1));
          indices[${pr}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${fr}] = gs_reflect(r, border[1], border[3]);
          indices[${pr}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${d.paddingMode} is not supported`)}})()+`
    return ${s.getByIndices("indices")};
  }
`,Pp=(s,o,d)=>(()=>{switch(d.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${hs}], indices[${As}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${hs}], indices[${As}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${hs}], indices[${As}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${hs}], indices[${As}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${hs}], indices[${As}], border);

          let dx2 = ${o}(f32(x2) - x);
          let dx1 = ${o}(x - f32(x1));
          let dy2 = ${o}(f32(y2) - y);
          let dy1 = ${o}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${o}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${hs}], indices[${As}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${d.mode} is not supported`)}})()+`${s.setByOffset("global_idx","result")}`,Ap=(s,o)=>{let d=dt("x",s[0].dataType,s[0].dims.length),g=[s[1].dims[0],s[1].dims[1],s[1].dims[2]],y=dt("grid",s[1].dataType,g.length,2),x=[s[0].dims[0],s[0].dims[1],s[1].dims[1],s[1].dims[2]];o.format==="NHWC"&&(x=[s[0].dims[0],s[1].dims[1],s[1].dims[2],s[0].dims[3]],[hs,As,fr,pr]=[0,3,1,2]);let b=$t("output",s[0].dataType,x.length),P=d.type.value,k=it.size(x),O=[{type:12,data:k},...Gt(s[0].dims,g,x)],$=V=>`
  ${V.registerUniform("output_size","u32").declareVariables(d,y,b)}
  ${bp}
  ${Mp(P)}
  ${Tp(o)}
  ${Ep(o)}
  ${Sp(d,P,o)}

  ${V.mainStart()}
    ${V.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${fr}]);
      let W_in = i32(uniforms.x_shape[${pr}]);

      ${o.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${b.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${hs}], indices[${fr}], indices[${pr}]);
      let nxy = ${y.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${Pp(b,P,o)}
  }`;return{name:"GridSample",shaderCache:{hint:`${o.cacheKey}`,inputDependencies:["type","type"]},getRunData:V=>{let G=it.size(x);return{outputs:[{dims:x,dataType:V[0].dataType}],dispatchGroup:{x:Math.ceil(G/64)},programUniforms:O}},getShaderSource:$}},Cp=(s,o)=>{jc(s.inputs),s.compute(Ap(s.inputs,o))},sa=s=>Jt({alignCorners:s.align_corners,mode:s.mode,paddingMode:s.padding_mode,format:s.format})}),yi,Wc,Ip,Hc,qc,uo,Lp,js=l(()=>{Wt(),ie(),mn(),ti(),Wl(),sn(),ar(),yi=(s,o)=>s.length>o&&s[o].dims.length>0?s[o]:void 0,Wc=(s,o)=>{let d=s[0],g=yi(s,1),y=yi(s,2),x=yi(s,3),b=yi(s,4),P=yi(s,5),k=yi(s,6),O=yi(s,7);if(d.dims.length!==3&&d.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let $=d.dims[0],V=d.dims[1],G=d.dims.length===3?d.dims[2]:o.numHeads*d.dims[4],ee=V,X=0,re=0,Te=Math.floor(G/o.numHeads);if(k&&O&&it.size(k.dims)&&it.size(O.dims)){if(k.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(k.dims[0]!==$||k.dims[1]!==o.numHeads||k.dims[3]!==Te)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(O.dims[0]!==$||O.dims[1]!==o.numHeads||O.dims[3]!==Te)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(k.dims[2]!==O.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(O.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');X=k.dims[2],re=k.dims[2]}else if(k&&it.size(k.dims)||O&&it.size(O.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let ue;if(g&&it.size(g.dims)>0){if(d.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(g.dims.length<3||g.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(d.dims[0]!==g.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(g.dims.length===3){if(g.dims[2]!==d.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');ue=2,ee=g.dims[1]}else if(g.dims.length===5){if(g.dims[2]!==o.numHeads||g.dims[3]!==2||g.dims[4]!==Te)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(y)throw new Error('Expect "value" be none when "key" has packed kv format.');ue=5,ee=g.dims[1]}else{if(g.dims[1]!==o.numHeads||g.dims[3]!==Te)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');ue=0,ee=g.dims[2]}}else{if(d.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(d.dims[2]!==o.numHeads||d.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');ue=3}if(x&&it.size(x.dims)>0){if(x.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(g&&g.dims.length===5&&g.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let ce=X+ee,ke=0;if(b&&it.size(b.dims)>0){ke=8;let z=b.dims;throw z.length===1?z[0]===$?ke=1:z[0]===3*$+2&&(ke=3):z.length===2&&z[0]===$&&z[1]===ce&&(ke=5),ke===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let Le=!1,M=G;if(y&&it.size(y.dims)>0){if(y.dims.length!==3&&y.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(d.dims[0]!==y.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(y.dims.length===3){if(ee!==y.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');M=y.dims[2]}else{if(ee!==y.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');M=y.dims[1]*y.dims[3],Le=!0}}let C=!1;if(b&&it.size(b.dims)>0)throw new Error("Key padding mask is not supported");if(P&&it.size(P.dims)>0){if(P.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(P.dims[0]!==$||P.dims[1]!==o.numHeads||P.dims[2]!==V||P.dims[3]!==ce)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:$,sequenceLength:V,pastSequenceLength:X,kvSequenceLength:ee,totalSequenceLength:ce,maxSequenceLength:re,inputHiddenSize:0,hiddenSize:G,vHiddenSize:M,headSize:Te,vHeadSize:Math.floor(M/o.numHeads),numHeads:o.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:o.maskFilterValue,maskType:ke,scale:o.scale,broadcastResPosBias:C,passPastInKv:Le,qkvFormat:ue}},Ip=s=>Jt({...s}),Hc=Jt({perm:[0,2,1,3]}),qc=(s,o,d,g,y,x,b)=>{let P=[g,y,x],k=it.size(P),O=[{type:12,data:k},{type:12,data:b},{type:12,data:x}],$=V=>{let G=$t("qkv_with_bias",o.dataType,P),ee=dt("qkv",o.dataType,P),X=dt("bias",d.dataType,P),re=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${V.registerUniforms(re).declareVariables(ee,X,G)}
  ${V.mainStart()}
    ${V.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return s.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:P,dataType:o.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(k/64)},programUniforms:O}),getShaderSource:$},{inputs:[o,d],outputs:[-1]})[0]},uo=(s,o,d,g,y,x,b,P)=>{let k=x;if(b&&it.size(b.dims)>0){if(g===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return k=qc(s,x,b,o,g,d*y,P),k=k.reshape([o,g,d,y]),d===1||g===1?k:s.compute(Ei(k,Hc.perm),{inputs:[k],outputs:[-1]})[0]}else return x.dims.length===3&&(k=x.reshape([o,g,d,y])),d===1||g===1?k:s.compute(Ei(k,Hc.perm),{inputs:[k],outputs:[-1]})[0]},Lp=(s,o)=>{let d=Wc(s.inputs,o),g=s.inputs[0],y=yi(s.inputs,1),x=yi(s.inputs,2),b=yi(s.inputs,3),P=yi(s.inputs,4),k=yi(s.inputs,5),O=yi(s.inputs,6),$=yi(s.inputs,7);if(g.dims.length===5)throw new Error("Packed QKV is not implemented");if((y==null?void 0:y.dims.length)===5)throw new Error("Packed KV is not implemented");let V=y&&x&&y.dims.length===4&&x.dims.length===4,G=uo(s,d.batchSize,d.numHeads,d.sequenceLength,d.headSize,g,b,0);if(V)return kr(s,G,y,x,P,void 0,O,$,k,d);if(!y||!x)throw new Error("key and value must be provided");let ee=uo(s,d.batchSize,d.numHeads,d.kvSequenceLength,d.headSize,y,b,d.hiddenSize),X=uo(s,d.batchSize,d.numHeads,d.kvSequenceLength,d.vHeadSize,x,b,2*d.hiddenSize);kr(s,G,ee,X,P,void 0,O,$,k,d)}}),Dp,kp,Op,Fp,Kc,Rp,Xc,Bp=l(()=>{Wt(),ie(),mn(),sn(),Dp=s=>{if(!s||s.length<1)throw new Error("too few inputs")},kp=(s,o)=>{let d=[],g=o.numOutputs;return s[1].dims[0]>0&&(s[1].getBigInt64Array().forEach(y=>d.push(Number(y))),g=d.length),Jt({numOutputs:g,axis:o.axis,splitSizes:d})},Op=s=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${s}u; i += 1u ) {
    if (index < ${Nt("uniforms.size_in_split_axis","i",s)}) {
        return i;
    }
    }
    return ${s}u;
}`,Fp=s=>{let o=s.length,d=[];for(let g=0;g<o;++g){let y=s[g].setByIndices("indices","input[global_idx]");o===1?d.push(y):g===0?d.push(`if (output_number == ${g}u) { ${y} }`):g===o-1?d.push(`else { ${y} }`):d.push(`else if (output_number == ${g}) { ${y} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${s[0].type.indices}, global_idx: u32) {
        ${d.join(`
`)}
      }`},Kc=(s,o)=>{let d=s[0].dims,g=it.size(d),y=s[0].dataType,x=it.normalizeAxis(o.axis,d.length),b=new Array(o.numOutputs),P=dt("input",y,d.length),k=new Array(o.numOutputs),O=[],$=[],V=0,G=[{type:12,data:g}];for(let X=0;X<o.numOutputs;X++){V+=o.splitSizes[X],k[X]=V;let re=d.slice();re[x]=o.splitSizes[X],$.push(re),b[X]=$t(`output${X}`,y,re.length),O.push({dims:$[X],dataType:s[0].dataType})}G.push({type:12,data:k},...Gt(d,...$));let ee=X=>`
  ${X.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",k.length).declareVariables(P,...b)}
  ${Op(k.length)}
  ${Fp(b)}

  ${X.mainStart()}
    ${X.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${P.offsetToIndices("global_idx")};
    var index = ${P.indicesGet("indices",x)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${Nt("uniforms.size_in_split_axis","output_number - 1u",k.length)};
      ${P.indicesSet("indices",x,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:o.cacheKey,inputDependencies:["rank"]},getShaderSource:ee,getRunData:()=>({outputs:O,dispatchGroup:{x:Math.ceil(g/64)},programUniforms:G})}},Rp=(s,o)=>{Dp(s.inputs);let d=s.inputs.length===1?o:kp(s.inputs,o);s.compute(Kc(s.inputs,d),{inputs:[0]})},Xc=s=>{let o=s.axis,d=s.splitSizes,g=s.numOutputs<0?d.length:s.numOutputs;if(g!==d.length)throw new Error("numOutputs and splitSizes lengh must be equal");return Jt({axis:o,numOutputs:g,splitSizes:d})}}),zp,ra,$p,oa=l(()=>{Wt(),ie(),mn(),sn(),zp=(s,o)=>{let[d,g,y,x]=s,{numHeads:b,rotaryEmbeddingDim:P}=o;if(d.dims.length!==3&&d.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${d.dims.length}`);if(!it.areEqual(g.dims,[])&&!it.areEqual(g.dims,[1])&&g.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${g.dims.length}`);if(y.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${y.dims.length}`);if(x.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${x.dims.length}`);if(!it.areEqual(y.dims,x.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(P>0&&b===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let k=d.dims[0],O=d.dims[d.dims.length-2],$=y.dims[0],V=it.sizeFromDimension(d.dims,1)/O,G=P===0?y.dims[1]*2:V/b;if(P>G)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(g.dims.length===2){if(k!==g.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${g.dims[0]}`);if(O!==g.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${g.dims[1]}`)}if(G/2!==y.dims[1]&&P/2!==y.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${y.dims[1]}`);if(O>$)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},ra=(s,o)=>{let{interleaved:d,numHeads:g,rotaryEmbeddingDim:y,scale:x}=o,b=s[0].dims[0],P=it.sizeFromDimension(s[0].dims,1),k=s[0].dims[s[0].dims.length-2],O=P/k,$=s[2].dims[1],V=y===0?$*2:O/g,G=new Array(b,k,O/V,V-$),ee=it.computeStrides(G),X=[{type:1,data:x},{type:12,data:G},{type:12,data:ee},...s[0].dims.length===3?new Array({type:12,data:[P,O,V,1]}):[],...s[0].dims.length===4?new Array({type:12,data:[P,V,k*V,1]}):[],...Gt(s[0].dims,s[1].dims,s[2].dims,s[3].dims,s[0].dims)],re=Te=>{let ue=dt("input",s[0].dataType,s[0].dims.length),ce=dt("position_ids",s[1].dataType,s[1].dims.length),ke=dt("cos_cache",s[2].dataType,s[2].dims.length),Le=dt("sin_cache",s[3].dataType,s[3].dims.length),M=$t("output",s[0].dataType,s[0].dims.length);return Te.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:G.length},{name:"global_strides",type:"u32",length:ee.length},{name:"input_output_strides",type:"u32",length:ee.length}]),`
        ${Te.declareVariables(ue,ce,ke,Le,M)}

        ${Te.mainStart(cs)}
          let half_rotary_emb_dim = uniforms.${ke.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${Te.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${ce.broadcastedIndicesToOffset("bsnh.xy",$t("",ce.type.tensor,2))};
            let position_id =
                u32(${ce.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${d});
            let j = i + select(half_rotary_emb_dim, 1, ${d});
            let re = ${ue.getByOffset("i")} * ${ke.get("position_id","bsnh[3]")} -
                ${ue.getByOffset("j")} * ${Le.get("position_id","bsnh[3]")};
            ${M.setByOffset("i","re")}
            let im = ${ue.getByOffset("i")} * ${Le.get("position_id","bsnh[3]")} +
                ${ue.getByOffset("j")} * ${ke.get("position_id","bsnh[3]")};
            ${M.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${M.setByOffset("k",ue.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:Jt({interleaved:d}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:re,getRunData:()=>({outputs:[{dims:s[0].dims,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(it.size(G)/cs)},programUniforms:X})}},$p=(s,o)=>{zp(s.inputs,o),s.compute(ra(s.inputs,o))}}),Np,Up,Yc,ho,Gp,_y=l(()=>{mn(),Wt(),Wl(),js(),Bp(),ar(),oa(),sn(),Np=(s,o)=>{if(o.doRotary&&s.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let d=s[0],g=s[1],y=s[2],x=s[3],b=s[4];if(o.doRotary!==0&&s.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(o.localWindowSize!==-1)throw new Error("Local attention is not supported");if(o.softcap!==0)throw new Error("Softcap is not supported");if(o.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(o.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(d.dims.length!==3&&d.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let P=!1,k=d.dims[0],O=d.dims[1],$=d.dims.length===3?P?d.dims[2]/3:d.dims[2]:o.numHeads*d.dims[4],V=O,G=0,ee=!g||g.dims.length===0,X=Math.floor(ee?$/(o.numHeads+2*o.kvNumHeads):$/o.numHeads);ee&&($=X*o.numHeads);let re=x&&x.dims.length!==0,Te=b&&b.dims.length!==0;if(re&&x.dims.length===4&&x.dims[0]===k&&x.dims[1]!==o.kvNumHeads&&x.dims[2]===o.kvNumHeads&&x.dims[3]===X)throw new Error("BSNH pastKey/pastValue is not supported");if(re&&Te){if(x.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(b.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');G=x.dims[2]}else if(re||Te)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let ue=1;if(g&&g.dims.length>0){if(d.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(g.dims.length<3||g.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(d.dims[0]!==g.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(g.dims.length===3){if(d.dims[2]%g.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');V=g.dims[1]}else if(g.dims.length===5){if(g.dims[2]!==o.numHeads||g.dims[3]!==2||g.dims[4]!==X)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(y)throw new Error('Expect "value" be none when "key" has packed kv format.');V=g.dims[1]}else{if(g.dims[1]!==o.numHeads||g.dims[3]!==X)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');V=g.dims[2]}}else{if(d.dims.length!==3&&d.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(d.dims.length===5&&(d.dims[2]!==o.numHeads||d.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');ue=3}let ce=0,ke=!1,Le=o.kvNumHeads?X*o.kvNumHeads:$;if(y&&y.dims.length>0){if(y.dims.length!==3&&y.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(d.dims[0]!==y.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(y.dims.length===3){if(V!==y.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');Le=y.dims[2]}else{if(V!==y.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');Le=y.dims[1]*y.dims[3],ke=!0}}let M=s.length>4?s[5]:void 0;if(M&&M.dims.length!==1&&M.dims[0]!==k)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:k,sequenceLength:O,pastSequenceLength:G,kvSequenceLength:V,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:$,vHiddenSize:Le,headSize:X,vHeadSize:Math.floor(Le/o.kvNumHeads),numHeads:o.numHeads,kvNumHeads:o.kvNumHeads,nReps:o.numHeads/o.kvNumHeads,pastPresentShareBuffer:!1,maskType:ce,scale:o.scale,broadcastResPosBias:!1,passPastInKv:ke,qkvFormat:ue}},Up=Jt({perm:[0,2,1,3]}),Yc=(s,o,d)=>{let g=o,y=d.kvNumHeads;return o.dims.length===3&&d.kvSequenceLength!==0&&(g=o.reshape([d.batchSize,d.kvSequenceLength,y,d.headSize]),g=s.compute(Ei(g,Up.perm),{inputs:[g],outputs:[-1]})[0]),g},ho=(s,o,d,g)=>{let y=7,x=["type","type"],b=[s*o],P=s*o,k=[{type:12,data:P},{type:12,data:o},{type:12,data:s}],O=$=>{let V=dt("seq_lens",d.dataType,d.dims),G=dt("total_seq_lens",g.dataType,g.dims),ee=$t("pos_ids",y,b),X=[{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}];return`
  ${$.registerUniforms(X).declareVariables(V,G,ee)}
  ${$.mainStart()}
    ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${G.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${V.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${ee.setByOffset("global_idx","pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${ee.setByOffset("global_idx","pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${ee.setByOffset("global_idx","seqlen")}
    };
  }
  `};return{name:"GeneratePositionIds",shaderCache:{hint:`${s};${o}`,inputDependencies:x},getRunData:()=>({outputs:[{dims:b,dataType:y}],dispatchGroup:{x:Math.ceil(P/64)},programUniforms:k}),getShaderSource:O}},Gp=(s,o)=>{var Le;let d=Np(s.inputs,o);if(s.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((Le=s.inputs[1])==null?void 0:Le.dims.length)===5)throw new Error("Packed KV is not implemented");let g=s.inputs[0],y=s.inputs[1]&&s.inputs[1].dims.length>0?s.inputs[1]:void 0,x=s.inputs[2]&&s.inputs[2].dims.length>0?s.inputs[2]:void 0,b=s.inputs[3]&&s.inputs[3].dims.length!==0?s.inputs[3]:void 0,P=s.inputs[4]&&s.inputs[4].dims.length!==0?s.inputs[4]:void 0,k=s.inputs.length>4?s.inputs[5]:void 0,O=s.inputs.length>5?s.inputs[6]:void 0,$=d.kvNumHeads?d.kvNumHeads:d.numHeads,V=Jt({axis:2,numOutputs:3,splitSizes:[d.numHeads*d.headSize,$*d.headSize,$*d.headSize]}),[G,ee,X]=!y&&!x?s.compute(Kc([g],V),{inputs:[g],outputs:[-1,-1,-1]}):[g,y,x],re,Te;if(o.doRotary){let M=s.compute(ho(d.batchSize,d.sequenceLength,k,O),{inputs:[k,O],outputs:[-1]})[0],C=s.inputs[7],z=s.inputs[8],oe=Jt({interleaved:o.rotaryInterleaved!==0,numHeads:d.numHeads,rotaryEmbeddingDim:0,scale:o.scale}),ve=[G,M,C,z],Pe=[-1];re=s.compute(ra(ve,oe),{inputs:ve,outputs:Pe})[0],ve.splice(0,1,ee);let Ue=Jt({interleaved:o.rotaryInterleaved!==0,numHeads:d.kvNumHeads,rotaryEmbeddingDim:0,scale:o.scale});Te=s.compute(ra(ve,Ue),{inputs:ve,outputs:Pe})[0]}let ue=uo(s,d.batchSize,d.numHeads,d.sequenceLength,d.headSize,o.doRotary?re:G,void 0,0),ce=Yc(s,o.doRotary?Te:ee,d),ke=Yc(s,X,d);kr(s,ue,ce,ke,void 0,void 0,b,P,void 0,d,k,O)}}),Jc,Vp,aa,jp,yy=l(()=>{Wt(),ie(),ar(),sn(),Jc=(s,o,d,g,y,x,b,P)=>{let k=kn(x),O=k===1?"f32":`vec${k}f`,$=k===1?"vec2f":`mat2x${k}f`,V=y*b,G=64;V===1&&(G=256);let ee=[y,b,x/k],X=[y,b,2],re=["rank","type","type"],Te=[];Te.push(...Gt(ee,X));let ue=ce=>{let ke=dt("x",o.dataType,3,k),Le=dt("scale",d.dataType,d.dims),M=dt("bias",g.dataType,g.dims),C=$t("output",1,3,2),z=[ke,Le,M,C];return`
  var<workgroup> workgroup_shared : array<${$}, ${G}>;
  const workgroup_size = ${G}u;
  ${ce.declareVariables(...z)}
  ${ce.mainStart(G)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${O}(0);
    var squared_sum = ${O}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${O}(${ke.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${$}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${Gs("workgroup_shared[0][0]",k)} / f32(hight * ${k});
      let squared_sum_final = ${Gs("workgroup_shared[0][1]",k)} / f32(hight * ${k});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${P}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return s.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${k};${P};${G}`,inputDependencies:re},getRunData:()=>({outputs:[{dims:X,dataType:1}],dispatchGroup:{x:V},programUniforms:Te}),getShaderSource:ue},{inputs:[o,d,g],outputs:[-1]})[0]},Vp=(s,o,d)=>{let g=o[0].dims,y=g,x=2,b=g[0],P=g[1],k=it.sizeFromDimension(g,x),O=kn(k),$=it.size(y)/O,V=Jc(s,o[0],o[1],o[2],b,k,P,d.epsilon),G=[b,P,k/O],ee=[b,P],X=["type","none"],re=Te=>{let ue=dt("x",o[0].dataType,G.length,O),ce=dt("scale_shift",1,ee.length,2),ke=$t("output",o[0].dataType,G.length,O),Le=[ue,ce,ke];return`
  ${Te.registerUniform("output_size","u32").declareVariables(...Le)}
  ${Te.mainStart()}
  ${Te.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${ke.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${ce.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${ue.getByOffset("global_idx")} * ${ke.type.value}(scale_shift.x) + ${ke.type.value}(scale_shift.y);
      ${ke.setByOffset("global_idx","value")};
  }`};s.compute({name:"InstanceNormalization",shaderCache:{hint:`${O}`,inputDependencies:X},getRunData:()=>({outputs:[{dims:y,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:[{type:12,data:$},...Gt(G,ee,G)]}),getShaderSource:re},{inputs:[o[0],V]})},aa=(s,o,d)=>{let g=o[0].dims,y=g,x=g[0],b=g[g.length-1],P=it.sizeFromDimension(g,1)/b,k=kn(b),O=it.size(y)/k,$=[{type:12,data:P},{type:12,data:Math.floor(b/k)}],V=["type","type"],G=!1,ee=[0,g.length-1];for(let ue=0;ue<g.length-2;ue++)G=G||g[ue+1]!==1,ee.push(ue+1);G=G&&g[g.length-1]!==1;let X=G?s.compute(Ei(s.inputs[0],ee),{inputs:[s.inputs[0]],outputs:[-1]})[0]:s.inputs[0].reshape(Array.from({length:g.length},(ue,ce)=>g[ee[ce]])),re=Jc(s,X,o[1],o[2],x,P,b,d.epsilon),Te=ue=>{let ce=Zn(o[0].dataType),ke=k===1?"vec2f":`mat${k}x2f`,Le=z=>{let oe=z===0?"x":"y",ve=k===1?"f32":`vec${k}f`;switch(k){case 1:return`${ce}(${ve}(scale.${oe}))`;case 2:return`vec2<${ce}>(${ve}(scale[0].${oe}, scale[1].${oe}))`;case 4:return`vec4<${ce}>(${ve}(scale[0].${oe}, scale[1].${oe}, scale[2].${oe}, scale[3].${oe}))`;default:throw new Error(`Not supported compoents ${k}`)}},M=dt("input",o[0].dataType,o[0].dims,k),C=$t("output",o[0].dataType,y,k);return`
  @group(0) @binding(0) var<storage, read> input : array<${M.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${ke}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${C.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${ue.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${Le(0)}, ${Le(1)});
  }`};s.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${k}`,inputDependencies:V},getRunData:()=>({outputs:[{dims:y,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(O/64)},programUniforms:$}),getShaderSource:Te},{inputs:[o[0],re]})},jp=(s,o)=>{o.format==="NHWC"?aa(s,s.inputs,o):Vp(s,s.inputs,o)}}),Wp,vy,Hp,wy=l(()=>{Wt(),ie(),sn(),Wp=s=>{if(!s||s.length<2)throw new Error("layerNorm requires at least 2 inputs.")},vy=(s,o,d)=>{let g=o.simplified,y=s[0].dims,x=s[1],b=!g&&s[2],P=y,k=it.normalizeAxis(o.axis,y.length),O=it.sizeToDimension(y,k),$=it.sizeFromDimension(y,k),V=it.size(x.dims),G=b?it.size(b.dims):0;if(V!==$||b&&G!==$)throw new Error(`Size of X.shape()[axis:] == ${$}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${V} and bias size of ${G}`);let ee=[];for(let M=0;M<y.length;++M)M<k?ee.push(y[M]):ee.push(1);let X=kn($),re=["type","type"],Te=[{type:12,data:O},{type:1,data:$},{type:12,data:Math.floor($/X)},{type:1,data:o.epsilon}];b&&re.push("type");let ue=d>1,ce=d>2,ke=M=>{let C=Zn(s[0].dataType),z=[dt("x",s[0].dataType,s[0].dims,X),dt("scale",x.dataType,x.dims,X)];b&&z.push(dt("bias",b.dataType,b.dims,X)),z.push($t("output",s[0].dataType,P,X)),ue&&z.push($t("mean_data_output",1,ee)),ce&&z.push($t("inv_std_output",1,ee));let oe=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${M.registerUniforms(oe).declareVariables(...z)}
  ${M.mainStart()}
    ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${Sl("f32",X)};
    var mean_square_vector = ${Sl("f32",X)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${ds(C,X,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Gs("mean_vector",X)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Gs("mean_square_vector",X)} / uniforms.norm_size ${g?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${ds(C,X,"x[j + offset]")};
      let f32scale = ${ds(C,X,"scale[j]")};
      output[j + offset] = ${z[0].type.value}((f32input ${g?"":"- mean"}) * inv_std_dev * f32scale
        ${b?`+ ${ds(C,X,"bias[j]")}`:""}
      );
    }

    ${ue?"mean_data_output[global_idx] = mean":""};
    ${ce?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},Le=[{dims:P,dataType:s[0].dataType}];return ue&&Le.push({dims:ee,dataType:1}),ce&&Le.push({dims:ee,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${X};${d};${g}`,inputDependencies:re},getRunData:()=>({outputs:Le,dispatchGroup:{x:Math.ceil(O/64)},programUniforms:Te}),getShaderSource:ke}},Hp=(s,o)=>{Wp(s.inputs),s.compute(vy(s.inputs,o,s.outputCount))}}),qp,Br,xy=l(()=>{ie(),yc(),ea(),qp=s=>{if(!s||s.length!==2)throw new Error("MatMul requires 2 inputs.");if(s[0].dims[s[0].dims.length-1]!==s[1].dims[s[1].dims.length-2])throw new Error("shared dimension does not match.")},Br=s=>{qp(s.inputs);let o=Wi.calcShape(s.inputs[0].dims,s.inputs[1].dims,!0);if(!o)throw new Error("Can't use matmul on the given tensors");let d=o[o.length-1],g=s.inputs[0].dims[s.inputs[0].dims.length-1];if(d<8&&g<8)s.compute(Jo(s.inputs,{activation:""},o));else{let y=o[o.length-2],x=it.size(s.inputs[0].dims.slice(0,-2)),b=it.size(s.inputs[1].dims.slice(0,-2));if(x!==1&&y===1&&b===1){let P=s.inputs[0].reshape([1,x,g]),k=s.inputs[1].reshape([1,g,d]),O=[1,x,d],$=[P,k];s.compute(Zo($,{activation:""},o,O),{inputs:$})}else s.compute(Zo(s.inputs,{activation:""},o))}}}),Kp,Xp,Yp,Jp,Qp,by=l(()=>{Wt(),ie(),mn(),sn(),Kp=(s,o)=>{if(s.length<3||s.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let d=s[0],g=d.dims.length;if(d.dims[g-1]!==o.k)throw new Error("The last dim of input shape does not match the k value");let y=Math.floor((o.k+o.blockSize-1)/o.blockSize),x=o.blockSize/8*o.bits,b=s[1];if(!it.areEqual(b.dims,[o.n,y,x]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let P=s[2].dims;if(it.size(P)!==o.n*y)throw new Error("scales input size error.");if(s.length===4){let k=s[3].dims,O=o.bits>4?o.n*y:o.n*Math.floor((y+1)/2);if(it.size(k)!==O)throw new Error("zeroPoints input size error.")}},Xp=(s,o)=>{let d=s[0].dims,g=d.length,y=d[g-2],x=o.k,b=o.n,P=d.slice(0,g-2),k=it.size(P),O=s[1].dims[2]/4,$=s[0].dataType,V=kn(o.k),G=kn(O),ee=kn(b),X=P.concat([y,b]),re=y>1&&b/ee%2===0?2:1,Te=it.size(X)/ee/re,ue=64,ce=[],ke=[k,y,x/V],Le=it.convertShape(s[1].dims).slice();Le.splice(-1,1,O/G),ce.push(...Gt(ke)),ce.push(...Gt(Le)),ce.push(...Gt(s[2].dims)),s.length===4&&ce.push(...Gt(it.convertShape(s[3].dims)));let M=[k,y,b/ee];ce.push(...Gt(M));let C=z=>{let oe=ke.length,ve=dt("a",s[0].dataType,oe,V),Pe=dt("b",12,Le.length,G),Ue=dt("scales",s[2].dataType,s[2].dims.length),Je=[ve,Pe,Ue],st=s.length===4?dt("zero_points",12,s[3].dims.length):void 0;st&&Je.push(st);let gt=M.length,wt=$t("output",s[0].dataType,gt,ee),yt=Zn(s[0].dataType),ht=(()=>{switch(V){case 1:return`array<${yt}, 8>`;case 2:return`mat4x2<${yt}>`;case 4:return`mat2x4<${yt}>`;default:throw new Error(`${V}-component is not supported.`)}})(),Ft=()=>{let Ze=`
          // reuse a data
            var input_offset = ${ve.indicesToOffset(`${ve.type.indices}(batch, row, word_offset)`)};
            var a_data: ${ht};
            for (var j: u32 = 0; j < ${8/V}; j++) {
              a_data[j] = ${ve.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let ft=0;ft<ee*re;ft++)Ze+=`
            b_value = ${G===1?`b${ft}_data`:`b${ft}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${ht}(${Array.from({length:4},(St,Ht)=>`${yt}(b_value_lower[${Ht}]), ${yt}(b_value_upper[${Ht}])`).join(", ")});
            b_dequantized_values = ${V===1?`${ht}(${Array.from({length:8},(St,Ht)=>`(b_quantized_values[${Ht}] - ${st?`zero_point${ft}`:"zero_point"}) * scale${ft}`).join(", ")});`:`(b_quantized_values - ${ht}(${Array(8).fill(`${st?`zero_point${ft}`:"zero_point"}`).join(",")})) * scale${ft};`};
            workgroup_shared[local_id.x * ${re} + ${Math.floor(ft/ee)}]${ee>1?`[${ft%ee}]`:""} += ${Array.from({length:8/V},(St,Ht)=>`${V===1?`a_data[${Ht}] * b_dequantized_values[${Ht}]`:`dot(a_data[${Ht}], b_dequantized_values[${Ht}])`}`).join(" + ")};
          `;return Ze},xt=()=>{let Ze=`
            var col_index = col * ${ee};
            ${st?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${yt}(8);`}
            `;for(let ft=0;ft<ee*re;ft++)Ze+=`
            let scale${ft} = ${Ue.getByOffset("col_index * nBlocksPerCol + block")};
            ${st?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${st.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${ft} = ${yt}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return Ze},Ct=()=>{let Ze=`col_index = col * ${ee};`;for(let ft=0;ft<ee*re;ft++)Ze+=`
            let b${ft}_data = ${Pe.getByIndices(`${Pe.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return Ze+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${ht};
            var b_dequantized_values: ${ht};`,Ze};return`
        var<workgroup> workgroup_shared: array<${wt.type.value}, ${re*ue}>;
        ${z.declareVariables(...Je,wt)}
        ${z.mainStart([ue,1,1])}
          let output_indices = ${wt.offsetToIndices(`(global_idx / ${ue}) * ${re}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${ue}) {
            //process one block
            var word_offset: u32 = block * ${o.blockSize/V};
            ${xt()}
            for (var word: u32 = 0; word < ${O}; word += ${G}) {
              ${Ct()}
              for (var i: u32 = 0; i < ${G}; i++) {
                ${Ft()}
                word_offset += ${8/V};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${re}) {
            var output_value: ${wt.type.value} = ${wt.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${ue}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${re};
            }
            ${wt.setByIndices(`${wt.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${o.blockSize};${o.bits};${V};${G};${ee};${re};${ue}`,inputDependencies:Array(s.length).fill("rank")},getRunData:()=>({outputs:[{dims:X,dataType:$}],dispatchGroup:{x:Te},programUniforms:ce}),getShaderSource:C}},Yp=(s,o)=>{let d=s[0].dims,g=d.length,y=d[g-2],x=o.k,b=o.n,P=d.slice(0,g-2),k=it.size(P),O=s[1].dims[2]/4,$=s[0].dataType,V=kn(o.k),G=kn(O),ee=P.concat([y,b]),X=128,re=b%8===0?8:b%4===0?4:1,Te=X/re,ue=Te*G*8,ce=ue/V,ke=ue/o.blockSize,Le=it.size(ee)/re,M=[],C=[k,y,x/V],z=it.convertShape(s[1].dims).slice();z.splice(-1,1,O/G),M.push(...Gt(C)),M.push(...Gt(z)),M.push(...Gt(s[2].dims)),s.length===4&&M.push(...Gt(it.convertShape(s[3].dims)));let oe=[k,y,b];M.push(...Gt(oe));let ve=Pe=>{let Ue=C.length,Je=dt("a",s[0].dataType,Ue,V),st=dt("b",12,z.length,G),gt=dt("scales",s[2].dataType,s[2].dims.length),wt=[Je,st,gt],yt=s.length===4?dt("zero_points",12,s[3].dims.length):void 0;yt&&wt.push(yt);let ht=oe.length,Ft=$t("output",s[0].dataType,ht),xt=Zn(s[0].dataType),Ct=()=>{switch(V){case 1:return`
          let a_data0 = vec4<${xt}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${xt}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${xt}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${xt}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${V}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${Je.type.value}, ${ce}>;
        var<workgroup> inter_results: array<array<${Ft.type.value}, ${Te}>, ${re}>;
        ${Pe.declareVariables(...wt,Ft)}
        ${Pe.mainStart([Te,re,1])}
          let output_indices = ${Ft.offsetToIndices(`workgroup_index * ${re}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${ke} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${ce};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${ce}; a_offset += ${X})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${Je.getByIndices(`${Je.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${Je.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${ke} + local_id.x;
            ${yt?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${yt.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${xt}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${xt}(8);`}
            let scale = ${gt.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${st.getByIndices(`${st.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${o.blockSize/V};
            for (var i: u32 = 0; i < ${G}; i++) {
              ${Ct()}
              let b_value = ${G===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${xt}>(${Array.from({length:4},(Ze,ft)=>`${xt}(b_value_lower[${ft}]), ${xt}(b_value_upper[${ft}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${xt}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(Ze,ft)=>`${`dot(a_data${ft}, b_dequantized_values[${ft}])`}`).join(" + ")};
              word_offset += ${8/V};
            }
            workgroupBarrier();
          }

          if (local_idx < ${re}) {
            var output_value: ${Ft.type.value} = ${Ft.type.value}(0);
            for (var b = 0u; b < ${Te}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${Ft.setByIndices(`${Ft.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${o.blockSize};${V};${G};${Te};${re}`,inputDependencies:Array(s.length).fill("rank")},getRunData:()=>({outputs:[{dims:ee,dataType:$}],dispatchGroup:{x:Le},programUniforms:M}),getShaderSource:ve}},Jp=(s,o)=>{Kp(s.inputs,o),o.blockSize===32&&s.adapterInfo.isVendor("intel")&&s.adapterInfo.isArchitecture("gen-12lp")?s.compute(Yp(s.inputs,o)):s.compute(Xp(s.inputs,o))},Qp=s=>Jt(s)}),la,My,Zp,em,tm,nm,Qc,im,sm,rm=l(()=>{Wt(),ie(),sn(),la=s=>{if(!s||s.length<1)throw new Error("Too few inputs");if(s[0].dataType!==1&&s[0].dataType!==10)throw new Error("Input type must be float or float16.");if(s.length>=2){let o=s[0].dims.length*2===s[1].dims[0];if(s.length===4&&(o=s[3].dims[0]*2===s[1].dims[0]),!o)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},My=(s,o,d)=>{let g="";for(let y=o-1;y>=0;--y)g+=`
            k = i32(${s.indicesGet("indices",y)}) - ${Nt("uniforms.pads",y,d)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${Nt("uniforms.x_shape",y,o)})) {
              break;
            }
            offset += k * i32(${Nt("uniforms.x_strides",y,o)});
        `;return`
          value = ${s.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${g}
            value = x[offset];
          }
      `},Zp=(s,o,d)=>{let g="";for(let y=o-1;y>=0;--y)g+=`
                k = i32(${s.indicesGet("indices",y)}) - ${Nt("uniforms.pads",y,d)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${Nt("uniforms.x_shape",y,o)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${Nt("uniforms.x_shape",y,o)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${Nt("uniforms.x_strides",y,o)});
            `;return`
              var offset = 0;
              var k = 0;
              ${g}
              value = x[offset];
          `},em=(s,o,d)=>{let g="";for(let y=o-1;y>=0;--y)g+=`
                k = i32(${s.indicesGet("indices",y)}) - ${Nt("uniforms.pads",y,d)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${Nt("uniforms.x_shape",y,o)})) {
                  k = i32(${Nt("uniforms.x_shape",y,o)}) - 1;
                }
                offset += k * i32(${Nt("uniforms.x_strides",y,o)});
            `;return`
              var offset = 0;
              var k = 0;
              ${g}
              value = x[offset];
          `},tm=(s,o,d)=>{let g="";for(let y=o-1;y>=0;--y)g+=`
                k = i32(${s.indicesGet("indices",y)}) - ${Nt("uniforms.pads",y,d)};
                if (k < 0)  {
                  k += i32(${Nt("uniforms.x_shape",y,o)}]);
                }
                if (k >= i32(${Nt("uniforms.x_shape",y,o)})) {
                  k -= i32(${Nt("uniforms.x_shape",y,o)});
                }
                offset += k * i32(${Nt("uniforms.x_strides",y,o)});
            `;return`
              var offset = 0;
              var k = 0;
              ${g}
              value = x[offset];
          `},nm=(s,o,d)=>{switch(d.mode){case 0:return My(s,o,d.pads.length);case 1:return Zp(s,o,d.pads.length);case 2:return em(s,o,d.pads.length);case 3:return tm(s,o,d.pads.length);default:throw new Error("Invalid mode")}},Qc=(s,o)=>{let d=it.padShape(s[0].dims.slice(),o.pads),g=s[0].dims,y=it.size(d),x=[{type:12,data:y},{type:6,data:o.pads}],b=s.length>=3&&s[2].data;o.mode===0&&x.push({type:b?s[2].dataType:1,data:o.value}),x.push(...Gt(s[0].dims,d));let P=["rank"],k=O=>{let $=$t("output",s[0].dataType,d.length),V=dt("x",s[0].dataType,g.length),G=V.type.value,ee=nm($,g.length,o),X=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:o.pads.length}];return o.mode===0&&X.push({name:"constant_value",type:b?G:"f32"}),`
            ${O.registerUniforms(X).declareVariables(V,$)}
            ${O.mainStart()}
            ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${$.offsetToIndices("global_idx")};

            var value = ${G}(0);
            ${ee}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${o.mode}${b}`,inputDependencies:P},getRunData:()=>({outputs:[{dims:d,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(it.size(d)/64)},programUniforms:x}),getShaderSource:k}},im=(s,o)=>{if(s.length>1){let d=s[1].getBigInt64Array(),g=s.length>=3&&s[2].data?s[2].dataType===10?s[2].getUint16Array()[0]:s[2].getFloat32Array()[0]:0,y=s[0].dims.length,x=new Int32Array(2*y).fill(0);if(s.length>=4){let P=s[3].getBigInt64Array();for(let k=0;k<P.length;k++)x[Number(P[k])]=Number(d[k]),x[Number(P[k])+y]=Number(d[k+P.length])}else d.forEach((P,k)=>x[Number(k)]=Number(P));let b=[];return x.forEach(P=>b.push(P)),{mode:o.mode,value:g,pads:b}}else return o},sm=(s,o)=>{la(s.inputs);let d=im(s.inputs,o);s.compute(Qc(s.inputs,d),{inputs:[0]})}}),fo,Zc,ca,eu,tu,nu,om,iu,ua,am,lm,da,cm,um,ha,dm,hm,fa,fm,Ty=l(()=>{qe(),Wt(),ie(),sn(),fo=s=>{if(R.webgpu.validateInputContent&&(!s||s.length!==1))throw new Error("Pool ops requires 1 input.")},Zc=(s,o,d)=>{let g=o.format==="NHWC",y=s.dims.slice();g&&y.splice(1,0,y.pop());let x=Object.hasOwnProperty.call(o,"dilations"),b=o.kernelShape.slice(),P=o.strides.slice(),k=x?o.dilations.slice():[],O=o.pads.slice();Es.adjustPoolAttributes(d,y,b,P,k,O);let $=Es.computePoolOutputShape(d,y,P,k,b,O,o.autoPad),V=Object.assign({},o);x?Object.assign(V,{kernelShape:b,strides:P,pads:O,dilations:k,cacheKey:o.cacheKey}):Object.assign(V,{kernelShape:b,strides:P,pads:O,cacheKey:o.cacheKey});let G=$.slice();return G.push(G.splice(1,1)[0]),[V,g?G:$]},ca=(s,o)=>{let d=o.format==="NHWC",g=it.size(s),y=it.size(o.kernelShape),x=[{type:12,data:g},{type:12,data:y}],b=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(o.kernelShape.length<=2){let P=o.kernelShape[o.kernelShape.length-1],k=o.strides[o.strides.length-1],O=o.pads[o.pads.length/2-1],$=o.pads[o.pads.length-1],V=!!(O+$);x.push({type:12,data:P},{type:12,data:k},{type:12,data:O},{type:12,data:$}),b.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let G=!1;if(o.kernelShape.length===2){let ee=o.kernelShape[o.kernelShape.length-2],X=o.strides[o.strides.length-2],re=o.pads[o.pads.length/2-2],Te=o.pads[o.pads.length-2];G=!!(re+Te),x.push({type:12,data:ee},{type:12,data:X},{type:12,data:re},{type:12,data:Te}),b.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[x,b,!0,V,G]}else{if(d)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let P=it.computeStrides(o.kernelShape);x.push({type:12,data:P},{type:12,data:o.pads},{type:12,data:o.strides}),b.push({name:"kernelStrides",type:"u32",length:P.length},{name:"pads",type:"u32",length:o.pads.length},{name:"strides",type:"u32",length:o.strides.length});let k=o.pads.reduce((O,$)=>O+$);return[x,b,!!k,!1,!1]}},eu=(s,o,d,g,y,x,b,P,k,O,$,V)=>{let G=y.format==="NHWC",ee=o.type.value,X=$t("output",o.type.tensor,g);if(y.kernelShape.length<=2){let re="",Te="",ue="",ce=d-(G?2:1);if($?re=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${ce}] = indices[${ce}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${ce}] < 0 || xIndices[${ce}]
                      >= uniforms.x_shape[${ce}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${o.indicesToOffset("xIndices")}];
                  ${x}
                }`:re=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${ce}] = indices[${ce}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${o.indicesToOffset("xIndices")}];
                  ${x}
                }`,y.kernelShape.length===2){let ke=d-(G?3:2);V?Te=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${ke}] = indices[${ke}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${ke}] < 0 || xIndices[${ke}] >= uniforms.x_shape[${ke}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:Te=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${ke}] = indices[${ke}] * uniforms.sh - uniforms.phStart + j;
                `,ue=`
              }
            `}return`
            ${s.registerUniforms(k).declareVariables(o,X)}

            ${s.mainStart()}
              ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${X.offsetToIndices("global_idx")};
              var xIndices = ${X.offsetToIndices("global_idx")};

              var value = ${ee}(${P});
              var pad = 0;
              ${Te}
              ${re}
              ${ue}
              ${b}

              output[global_idx] = value;
            }`}else{if(G)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let re=y.kernelShape.length,Te=y.pads.length,ue="";return O?ue=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${o.indicesToOffset("xIndices")}];
                ${x}
              }`:ue=`
              }
              let x_val = x[${o.indicesToOffset("xIndices")}];
              ${x}
            `,`
            ${s.registerUniforms(k).declareVariables(o,X)}

            ${s.mainStart()}
              ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${X.offsetToIndices("global_idx")};
              var xIndices = ${X.offsetToIndices("global_idx")};

              var offsets: array<u32, ${re}>;

              var value = ${ee}(${P});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${re-1}u; j++) {
                  offsets[j] = offset / ${Nt("uniforms.kernelStrides","j",re)};
                  offset -= offsets[j] * ${Nt("uniforms.kernelStrides","j",re)};
                }
                offsets[${re-1}] = offset;

                isPad = false;
                for (var j = ${d-re}u; j < ${d}u; j++) {
                  xIndices[j] = indices[j] * ${Nt("uniforms.strides",`j - ${d-re}u`,re)}
                    + offsets[j - ${d-re}u] - ${Nt("uniforms.pads","j - 2u",Te)};
                  ${ue}
              }
              ${b}

              output[global_idx] = value;
            }`}},tu=s=>`${s.format};${s.ceilMode};${s.autoPad};${s.kernelShape.length}`,nu=s=>`${tu(s)};${s.countIncludePad}`,om=s=>`${tu(s)};${s.storageOrder};${s.dilations}`,iu=s=>({format:s.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][s.auto_pad],ceilMode:s.ceil_mode,kernelShape:s.kernel_shape,strides:s.strides,pads:s.pads}),ua=(s,o,d,g)=>{let[y,x]=Zc(o,g,d),b=dt("x",o.dataType,o.dims.length),P=b.type.value,k="value += x_val;",O="";y.countIncludePad?O+=`value /= ${P}(uniforms.kernelSize);`:O+=`value /= ${P}(i32(uniforms.kernelSize) - pad);`;let[$,V,G,ee,X]=ca(x,y);$.push(...Gt(o.dims,x));let re=["rank"];return{name:s,shaderCache:{hint:`${g.cacheKey};${G};${ee};${X}`,inputDependencies:re},getRunData:()=>({outputs:[{dims:x,dataType:o.dataType}],dispatchGroup:{x:Math.ceil(it.size(x)/64)},programUniforms:$}),getShaderSource:Te=>eu(Te,b,o.dims.length,x.length,y,k,O,0,V,G,ee,X)}},am=s=>{let o=s.count_include_pad!==0,d=iu(s);if(d.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let g={countIncludePad:o,...d,cacheKey:""};return{...g,cacheKey:nu(g)}},lm=(s,o)=>{fo(s.inputs),s.compute(ua("AveragePool",s.inputs[0],!1,o))},da={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},cm=s=>{let o=s.format;return{format:o,...da,cacheKey:o}},um=(s,o)=>{fo(s.inputs),s.compute(ua("GlobalAveragePool",s.inputs[0],!0,o))},ha=(s,o,d,g)=>{let[y,x]=Zc(o,g,d),b=`
      value = max(x_val, value);
    `,P="",k=dt("x",o.dataType,o.dims.length),O=["rank"],[$,V,G,ee,X]=ca(x,y);return $.push(...Gt(o.dims,x)),{name:s,shaderCache:{hint:`${g.cacheKey};${G};${ee};${X}`,inputDependencies:O},getRunData:()=>({outputs:[{dims:x,dataType:o.dataType}],dispatchGroup:{x:Math.ceil(it.size(x)/64)},programUniforms:$}),getShaderSource:re=>eu(re,k,o.dims.length,x.length,y,b,P,o.dataType===10?-65504:-1e5,V,G,ee,X)}},dm=(s,o)=>{fo(s.inputs),s.compute(ha("MaxPool",s.inputs[0],!1,o))},hm=s=>{let o=s.storage_order,d=s.dilations,g=iu(s);if(o!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(g.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let y={storageOrder:o,dilations:d,...g,cacheKey:""};return{...y,cacheKey:om(y)}},fa=s=>{let o=s.format;return{format:o,...da,cacheKey:o}},fm=(s,o)=>{fo(s.inputs),s.compute(ha("GlobalMaxPool",s.inputs[0],!0,o))}}),pm,mm,su,pa,$0=l(()=>{Wt(),ie(),mn(),sn(),pm=(s,o)=>{if(s.length<2||s.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(s.length===3&&s[1].dims===s[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(s.length===3&&s[0].dataType!==s[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(s[0].dataType===6&&s.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(s[1].dims.length!==0&&s[1].dims.length!==1&&s[1].dims.length!==s[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(s.length>2){if(s[0].dataType!==s[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(s[1].dims.length!==s[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!s[1].dims.map((d,g)=>d===s[2].dims[g]).reduce((d,g)=>d&&g,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(o.blockSize>0){if(s[1].dims.length===0||s[1].dims.length===1&&s[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!s[1].dims.map((y,x)=>x===o.axis||y===s[0].dims[x]).reduce((y,x)=>y&&x,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(s[1].dims.length!==s[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let d=s[0].dims[o.axis],g=s[1].dims[o.axis];if(o.blockSize<Math.ceil(d/g)||o.blockSize>Math.ceil(d/(g-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},mm=(s,o)=>{let d=it.normalizeAxis(o.axis,s[0].dims.length),g=s[0].dataType,y=g===3,x=s[0].dims,b=s[1].dataType,P=it.size(x),k=g===3||g===2,O=k?[Math.ceil(it.size(s[0].dims)/4)]:s[0].dims,$=s[1].dims,V=s.length>2?s[2]:void 0,G=V?k?[Math.ceil(it.size(V.dims)/4)]:V.dims:void 0,ee=$.length===0||$.length===1&&$[0]===1,X=ee===!1&&$.length===1,re=kn(P),Te=ee&&(!k||re===4),ue=Te?re:1,ce=Te&&!k?re:1,ke=dt("input",k?12:g,O.length,ce),Le=dt("scale",b,$.length),M=V?dt("zero_point",k?12:g,G.length):void 0,C=$t("output",b,x.length,ue),z=[ke,Le];M&&z.push(M);let oe=[O,$];V&&oe.push(G);let ve=[{type:12,data:P/ue},{type:12,data:d},{type:12,data:o.blockSize},...Gt(...oe,x)],Pe=Ue=>{let Je=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${Ue.registerUniforms(Je).declareVariables(...z,C)}
      ${Ue.mainStart()}
          ${Ue.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${C.offsetToIndices("global_idx")};

          // Set input x
          ${k?`
            let input = ${ke.getByOffset("global_idx / 4")};
            let x_vec = ${y?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${ue===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${ke.getByOffset("global_idx")};`};

          // Set scale input
          ${ee?`let scale_value= ${Le.getByOffset("0")}`:X?`
            let scale_index = ${C.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${Le.getByOffset("scale_index")};`:`
            var scale_indices: ${Le.type.indices} = output_indices;
            let index = ${Le.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${Le.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${Le.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${M?ee?k?`
                let zero_point_input = ${M.getByOffset("0")};
                let zero_point_vec =  ${y?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${M.getByOffset("0")}`:X?k?`
                let zero_point_index = ${C.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${M.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${y?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${C.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${M.getByOffset("zero_point_index")};`:k?`
                let zero_point_offset = ${Le.indicesToOffset("scale_indices")};
                let zero_point_input = ${M.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${y?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${M.getByIndices("scale_indices")};`:`let zero_point_value = ${k?y?"i32":"u32":ke.type.value}(0);`};
      // Compute and write output
      ${C.setByOffset("global_idx",`${C.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:o.cacheKey,inputDependencies:M?["rank","rank","rank"]:["rank","rank"]},getShaderSource:Pe,getRunData:()=>({outputs:[{dims:x,dataType:b}],dispatchGroup:{x:Math.ceil(P/ue/64),y:1,z:1},programUniforms:ve})}},su=(s,o)=>{pm(s.inputs,o),s.compute(mm(s.inputs,o))},pa=s=>Jt({axis:s.axis,blockSize:s.blockSize})}),gm,_m,ru,Ey=l(()=>{qe(),Wt(),sn(),gm=(s,o,d)=>{let g=s===o,y=s<o&&d<0,x=s>o&&d>0;if(g||y||x)throw new Error("Range these inputs' contents are invalid.")},_m=(s,o,d,g)=>{let y=Math.abs(Math.ceil((o-s)/d)),x=[y],b=y,P=[{type:12,data:b},{type:g,data:s},{type:g,data:d},...Gt(x)],k=O=>{let $=$t("output",g,x.length),V=$.type.value,G=[{name:"outputSize",type:"u32"},{name:"start",type:V},{name:"delta",type:V}];return`
        ${O.registerUniforms(G).declareVariables($)}
        ${O.mainStart()}
        ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${V}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${g}`},getShaderSource:k,getRunData:()=>({outputs:[{dims:x,dataType:g}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:P})}},ru=s=>{let o=0,d=0,g=0;s.inputs[0].dataType===6?(o=s.inputs[0].getInt32Array()[0],d=s.inputs[1].getInt32Array()[0],g=s.inputs[2].getInt32Array()[0]):s.inputs[0].dataType===1&&(o=s.inputs[0].getFloat32Array()[0],d=s.inputs[1].getFloat32Array()[0],g=s.inputs[2].getFloat32Array()[0]),R.webgpu.validateInputContent&&gm(o,d,g),s.compute(_m(o,d,g,s.inputs[0].dataType),{inputs:[]})}}),ym,ma,ou,vm,au,Sy,N0=l(()=>{Wt(),ie(),mn(),sn(),ym=(s,o,d,g)=>{if(s!=="none"&&g!=="i32"&&g!=="u32"&&g!=="f32")throw new Error(`Input ${g} is not supported with reduction ${s}.`);let y=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,x=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${o}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(s){case"none":return`${o}=${d};`;case"add":return g==="i32"||g==="u32"?`atomicAdd(&${o}, bitcast<${g}>(${d}));`:`
              ${y}bitcast<${g}>(oldValue) + (${d})${x}`;case"max":return g==="i32"||g==="u32"?`atomicMax(&${o}, bitcast<${g}>(${d}));`:`
                ${y}max(bitcast<f32>(oldValue), (${d}))${x}`;case"min":return g==="i32"||g==="u32"?`atomicMin(&${o}, bitcast<${g}>(${d}));`:`${y}min(bitcast<${g}>(oldValue), (${d}))${x}`;case"mul":return`${y}(bitcast<${g}>(oldValue) * (${d}))${x}`;default:throw new Error(`Reduction ${s} is not supported.`)}},ma=(s,o)=>`${s===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[${o?"i - indices_start":"i"}];
    let dim_value = uniforms.output_shape[${o?"i - indices_start":"i"} + uniforms.last_index_dimension];`}
    
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));`,ou=(s,o,d)=>`for (var i = 0u; i < uniforms.num_updates_elements; i++) {
        let value = updates[uniforms.num_updates_elements * ${d?"global_idx":"idx"} + i];
        ${ym(s.reduction,"output[data_offset + i]","value",o)}
      }`,vm=(s,o)=>{let d=s[0].dims,g=s[1].dims,y=d,x=1,b=Math.ceil(it.size(g)/x),P=g[g.length-1],k=it.sizeFromDimension(d,P),O=it.sizeFromDimension(g,0)/P,$=[{type:12,data:b},{type:12,data:P},{type:12,data:k},...Gt(s[1].dims,s[2].dims,y)],V=G=>{let ee=dt("indices",s[1].dataType,s[1].dims.length),X=dt("updates",s[2].dataType,s[2].dims.length,x),re=o.reduction!=="none"&&o.reduction!==""?Dr("output",s[0].dataType,y.length):$t("output",s[0].dataType,y.length,x);return`
      ${G.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(ee,X,re)}
      ${G.mainStart()}
        ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var hasDuplicates = false;
  if (${o.reduction==="none"}) {
    for (var i = 0; i < ${O}; i = i + 1) {
      for (var j = i + 1; j < ${O}; j = j + 1) {
        var index_i = i32(indices[i].x);
        var index_j = i32(indices[j].x);
        if (index_i == index_j) {
          hasDuplicates = true;
          break;
        }
      }
      if (hasDuplicates) {
        break;
      }
    }
  }

  if (${o.reduction==="none"} && hasDuplicates) {
    if (global_idx != 0u) {
      return;
    }
    // Process each index-update pair individually when duplicates exist
    for (var idx = 0u; idx < ${O}u; idx++) {
      var data_offset = 0u;
      for (var i = 0u; i < uniforms.last_index_dimension; i++) {
        var index = i32(indices[idx * uniforms.last_index_dimension + i].x);
        ${ma(d.length,!1)}
      }
      ${ou(o,re.type.value,!1)}
    }
    return;
  }

  var data_offset = 0u;
  var indices_start = uniforms.last_index_dimension * global_idx;
  var indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${ma(d.length,!0)}
  }
  ${ou(o,re.type.value,!0)}
  }`};return{name:"ScatterND",shaderCache:{hint:`${o.cacheKey}_${o.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:y,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:$}),getShaderSource:V}},au=s=>Jt({reduction:s.reduction}),Sy=(s,o)=>{s.compute(vm(s.inputs,o),{inputs:[s.inputs[1],s.inputs[2]],outputs:[]})}}),lu,ga,wm,cu,xm,_a,bm,Mm,Tm,ya,Em,Sm,uu,va,Pm,Am,Cm,Im,Lm,Dm,Py=l(()=>{Wt(),ie(),mn(),sn(),lu=(s,o)=>{if(s.every(d=>d>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),s.length>0){if(o.mode==="linear"){if(!(s.length===2||s.length===3||s.length===4&&s[0]===1&&s[1]===1||s.length===4&&s[0]===1&&s[3]===1||s.length===5&&s[0]===1&&s[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(o.mode==="cubic"&&!(s.length===2||s.length===4&&s[0]===1&&s[1]===1||s.length===4&&s[0]===1&&s[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},ga=(s,o,d)=>{o.every(y=>y>=0&&y<d||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let g=new Array(d).fill(1);return o.forEach((y,x)=>g[y]=s[x]),g},wm=(s,o,d,g,y,x)=>{let[b,P,k]=d>10?[1,2,3]:[-1,s.length>1?1:-1,-1],O=s[0].dims.length;if(b>0&&s.length>b&&s[b].dims.length>0)s[b].getFloat32Array().forEach($=>x.push($));else if(o.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(P>0&&s.length>P&&s[P].dims.length===1&&s[P].dims[0]>0){if(s[P].getFloat32Array().forEach($=>g.push($)),g.length!==0&&g.length!==O&&d>=18&&g.length!==o.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");lu(g,o),o.axes.length>0&&ga(g,o.axes,O).forEach(($,V)=>g[V]=$)}if(k>0&&s.length>k&&s[k].dims.length===1&&s[k].dims[0]>0&&(s[k].getBigInt64Array().forEach($=>y.push(Number($))),y.length!==0&&y.length!==O&&d>=18&&y.length!==o.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(o.axes.length>0){if(g.length!==0&&g.length!==o.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(y.length!==0&&y.length!==o.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof g<"u"&&typeof y<"u"&&g.length>0&&y.length>O)throw new Error("Resize requires only of scales or sizes to be specified")},cu=(s,o,d,g)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${s}) * (${o});
  let whole = ${g}(big / (${d}));
  let fract = ${g}(big % (${d})) / ${g}(${d});
  return whole + fract;
`,xm=(s,o)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${o} { `+(()=>{switch(s){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${o}(xResized) / ${o}(xScale);
          } else {
            ${cu("xResized","lengthOriginal","lengthResized",o)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${o}(xResized) + 0.5) / ${o}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${o}(xResized) + 0.5) / ${o}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${cu("xResized","lengthOriginal - 1","lengthResized - 1",o)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${o}(roiStart) * ${o}(lengthOriginal - 1) +
                        (${o}(xResized) * ${o}(roiEnd - roiStart) * ${o}(lengthOriginal - 1)) /
                        ${o}(lengthResized - 1);
                  } else {
                    return 0.5 * ${o}(roiStart + roiEnd) * ${o}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${o}xScale * ${o}(lengthResized);
                  const adjustment = ${o}(lengthResized) / outputWidth;
                  const center = ${o}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${o}(xResized) + 0.5) / ${o}(xScale)) - 0.5;`;case"half_pixel":return`return ((${o}(xResized) + 0.5) / ${o}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${s} is not supported`)}})()+"}",_a=(s,o,d)=>`fn getNearestPixelFromOriginal(xOriginal: ${d}, isDownSample: bool) -> ${d} {`+(()=>{switch(s){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(o<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${s} is not supported`)}})()+"}",bm=(s,o,d)=>{let g=new Array(d).fill(0).concat(new Array(d).fill(1)),y=s.length===0?g:s.slice();return o.length>0?(o.forEach((x,b)=>{g[x]=y[b],g[b+d]=y[o.length+b]}),g):y},Mm=(s,o,d,g)=>{let y=[];if(d.length>0)if(g.length>0){if(s.forEach(x=>y.push(x)),Math.max(...g)>s.length)throw new Error("axes is out of bound");g.forEach((x,b)=>y[x]=d[b])}else d.forEach(x=>y.push(x));else{if(o.length===0)throw new Error("Resize requires either scales or sizes.");y=s.map((x,b)=>Math.round(x*o[b]))}return y},Tm=(s,o,d)=>{let g=(()=>{switch(d.keepAspectRatioPolicy){case"not_larger":return d.axes.length>0?Math.min(...d.axes.map(x=>o[x]),Number.MAX_VALUE):Math.min(...o,Number.MAX_VALUE);case"not_smaller":return d.axes.length>0?Math.max(...d.axes.map(x=>o[x]),Number.MIN_VALUE):Math.max(...o,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${d.keepAspectRatioPolicy} is not supported`)}})();o.fill(1,0,o.length);let y=s.slice();return d.axes.length>0?(d.axes.forEach(x=>o[x]=g),d.axes.forEach(x=>y[x]=Math.round(s[x]*o[x]))):(o.fill(g,0,o.length),y.forEach((x,b)=>y[b]=Math.round(x*o[b]))),y},ya=(s,o,d,g,y)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${s.type.indices}) -> array<${s.type.value}, ${d.length}> {
      var original_indices: array<${s.type.value}, ${d.length}>;
      for (var i:u32 = 0; i < ${d.length}; i++) {
        var output_index = ${s.indicesGet("output_indices","i")};
        var scale = ${Nt("uniforms.scales","i",g)};
        var roi_low = ${Nt("uniforms.roi","i",y)};
        var roi_hi = ${Nt("uniforms.roi",`i + ${o.length}`,y)};
        if (scale == 1.0) {
          original_indices[i] = ${s.type.value}(output_index);
        } else {
          var input_shape_i = ${Nt("uniforms.input_shape","i",o.length)};
          var output_shape_i = ${Nt("uniforms.output_shape","i",d.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,Em=(s,o,d,g,y,x,b)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${o.type.indices}) -> ${s.type.indices} {
      var input_indices: ${s.type.indices};
      for (var i:u32 = 0; i < ${g.length}; i++) {
        var output_index = ${o.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${Nt("uniforms.scales","i",y)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${Nt("uniforms.roi","i",x)};
          var roi_hi = ${Nt("uniforms.roi",`i + ${d.length}`,x)};
          var input_shape_i = ${Nt("uniforms.input_shape","i",d.length)};
          var output_shape_i = ${Nt("uniforms.output_shape","i",g.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${b} || (original_idx >= 0 && original_idx < ${o.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${o.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${s.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,Sm=(s,o)=>`
    fn checkInputIndices(input_indices: ${s.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${o.length}; i++) {
        var input_index = ${s.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${Nt("uniforms.input_shape","i",o.length)}) {
          return false;
        }
      }
      return true;
    }`,uu=(s,o,d,g)=>s.rank>g?`
    ${s.indicesSet("input_indices",o,"channel")};
    ${s.indicesSet("input_indices",d,"batch")};
`:"",va=(s,o,d,g,y)=>{let[x,b,P,k]=d.length===2?[-1,0,1,-1]:[0,2,3,1],O=s.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${O} {
      var input_indices: ${s.type.indices};
      ${s.indicesSet("input_indices",b,`max(0, min(row, ${d[b]} - 1))`)};
      ${s.indicesSet("input_indices",P,`max(0, min(col, ${d[P]} - 1))`)};
      ${uu(s,k,x,2)}
      return ${s.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${o.type.indices}) -> ${O} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${O} = originalIndices[${b}];
      var col:${O} = originalIndices[${P}];
      ${g?`if (row < 0 || row > (${d[b]} - 1) || col < 0 || col > (${d[P]} - 1)) {
        return ${y};
      }`:""};
      row = max(0, min(row, ${d[b]} - 1));
      col = max(0, min(col, ${d[P]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${d.length>2?`u32(originalIndices[${k}])`:"0"};
      var batch: u32 =  ${d.length>2?`u32(originalIndices[${x}])`:"0"};
      var x11: ${O} = getInputValue(batch, channel, row1, col1);
      var x12: ${O} = getInputValue(batch, channel, row1, col2);
      var x21: ${O} = getInputValue(batch, channel, row2, col1);
      var x22: ${O} = getInputValue(batch, channel, row2, col2);
      var dx1: ${O} = abs(row - ${O}(row1));
      var dx2: ${O} = abs(${O}(row2) - row);
      var dy1: ${O} = abs(col - ${O}(col1));
      var dy2: ${O} = abs(${O}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Pm=(s,o,d,g,y,x,b,P,k,O)=>{let $=d.length===2,[V,G]=$?[0,1]:[2,3],ee=s.type.value,X=re=>{let Te=re===V?"row":"col";return`
      fn ${Te}CubicInterpolation(input_indices: ${s.type.indices}, output_indices: ${o.type.indices}) -> ${ee} {
        var output_index = ${o.indicesGet("output_indices",re)};
        var originalIdx: ${ee} = getOriginalCoordinateFromResizedCoordinate(output_index, ${y[re]},
        ${g[re]}, ${d[re]}, ${x[re]}, ${x[re]} + ${d.length});
        var fractOriginalIdx: ${ee} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${P} && (originalIdx < 0 || originalIdx > (${d[re]} - 1))) {
          return ${k};
        }
        var data: array<${ee}, 4> = array<${ee}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${Te}: ${ee} = originalIdx + ${ee}(i);
          if (${Te} < 0 || ${Te} >= ${d[re]}) {
            ${O?`coefs[i + 1] = 0.0;
                        continue;`:P?`return ${k};`:`${Te} = max(0, min(${Te}, ${d[re]} - 1));`};
          }
        var input_indices_copy: ${s.type.indices} = input_indices;
          ${s.indicesSet("input_indices_copy",re,`u32(${Te})`)};
          data[i + 1] = ${re===V?s.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${X(V)};
    ${X(G)};
  fn getCubicInterpolationCoefs(s: ${ee}) -> array<${ee}, 4> {
    var absS = abs(s);
    var coeffs: array<${ee}, 4> = array<${ee}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${ee} = 1.0 - absS;
    var twoMinusAbsS: ${ee} = 2.0 - absS;
    var onePlusAbsS: ${ee} = 1.0 + absS;
    coeffs[0] = ((${b} * onePlusAbsS - 5 * ${b}) * onePlusAbsS + 8 * ${b}) * onePlusAbsS - 4 * ${b};
    coeffs[1] = ((${b} + 2) * absS - (${b} + 3)) * absS * absS + 1;
    coeffs[2] = ((${b} + 2) * oneMinusAbsS - (${b} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${b} * twoMinusAbsS - 5 * ${b}) * twoMinusAbsS + 8 * ${b}) * twoMinusAbsS - 4 * ${b};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${ee}, 4>, coefs: array<${ee}, 4>) -> ${ee} {
    var coefsSum: ${ee} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${o.type.indices}) -> ${ee} {
    var input_indices: ${s.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},Am=(s,o,d,g,y)=>{let[x,b,P,k,O]=d.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],$=s.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${$} {
      var input_indices: ${s.type.indices};
      ${s.indicesSet("input_indices",b,`max(0, min(depth, ${d[b]} - 1))`)};
      ${s.indicesSet("input_indices",P,`max(0, min(height, ${d[P]} - 1))`)};
      ${s.indicesSet("input_indices",k,`max(0, min(width, ${d[k]} - 1))`)};
      ${uu(s,O,x,3)}
      return ${s.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${o.type.indices}) -> ${$} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${$} = originalIndices[${b}];
      var height:${$} = originalIndices[${P}];
      var width:${$} = originalIndices[${k}];
      ${g?`if (depth < 0 || depth > (${d[b]} - 1) || height < 0 || height > (${d[P]} - 1) || width < 0 || (width > ${d[k]} - 1)) {
      return ${y};
        }`:""};

    depth = max(0, min(depth, ${d[b]} - 1));
      height = max(0, min(height, ${d[P]} - 1));
      width = max(0, min(width, ${d[k]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${d.length>3?`u32(originalIndices[${O}])`:"0"};
      var batch: u32 =  ${d.length>3?`u32(originalIndices[${x}])`:"0"};

      var x111: ${$} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${$} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${$} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${$} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${$} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${$} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${$} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${$} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${$} = abs(depth - ${$}(depth1));
      var dx2: ${$} = abs(${$}(depth2) - depth);
      var dy1: ${$} = abs(height - ${$}(height1));
      var dy2: ${$} = abs(${$}(height2) - height);
      var dz1: ${$} = abs(width - ${$}(width1));
      var dz2: ${$} = abs(${$}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},Cm=(s,o,d,g,y,x)=>{let b=s.dims,P=bm(x,o.axes,b.length),k=Mm(b,g,y,o.axes),O=g.slice();g.length===0&&(O=b.map((ce,ke)=>ce===0?1:k[ke]/ce),o.keepAspectRatioPolicy!=="stretch"&&(k=Tm(b,O,o)));let $=$t("output",s.dataType,k.length),V=dt("input",s.dataType,b.length),G=it.size(k),ee=b.length===k.length&&b.every((ce,ke)=>ce===k[ke]),X=o.coordinateTransformMode==="tf_crop_and_resize",re=o.extrapolationValue,Te=V.type.value,ue=ce=>`
      ${ee?"":`
      ${xm(o.coordinateTransformMode,Te)};
      ${(()=>{switch(o.mode){case"nearest":return`
              ${Sm(V,b)};
              ${_a(o.nearestMode,d,Te)};
              ${Em(V,$,b,k,O.length,P.length,X)};
              `;case"linear":return`
              ${ya($,b,k,O.length,P.length)};
              ${(()=>{if(b.length===2||b.length===4)return`${va(V,$,b,X,re)}`;if(b.length===3||b.length===5)return`${Am(V,$,b,X,re)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(b.length===2||b.length===4)return`${Pm(V,$,b,k,O,P,o.cubicCoeffA,X,o.extrapolationValue,o.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${ce.registerUniform("output_size","u32").registerUniform("scales","f32",O.length).registerUniform("roi","f32",P.length).declareVariables(V,$)}
      ${ce.mainStart()}
        ${ce.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${ee?"output[global_idx] = input[global_idx];":`
        let output_indices = ${$.offsetToIndices("global_idx")};
        var input_indices: ${V.type.indices};
        ${(()=>{switch(o.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${V.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${o.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${b.length===2||b.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${o.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${o.cacheKey}|${d}|${O.length>0?o.mode==="cubic"?O:O.length:""}|${y.length>0?y:""}|${P.length>0?P:""}|${ee}|${o.mode==="nearest"?b.length:b}`,inputDependencies:["rank"]},getShaderSource:ue,getRunData:()=>({outputs:[{dims:k,dataType:s.dataType}],dispatchGroup:{x:Math.ceil(G/64)},programUniforms:[{type:12,data:G},{type:1,data:O},{type:1,data:P},...Gt(b,k)]})}},Im=s=>{let o=s.customDataBuffer;return new Uint32Array(o,o.byteOffset,1)[0]},Lm=(s,o)=>{let d=[],g=[],y=[],x=Im(s);if(o.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");wm(s.inputs,o,x,d,g,y),s.compute(Cm(s.inputs[0],o,x,d,g,y),{inputs:[0]})},Dm=s=>{let o=s.antialias,d=s.axes,g=s.coordinateTransformMode,y=s.cubicCoeffA,x=s.excludeOutside!==0,b=s.extrapolationValue,P=s.keepAspectRatioPolicy,k=s.mode,O=s.nearestMode===""?"simple":s.nearestMode;return Jt({antialias:o,axes:d,coordinateTransformMode:g,cubicCoeffA:y,excludeOutside:x,extrapolationValue:b,keepAspectRatioPolicy:P,mode:k,nearestMode:O})}}),km,Om,Fm,Rm=l(()=>{Wt(),ie(),sn(),km=s=>{if(!s||s.length<3)throw new Error("layerNorm requires at least 3 inputs.");let o=s[0],d=s[1],g=s[2];if(o.dataType!==d.dataType||o.dataType!==g.dataType)throw new Error("All inputs must have the same data type");if(o.dims.length!==3&&o.dims.length!==2)throw new Error("Input must be 2D or 3D");if(d.dims.length!==3&&d.dims.length!==2)throw new Error("Skip must be 2D or 3D");let y=o.dims[o.dims.length-1],x=o.dims[o.dims.length-2];if(d.dims[d.dims.length-1]!==y)throw new Error("Skip must have the same hidden size as input");if(d.dims[d.dims.length-2]!==x)throw new Error("Skip must have the same sequence length as input");if(g.dims.length!==1)throw new Error("Gamma must be 1D");if(g.dims[g.dims.length-1]!==y)throw new Error("Gamma must have the same hidden size as input");if(s.length>3){let b=s[3];if(b.dims.length!==1)throw new Error("Beta must be 1D");if(b.dims[b.dims.length-1]!==y)throw new Error("Beta must have the same hidden size as input")}if(s.length>4){let b=s[4];if(b.dims.length!==1)throw new Error("Bias must be 1D");if(b.dims[b.dims.length-1]!==y)throw new Error("Bias must have the same hidden size as input")}},Om=(s,o,d,g)=>{let y=o.simplified,x=s[0].dims,b=it.size(x),P=x,k=b,O=x.slice(-1)[0],$=g?x.slice(0,-1).concat(1):[],V=!y&&s.length>3,G=s.length>4,ee=g&&d>1,X=g&&d>2,re=d>3,Te=64,ue=kn(O),ce=[{type:12,data:k},{type:12,data:ue},{type:12,data:O},{type:1,data:o.epsilon}],ke=M=>{let C=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],z=[dt("x",s[0].dataType,s[0].dims,ue),dt("skip",s[1].dataType,s[1].dims,ue),dt("gamma",s[2].dataType,s[2].dims,ue)];V&&z.push(dt("beta",s[3].dataType,s[3].dims,ue)),G&&z.push(dt("bias",s[4].dataType,s[4].dims,ue)),z.push($t("output",s[0].dataType,P,ue)),ee&&z.push($t("mean_output",1,$)),X&&z.push($t("inv_std_output",1,$)),re&&z.push($t("input_skip_bias_sum",s[0].dataType,P,ue));let oe=Zn(s[0].dataType),ve=Zn(1,ue);return`

      ${M.registerUniforms(C).declareVariables(...z)}
      var<workgroup> sum_shared : array<${ve}, ${Te}>;
      var<workgroup> sum_squared_shared : array<${ve}, ${Te}>;

      ${M.mainStart([Te,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${Te};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${Te};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${Te-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${G?"bias[offset1d + i]":oe+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${re?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${ds(oe,ue,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${Te};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Gs("sum",ue)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Gs("square_sum",ue)} / f32(uniforms.hidden_size) ${y?"":"- mean * mean"} + uniforms.epsilon);
        ${ee?"mean_output[global_idx] = mean;":""}
        ${X?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${y?"":`- ${oe}(mean)`}) *
            ${oe}(inv_std_dev) * gamma[offset1d + i]
            ${V?"+ beta[offset1d + i]":""};
        }
      }`},Le=[{dims:P,dataType:s[0].dataType}];return d>1&&Le.push({dims:$,dataType:1}),d>2&&Le.push({dims:$,dataType:1}),d>3&&Le.push({dims:x,dataType:s[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${ue};${ee};${X};${re}`,inputDependencies:s.map((M,C)=>"type")},getShaderSource:ke,getRunData:()=>({outputs:Le,dispatchGroup:{x:Math.ceil(k/O)},programUniforms:ce})}},Fm=(s,o)=>{km(s.inputs);let d=[0];s.outputCount>1&&d.push(-3),s.outputCount>2&&d.push(-3),s.outputCount>3&&d.push(3),s.compute(Om(s.inputs,o,s.outputCount,!1),{outputs:d})}}),Bm,po,du,hu,zm,$m,fu,Nm,pu=l(()=>{Wt(),ie(),mn(),sn(),Bm=(s,o)=>{if(!s||s.length<1)throw new Error("too few inputs");if(o.axes.length!==0){if(o.axes.length!==o.starts.length||o.axes.length!==o.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(o.starts.length!==o.ends.length)throw new Error("starts and ends must have the same length");s.slice(1).forEach((d,g)=>{if(s[g+1].dataType!==6&&s[g+1].dataType!==7)throw new Error(`Input ${g} must be an array of int32 or int64`)})},po=(s,o)=>{let d=[];if(s.length>o)if(s[o].dataType===7)s[o].getBigInt64Array().forEach(g=>d.push(Number(g)));else if(s[o].dataType===6)s[o].getInt32Array().forEach(g=>d.push(Number(g)));else throw new Error(`Input ${o} must be an array of int32 or int64`);return d},du=(s,o)=>{if(s.length>1){let d=po(s,1),g=po(s,2),y=po(s,3);return y.length===0&&(y=[...Array(s[0].dims.length).keys()]),Jt({starts:d,ends:g,axes:y})}else return o},hu=(s,o,d,g,y)=>{let x=s;return s<0&&(x+=d[g[o]]),y[o]<0?Math.max(0,Math.min(x,d[g[o]]-1)):Math.max(0,Math.min(x,d[g[o]]))},zm=(s,o,d)=>`fn calculateInputIndices(output_indices: ${o.type.indices}) -> ${s.type.indices} {
          var input_indices: ${s.type.indices};
          var carry = 0u;
          for (var i = ${d.length}; i >= 0; i--) {
            let input_shape_i = ${Nt("uniforms.input_shape","i",d.length)};
            let steps_i = ${Nt("uniforms.steps","i",d.length)};
            let signs_i = ${Nt("uniforms.signs","i",d.length)};
            let starts_i = ${Nt("uniforms.starts","i",d.length)};
            var output_index = ${o.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${s.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,$m=(s,o)=>{let d=s[0].dims,g=it.size(d),y=o.axes.length>0?it.normalizeAxes(o.axes,d.length):[...Array(d.length).keys()],x=po(s,4);x.forEach(ue=>ue!==0||(()=>{throw new Error("step cannot be 0")})),x.length===0&&(x=Array(y.length).fill(1));let b=o.starts.map((ue,ce)=>hu(ue,ce,d,y,x)),P=o.ends.map((ue,ce)=>hu(ue,ce,d,y,x));if(y.length!==b.length||y.length!==P.length)throw new Error("start, ends and axes should have the same number of elements");if(y.length!==d.length)for(let ue=0;ue<d.length;++ue)y.includes(ue)||(b.splice(ue,0,0),P.splice(ue,0,d[ue]),x.splice(ue,0,1));let k=x.map(ue=>Math.sign(ue));x.forEach((ue,ce,ke)=>{if(ue<0){let Le=(P[ce]-b[ce])/ue,M=b[ce],C=M+Le*x[ce];b[ce]=C,P[ce]=M,ke[ce]=-ue}});let O=d.slice(0);y.forEach((ue,ce)=>{O[ue]=Math.ceil((P[ue]-b[ue])/x[ue])});let $={dims:O,dataType:s[0].dataType},V=$t("output",s[0].dataType,O.length),G=dt("input",s[0].dataType,s[0].dims.length),ee=it.size(O),X=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:b.length},{name:"signs",type:"i32",length:k.length},{name:"steps",type:"u32",length:x.length}],re=[{type:12,data:ee},{type:12,data:b},{type:6,data:k},{type:12,data:x},...Gt(s[0].dims,O)],Te=ue=>`
      ${ue.registerUniforms(X).declareVariables(G,V)}
        ${zm(G,V,d)}
        ${ue.mainStart()}
          ${ue.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${V.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${V.setByOffset("global_idx",G.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${k.length}_${b.length}_${x.length}`,inputDependencies:["rank"]},getShaderSource:Te,getRunData:()=>({outputs:[$],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:re})}},fu=(s,o)=>{Bm(s.inputs,o);let d=du(s.inputs,o);s.compute($m(s.inputs,d),{inputs:[0]})},Nm=s=>{let o=s.starts,d=s.ends,g=s.axes;return Jt({starts:o,ends:d,axes:g})}}),Um,Gm,Vm,jm,Ay=l(()=>{Wt(),ie(),mn(),ar(),sn(),Um=s=>{if(!s||s.length!==1)throw new Error("Softmax op requires 1 input.")},Gm=(s,o)=>{let d=s.inputs[0],g=d.dims,y=it.size(g),x=g.length,b=it.normalizeAxis(o.axis,x),P=b<g.length-1,k,O=[];P?(O=Array.from({length:x},(z,oe)=>oe),O[b]=x-1,O[x-1]=b,k=s.compute(Ei(d,O),{inputs:[d],outputs:[-1]})[0]):k=d;let $=k.dims,V=$[x-1],G=y/V,ee=kn(V),X=V/ee,re=64;G===1&&(re=256);let Te=(z,oe)=>oe===4?`max(max(${z}.x, ${z}.y), max(${z}.z, ${z}.w))`:oe===2?`max(${z}.x, ${z}.y)`:oe===3?`max(max(${z}.x, ${z}.y), ${z}.z)`:z,ue=dt("x",k.dataType,k.dims,ee),ce=$t("result",k.dataType,k.dims,ee),ke=ue.type.value,Le=Zn(k.dataType)==="f32"?`var threadMax = ${ke}(-3.402823e+38f);`:`var threadMax = ${ke}(-65504.0h);`,M=z=>`
      var<workgroup> rowMaxShared : ${ke};
      var<workgroup> rowSumShared : ${ke};
      var<workgroup> threadShared : array<${ke}, ${re}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${ke} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${ke}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${z.registerUniform("packedCols","i32").declareVariables(ue,ce)}
      ${z.mainStart(re)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${re};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${Le}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${ke}(${Te("threadShared[0]",ee)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${ke}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${ke}(${Gs("threadShared[0]",ee)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,C=s.compute({name:"Softmax",shaderCache:{hint:`${ee};${re}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:$,dataType:k.dataType}],dispatchGroup:{x:G},programUniforms:[{type:6,data:X}]}),getShaderSource:M},{inputs:[k],outputs:[P?-1:0]})[0];P&&s.compute(Ei(C,O),{inputs:[C]})},Vm=(s,o)=>{Um(s.inputs),Gm(s,o)},jm=s=>Jt({axis:s.axis})}),mo,Wm,Hm,qm,Km,Cy=l(()=>{Wt(),ie(),sn(),mo=s=>Array.from(s.getBigInt64Array(),Number),Wm=s=>{if(!s||s.length!==2)throw new Error("Tile requires 2 inputs.");if(s[0].dataType!==1&&s[0].dataType!==10&&s[0].dataType!==6&&s[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(s[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(s[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(mo(s[1]).length!==s[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Hm=(s,o)=>{let d=[];for(let g=0;g<s.length;++g)d.push(s[g]*o[g]);return d},qm=(s,o)=>{let d=s[0].dims,g=o??mo(s[1]),y=Hm(d,g),x=it.size(y),b=s[0].dataType,P=dt("input",b,d.length),k=$t("output",b,y.length),O=$=>`
      const inputShape = ${P.indices(...d)};
      ${$.registerUniform("output_size","u32").declareVariables(P,k)}
      ${$.mainStart()}
      ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${k.offsetToIndices("global_idx")};
      var input_indices: ${P.type.indices};
      for (var i = 0; i < ${d.length}; i++) {
        let input_dim_i = ${P.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${k.indicesGet("output_indices","i")}  % input_dim_i;

        ${P.indicesSet("input_indices","i","input_dim_value")}
      }
      ${k.setByOffset("global_idx",P.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${g}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:y,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(x/64)},programUniforms:[{type:12,data:x},...Gt(s[0].dims,y)]}),getShaderSource:O}},Km=s=>{Wm(s.inputs),s.compute(qm(s.inputs),{inputs:[0]})}}),wa,Xm,Ym,Iy=l(()=>{Wt(),ie(),sn(),wa=(s,o,d,g,y)=>{let x=$t("output_data",y,d.length,4),b=dt("a_data",o[1].dataType,o[1].dims.length,4),P=dt("b_data",o[2].dataType,o[2].dims.length,4),k=dt("c_data",o[0].dataType,o[0].dims.length,4),O,$=(V,G,ee)=>`select(${G}, ${V}, ${ee})`;if(!g)O=x.setByOffset("global_idx",$(b.getByOffset("global_idx"),P.getByOffset("global_idx"),k.getByOffset("global_idx")));else{let V=(G,ee,X="")=>{let re=`a_data[index_a${ee}][component_a${ee}]`,Te=`b_data[index_b${ee}][component_b${ee}]`,ue=`bool(c_data[index_c${ee}] & (0xffu << (component_c${ee} * 8)))`;return`
            let output_indices${ee} = ${x.offsetToIndices(`global_idx * 4u + ${ee}u`)};
            let offset_a${ee} = ${b.broadcastedIndicesToOffset(`output_indices${ee}`,x)};
            let offset_b${ee} = ${P.broadcastedIndicesToOffset(`output_indices${ee}`,x)};
            let offset_c${ee} = ${k.broadcastedIndicesToOffset(`output_indices${ee}`,x)};
            let index_a${ee} = offset_a${ee} / 4u;
            let index_b${ee} = offset_b${ee} / 4u;
            let index_c${ee} = offset_c${ee} / 4u;
            let component_a${ee} = offset_a${ee} % 4u;
            let component_b${ee} = offset_b${ee} % 4u;
            let component_c${ee} = offset_c${ee} % 4u;
            ${G}[${ee}] = ${X}(${$(re,Te,ue)});
          `};y===9?O=`
            var data = vec4<u32>(0);
            ${V("data",0,"u32")}
            ${V("data",1,"u32")}
            ${V("data",2,"u32")}
            ${V("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:O=`
            ${V("output_data[global_idx]",0)}
            ${V("output_data[global_idx]",1)}
            ${V("output_data[global_idx]",2)}
            ${V("output_data[global_idx]",3)}
          `}return`
        ${s.registerUniform("vec_size","u32").declareVariables(k,b,P,x)}
        ${s.mainStart()}
        ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${O}
      }`},Xm=s=>{let o=s[1].dims,d=s[2].dims,g=s[0].dims,y=s[1].dataType,x=!(it.areEqual(o,d)&&it.areEqual(d,g)),b=o,P=it.size(o);if(x){let O=Wi.calcShape(Wi.calcShape(o,d,!1),g,!1);if(!O)throw new Error("Can't perform where op on the given tensors");b=O,P=it.size(b)}let k=Math.ceil(P/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:O=>wa(O,s,b,x,y),getRunData:()=>({outputs:[{dims:b,dataType:y}],dispatchGroup:{x:Math.ceil(P/64/4)},programUniforms:[{type:12,data:k},...Gt(g,o,d,b)]})}},Ym=s=>{s.compute(Xm(s.inputs))}}),gn,U0=l(()=>{yh(),Wl(),Ph(),ny(),of(),gf(),iy(),$f(),oy(),ay(),ly(),cy(),uy(),dy(),hy(),fy(),mp(),py(),my(),gy(),_y(),yy(),wy(),xy(),by(),js(),rm(),Ty(),$0(),Ey(),N0(),Nl(),Py(),oa(),Rm(),pu(),Ay(),Bp(),Cy(),ar(),lc(),Iy(),gn=new Map([["Abs",[Lh]],["Acos",[Dh]],["Acosh",[Kl]],["Add",[cf]],["ArgMax",[_h,Vl]],["ArgMin",[Gl,Vl]],["Asin",[kh]],["Asinh",[Oh]],["Atan",[Xl]],["Atanh",[Fh]],["Attention",[Mh]],["AveragePool",[lm,am]],["BatchNormalization",[Sh]],["BiasAdd",[ql]],["BiasSplitGelu",[rf]],["Cast",[Yl,Rh]],["Ceil",[Jl]],["Clip",[zh]],["Concat",[wf,pc]],["Conv",[Rr,Sc]],["ConvTranspose",[Lc,Vf]],["Cos",[$h]],["Cosh",[Nh]],["CumSum",[Hf,Dc]],["DepthToSpace",[Xf,Oc]],["DequantizeLinear",[su,pa]],["Div",[uc]],["Einsum",[Zf,ep]],["Elu",[Uh,Or]],["Equal",[uf]],["Erf",[Ql]],["Exp",[Gh]],["Expand",[sp]],["FastGelu",[op]],["Floor",[Vh]],["FusedConv",[Rr,Sc]],["Gather",[cp,$c]],["GatherElements",[yp,Gc]],["GatherBlockQuantized",[fp,pp]],["GatherND",[up,dp]],["Gelu",[Zl]],["Gemm",[xp,wp]],["GlobalAveragePool",[um,cm]],["GlobalMaxPool",[fm,fa]],["Greater",[ff]],["GreaterOrEqual",[pf]],["GridSample",[Cp,sa]],["GroupQueryAttention",[Gp]],["HardSigmoid",[Xh,Kh]],["InstanceNormalization",[jp]],["LayerNormalization",[Hp]],["LeakyRelu",[jh,Or]],["Less",[hc]],["LessOrEqual",[mf]],["Log",[ef]],["MatMul",[Br]],["MatMulNBits",[Jp,Qp]],["MaxPool",[dm,hm]],["Mul",[df]],["MultiHeadAttention",[Lp,Ip]],["Neg",[ec]],["Not",[Wh]],["Pad",[sm]],["Pow",[dc]],["QuickGelu",[nf,Or]],["Range",[ru]],["Reciprocal",[Hh]],["ReduceMin",[ph]],["ReduceMean",[Rl]],["ReduceMax",[fh]],["ReduceSum",[mh]],["ReduceProd",[zl]],["ReduceL1",[dh]],["ReduceL2",[hh]],["ReduceLogSum",[$l]],["ReduceLogSumExp",[Bl]],["ReduceSumSquare",[gh]],["Relu",[qh]],["Resize",[Lm,Dm]],["RotaryEmbedding",[$p]],["ScatterND",[Sy,au]],["Sigmoid",[tc]],["Sin",[nc]],["Sinh",[Yh]],["Slice",[fu,Nm]],["SkipLayerNormalization",[Fm]],["Split",[Rp,Xc]],["Sqrt",[Jh]],["Softmax",[Vm,jm]],["Sub",[hf]],["Tan",[ic]],["Tanh",[Qh]],["ThresholdedRelu",[oc,Or]],["Tile",[Km]],["Transpose",[jd,Cl]],["Where",[Ym]]])}),Ly,G0=l(()=>{qe(),Lt(),sn(),Ly=class{constructor(s){this.backend=s,this.repo=new Map,this.attributesBound=!1}getArtifact(s){return this.repo.get(s)}setArtifact(s,o){this.repo.set(s,o)}run(s,o,d,g,y){ze(s.programInfo.name);let x=this.backend.device,b=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let P=[];for(let O of o)P.push({binding:P.length,resource:{buffer:O.buffer}});for(let O of d)P.push({binding:P.length,resource:{buffer:O.buffer}});y&&P.push({binding:P.length,resource:y});let k=x.createBindGroup({layout:s.computePipeline.getBindGroupLayout(0),entries:P,label:s.programInfo.name});if(this.backend.sessionStatus==="capturing"){let O={kernelId:this.backend.currentKernelId,computePipeline:s.computePipeline,bindGroup:k,dispatchGroup:g};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(O)}b.setPipeline(s.computePipeline),b.setBindGroup(0,k),b.dispatchWorkgroups(...g),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Oe(s.programInfo.name)}dispose(){}build(s,o){ze(s.name);let d=this.backend.device,g=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(O=>{d.features.has(O.feature)&&g.push(`enable ${O.extension};`)});let y=$d(o,this.backend.device.limits),x=s.getShaderSource(y),b=`${g.join(`
`)}
${y.additionalImplementations}
${x}`,P=d.createShaderModule({code:b,label:s.name});ct("verbose",()=>`[WebGPU] ${s.name} shader code: ${b}`);let k=d.createComputePipeline({compute:{module:P,entryPoint:"main"},layout:"auto",label:s.name});return Oe(s.name),{programInfo:s,computePipeline:k,uniformVariablesInfo:y.variablesInfo}}normalizeDispatchGroupSize(s){let o=typeof s=="number"?s:s.x,d=typeof s=="number"?1:s.y||1,g=typeof s=="number"?1:s.z||1,y=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(o<=y&&d<=y&&g<=y)return[o,d,g];let x=o*d*g,b=Math.ceil(Math.sqrt(x));if(b>y){if(b=Math.ceil(Math.cbrt(x)),b>y)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[b,b,b]}else return[b,b,1]}}}),Dy={};f(Dy,{WebGpuBackend:()=>Zm});var mu,Jm,Qm,Zm,ky=l(()=>{qe(),Wt(),Lt(),Re(),Hn(),U0(),G0(),mu=(s,o)=>{if(o.length!==s.length)throw new Error(`inputDependencies length ${o.length} is not equal to inputTensors length ${s.length}.`);let d=[];for(let g=0;g<s.length;++g){let y=s[g].dataType;switch(o[g]){case"none":{d.push("");break}case"type":{d.push(`${y}`);break}case"rank":{let x=s[g].dims.length;d.push(`${y};${x}`);break}case"dims":{let x=s[g].dims.join(",");d.push(`${y};${x}`);break}default:throw new Error(`unsupported input dependency: ${o[g]}`)}}return d.join("|")},Jm=(s,o,d)=>{var y,x;let g=s.name;return(y=s.shaderCache)!=null&&y.hint&&(g+="["+s.shaderCache.hint+"]"),g+=":"+d+`:${mu(o,((x=s.shaderCache)==null?void 0:x.inputDependencies)??new Array(o.length).fill("dims"))}`,g},Qm=class{constructor(s){s&&(this.architecture=s.architecture,this.vendor=s.vendor)}isArchitecture(s){return this.architecture===s}isVendor(s){return this.vendor===s}},Zm=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let s=this.kernelCustomData.get(this.currentKernelId);return s||(s={},this.kernelCustomData.set(this.currentKernelId,s)),s}async initialize(s,o){this.env=s;let d=[],g={requiredLimits:{maxComputeWorkgroupStorageSize:o.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:o.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:o.limits.maxStorageBufferBindingSize,maxBufferSize:o.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:o.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:o.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:o.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:o.limits.maxComputeWorkgroupSizeZ},requiredFeatures:d},y=x=>o.features.has(x)&&d.push(x)&&!0;y("chromium-experimental-timestamp-query-inside-passes")||y("timestamp-query"),y("shader-f16"),y("subgroups"),this.device=await o.requestDevice(g),this.adapterInfo=new Qm(o.info||await o.requestAdapterInfo()),this.gpuDataManager=Qn(this),this.programManager=new Ly(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,_i(s.logLevel,!!s.debug),this.device.onuncapturederror=x=>{x.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${x.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:o,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let s=this.getCommandEncoder(),o={};this.queryType==="at-passes"&&(o.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=s.beginComputePass(o)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;ze(),this.endComputePass();let s;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),s=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(s,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,s,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&s.mapAsync(GPUMapMode.READ).then(()=>{var g;let o=new BigUint64Array(s.getMappedRange()),d=this.pendingQueries.get(s);for(let y=0;y<o.length/2;y++){let x=d[y],b=x.kernelId,P=this.kernels.get(b),k=P.kernelType,O=P.kernelName,$=x.programName,V=x.inputTensorViews,G=x.outputTensorViews,ee=o[y*2],X=o[y*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=ee);let re=Number(ee-this.queryTimeBase),Te=Number(X-this.queryTimeBase);if(!Number.isSafeInteger(re)||!Number.isSafeInteger(Te))throw new RangeError("incorrect timestamp range");if((g=this.env.webgpu.profiling)!=null&&g.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:V.map(ue=>({dims:ue.dims,dataType:gi(ue.dataType)})),outputsMetadata:G.map(ue=>({dims:ue.dims,dataType:gi(ue.dataType)})),kernelId:b,kernelType:k,kernelName:O,programName:$,startTime:re,endTime:Te});else{let ue="";V.forEach((ke,Le)=>{ue+=`input[${Le}]: [${ke.dims}] | ${gi(ke.dataType)}, `});let ce="";G.forEach((ke,Le)=>{ce+=`output[${Le}]: [${ke.dims}] | ${gi(ke.dataType)}, `}),console.log(`[profiling] kernel "${b}|${k}|${O}|${$}" ${ue}${ce}execution time: ${Te-re} ns`)}U("GPU",`${$}::${ee}::${X}`)}s.unmap(),this.pendingQueries.delete(s)}),Oe()}run(s,o,d,g,y,x){ze(s.name);let b=[];for(let ce=0;ce<o.length;++ce){let ke=o[ce].data;if(ke===0)continue;let Le=this.gpuDataManager.get(ke);if(!Le)throw new Error(`no GPU data for input: ${ke}`);b.push(Le)}let{outputs:P,dispatchGroup:k,programUniforms:O}=s.getRunData(o),$=d.length===0?P.map((ce,ke)=>ke):d;if($.length!==P.length)throw new Error(`Output size ${$.length} must be equal to ${P.length}.`);let V=[],G=[];for(let ce=0;ce<P.length;++ce){if(!Number.isInteger($[ce])||$[ce]<-3||$[ce]>=x)throw new Error(`Invalid output index: ${$[ce]}`);if($[ce]===-3)continue;let ke=$[ce]===-1,Le=$[ce]===-2,M=ke||Le?y(P[ce].dataType,P[ce].dims):g($[ce],P[ce].dataType,P[ce].dims);if(V.push(M),M.data===0)continue;let C=this.gpuDataManager.get(M.data);if(!C)throw new Error(`no GPU data for output: ${M.data}`);if(ke&&this.temporaryData.push(C),Le){let z=this.kernelPersistentData.get(this.currentKernelId);z||(z=[],this.kernelPersistentData.set(this.currentKernelId,z)),z.push(C)}G.push(C)}if(b.length!==o.length||G.length!==V.length){if(G.length===0)return Oe(s.name),V;throw new Error(`Program ${s.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let ee;if(O){let ce=0,ke=[];O.forEach(z=>{let oe=typeof z.data=="number"?[z.data]:z.data;if(oe.length===0)return;let ve=z.type===10?2:4,Pe,Ue;z.type===10?(Ue=oe.length>4?16:oe.length>2?8:oe.length*ve,Pe=oe.length>4?16:ve*oe.length):(Ue=oe.length<=2?oe.length*ve:16,Pe=16),ce=Math.ceil(ce/Ue)*Ue,ke.push(ce);let Je=z.type===10?8:4;ce+=oe.length>4?Math.ceil(oe.length/Je)*Pe:oe.length*ve});let Le=16;ce=Math.ceil(ce/Le)*Le;let M=new ArrayBuffer(ce);O.forEach((z,oe)=>{let ve=ke[oe],Pe=typeof z.data=="number"?[z.data]:z.data;if(z.type===6)new Int32Array(M,ve,Pe.length).set(Pe);else if(z.type===12)new Uint32Array(M,ve,Pe.length).set(Pe);else if(z.type===10)new Uint16Array(M,ve,Pe.length).set(Pe);else if(z.type===1)new Float32Array(M,ve,Pe.length).set(Pe);else throw new Error(`Unsupported uniform type: ${gi(z.type)}`)});let C=this.gpuDataManager.create(ce,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(C.buffer,0,M,0,ce),this.gpuDataManager.release(C.id),ee={offset:0,size:ce,buffer:C.buffer}}let X=this.programManager.normalizeDispatchGroupSize(k),re=X[1]===1&&X[2]===1,Te=Jm(s,o,re),ue=this.programManager.getArtifact(Te);if(ue||(ue=this.programManager.build(s,X),this.programManager.setArtifact(Te,ue),ct("info",()=>`[artifact] key: ${Te}, programName: ${s.name}`)),O&&ue.uniformVariablesInfo){if(O.length!==ue.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${ue.uniformVariablesInfo.length}, got ${O.length} in program "${ue.programInfo.name}".`);for(let ce=0;ce<O.length;ce++){let ke=O[ce],Le=ke.type,M=typeof ke.data=="number"?1:ke.data.length,[C,z]=ue.uniformVariablesInfo[ce];if(Le!==C||M!==z)throw new Error(`Uniform variable ${ce} mismatch: expect type ${C} with size ${z}, got type ${Le} with size ${M} in program "${ue.programInfo.name}".`)}}if(ct("info",()=>`[ProgramManager] run "${s.name}" (key=${Te}) with ${X[0]}x${X[1]}x${X[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let ce={kernelId:this.currentKernelId,programName:ue.programInfo.name,inputTensorViews:o,outputTensorViews:V};this.pendingKernels.push(ce),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(ce)}return this.programManager.run(ue,b,G,X,ee),Oe(s.name),V}upload(s,o){this.gpuDataManager.upload(s,o)}memcpy(s,o){this.gpuDataManager.memcpy(s,o)}async download(s,o){await this.gpuDataManager.download(s,o)}alloc(s){return this.gpuDataManager.create(s).id}free(s){return this.gpuDataManager.release(s)}createKernel(s,o,d,g){let y=gn.get(s);if(!y)throw new Error(`kernel not implemented: ${s}`);let x={kernelType:s,kernelName:g,kernelEntry:y[0],attributes:[y[1],d]};this.kernels.set(o,x)}releaseKernel(s){let o=this.kernelPersistentData.get(s);if(o){for(let d of o)this.gpuDataManager.release(d.id);this.kernelPersistentData.delete(s)}this.kernelCustomData.delete(s),this.kernels.delete(s)}computeKernel(s,o,d){let g=this.kernels.get(s);if(!g)throw new Error(`kernel not created: ${s}`);let y=g.kernelType,x=g.kernelName,b=g.kernelEntry,P=g.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${y}] ${x}" is not allowed to be called recursively`);this.currentKernelId=s,P[0]&&(P[1]=P[0](P[1]),P[0]=void 0),ct("info",()=>`[WebGPU] Start to run kernel "[${y}] ${x}"...`);let k=this.env.debug;this.temporaryData=[];try{return k&&this.device.pushErrorScope("validation"),b(o,P[1]),0}catch(O){return d.push(Promise.resolve(`[WebGPU] Kernel "[${y}] ${x}" failed. ${O}`)),1}finally{k&&d.push(this.device.popErrorScope().then(O=>O?`GPU validation error for kernel "[${y}] ${x}": ${O.message}`:null));for(let O of this.temporaryData)this.gpuDataManager.release(O.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(s,o,d,g){let y=this.sessionExternalDataMapping.get(s);y||(y=new Map,this.sessionExternalDataMapping.set(s,y));let x=y.get(o),b=this.gpuDataManager.registerExternalBuffer(d,g,x);return y.set(o,[b,d]),b}unregisterBuffers(s){let o=this.sessionExternalDataMapping.get(s);o&&(o.forEach(d=>this.gpuDataManager.unregisterExternalBuffer(d[0])),this.sessionExternalDataMapping.delete(s))}getBuffer(s){let o=this.gpuDataManager.get(s);if(!o)throw new Error(`no GPU data for buffer: ${s}`);return o.buffer}createDownloader(s,o,d){return async()=>{let g=await oi(this,s,o);return Ae(g.buffer,d)}}writeTimestamp(s){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,s)}setQueryType(){var s;this.queryType="none",(((s=this.env.webgpu.profiling)==null?void 0:s.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){ct("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){ct("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){ct("info","replay"),this.sessionStatus="replaying";let s=this.capturedCommandList.get(this.currentSessionId),o=this.capturedPendingKernels.get(this.currentSessionId),d=s.length;this.pendingKernels=[];for(let g=0;g<d;g++){let y=this.getComputePassEncoder(),x=s[g];this.writeTimestamp(this.pendingDispatchNumber*2),y.setPipeline(x.computePipeline),y.setBindGroup(0,x.bindGroup),y.dispatchWorkgroups(...x.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(o[g]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(s){this.unregisterBuffers(s),this.capturedCommandList.has(s)&&this.capturedCommandList.delete(s),this.capturedPendingKernels.has(s)&&this.capturedPendingKernels.delete(s),this.gpuDataManager.onReleaseSession(s)}onRunStart(s){this.currentSessionId=s,this.setQueryType()}}}),gu={};f(gu,{init:()=>eg});var go,Oy,eg,Fy=l(()=>{Wt(),Lt(),ie(),Ss(),go=class Bb{constructor(o,d,g,y){this.module=o,this.dataType=d,this.data=g,this.dims=y}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let o=it.size(this.dims);return o===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,o)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let o=it.size(this.dims);return o===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,o)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let o=it.size(this.dims);return o===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,o)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let o=it.size(this.dims);return o===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,o)}reshape(o){if(it.size(o)!==it.size(this.dims))throw new Error("Invalid new shape");return new Bb(this.module,this.dataType,this.data,o)}},Oy=class{constructor(s,o,d){this.module=s,this.backend=o,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=o.adapterInfo;let g=s.PTR_SIZE,y=d/s.PTR_SIZE,x=g===4?"i32":"i64";this.opKernelContext=Number(s.getValue(g*y++,x));let b=Number(s.getValue(g*y++,x));this.outputCount=Number(s.getValue(g*y++,x)),this.customDataOffset=Number(s.getValue(g*y++,"*")),this.customDataSize=Number(s.getValue(g*y++,x));let P=[];for(let k=0;k<b;k++){let O=Number(s.getValue(g*y++,x)),$=Number(s.getValue(g*y++,"*")),V=Number(s.getValue(g*y++,x)),G=[];for(let ee=0;ee<V;ee++)G.push(Number(s.getValue(g*y++,x)));P.push(new go(s,O,$,G))}this.inputs=P}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(s,o){var b;let d=((b=o==null?void 0:o.inputs)==null?void 0:b.map(P=>typeof P=="number"?this.inputs[P]:P))??this.inputs,g=(o==null?void 0:o.outputs)??[],y=(P,k,O)=>new go(this.module,k,this.output(P,O),O),x=(P,k)=>{let O=ki(P,k);if(!O)throw new Error(`Unsupported data type: ${P}`);let $=O>0?this.backend.gpuDataManager.create(O).id:0;return new go(this.module,P,$,k)};return this.backend.run(s,d,g,y,x,this.outputCount)}output(s,o){let d=this.module.stackSave();try{let g=this.module.PTR_SIZE,y=g===4?"i32":"i64",x=this.module.stackAlloc((1+o.length)*g);this.module.setValue(x,o.length,y);for(let b=0;b<o.length;b++)this.module.setValue(x+g*(b+1),o[b],y);return this.module._JsepOutput(this.opKernelContext,s,x)}catch(g){throw new Error(`Failed to generate kernel's output[${s}] with dims [${o}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${g}`)}finally{this.module.stackRestore(d)}}},eg=async(s,o,d,g)=>{let y=o.jsepInit;if(!y)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(s==="webgpu"){let x=(ky(),h(Dy)).WebGpuBackend,b=new x;await b.initialize(d,g),y("webgpu",[b,P=>b.alloc(Number(P)),P=>b.free(P),(P,k,O,$=!1)=>{if($)ct("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(P)}, dst=${Number(k)}, size=${Number(O)}`),b.memcpy(Number(P),Number(k));else{ct("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(P)}, gpuDataId=${Number(k)}, size=${Number(O)}`);let V=o.HEAPU8.subarray(Number(P>>>0),Number(P>>>0)+Number(O));b.upload(Number(k),V)}},async(P,k,O)=>{ct("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${P}, dataOffset=${k}, size=${O}`),await b.download(Number(P),()=>o.HEAPU8.subarray(Number(k)>>>0,Number(k+O)>>>0))},(P,k,O)=>b.createKernel(P,Number(k),O,o.UTF8ToString(o._JsepGetNodeName(Number(k)))),P=>b.releaseKernel(P),(P,k,O,$)=>{ct("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${O}, kernel=${P}, contextDataOffset=${k}`);let V=new Oy(o,b,Number(k));return b.computeKernel(Number(P),V,$)},()=>b.captureBegin(),()=>b.captureEnd(),()=>b.replay()])}else{let x=new Ti(d);y("webnn",[x,()=>x.reserveTensorId(),b=>x.releaseTensorId(b),async(b,P,k,O,$)=>x.ensureTensor(b,P,k,O,$),(b,P)=>{x.uploadTensor(b,P)},async(b,P)=>x.downloadTensor(b,P)])}}}),_u,yu,vu,mr,tg,wu,xa,gr,xu,bu,Mu,Tu,Eu,ng=l(()=>{en(),ui(),Wt(),ge(),Pt(),or(),_u=(s,o)=>{se()._OrtInit(s,o)!==0&&pt("Can't initialize onnxruntime.")},yu=async s=>{_u(s.wasm.numThreads,Ms(s.logLevel))},vu=async(s,o)=>{var d,g;(g=(d=se()).asyncInit)==null||g.call(d);{let y=(Fy(),h(gu)).init;if(o==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let x=s.webgpu.adapter;if(x){if(typeof x.limits!="object"||typeof x.features!="object"||typeof x.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let b=s.webgpu.powerPreference;if(b!==void 0&&b!=="low-power"&&b!=="high-performance")throw new Error(`Invalid powerPreference setting: "${b}"`);let P=s.webgpu.forceFallbackAdapter;if(P!==void 0&&typeof P!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${P}"`);if(x=await navigator.gpu.requestAdapter({powerPreference:b,forceFallbackAdapter:P}),!x)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await y("webgpu",se(),s,x)}if(o==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await y("webnn",se(),s)}}},mr=new Map,tg=s=>{let o=se(),d=o.stackSave();try{let g=o.PTR_SIZE,y=o.stackAlloc(2*g);o._OrtGetInputOutputCount(s,y,y+g)!==0&&pt("Can't get session input/output count.");let x=g===4?"i32":"i64";return[Number(o.getValue(y,x)),Number(o.getValue(y+g,x))]}finally{o.stackRestore(d)}},wu=(s,o)=>{let d=se(),g=d.stackSave(),y=0;try{let x=d.PTR_SIZE,b=d.stackAlloc(2*x);d._OrtGetInputOutputMetadata(s,o,b,b+x)!==0&&pt("Can't get session input/output metadata.");let P=Number(d.getValue(b,"*"));y=Number(d.getValue(b+x,"*"));let k=d.HEAP32[y/4];if(k===0)return[P,0];let O=d.HEAPU32[y/4+1],$=[];for(let V=0;V<O;V++){let G=Number(d.getValue(y+8+V*x,"*"));$.push(G!==0?d.UTF8ToString(G):Number(d.getValue(y+8+(V+O)*x,"*")))}return[P,k,$]}finally{d.stackRestore(g),y!==0&&d._OrtFree(y)}},xa=s=>{let o=se(),d=o._malloc(s.byteLength);if(d===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${s.byteLength}.`);return o.HEAPU8.set(s,d),[d,s.byteLength]},gr=async(s,o)=>{var V,G,ee,X;let d,g,y=se();Array.isArray(s)?[d,g]=s:s.buffer===y.HEAPU8.buffer?[d,g]=[s.byteOffset,s.byteLength]:[d,g]=xa(s);let x=0,b=0,P=0,k=[],O=[],$=[];try{if([b,k]=await bi(o),(o==null?void 0:o.externalData)&&y.mountExternalData){let oe=[];for(let ve of o.externalData){let Pe=typeof ve=="string"?ve:ve.path;oe.push(ji(typeof ve=="string"?ve:ve.data).then(Ue=>{y.mountExternalData(Pe,Ue)}))}await Promise.all(oe)}for(let oe of(o==null?void 0:o.executionProviders)??[])if((typeof oe=="string"?oe:oe.name)==="webnn"){if(y.shouldTransferToMLTensor=!1,typeof oe!="string"){let ve=oe,Pe=ve==null?void 0:ve.context,Ue=ve==null?void 0:ve.gpuDevice,Je=ve==null?void 0:ve.deviceType,st=ve==null?void 0:ve.powerPreference;Pe?y.currentContext=Pe:Ue?y.currentContext=await y.webnnCreateMLContext(Ue):y.currentContext=await y.webnnCreateMLContext({deviceType:Je,powerPreference:st})}else y.currentContext=await y.webnnCreateMLContext();break}x=await y._OrtCreateSession(d,g,b),(V=y.webgpuOnCreateSession)==null||V.call(y,x),x===0&&pt("Can't create a session."),(G=y.jsepOnCreateSession)==null||G.call(y),y.currentContext&&(y.webnnRegisterMLContext(x,y.currentContext),y.currentContext=void 0,y.shouldTransferToMLTensor=!0);let[re,Te]=tg(x),ue=!!(o!=null&&o.enableGraphCapture),ce=[],ke=[],Le=[],M=[],C=[];for(let oe=0;oe<re;oe++){let[ve,Pe,Ue]=wu(x,oe);ve===0&&pt("Can't get an input name."),O.push(ve);let Je=y.UTF8ToString(ve);ce.push(Je),Le.push(Pe===0?{name:Je,isTensor:!1}:{name:Je,isTensor:!0,type:gi(Pe),shape:Ue})}for(let oe=0;oe<Te;oe++){let[ve,Pe,Ue]=wu(x,oe+re);ve===0&&pt("Can't get an output name."),$.push(ve);let Je=y.UTF8ToString(ve);ke.push(Je),M.push(Pe===0?{name:Je,isTensor:!1}:{name:Je,isTensor:!0,type:gi(Pe),shape:Ue});{if(ue&&(o==null?void 0:o.preferredOutputLocation)===void 0){C.push("gpu-buffer");continue}let st=typeof(o==null?void 0:o.preferredOutputLocation)=="string"?o.preferredOutputLocation:((ee=o==null?void 0:o.preferredOutputLocation)==null?void 0:ee[Je])??"cpu";if(st!=="cpu"&&st!=="cpu-pinned"&&st!=="gpu-buffer"&&st!=="ml-tensor")throw new Error(`Not supported preferred output location: ${st}.`);if(ue&&st!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${st}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);C.push(st)}}let z=null;return C.some(oe=>oe==="gpu-buffer"||oe==="ml-tensor")&&(P=y._OrtCreateBinding(x),P===0&&pt("Can't create IO binding."),z={handle:P,outputPreferredLocations:C,outputPreferredLocationsEncoded:C.map(oe=>zi(oe))}),mr.set(x,[x,O,$,z,ue,!1]),[x,ce,ke,Le,M]}catch(re){throw O.forEach(Te=>y._OrtFree(Te)),$.forEach(Te=>y._OrtFree(Te)),P!==0&&y._OrtReleaseBinding(P)!==0&&pt("Can't release IO binding."),x!==0&&y._OrtReleaseSession(x)!==0&&pt("Can't release session."),re}finally{y._free(d),b!==0&&y._OrtReleaseSessionOptions(b)!==0&&pt("Can't release session options."),k.forEach(re=>y._free(re)),(X=y.unmountExternalData)==null||X.call(y)}},xu=s=>{var k,O,$;let o=se(),d=mr.get(s);if(!d)throw new Error(`cannot release session. invalid session id: ${s}`);let[g,y,x,b,P]=d;b&&(P&&o._OrtClearBoundOutputs(b.handle)!==0&&pt("Can't clear bound outputs."),o._OrtReleaseBinding(b.handle)!==0&&pt("Can't release IO binding.")),(k=o.jsepOnReleaseSession)==null||k.call(o,s),(O=o.webnnOnReleaseSession)==null||O.call(o,s),($=o.webgpuOnReleaseSession)==null||$.call(o,s),y.forEach(V=>o._OrtFree(V)),x.forEach(V=>o._OrtFree(V)),o._OrtReleaseSession(g)!==0&&pt("Can't release session."),mr.delete(s)},bu=async(s,o,d,g,y,x,b=!1)=>{if(!s){o.push(0);return}let P=se(),k=P.PTR_SIZE,O=s[0],$=s[1],V=s[3],G=V,ee,X;if(O==="string"&&(V==="gpu-buffer"||V==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(b&&V!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${x} when enableGraphCapture is true.`);if(V==="gpu-buffer"){let ue=s[2].gpuBuffer;X=ki(Bi(O),$);{let ce=P.jsepRegisterBuffer;if(!ce)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');ee=ce(g,x,ue,X)}}else if(V==="ml-tensor"){let ue=s[2].mlTensor;X=ki(Bi(O),$);let ce=P.webnnRegisterMLTensor;if(!ce)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');ee=ce(g,ue,Bi(O),$)}else{let ue=s[2];if(Array.isArray(ue)){X=k*ue.length,ee=P._malloc(X),d.push(ee);for(let ce=0;ce<ue.length;ce++){if(typeof ue[ce]!="string")throw new TypeError(`tensor data at index ${ce} is not a string`);P.setValue(ee+ce*k,Fe(ue[ce],d),"*")}}else{let ce=P.webnnIsGraphInput;if(O!=="string"&&ce){let ke=P.UTF8ToString(y);if(ce(g,ke)){let Le=Bi(O);X=ki(Le,$),G="ml-tensor";let M=P.webnnCreateTemporaryTensor,C=P.webnnUploadTensor;if(!M||!C)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let z=await M(g,Le,$);C(z,new Uint8Array(ue.buffer,ue.byteOffset,ue.byteLength)),ee=z}else X=ue.byteLength,ee=P._malloc(X),d.push(ee),P.HEAPU8.set(new Uint8Array(ue.buffer,ue.byteOffset,X),ee)}else X=ue.byteLength,ee=P._malloc(X),d.push(ee),P.HEAPU8.set(new Uint8Array(ue.buffer,ue.byteOffset,X),ee)}}let re=P.stackSave(),Te=P.stackAlloc(4*$.length);try{$.forEach((ce,ke)=>P.setValue(Te+ke*k,ce,k===4?"i32":"i64"));let ue=P._OrtCreateTensor(Bi(O),ee,X,Te,$.length,zi(G));ue===0&&pt(`Can't create tensor for input/output. session=${g}, index=${x}.`),o.push(ue)}finally{P.stackRestore(re)}},Mu=async(s,o,d,g,y,x)=>{var Ue,Je,st,gt;let b=se(),P=b.PTR_SIZE,k=mr.get(s);if(!k)throw new Error(`cannot run inference. invalid session id: ${s}`);let O=k[0],$=k[1],V=k[2],G=k[3],ee=k[4],X=k[5],re=o.length,Te=g.length,ue=0,ce=[],ke=[],Le=[],M=[],C=b.stackSave(),z=b.stackAlloc(re*P),oe=b.stackAlloc(re*P),ve=b.stackAlloc(Te*P),Pe=b.stackAlloc(Te*P);try{[ue,ce]=Tt(x);for(let ht=0;ht<re;ht++)await bu(d[ht],ke,M,s,$[o[ht]],o[ht],ee);for(let ht=0;ht<Te;ht++)await bu(y[ht],Le,M,s,V[g[ht]],re+g[ht],ee);for(let ht=0;ht<re;ht++)b.setValue(z+ht*P,ke[ht],"*"),b.setValue(oe+ht*P,$[o[ht]],"*");for(let ht=0;ht<Te;ht++)b.setValue(ve+ht*P,Le[ht],"*"),b.setValue(Pe+ht*P,V[g[ht]],"*");if(G&&!X){let{handle:ht,outputPreferredLocations:Ft,outputPreferredLocationsEncoded:xt}=G;if($.length!==re)throw new Error(`input count from feeds (${re}) is expected to be always equal to model's input count (${$.length}).`);for(let Ct=0;Ct<re;Ct++){let Ze=o[Ct];await b._OrtBindInput(ht,$[Ze],ke[Ct])!==0&&pt(`Can't bind input[${Ct}] for session=${s}.`)}for(let Ct=0;Ct<Te;Ct++){let Ze=g[Ct];(Ue=y[Ct])!=null&&Ue[3]?b._OrtBindOutput(ht,V[Ze],Le[Ct],0)!==0&&pt(`Can't bind pre-allocated output[${Ct}] for session=${s}.`):b._OrtBindOutput(ht,V[Ze],0,xt[Ze])!==0&&pt(`Can't bind output[${Ct}] to ${Ft[Ct]} for session=${s}.`)}mr.set(s,[O,$,V,G,ee,!0])}(Je=b.jsepOnRunStart)==null||Je.call(b,O),(st=b.webnnOnRunStart)==null||st.call(b,O);let wt;G?wt=await b._OrtRunWithBinding(O,G.handle,Te,ve,ue):wt=await b._OrtRun(O,oe,z,re,Pe,Te,ve,ue),wt!==0&&pt("failed to call OrtRun().");let yt=[];for(let ht=0;ht<Te;ht++){let Ft=Number(b.getValue(ve+ht*P,"*"));if(Ft===Le[ht]){yt.push(y[ht]);continue}let xt=b.stackSave(),Ct=b.stackAlloc(4*P),Ze=!1,ft,St=0;try{b._OrtGetTensorData(Ft,Ct,Ct+P,Ct+2*P,Ct+3*P)!==0&&pt(`Can't access output tensor data on index ${ht}.`);let Ht=P===4?"i32":"i64",un=Number(b.getValue(Ct,Ht));St=b.getValue(Ct+P,"*");let Sn=b.getValue(Ct+P*2,"*"),Kn=Number(b.getValue(Ct+P*3,Ht)),On=[];for(let Pn=0;Pn<Kn;Pn++)On.push(Number(b.getValue(Sn+Pn*P,Ht)));b._OrtFree(Sn)!==0&&pt("Can't free memory for tensor dims.");let Zt=On.reduce((Pn,Fn)=>Pn*Fn,1);ft=gi(un);let Nn=G==null?void 0:G.outputPreferredLocations[g[ht]];if(ft==="string"){if(Nn==="gpu-buffer"||Nn==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let Pn=[];for(let Fn=0;Fn<Zt;Fn++){let Xn=b.getValue(St+Fn*P,"*"),Yi=b.getValue(St+(Fn+1)*P,"*"),Lu=Fn===Zt-1?void 0:Yi-Xn;Pn.push(b.UTF8ToString(Xn,Lu))}yt.push([ft,On,Pn,"cpu"])}else if(Nn==="gpu-buffer"&&Zt>0){let Pn=b.jsepGetBuffer;if(!Pn)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Fn=Pn(St),Xn=ki(un,Zt);if(Xn===void 0||!Ts(ft))throw new Error(`Unsupported data type: ${ft}`);Ze=!0,yt.push([ft,On,{gpuBuffer:Fn,download:b.jsepCreateDownloader(Fn,Xn,ft),dispose:()=>{b._OrtReleaseTensor(Ft)!==0&&pt("Can't release tensor.")}},"gpu-buffer"])}else if(Nn==="ml-tensor"&&Zt>0){let Pn=b.webnnEnsureTensor,Fn=b.webnnIsInt64Supported;if(!Pn||!Fn)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(ki(un,Zt)===void 0||!zs(ft))throw new Error(`Unsupported data type: ${ft}`);if(ft==="int64"&&!Fn(s))throw new Error('preferredLocation "ml-tensor" for int64 output is not supported by current WebNN Context.');let Xn=await Pn(s,St,un,On,!1);Ze=!0,yt.push([ft,On,{mlTensor:Xn,download:b.webnnCreateMLTensorDownloader(St,ft),dispose:()=>{b.webnnReleaseTensorId(St),b._OrtReleaseTensor(Ft)}},"ml-tensor"])}else{let Pn=Mi(ft),Fn=new Pn(Zt);new Uint8Array(Fn.buffer,Fn.byteOffset,Fn.byteLength).set(b.HEAPU8.subarray(St,St+Fn.byteLength)),yt.push([ft,On,Fn,"cpu"])}}finally{b.stackRestore(xt),ft==="string"&&St&&b._free(St),Ze||b._OrtReleaseTensor(Ft),(gt=b.webnnOnRunEnd)==null||gt.call(b,O)}}return G&&!ee&&(b._OrtClearBoundOutputs(G.handle)!==0&&pt("Can't clear bound outputs."),mr.set(s,[O,$,V,G,ee,!1])),yt}finally{b.stackRestore(C),ke.forEach(wt=>b._OrtReleaseTensor(wt)),Le.forEach(wt=>b._OrtReleaseTensor(wt)),M.forEach(wt=>b._free(wt)),ue!==0&&b._OrtReleaseRunOptions(ue),ce.forEach(wt=>b._free(wt))}},Tu=s=>{let o=se(),d=mr.get(s);if(!d)throw new Error("invalid session id");let g=d[0],y=o._OrtEndProfiling(g);y===0&&pt("Can't get an profile file name."),o._OrtFree(y)},Eu=s=>{let o=[];for(let d of s){let g=d[2];!Array.isArray(g)&&"buffer"in g&&o.push(g.buffer)}return o}}),Ws,Si,_o,yo,vo,ba,Su,Ma,_r,zr,ig,Pu,sg,rg,og,ag,lg,cg,ug=l(()=>{qe(),ng(),ge(),Me(),Ws=()=>!!R.wasm.proxy&&typeof document<"u",_o=!1,yo=!1,vo=!1,Ma=new Map,_r=(s,o)=>{let d=Ma.get(s);d?d.push(o):Ma.set(s,[o])},zr=()=>{if(_o||!yo||vo||!Si)throw new Error("worker not ready")},ig=s=>{switch(s.data.type){case"init-wasm":_o=!1,s.data.err?(vo=!0,Su[1](s.data.err)):(yo=!0,Su[0]()),ba&&(URL.revokeObjectURL(ba),ba=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let o=Ma.get(s.data.type);s.data.err?o.shift()[1](s.data.err):o.shift()[0](s.data.out);break}}},Pu=async()=>{if(!yo){if(_o)throw new Error("multiple calls to 'initWasm()' detected.");if(vo)throw new Error("previous call to 'initWasm()' failed.");if(_o=!0,Ws())return new Promise((s,o)=>{Si==null||Si.terminate(),Di().then(([d,g])=>{try{Si=g,Si.onerror=x=>o(x),Si.onmessage=ig,Su=[s,o];let y={type:"init-wasm",in:R};if(!y.in.wasm.wasmPaths&&d){let x=cn();x&&(y.in.wasm.wasmPaths=x)}Si.postMessage(y),ba=d}catch(y){o(y)}},o)});try{await J(R.wasm),await yu(R),yo=!0}catch(s){throw vo=!0,s}finally{_o=!1}}},sg=async s=>{if(Ws())return zr(),new Promise((o,d)=>{_r("init-ep",[o,d]);let g={type:"init-ep",in:{epName:s,env:R}};Si.postMessage(g)});await vu(R,s)},rg=async s=>Ws()?(zr(),new Promise((o,d)=>{_r("copy-from",[o,d]);let g={type:"copy-from",in:{buffer:s}};Si.postMessage(g,[s.buffer])})):xa(s),og=async(s,o)=>{if(Ws()){if(o!=null&&o.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return zr(),new Promise((d,g)=>{_r("create",[d,g]);let y={type:"create",in:{model:s,options:{...o}}},x=[];s instanceof Uint8Array&&x.push(s.buffer),Si.postMessage(y,x)})}else return gr(s,o)},ag=async s=>{if(Ws())return zr(),new Promise((o,d)=>{_r("release",[o,d]);let g={type:"release",in:s};Si.postMessage(g)});xu(s)},lg=async(s,o,d,g,y,x)=>{if(Ws()){if(d.some(b=>b[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(y.some(b=>b))throw new Error("pre-allocated output tensor is not supported for proxy.");return zr(),new Promise((b,P)=>{_r("run",[b,P]);let k=d,O={type:"run",in:{sessionId:s,inputIndices:o,inputs:k,outputIndices:g,options:x}};Si.postMessage(O,Eu(k))})}else return Mu(s,o,d,g,y,x)},cg=async s=>{if(Ws())return zr(),new Promise((o,d)=>{_r("end-profiling",[o,d]);let g={type:"end-profiling",in:s};Si.postMessage(g)});Tu(s)}}),Au,dg,hg,Ry=l(()=>{qe(),ug(),Wt(),tt(),or(),Au=(s,o)=>{switch(s.location){case"cpu":return[s.type,s.dims,s.data,"cpu"];case"gpu-buffer":return[s.type,s.dims,{gpuBuffer:s.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[s.type,s.dims,{mlTensor:s.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${s.location} for ${o()}`)}},dg=s=>{switch(s[3]){case"cpu":return new Be(s[0],s[2],s[1]);case"gpu-buffer":{let o=s[0];if(!Ts(o))throw new Error(`not supported data type: ${o} for deserializing GPU tensor`);let{gpuBuffer:d,download:g,dispose:y}=s[2];return Be.fromGpuBuffer(d,{dataType:o,dims:s[1],download:g,dispose:y})}case"ml-tensor":{let o=s[0];if(!zs(o))throw new Error(`not supported data type: ${o} for deserializing MLTensor tensor`);let{mlTensor:d,download:g,dispose:y}=s[2];return Be.fromMLTensor(d,{dataType:o,dims:s[1],download:g,dispose:y})}default:throw new Error(`invalid data location: ${s[3]}`)}},hg=class{async fetchModelAndCopyToWasmMemory(s){return rg(await ji(s))}async loadModel(s,o){ze();let d;typeof s=="string"?d=await this.fetchModelAndCopyToWasmMemory(s):d=s,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await og(d,o),Oe()}async dispose(){return ag(this.sessionId)}async run(s,o,d){ze();let g=[],y=[];Object.entries(s).forEach(V=>{let G=V[0],ee=V[1],X=this.inputNames.indexOf(G);if(X===-1)throw new Error(`invalid input '${G}'`);g.push(ee),y.push(X)});let x=[],b=[];Object.entries(o).forEach(V=>{let G=V[0],ee=V[1],X=this.outputNames.indexOf(G);if(X===-1)throw new Error(`invalid output '${G}'`);x.push(ee),b.push(X)});let P=g.map((V,G)=>Au(V,()=>`input "${this.inputNames[y[G]]}"`)),k=x.map((V,G)=>V?Au(V,()=>`output "${this.outputNames[b[G]]}"`):null),O=await lg(this.sessionId,y,P,b,k,d),$={};for(let V=0;V<O.length;V++)$[this.outputNames[b[V]]]=x[V]??dg(O[V]);return Oe(),$}startProfiling(){}endProfiling(){cg(this.sessionId)}}}),fg={};f(fg,{OnnxruntimeWebAssemblyBackend:()=>Iu,initializeFlags:()=>Cu,wasmBackend:()=>pg});var Cu,Iu,pg,By=l(()=>{qe(),ug(),Ry(),Cu=()=>{(typeof R.wasm.initTimeout!="number"||R.wasm.initTimeout<0)&&(R.wasm.initTimeout=0);let s=R.wasm.simd;if(typeof s!="boolean"&&s!==void 0&&s!=="fixed"&&s!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${s}". Reset it to \`false\` and ignore SIMD feature checking.`),R.wasm.simd=!1),typeof R.wasm.proxy!="boolean"&&(R.wasm.proxy=!1),typeof R.wasm.trace!="boolean"&&(R.wasm.trace=!1),typeof R.wasm.numThreads!="number"||!Number.isInteger(R.wasm.numThreads)||R.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)R.wasm.numThreads=1;else{let o=typeof navigator>"u"?u("node:os").cpus().length:navigator.hardwareConcurrency;R.wasm.numThreads=Math.min(4,Math.ceil((o||1)/2))}},Iu=class{async init(s){Cu(),await Pu(),await sg(s)}async createInferenceSessionHandler(s,o){let d=new hg;return await d.loadModel(s,o),d}},pg=new Iu}),mg={};f(mg,{InferenceSession:()=>$e,TRACE:()=>U,TRACE_FUNC_BEGIN:()=>ze,TRACE_FUNC_END:()=>Oe,Tensor:()=>Be,default:()=>$y,env:()=>R,registerBackend:()=>v}),qe(),qe(),qe();var zy="1.22.0-dev.20250409-89f8206ba4",$y=de;{let s=(By(),h(fg)).wasmBackend;v("webgpu",s,5),v("webnn",s,5),v("cpu",s,10),v("wasm",s,10)}return Object.defineProperty(R.versions,"web",{value:zy,enumerable:!0}),h(mg)})();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */e.exports=t})(Ab);var Cb=Ab.exports;const WP=Ji({__proto__:null,default:jP(Cb)},[Cb]);var HP={"onnxruntime-common":e=>{e.exports=VP},"onnxruntime-web":e=>{e.exports=WP},"?2ce3":()=>{},"?7992":()=>{},"?5af5":()=>{},"?2b25":()=>{},"?db59":()=>{},"?383f":()=>{},"?fa4b":()=>{},"./node_modules/@huggingface/jinja/dist/index.js":(e,n,t)=>{t.r(n),t.d(n,{Environment:()=>lt,Interpreter:()=>wn,Template:()=>an,parse:()=>et,tokenize:()=>h});var i=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Comment:"Comment"}),r=class{constructor(B,le){this.value=B,this.type=le}};function a(B){return/\w/.test(B)}function c(B){return/[0-9]/.test(B)}function u(B){return/\s/.test(B)}var l=[["{%",i.OpenStatement],["%}",i.CloseStatement],["{{",i.OpenExpression],["}}",i.CloseExpression],["(",i.OpenParen],[")",i.CloseParen],["{",i.OpenCurlyBracket],["}",i.CloseCurlyBracket],["[",i.OpenSquareBracket],["]",i.CloseSquareBracket],[",",i.Comma],[".",i.Dot],[":",i.Colon],["|",i.Pipe],["<=",i.ComparisonBinaryOperator],[">=",i.ComparisonBinaryOperator],["==",i.ComparisonBinaryOperator],["!=",i.ComparisonBinaryOperator],["<",i.ComparisonBinaryOperator],[">",i.ComparisonBinaryOperator],["+",i.AdditiveBinaryOperator],["-",i.AdditiveBinaryOperator],["~",i.AdditiveBinaryOperator],["*",i.MultiplicativeBinaryOperator],["/",i.MultiplicativeBinaryOperator],["%",i.MultiplicativeBinaryOperator],["=",i.Equals]],f=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function m(B,le={}){return B.endsWith(`
`)&&(B=B.slice(0,-1)),le.lstrip_blocks&&(B=B.replace(/^[ \t]*({[#%-])/gm,"$1")),le.trim_blocks&&(B=B.replace(/([#%-]})\n/g,"$1")),B.replace(/{%\s*(end)?generation\s*%}/gs,"")}function h(B,le={}){var Tt,en;const J=[],se=m(B,le);let ge=0,Fe=0;const Ke=Dt=>{let tn="";for(;Dt(se[ge]);){if(se[ge]==="\\"){if(++ge,ge>=se.length)throw new SyntaxError("Unexpected end of input");const Vt=se[ge++],nn=f.get(Vt);if(nn===void 0)throw new SyntaxError(`Unexpected escaped character: ${Vt}`);tn+=nn;continue}if(tn+=se[ge++],ge>=se.length)throw new SyntaxError("Unexpected end of input")}return tn},pt=()=>{const Dt=J.at(-1);Dt&&Dt.type===i.Text&&(Dt.value=Dt.value.trimEnd(),Dt.value===""&&J.pop())},Pt=()=>{for(;ge<se.length&&u(se[ge]);)++ge};e:for(;ge<se.length;){const Dt=(Tt=J.at(-1))==null?void 0:Tt.type;if(Dt===void 0||Dt===i.CloseStatement||Dt===i.CloseExpression||Dt===i.Comment){let Vt="";for(;ge<se.length&&!(se[ge]==="{"&&(se[ge+1]==="%"||se[ge+1]==="{"||se[ge+1]==="#"));)Vt+=se[ge++];if(Vt.length>0){J.push(new r(Vt,i.Text));continue}}if(se[ge]==="{"&&se[ge+1]==="#"){ge+=2;const Vt=se[ge]==="-";Vt&&++ge;let nn="";for(;se[ge]!=="#"||se[ge+1]!=="}";){if(ge+2>=se.length)throw new SyntaxError("Missing end of comment tag");nn+=se[ge++]}const Tn=nn.endsWith("-");Tn&&(nn=nn.slice(0,-1)),Vt&&pt(),J.push(new r(nn,i.Comment)),ge+=2,Tn&&Pt();continue}if(se.slice(ge,ge+3)==="{%-"){pt(),J.push(new r("{%",i.OpenStatement)),ge+=3;continue}if(se.slice(ge,ge+3)==="{{-"){pt(),J.push(new r("{{",i.OpenExpression)),Fe=0,ge+=3;continue}if(Ke(u),se.slice(ge,ge+3)==="-%}"){J.push(new r("%}",i.CloseStatement)),ge+=3,Pt();continue}if(se.slice(ge,ge+3)==="-}}"){J.push(new r("}}",i.CloseExpression)),ge+=3,Pt();continue}const tn=se[ge];if(tn==="-"||tn==="+"){const Vt=(en=J.at(-1))==null?void 0:en.type;if(Vt===i.Text||Vt===void 0)throw new SyntaxError(`Unexpected character: ${tn}`);switch(Vt){case i.Identifier:case i.NumericLiteral:case i.StringLiteral:case i.CloseParen:case i.CloseSquareBracket:break;default:{++ge;const nn=Ke(c);J.push(new r(`${tn}${nn}`,nn.length>0?i.NumericLiteral:i.UnaryOperator));continue}}}for(const[Vt,nn]of l){if(Vt==="}}"&&Fe>0)continue;if(se.slice(ge,ge+Vt.length)===Vt){J.push(new r(Vt,nn)),nn===i.OpenExpression?Fe=0:nn===i.OpenCurlyBracket?++Fe:nn===i.CloseCurlyBracket&&--Fe,ge+=Vt.length;continue e}}if(tn==="'"||tn==='"'){++ge;const Vt=Ke(nn=>nn!==tn);J.push(new r(Vt,i.StringLiteral)),++ge;continue}if(c(tn)){let Vt=Ke(c);if(se[ge]==="."&&c(se[ge+1])){++ge;const nn=Ke(c);Vt=`${Vt}.${nn}`}J.push(new r(Vt,i.NumericLiteral));continue}if(a(tn)){const Vt=Ke(a);J.push(new r(Vt,i.Identifier));continue}throw new SyntaxError(`Unexpected character: ${tn}`)}return J}var p=class{constructor(){Ce(this,"type","Statement")}},_=class extends p{constructor(le){super();Ce(this,"type","Program");this.body=le}},v=class extends p{constructor(le,J,se){super();Ce(this,"type","If");this.test=le,this.body=J,this.alternate=se}},S=class extends p{constructor(le,J,se,ge){super();Ce(this,"type","For");this.loopvar=le,this.iterable=J,this.body=se,this.defaultBlock=ge}},D=class extends p{constructor(){super(...arguments);Ce(this,"type","Break")}},w=class extends p{constructor(){super(...arguments);Ce(this,"type","Continue")}},T=class extends p{constructor(le,J,se){super();Ce(this,"type","Set");this.assignee=le,this.value=J,this.body=se}},F=class extends p{constructor(le,J,se){super();Ce(this,"type","Macro");this.name=le,this.args=J,this.body=se}},E=class extends p{constructor(le){super();Ce(this,"type","Comment");this.value=le}},A=class extends p{constructor(){super(...arguments);Ce(this,"type","Expression")}},L=class extends A{constructor(le,J,se){super();Ce(this,"type","MemberExpression");this.object=le,this.property=J,this.computed=se}},I=class extends A{constructor(le,J){super();Ce(this,"type","CallExpression");this.callee=le,this.args=J}},R=class extends A{constructor(le){super();Ce(this,"type","Identifier");this.value=le}},N=class extends A{constructor(le){super();Ce(this,"type","Literal");this.value=le}},q=class extends N{constructor(){super(...arguments);Ce(this,"type","IntegerLiteral")}},ne=class extends N{constructor(){super(...arguments);Ce(this,"type","FloatLiteral")}},Q=class extends N{constructor(){super(...arguments);Ce(this,"type","StringLiteral")}},W=class extends N{constructor(){super(...arguments);Ce(this,"type","ArrayLiteral")}},te=class extends N{constructor(){super(...arguments);Ce(this,"type","TupleLiteral")}},K=class extends N{constructor(){super(...arguments);Ce(this,"type","ObjectLiteral")}},pe=class extends A{constructor(le,J,se){super();Ce(this,"type","BinaryExpression");this.operator=le,this.left=J,this.right=se}},be=class extends A{constructor(le,J){super();Ce(this,"type","FilterExpression");this.operand=le,this.filter=J}},Ee=class extends p{constructor(le,J){super();Ce(this,"type","FilterStatement");this.filter=le,this.body=J}},Ge=class extends A{constructor(le,J){super();Ce(this,"type","SelectExpression");this.lhs=le,this.test=J}},_e=class extends A{constructor(le,J,se){super();Ce(this,"type","TestExpression");this.operand=le,this.negate=J,this.test=se}},De=class extends A{constructor(le,J){super();Ce(this,"type","UnaryExpression");this.operator=le,this.argument=J}},he=class extends A{constructor(le=void 0,J=void 0,se=void 0){super();Ce(this,"type","SliceExpression");this.start=le,this.stop=J,this.step=se}},Z=class extends A{constructor(le,J){super();Ce(this,"type","KeywordArgumentExpression");this.key=le,this.value=J}},me=class extends A{constructor(le){super();Ce(this,"type","SpreadExpression");this.argument=le}},we=class extends p{constructor(le,J,se){super();Ce(this,"type","CallStatement");this.call=le,this.callerArgs=J,this.body=se}},xe=class extends A{constructor(le,J,se){super();Ce(this,"type","Ternary");this.condition=le,this.trueExpr=J,this.falseExpr=se}};function et(B){const le=new _([]);let J=0;function se(bt,ct){const Lt=B[J++];if(!Lt||Lt.type!==bt)throw new Error(`Parser Error: ${ct}. ${Lt.type} !== ${bt}.`);return Lt}function ge(bt){if(!Pt(bt))throw new SyntaxError(`Expected ${bt}`);++J}function Fe(){switch(B[J].type){case i.Comment:return new E(B[J++].value);case i.Text:return Tt();case i.OpenStatement:return en();case i.OpenExpression:return Dt();default:throw new SyntaxError(`Unexpected token type: ${B[J].type}`)}}function Ke(...bt){return J+bt.length<=B.length&&bt.every((ct,Lt)=>ct===B[J+Lt].type)}function pt(...bt){var ct,Lt,yn;return((ct=B[J])==null?void 0:ct.type)===i.OpenStatement&&((Lt=B[J+1])==null?void 0:Lt.type)===i.Identifier&&bt.includes((yn=B[J+1])==null?void 0:yn.value)}function Pt(...bt){return J+bt.length<=B.length&&bt.every((ct,Lt)=>B[J+Lt].type==="Identifier"&&ct===B[J+Lt].value)}function Tt(){return new Q(se(i.Text,"Expected text token").value)}function en(){if(se(i.OpenStatement,"Expected opening statement token"),B[J].type!==i.Identifier)throw new SyntaxError(`Unknown statement, got ${B[J].type}`);const bt=B[J].value;let ct;switch(bt){case"set":++J,ct=tn();break;case"if":++J,ct=Vt(),se(i.OpenStatement,"Expected {% token"),ge("endif"),se(i.CloseStatement,"Expected %} token");break;case"macro":++J,ct=nn(),se(i.OpenStatement,"Expected {% token"),ge("endmacro"),se(i.CloseStatement,"Expected %} token");break;case"for":++J,ct=bi(),se(i.OpenStatement,"Expected {% token"),ge("endfor"),se(i.CloseStatement,"Expected %} token");break;case"call":{++J;let Lt=null;Ke(i.OpenParen)&&(Lt=Wt());const yn=_i();if(yn.type!=="Identifier")throw new SyntaxError("Expected identifier following call statement");const Wi=Wt();se(i.CloseStatement,"Expected closing statement token");const it=[];for(;!pt("endcall");)it.push(Fe());se(i.OpenStatement,"Expected '{%'"),ge("endcall"),se(i.CloseStatement,"Expected closing statement token");const Es=new I(yn,Wi);ct=new we(Es,Lt,it);break}case"break":++J,se(i.CloseStatement,"Expected closing statement token"),ct=new D;break;case"continue":++J,se(i.CloseStatement,"Expected closing statement token"),ct=new w;break;case"filter":{++J;let Lt=_i();Lt instanceof R&&Ke(i.OpenParen)&&(Lt=zi(Lt)),se(i.CloseStatement,"Expected closing statement token");const yn=[];for(;!pt("endfilter");)yn.push(Fe());se(i.OpenStatement,"Expected '{%'"),ge("endfilter"),se(i.CloseStatement,"Expected '%}'"),ct=new Ee(Lt,yn);break}default:throw new SyntaxError(`Unknown statement type: ${bt}`)}return ct}function Dt(){se(i.OpenExpression,"Expected opening expression token");const bt=ui();return se(i.CloseExpression,"Expected closing expression token"),bt}function tn(){const bt=Tn();let ct=null;const Lt=[];if(Ke(i.Equals))++J,ct=Tn();else{for(se(i.CloseStatement,"Expected %} token");!pt("endset");)Lt.push(Fe());se(i.OpenStatement,"Expected {% token"),ge("endset")}return se(i.CloseStatement,"Expected closing statement token"),new T(bt,ct,Lt)}function Vt(){const bt=ui();se(i.CloseStatement,"Expected closing statement token");const ct=[],Lt=[];for(;!pt("elif","else","endif");)ct.push(Fe());if(pt("elif")){++J,++J;const yn=Vt();Lt.push(yn)}else if(pt("else"))for(++J,++J,se(i.CloseStatement,"Expected closing statement token");!pt("endif");)Lt.push(Fe());return new v(bt,ct,Lt)}function nn(){const bt=_i();if(bt.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const ct=Wt();se(i.CloseStatement,"Expected closing statement token");const Lt=[];for(;!pt("endmacro");)Lt.push(Fe());return new F(bt,ct,Lt)}function Tn(bt=!1){const ct=bt?_i:ui,Lt=[ct()],yn=Ke(i.Comma);for(;yn&&(++J,Lt.push(ct()),!!Ke(i.Comma)););return yn?new te(Lt):Lt[0]}function bi(){const bt=Tn(!0);if(!(bt instanceof R||bt instanceof te))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${bt.type} instead`);if(!Pt("in"))throw new SyntaxError("Expected `in` keyword following loop variable");++J;const ct=ui();se(i.CloseStatement,"Expected closing statement token");const Lt=[];for(;!pt("endfor","else");)Lt.push(Fe());const yn=[];if(pt("else"))for(++J,++J,se(i.CloseStatement,"Expected closing statement token");!pt("endfor");)yn.push(Fe());return new S(bt,ct,Lt,yn)}function ui(){return Bi()}function Bi(){const bt=gi();if(Pt("if")){++J;const ct=gi();if(Pt("else")){++J;const Lt=Bi();return new xe(ct,bt,Lt)}else return new Ge(bt,ct)}return bt}function gi(){let bt=ki();for(;Pt("or");){const ct=B[J];++J;const Lt=ki();bt=new pe(ct,bt,Lt)}return bt}function ki(){let bt=Mi();for(;Pt("and");){const ct=B[J];++J;const Lt=Mi();bt=new pe(ct,bt,Lt)}return bt}function Mi(){let bt;for(;Pt("not");){const ct=B[J];++J;const Lt=Mi();bt=new De(ct,Lt)}return bt??Ms()}function Ms(){let bt=Ts();for(;;){let ct;if(Pt("not","in"))ct=new r("not in",i.Identifier),J+=2;else if(Pt("in"))ct=B[J++];else if(Ke(i.ComparisonBinaryOperator))ct=B[J++];else break;const Lt=Ts();bt=new pe(ct,bt,Lt)}return bt}function Ts(){let bt=Ns();for(;Ke(i.AdditiveBinaryOperator);){const ct=B[J];++J;const Lt=Ns();bt=new pe(ct,bt,Lt)}return bt}function zs(){const bt=$s(_i());return Ke(i.OpenParen)?zi(bt):bt}function zi(bt){let ct=new I(bt,Wt());return ct=$s(ct),Ke(i.OpenParen)&&(ct=zi(ct)),ct}function Wt(){se(i.OpenParen,"Expected opening parenthesis for arguments list");const bt=ji();return se(i.CloseParen,"Expected closing parenthesis for arguments list"),bt}function ji(){const bt=[];for(;!Ke(i.CloseParen);){let ct;if(B[J].type===i.MultiplicativeBinaryOperator&&B[J].value==="*"){++J;const Lt=ui();ct=new me(Lt)}else if(ct=ui(),Ke(i.Equals)){if(++J,!(ct instanceof R))throw new SyntaxError("Expected identifier for keyword argument");const Lt=ui();ct=new Z(ct,Lt)}bt.push(ct),Ke(i.Comma)&&++J}return bt}function or(){const bt=[];let ct=!1;for(;!Ke(i.CloseSquareBracket);)Ke(i.Colon)?(bt.push(void 0),++J,ct=!0):(bt.push(ui()),Ke(i.Colon)&&(++J,ct=!0));if(bt.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(ct){if(bt.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new he(...bt)}return bt[0]}function $s(bt){for(;Ke(i.Dot)||Ke(i.OpenSquareBracket);){const ct=B[J];++J;let Lt;const yn=ct.type===i.OpenSquareBracket;if(yn)Lt=or(),se(i.CloseSquareBracket,"Expected closing square bracket");else if(Lt=_i(),Lt.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");bt=new L(bt,Lt,yn)}return bt}function Ns(){let bt=Us();for(;Ke(i.MultiplicativeBinaryOperator);){const ct=B[J++],Lt=Us();bt=new pe(ct,bt,Lt)}return bt}function Us(){let bt=rs();for(;Pt("is");){++J;const ct=Pt("not");ct&&++J;const Lt=_i();if(!(Lt instanceof R))throw new SyntaxError("Expected identifier for the test");bt=new _e(bt,ct,Lt)}return bt}function rs(){let bt=zs();for(;Ke(i.Pipe);){++J;let ct=_i();if(!(ct instanceof R))throw new SyntaxError("Expected identifier for the filter");Ke(i.OpenParen)&&(ct=zi(ct)),bt=new be(bt,ct)}return bt}function _i(){const bt=B[J++];switch(bt.type){case i.NumericLiteral:{const ct=bt.value;return ct.includes(".")?new ne(Number(ct)):new q(Number(ct))}case i.StringLiteral:{let ct=bt.value;for(;Ke(i.StringLiteral);)ct+=B[J++].value;return new Q(ct)}case i.Identifier:return new R(bt.value);case i.OpenParen:{const ct=Tn();return se(i.CloseParen,"Expected closing parenthesis, got ${tokens[current].type} instead."),ct}case i.OpenSquareBracket:{const ct=[];for(;!Ke(i.CloseSquareBracket);)ct.push(ui()),Ke(i.Comma)&&++J;return++J,new W(ct)}case i.OpenCurlyBracket:{const ct=new Map;for(;!Ke(i.CloseCurlyBracket);){const Lt=ui();se(i.Colon,"Expected colon between key and value in object literal");const yn=ui();ct.set(Lt,yn),Ke(i.Comma)&&++J}return++J,new K(ct)}default:throw new SyntaxError(`Unexpected token: ${bt.type}`)}}for(;J<B.length;)le.body.push(Fe());return le}function Ve(B,le,J=1){le===void 0&&(le=B,B=0);const se=[];for(let ge=B;ge<le;ge+=J)se.push(ge);return se}function nt(B,le,J,se=1){const ge=Math.sign(se);ge>=0?(le=(le??(le=0))<0?Math.max(B.length+le,0):Math.min(le,B.length),J=(J??(J=B.length))<0?Math.max(B.length+J,0):Math.min(J,B.length)):(le=(le??(le=B.length-1))<0?Math.max(B.length+le,-1):Math.min(le,B.length-1),J=(J??(J=-1))<-1?Math.max(B.length+J,-1):Math.min(J,B.length-1));const Fe=[];for(let Ke=le;ge*Ke<ge*J;Ke+=se)Fe.push(B[Ke]);return Fe}function Be(B){return B.replace(/\b\w/g,le=>le.toUpperCase())}function ae(B){return U(new Date,B)}function U(B,le){const J=new Intl.DateTimeFormat(void 0,{month:"long"}),se=new Intl.DateTimeFormat(void 0,{month:"short"}),ge=Fe=>Fe<10?"0"+Fe:Fe.toString();return le.replace(/%[YmdbBHM%]/g,Fe=>{switch(Fe){case"%Y":return B.getFullYear().toString();case"%m":return ge(B.getMonth()+1);case"%d":return ge(B.getDate());case"%b":return se.format(B);case"%B":return J.format(B);case"%H":return ge(B.getHours());case"%M":return ge(B.getMinutes());case"%%":return"%";default:return Fe}})}function Se(B){return B.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function ze(B,le,J,se){if(se===0)return B;let ge=se==null||se<0?1/0:se;const Fe=le.length===0?new RegExp("(?=)","gu"):new RegExp(Se(le),"gu");return B.replaceAll(Fe,Ke=>ge>0?(--ge,J):Ke)}var Oe=class extends Error{},Ye=class extends Error{},H=class{constructor(B=void 0){Ce(this,"type","RuntimeValue");Ce(this,"value");Ce(this,"builtins",new Map);this.value=B}__bool__(){return new fe(!!this.value)}toString(){return String(this.value)}},Y=class extends H{constructor(){super(...arguments);Ce(this,"type","IntegerValue")}},$e=class extends H{constructor(){super(...arguments);Ce(this,"type","FloatValue")}toString(){return this.value%1===0?this.value.toFixed(1):this.value.toString()}},Ie=class extends H{constructor(){super(...arguments);Ce(this,"type","StringValue");Ce(this,"builtins",new Map([["upper",new tt(()=>new Ie(this.value.toUpperCase()))],["lower",new tt(()=>new Ie(this.value.toLowerCase()))],["strip",new tt(()=>new Ie(this.value.trim()))],["title",new tt(()=>new Ie(Be(this.value)))],["capitalize",new tt(()=>new Ie(this.value.charAt(0).toUpperCase()+this.value.slice(1)))],["length",new Y(this.value.length)],["rstrip",new tt(()=>new Ie(this.value.trimEnd()))],["lstrip",new tt(()=>new Ie(this.value.trimStart()))],["startswith",new tt(le=>{if(le.length===0)throw new Error("startswith() requires at least one argument");const J=le[0];if(J instanceof Ie)return new fe(this.value.startsWith(J.value));if(J instanceof de){for(const se of J.value){if(!(se instanceof Ie))throw new Error("startswith() tuple elements must be strings");if(this.value.startsWith(se.value))return new fe(!0)}return new fe(!1)}throw new Error("startswith() argument must be a string or tuple of strings")})],["endswith",new tt(le=>{if(le.length===0)throw new Error("endswith() requires at least one argument");const J=le[0];if(J instanceof Ie)return new fe(this.value.endsWith(J.value));if(J instanceof de){for(const se of J.value){if(!(se instanceof Ie))throw new Error("endswith() tuple elements must be strings");if(this.value.endsWith(se.value))return new fe(!0)}return new fe(!1)}throw new Error("endswith() argument must be a string or tuple of strings")})],["split",new tt(le=>{const J=le[0]??new He;if(!(J instanceof Ie||J instanceof He))throw new Error("sep argument must be a string or null");const se=le[1]??new Y(-1);if(!(se instanceof Y))throw new Error("maxsplit argument must be a number");let ge=[];if(J instanceof He){const Fe=this.value.trimStart();for(const{0:Ke,index:pt}of Fe.matchAll(/\S+/g)){if(se.value!==-1&&ge.length>=se.value&&pt!==void 0){ge.push(Ke+Fe.slice(pt+Ke.length));break}ge.push(Ke)}}else{if(J.value==="")throw new Error("empty separator");ge=this.value.split(J.value),se.value!==-1&&ge.length>se.value&&ge.push(ge.splice(se.value).join(J.value))}return new de(ge.map(Fe=>new Ie(Fe)))})],["replace",new tt(le=>{if(le.length<2)throw new Error("replace() requires at least two arguments");const J=le[0],se=le[1];if(!(J instanceof Ie&&se instanceof Ie))throw new Error("replace() arguments must be strings");let ge;if(le.length>2?le[2].type==="KeywordArgumentsValue"?ge=le[2].value.get("count")??new He:ge=le[2]:ge=new He,!(ge instanceof Y||ge instanceof He))throw new Error("replace() count argument must be a number or null");return new Ie(ze(this.value,J.value,se.value,ge.value))})]]))}},fe=class extends H{constructor(){super(...arguments);Ce(this,"type","BooleanValue")}};function Qe(B,le,J,se=!0){const ge=J??0;switch(B.type){case"NullValue":return"null";case"UndefinedValue":return se?"null":"undefined";case"IntegerValue":case"FloatValue":case"StringValue":case"BooleanValue":return JSON.stringify(B.value);case"ArrayValue":case"ObjectValue":{const Fe=le?" ".repeat(le):"",Ke=`
`+Fe.repeat(ge),pt=Ke+Fe;if(B.type==="ArrayValue"){const Pt=B.value.map(Tt=>Qe(Tt,le,ge+1,se));return le?`[${pt}${Pt.join(`,${pt}`)}${Ke}]`:`[${Pt.join(", ")}]`}else{const Pt=Array.from(B.value.entries()).map(([Tt,en])=>{const Dt=`"${Tt}": ${Qe(en,le,ge+1,se)}`;return le?`${pt}${Dt}`:Dt});return le?`{${Pt.join(",")}${Ke}}`:`{${Pt.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${B.type}`)}}var Ne=class extends H{constructor(){super(...arguments);Ce(this,"type","ObjectValue");Ce(this,"builtins",new Map([["get",new tt(([le,J])=>{if(!(le instanceof Ie))throw new Error(`Object key must be a string: got ${le.type}`);return this.value.get(le.value)??J??new He})],["items",new tt(()=>this.items())],["keys",new tt(()=>this.keys())],["values",new tt(()=>this.values())],["dictsort",new tt(le=>{let J=new Map;const se=le.filter(Pt=>Pt instanceof ut?(J=Pt.value,!1):!0),ge=se.at(0)??J.get("case_sensitive")??new fe(!1);if(!(ge instanceof fe))throw new Error("case_sensitive must be a boolean");const Fe=se.at(1)??J.get("by")??new Ie("key");if(!(Fe instanceof Ie))throw new Error("by must be a string");if(!["key","value"].includes(Fe.value))throw new Error("by must be either 'key' or 'value'");const Ke=se.at(2)??J.get("reverse")??new fe(!1);if(!(Ke instanceof fe))throw new Error("reverse must be a boolean");const pt=Array.from(this.value.entries()).map(([Pt,Tt])=>new de([new Ie(Pt),Tt])).sort((Pt,Tt)=>{const en=Fe.value==="key"?0:1,Dt=Pt.value[en],tn=Tt.value[en],Vt=Xt(Dt,tn,ge.value);return Ke.value?-Vt:Vt});return new de(pt)})]]))}__bool__(){return new fe(this.value.size>0)}items(){return new de(Array.from(this.value.entries()).map(([le,J])=>new de([new Ie(le),J])))}keys(){return new de(Array.from(this.value.keys()).map(le=>new Ie(le)))}values(){return new de(Array.from(this.value.values()))}toString(){return Qe(this,null,0,!1)}},ut=class extends Ne{constructor(){super(...arguments);Ce(this,"type","KeywordArgumentsValue")}},de=class extends H{constructor(){super(...arguments);Ce(this,"type","ArrayValue");Ce(this,"builtins",new Map([["length",new Y(this.value.length)]]))}__bool__(){return new fe(this.value.length>0)}toString(){return Qe(this,null,0,!1)}},qe=class extends de{constructor(){super(...arguments);Ce(this,"type","TupleValue")}},tt=class extends H{constructor(){super(...arguments);Ce(this,"type","FunctionValue")}},He=class extends H{constructor(){super(...arguments);Ce(this,"type","NullValue")}},je=class extends H{constructor(){super(...arguments);Ce(this,"type","UndefinedValue")}},lt=class{constructor(B){Ce(this,"variables",new Map([["namespace",new tt(B=>{if(B.length===0)return new Ne(new Map);if(B.length!==1||!(B[0]instanceof Ne))throw new Error("`namespace` expects either zero arguments or a single object argument");return B[0]})]]));Ce(this,"tests",new Map([["boolean",B=>B.type==="BooleanValue"],["callable",B=>B instanceof tt],["odd",B=>{if(!(B instanceof Y))throw new Error(`cannot odd on ${B.type}`);return B.value%2!==0}],["even",B=>{if(!(B instanceof Y))throw new Error(`cannot even on ${B.type}`);return B.value%2===0}],["false",B=>B.type==="BooleanValue"&&!B.value],["true",B=>B.type==="BooleanValue"&&B.value],["none",B=>B.type==="NullValue"],["string",B=>B.type==="StringValue"],["number",B=>B instanceof Y||B instanceof $e],["integer",B=>B instanceof Y],["iterable",B=>B.type==="ArrayValue"||B.type==="StringValue"],["mapping",B=>B.type==="ObjectValue"],["lower",B=>{const le=B.value;return B.type==="StringValue"&&le===le.toLowerCase()}],["upper",B=>{const le=B.value;return B.type==="StringValue"&&le===le.toUpperCase()}],["none",B=>B.type==="NullValue"],["defined",B=>B.type!=="UndefinedValue"],["undefined",B=>B.type==="UndefinedValue"],["equalto",(B,le)=>B.value===le.value],["eq",(B,le)=>B.value===le.value]]));this.parent=B}set(B,le){return this.declareVariable(B,xn(le))}declareVariable(B,le){if(this.variables.has(B))throw new SyntaxError(`Variable already declared: ${B}`);return this.variables.set(B,le),le}setVariable(B,le){return this.variables.set(B,le),le}resolve(B){if(this.variables.has(B))return this;if(this.parent)return this.parent.resolve(B);throw new Error(`Unknown variable: ${B}`)}lookupVariable(B){try{return this.resolve(B).variables.get(B)??new je}catch{return new je}}};function Mt(B){B.set("false",!1),B.set("true",!0),B.set("none",null),B.set("raise_exception",le=>{throw new Error(le)}),B.set("range",Ve),B.set("strftime_now",ae),B.set("True",!0),B.set("False",!1),B.set("None",null)}function Rt(B,le){const J=le.split(".");let se=B;for(const ge of J)if(se instanceof Ne)se=se.value.get(ge)??new je;else if(se instanceof de){const Fe=parseInt(ge,10);if(!isNaN(Fe)&&Fe>=0&&Fe<se.value.length)se=se.value[Fe];else return new je}else return new je;return se}function Xt(B,le,J=!1){if(B instanceof He&&le instanceof He)return 0;if(B instanceof He||le instanceof He)throw new Error(`Cannot compare ${B.type} with ${le.type}`);if(B instanceof je&&le instanceof je)return 0;if(B instanceof je||le instanceof je)throw new Error(`Cannot compare ${B.type} with ${le.type}`);const se=Fe=>Fe instanceof Y||Fe instanceof $e||Fe instanceof fe,ge=Fe=>Fe instanceof fe?Fe.value?1:0:Fe.value;if(se(B)&&se(le)){const Fe=ge(B),Ke=ge(le);return Fe<Ke?-1:Fe>Ke?1:0}if(B.type!==le.type)throw new Error(`Cannot compare different types: ${B.type} and ${le.type}`);switch(B.type){case"StringValue":{let Fe=B.value,Ke=le.value;return J||(Fe=Fe.toLowerCase(),Ke=Ke.toLowerCase()),Fe<Ke?-1:Fe>Ke?1:0}default:throw new Error(`Cannot compare type: ${B.type}`)}}var wn=class{constructor(B){Ce(this,"global");this.global=B??new lt}run(B){return this.evaluate(B,this.global)}evaluateBinaryExpression(B,le){const J=this.evaluate(B.left,le);switch(B.operator.value){case"and":return J.__bool__().value?this.evaluate(B.right,le):J;case"or":return J.__bool__().value?J:this.evaluate(B.right,le)}const se=this.evaluate(B.right,le);switch(B.operator.value){case"==":return new fe(J.value==se.value);case"!=":return new fe(J.value!=se.value)}if(J instanceof je||se instanceof je){if(se instanceof je&&["in","not in"].includes(B.operator.value))return new fe(B.operator.value==="not in");throw new Error(`Cannot perform operation ${B.operator.value} on undefined values`)}else{if(J instanceof He||se instanceof He)throw new Error("Cannot perform operation on null values");if(B.operator.value==="~")return new Ie(J.value.toString()+se.value.toString());if((J instanceof Y||J instanceof $e)&&(se instanceof Y||se instanceof $e)){const ge=J.value,Fe=se.value;switch(B.operator.value){case"+":case"-":case"*":{const Ke=B.operator.value==="+"?ge+Fe:B.operator.value==="-"?ge-Fe:ge*Fe;return J instanceof $e||se instanceof $e?new $e(Ke):new Y(Ke)}case"/":return new $e(ge/Fe);case"%":{const Ke=ge%Fe;return J instanceof $e||se instanceof $e?new $e(Ke):new Y(Ke)}case"<":return new fe(ge<Fe);case">":return new fe(ge>Fe);case">=":return new fe(ge>=Fe);case"<=":return new fe(ge<=Fe)}}else if(J instanceof de&&se instanceof de)switch(B.operator.value){case"+":return new de(J.value.concat(se.value))}else if(se instanceof de){const ge=se.value.find(Fe=>Fe.value===J.value)!==void 0;switch(B.operator.value){case"in":return new fe(ge);case"not in":return new fe(!ge)}}}if(J instanceof Ie||se instanceof Ie)switch(B.operator.value){case"+":return new Ie(J.value.toString()+se.value.toString())}if(J instanceof Ie&&se instanceof Ie)switch(B.operator.value){case"in":return new fe(se.value.includes(J.value));case"not in":return new fe(!se.value.includes(J.value))}if(J instanceof Ie&&se instanceof Ne)switch(B.operator.value){case"in":return new fe(se.value.has(J.value));case"not in":return new fe(!se.value.has(J.value))}throw new SyntaxError(`Unknown operator "${B.operator.value}" between ${J.type} and ${se.type}`)}evaluateArguments(B,le){const J=[],se=new Map;for(const ge of B)if(ge.type==="SpreadExpression"){const Fe=ge,Ke=this.evaluate(Fe.argument,le);if(!(Ke instanceof de))throw new Error(`Cannot unpack non-iterable type: ${Ke.type}`);for(const pt of Ke.value)J.push(pt)}else if(ge.type==="KeywordArgumentExpression"){const Fe=ge;se.set(Fe.key.value,this.evaluate(Fe.value,le))}else{if(se.size>0)throw new Error("Positional arguments must come before keyword arguments");J.push(this.evaluate(ge,le))}return[J,se]}applyFilter(B,le,J){if(le.type==="Identifier"){const se=le;if(se.value==="tojson")return new Ie(Qe(B));if(B instanceof de)switch(se.value){case"list":return B;case"first":return B.value[0];case"last":return B.value[B.value.length-1];case"length":return new Y(B.value.length);case"reverse":return new de(B.value.slice().reverse());case"sort":return new de(B.value.slice().sort((ge,Fe)=>Xt(ge,Fe,!1)));case"join":return new Ie(B.value.map(ge=>ge.value).join(""));case"string":return new Ie(Qe(B,null,0,!1));case"unique":{const ge=new Set,Fe=[];for(const Ke of B.value)ge.has(Ke.value)||(ge.add(Ke.value),Fe.push(Ke));return new de(Fe)}default:throw new Error(`Unknown ArrayValue filter: ${se.value}`)}else if(B instanceof Ie)switch(se.value){case"length":case"upper":case"lower":case"title":case"capitalize":{const ge=B.builtins.get(se.value);if(ge instanceof tt)return ge.value([],J);if(ge instanceof Y)return ge;throw new Error(`Unknown StringValue filter: ${se.value}`)}case"trim":return new Ie(B.value.trim());case"indent":return new Ie(B.value.split(`
`).map((ge,Fe)=>Fe===0||ge.length===0?ge:"    "+ge).join(`
`));case"join":case"string":return B;case"int":{const ge=parseInt(B.value,10);return new Y(isNaN(ge)?0:ge)}case"float":{const ge=parseFloat(B.value);return new $e(isNaN(ge)?0:ge)}default:throw new Error(`Unknown StringValue filter: ${se.value}`)}else if(B instanceof Y||B instanceof $e)switch(se.value){case"abs":return B instanceof Y?new Y(Math.abs(B.value)):new $e(Math.abs(B.value));case"int":return new Y(Math.floor(B.value));case"float":return new $e(B.value);default:throw new Error(`Unknown NumericValue filter: ${se.value}`)}else if(B instanceof Ne)switch(se.value){case"items":return new de(Array.from(B.value.entries()).map(([ge,Fe])=>new de([new Ie(ge),Fe])));case"length":return new Y(B.value.size);default:{const ge=B.builtins.get(se.value);if(ge)return ge instanceof tt?ge.value([],J):ge;throw new Error(`Unknown ObjectValue filter: ${se.value}`)}}else if(B instanceof fe)switch(se.value){case"bool":return new fe(B.value);case"int":return new Y(B.value?1:0);case"float":return new $e(B.value?1:0);case"string":return new Ie(B.value?"true":"false");default:throw new Error(`Unknown BooleanValue filter: ${se.value}`)}throw new Error(`Cannot apply filter "${se.value}" to type: ${B.type}`)}else if(le.type==="CallExpression"){const se=le;if(se.callee.type!=="Identifier")throw new Error(`Unknown filter: ${se.callee.type}`);const ge=se.callee.value;if(ge==="tojson"){const[,Fe]=this.evaluateArguments(se.args,J),Ke=Fe.get("indent")??new He;if(!(Ke instanceof Y||Ke instanceof He))throw new Error("If set, indent must be a number");return new Ie(Qe(B,Ke.value))}else if(ge==="join"){let Fe;if(B instanceof Ie)Fe=Array.from(B.value);else if(B instanceof de)Fe=B.value.map(Tt=>Tt.value);else throw new Error(`Cannot apply filter "${ge}" to type: ${B.type}`);const[Ke,pt]=this.evaluateArguments(se.args,J),Pt=Ke.at(0)??pt.get("separator")??new Ie("");if(!(Pt instanceof Ie))throw new Error("separator must be a string");return new Ie(Fe.join(Pt.value))}else if(ge==="int"||ge==="float"){const[Fe,Ke]=this.evaluateArguments(se.args,J),pt=Fe.at(0)??Ke.get("default")??(ge==="int"?new Y(0):new $e(0));if(B instanceof Ie){const Pt=ge==="int"?parseInt(B.value,10):parseFloat(B.value);return isNaN(Pt)?pt:ge==="int"?new Y(Pt):new $e(Pt)}else{if(B instanceof Y||B instanceof $e)return B;if(B instanceof fe)return ge==="int"?new Y(B.value?1:0):new $e(B.value?1:0);throw new Error(`Cannot apply filter "${ge}" to type: ${B.type}`)}}else if(ge==="default"){const[Fe,Ke]=this.evaluateArguments(se.args,J),pt=Fe[0]??new Ie(""),Pt=Fe[1]??Ke.get("boolean")??new fe(!1);if(!(Pt instanceof fe))throw new Error("`default` filter flag must be a boolean");return B instanceof je||Pt.value&&!B.__bool__().value?pt:B}if(B instanceof de){switch(ge){case"sort":{const[Fe,Ke]=this.evaluateArguments(se.args,J),pt=Fe.at(0)??Ke.get("reverse")??new fe(!1);if(!(pt instanceof fe))throw new Error("reverse must be a boolean");const Pt=Fe.at(1)??Ke.get("case_sensitive")??new fe(!1);if(!(Pt instanceof fe))throw new Error("case_sensitive must be a boolean");const Tt=Fe.at(2)??Ke.get("attribute")??new He;if(!(Tt instanceof Ie||Tt instanceof Y||Tt instanceof He))throw new Error("attribute must be a string, integer, or null");const en=Dt=>{if(Tt instanceof He)return Dt;const tn=Tt instanceof Y?String(Tt.value):Tt.value;return Rt(Dt,tn)};return new de(B.value.slice().sort((Dt,tn)=>{const Vt=en(Dt),nn=en(tn),Tn=Xt(Vt,nn,Pt.value);return pt.value?-Tn:Tn}))}case"selectattr":case"rejectattr":{const Fe=ge==="selectattr";if(B.value.some(Dt=>!(Dt instanceof Ne)))throw new Error(`\`${ge}\` can only be applied to array of objects`);if(se.args.some(Dt=>Dt.type!=="StringLiteral"))throw new Error(`arguments of \`${ge}\` must be strings`);const[Ke,pt,Pt]=se.args.map(Dt=>this.evaluate(Dt,J));let Tt;if(pt){const Dt=J.tests.get(pt.value);if(!Dt)throw new Error(`Unknown test: ${pt.value}`);Tt=Dt}else Tt=(...Dt)=>Dt[0].__bool__().value;const en=B.value.filter(Dt=>{const tn=Dt.value.get(Ke.value),Vt=tn?Tt(tn,Pt):!1;return Fe?Vt:!Vt});return new de(en)}case"map":{const[,Fe]=this.evaluateArguments(se.args,J);if(Fe.has("attribute")){const Ke=Fe.get("attribute");if(!(Ke instanceof Ie))throw new Error("attribute must be a string");const pt=Fe.get("default"),Pt=B.value.map(Tt=>{if(!(Tt instanceof Ne))throw new Error("items in map must be an object");const en=Rt(Tt,Ke.value);return en instanceof je?pt??new je:en});return new de(Pt)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${ge}`)}else if(B instanceof Ie){switch(ge){case"indent":{const[Fe,Ke]=this.evaluateArguments(se.args,J),pt=Fe.at(0)??Ke.get("width")??new Y(4);if(!(pt instanceof Y))throw new Error("width must be a number");const Pt=Fe.at(1)??Ke.get("first")??new fe(!1),Tt=Fe.at(2)??Ke.get("blank")??new fe(!1),en=B.value.split(`
`),Dt=" ".repeat(pt.value),tn=en.map((Vt,nn)=>!Pt.value&&nn===0||!Tt.value&&Vt.length===0?Vt:Dt+Vt);return new Ie(tn.join(`
`))}case"replace":{const Fe=B.builtins.get("replace");if(!(Fe instanceof tt))throw new Error("replace filter not available");const[Ke,pt]=this.evaluateArguments(se.args,J);return Fe.value([...Ke,new ut(pt)],J)}}throw new Error(`Unknown StringValue filter: ${ge}`)}else if(B instanceof Ne){const Fe=B.builtins.get(ge);if(Fe&&Fe instanceof tt){const[Ke,pt]=this.evaluateArguments(se.args,J);return pt.size>0&&Ke.push(new ut(pt)),Fe.value(Ke,J)}throw new Error(`Unknown ObjectValue filter: ${ge}`)}else throw new Error(`Cannot apply filter "${ge}" to type: ${B.type}`)}throw new Error(`Unknown filter: ${le.type}`)}evaluateFilterExpression(B,le){const J=this.evaluate(B.operand,le);return this.applyFilter(J,B.filter,le)}evaluateTestExpression(B,le){const J=this.evaluate(B.operand,le),se=le.tests.get(B.test.value);if(!se)throw new Error(`Unknown test: ${B.test.value}`);const ge=se(J);return new fe(B.negate?!ge:ge)}evaluateSelectExpression(B,le){return this.evaluate(B.test,le).__bool__().value?this.evaluate(B.lhs,le):new je}evaluateUnaryExpression(B,le){const J=this.evaluate(B.argument,le);switch(B.operator.value){case"not":return new fe(!J.value);default:throw new SyntaxError(`Unknown operator: ${B.operator.value}`)}}evaluateTernaryExpression(B,le){return this.evaluate(B.condition,le).__bool__().value?this.evaluate(B.trueExpr,le):this.evaluate(B.falseExpr,le)}evalProgram(B,le){return this.evaluateBlock(B.body,le)}evaluateBlock(B,le){let J="";for(const se of B){const ge=this.evaluate(se,le);ge.type!=="NullValue"&&ge.type!=="UndefinedValue"&&(J+=ge.toString())}return new Ie(J)}evaluateIdentifier(B,le){return le.lookupVariable(B.value)}evaluateCallExpression(B,le){const[J,se]=this.evaluateArguments(B.args,le);se.size>0&&J.push(new ut(se));const ge=this.evaluate(B.callee,le);if(ge.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${ge.type}`);return ge.value(J,le)}evaluateSliceExpression(B,le,J){if(!(B instanceof de||B instanceof Ie))throw new Error("Slice object must be an array or string");const se=this.evaluate(le.start,J),ge=this.evaluate(le.stop,J),Fe=this.evaluate(le.step,J);if(!(se instanceof Y||se instanceof je))throw new Error("Slice start must be numeric or undefined");if(!(ge instanceof Y||ge instanceof je))throw new Error("Slice stop must be numeric or undefined");if(!(Fe instanceof Y||Fe instanceof je))throw new Error("Slice step must be numeric or undefined");return B instanceof de?new de(nt(B.value,se.value,ge.value,Fe.value)):new Ie(nt(Array.from(B.value),se.value,ge.value,Fe.value).join(""))}evaluateMemberExpression(B,le){const J=this.evaluate(B.object,le);let se;if(B.computed){if(B.property.type==="SliceExpression")return this.evaluateSliceExpression(J,B.property,le);se=this.evaluate(B.property,le)}else se=new Ie(B.property.value);let ge;if(J instanceof Ne){if(!(se instanceof Ie))throw new Error(`Cannot access property with non-string: got ${se.type}`);ge=J.value.get(se.value)??J.builtins.get(se.value)}else if(J instanceof de||J instanceof Ie)if(se instanceof Y)ge=J.value.at(se.value),J instanceof Ie&&(ge=new Ie(J.value.at(se.value)));else if(se instanceof Ie)ge=J.builtins.get(se.value);else throw new Error(`Cannot access property with non-string/non-number: got ${se.type}`);else{if(!(se instanceof Ie))throw new Error(`Cannot access property with non-string: got ${se.type}`);ge=J.builtins.get(se.value)}return ge instanceof H?ge:new je}evaluateSet(B,le){const J=B.value?this.evaluate(B.value,le):this.evaluateBlock(B.body,le);if(B.assignee.type==="Identifier"){const se=B.assignee.value;le.setVariable(se,J)}else if(B.assignee.type==="TupleLiteral"){const se=B.assignee;if(!(J instanceof de))throw new Error(`Cannot unpack non-iterable type in set: ${J.type}`);const ge=J.value;if(ge.length!==se.value.length)throw new Error(`Too ${se.value.length>ge.length?"few":"many"} items to unpack in set`);for(let Fe=0;Fe<se.value.length;++Fe){const Ke=se.value[Fe];if(Ke.type!=="Identifier")throw new Error(`Cannot unpack to non-identifier in set: ${Ke.type}`);le.setVariable(Ke.value,ge[Fe])}}else if(B.assignee.type==="MemberExpression"){const se=B.assignee,ge=this.evaluate(se.object,le);if(!(ge instanceof Ne))throw new Error("Cannot assign to member of non-object");if(se.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");ge.value.set(se.property.value,J)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(B.assignee)}`);return new He}evaluateIf(B,le){const J=this.evaluate(B.test,le);return this.evaluateBlock(J.__bool__().value?B.body:B.alternate,le)}evaluateFor(B,le){const J=new lt(le);let se,ge;if(B.iterable.type==="SelectExpression"){const Tt=B.iterable;ge=this.evaluate(Tt.lhs,J),se=Tt.test}else ge=this.evaluate(B.iterable,J);if(!(ge instanceof de||ge instanceof Ne))throw new Error(`Expected iterable or object type in for loop: got ${ge.type}`);ge instanceof Ne&&(ge=ge.keys());const Fe=[],Ke=[];for(let Tt=0;Tt<ge.value.length;++Tt){const en=new lt(J),Dt=ge.value[Tt];let tn;if(B.loopvar.type==="Identifier")tn=Vt=>Vt.setVariable(B.loopvar.value,Dt);else if(B.loopvar.type==="TupleLiteral"){const Vt=B.loopvar;if(Dt.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${Dt.type}`);const nn=Dt;if(Vt.value.length!==nn.value.length)throw new Error(`Too ${Vt.value.length>nn.value.length?"few":"many"} items to unpack`);tn=Tn=>{for(let bi=0;bi<Vt.value.length;++bi){if(Vt.value[bi].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${Vt.value[bi].type}`);Tn.setVariable(Vt.value[bi].value,nn.value[bi])}}}else throw new Error(`Invalid loop variable(s): ${B.loopvar.type}`);se&&(tn(en),!this.evaluate(se,en).__bool__().value)||(Fe.push(Dt),Ke.push(tn))}let pt="",Pt=!0;for(let Tt=0;Tt<Fe.length;++Tt){const en=new Map([["index",new Y(Tt+1)],["index0",new Y(Tt)],["revindex",new Y(Fe.length-Tt)],["revindex0",new Y(Fe.length-Tt-1)],["first",new fe(Tt===0)],["last",new fe(Tt===Fe.length-1)],["length",new Y(Fe.length)],["previtem",Tt>0?Fe[Tt-1]:new je],["nextitem",Tt<Fe.length-1?Fe[Tt+1]:new je]]);J.setVariable("loop",new Ne(en)),Ke[Tt](J);try{const Dt=this.evaluateBlock(B.body,J);pt+=Dt.value}catch(Dt){if(Dt instanceof Ye)continue;if(Dt instanceof Oe)break;throw Dt}Pt=!1}if(Pt){const Tt=this.evaluateBlock(B.defaultBlock,J);pt+=Tt.value}return new Ie(pt)}evaluateMacro(B,le){return le.setVariable(B.name.value,new tt((J,se)=>{var Ke;const ge=new lt(se);J=J.slice();let Fe;((Ke=J.at(-1))==null?void 0:Ke.type)==="KeywordArgumentsValue"&&(Fe=J.pop());for(let pt=0;pt<B.args.length;++pt){const Pt=B.args[pt],Tt=J[pt];if(Pt.type==="Identifier"){const en=Pt;if(!Tt)throw new Error(`Missing positional argument: ${en.value}`);ge.setVariable(en.value,Tt)}else if(Pt.type==="KeywordArgumentExpression"){const en=Pt,Dt=Tt??(Fe==null?void 0:Fe.value.get(en.key.value))??this.evaluate(en.value,ge);ge.setVariable(en.key.value,Dt)}else throw new Error(`Unknown argument type: ${Pt.type}`)}return this.evaluateBlock(B.body,ge)})),new He}evaluateCallStatement(B,le){const J=new tt((pt,Pt)=>{const Tt=new lt(Pt);if(B.callerArgs)for(let en=0;en<B.callerArgs.length;++en){const Dt=B.callerArgs[en];if(Dt.type!=="Identifier")throw new Error(`Caller parameter must be an identifier, got ${Dt.type}`);Tt.setVariable(Dt.value,pt[en]??new je)}return this.evaluateBlock(B.body,Tt)}),[se,ge]=this.evaluateArguments(B.call.args,le);se.push(new ut(ge));const Fe=this.evaluate(B.call.callee,le);if(Fe.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${Fe.type}`);const Ke=new lt(le);return Ke.setVariable("caller",J),Fe.value(se,Ke)}evaluateFilterStatement(B,le){const J=this.evaluateBlock(B.body,le);return this.applyFilter(J,B.filter,le)}evaluate(B,le){if(!B)return new je;switch(B.type){case"Program":return this.evalProgram(B,le);case"Set":return this.evaluateSet(B,le);case"If":return this.evaluateIf(B,le);case"For":return this.evaluateFor(B,le);case"Macro":return this.evaluateMacro(B,le);case"CallStatement":return this.evaluateCallStatement(B,le);case"Break":throw new Oe;case"Continue":throw new Ye;case"IntegerLiteral":return new Y(B.value);case"FloatLiteral":return new $e(B.value);case"StringLiteral":return new Ie(B.value);case"ArrayLiteral":return new de(B.value.map(J=>this.evaluate(J,le)));case"TupleLiteral":return new qe(B.value.map(J=>this.evaluate(J,le)));case"ObjectLiteral":{const J=new Map;for(const[se,ge]of B.value){const Fe=this.evaluate(se,le);if(!(Fe instanceof Ie))throw new Error(`Object keys must be strings: got ${Fe.type}`);J.set(Fe.value,this.evaluate(ge,le))}return new Ne(J)}case"Identifier":return this.evaluateIdentifier(B,le);case"CallExpression":return this.evaluateCallExpression(B,le);case"MemberExpression":return this.evaluateMemberExpression(B,le);case"UnaryExpression":return this.evaluateUnaryExpression(B,le);case"BinaryExpression":return this.evaluateBinaryExpression(B,le);case"FilterExpression":return this.evaluateFilterExpression(B,le);case"FilterStatement":return this.evaluateFilterStatement(B,le);case"TestExpression":return this.evaluateTestExpression(B,le);case"SelectExpression":return this.evaluateSelectExpression(B,le);case"Ternary":return this.evaluateTernaryExpression(B,le);case"Comment":return new He;default:throw new SyntaxError(`Unknown node type: ${B.type}`)}}};function xn(B){switch(typeof B){case"number":return Number.isInteger(B)?new Y(B):new $e(B);case"string":return new Ie(B);case"boolean":return new fe(B);case"undefined":return new je;case"object":return B===null?new He:Array.isArray(B)?new de(B.map(xn)):new Ne(new Map(Object.entries(B).map(([le,J])=>[le,xn(J)])));case"function":return new tt((le,J)=>{const se=B(...le.map(ge=>ge.value))??null;return xn(se)});default:throw new Error(`Cannot convert to runtime value: ${B}`)}}var cn=`
`,jn="{%- ",ci=" -%}";function ss(B){switch(B.operator.type){case"MultiplicativeBinaryOperator":return 4;case"AdditiveBinaryOperator":return 3;case"ComparisonBinaryOperator":return 2;case"Identifier":return B.operator.value==="and"?1:B.operator.value==="in"||B.operator.value==="not in"?2:0}return 0}function Vi(B,le="	"){const J=typeof le=="number"?" ".repeat(le):le;return Mn(B.body,0,J).replace(/\n$/,"")}function Cn(...B){return jn+B.join(" ")+ci}function Mn(B,le,J){return B.map(se=>Di(se,le,J)).join(cn)}function Di(B,le,J){const se=J.repeat(le);switch(B.type){case"Program":return Mn(B.body,le,J);case"If":return bs(B,le,J);case"For":return qt(B,le,J);case"Set":return Me(B,le,J);case"Macro":return at(B,le,J);case"Break":return se+Cn("break");case"Continue":return se+Cn("continue");case"CallStatement":return rt(B,le,J);case"FilterStatement":return mt(B,le,J);case"Comment":return se+"{# "+B.value+" #}";default:return se+"{{- "+_t(B)+" -}}"}}function bs(B,le,J){const se=J.repeat(le),ge=[];let Fe=B;for(;Fe&&(ge.push({test:Fe.test,body:Fe.body}),Fe.alternate.length===1&&Fe.alternate[0].type==="If");)Fe=Fe.alternate[0];let Ke=se+Cn("if",_t(ge[0].test))+cn+Mn(ge[0].body,le+1,J);for(let pt=1;pt<ge.length;++pt)Ke+=cn+se+Cn("elif",_t(ge[pt].test))+cn+Mn(ge[pt].body,le+1,J);return Fe&&Fe.alternate.length>0&&(Ke+=cn+se+Cn("else")+cn+Mn(Fe.alternate,le+1,J)),Ke+=cn+se+Cn("endif"),Ke}function qt(B,le,J){const se=J.repeat(le);let ge="";if(B.iterable.type==="SelectExpression"){const Ke=B.iterable;ge=`${_t(Ke.lhs)} if ${_t(Ke.test)}`}else ge=_t(B.iterable);let Fe=se+Cn("for",_t(B.loopvar),"in",ge)+cn+Mn(B.body,le+1,J);return B.defaultBlock.length>0&&(Fe+=cn+se+Cn("else")+cn+Mn(B.defaultBlock,le+1,J)),Fe+=cn+se+Cn("endfor"),Fe}function Me(B,le,J){const se=J.repeat(le),ge=_t(B.assignee),Fe=B.value?_t(B.value):"",Ke=se+Cn("set",`${ge}${B.value?" = "+Fe:""}`);return B.body.length===0?Ke:Ke+cn+Mn(B.body,le+1,J)+cn+se+Cn("endset")}function at(B,le,J){const se=J.repeat(le),ge=B.args.map(_t).join(", ");return se+Cn("macro",`${B.name.value}(${ge})`)+cn+Mn(B.body,le+1,J)+cn+se+Cn("endmacro")}function rt(B,le,J){const se=J.repeat(le),ge=B.callerArgs&&B.callerArgs.length>0?`(${B.callerArgs.map(_t).join(", ")})`:"",Fe=_t(B.call);let Ke=se+Cn(`call${ge}`,Fe)+cn;return Ke+=Mn(B.body,le+1,J)+cn,Ke+=se+Cn("endcall"),Ke}function mt(B,le,J){const se=J.repeat(le),ge=B.filter.type==="Identifier"?B.filter.value:_t(B.filter);let Fe=se+Cn("filter",ge)+cn;return Fe+=Mn(B.body,le+1,J)+cn,Fe+=se+Cn("endfilter"),Fe}function _t(B,le=-1){switch(B.type){case"SpreadExpression":return`*${_t(B.argument)}`;case"Identifier":return B.value;case"IntegerLiteral":return`${B.value}`;case"FloatLiteral":return`${B.value}`;case"StringLiteral":return JSON.stringify(B.value);case"BinaryExpression":{const J=B,se=ss(J),ge=_t(J.left,se),Fe=_t(J.right,se+1),Ke=`${ge} ${J.operator.value} ${Fe}`;return se<le?`(${Ke})`:Ke}case"UnaryExpression":{const J=B;return J.operator.value+(J.operator.value==="not"?" ":"")+_t(J.argument,1/0)}case"CallExpression":{const J=B,se=J.args.map(_t).join(", ");return`${_t(J.callee)}(${se})`}case"MemberExpression":{const J=B;let se=_t(J.object);["Identifier","MemberExpression","CallExpression","StringLiteral","IntegerLiteral","FloatLiteral","ArrayLiteral","TupleLiteral","ObjectLiteral"].includes(J.object.type)||(se=`(${se})`);let ge=_t(J.property);return!J.computed&&J.property.type!=="Identifier"&&(ge=`(${ge})`),J.computed?`${se}[${ge}]`:`${se}.${ge}`}case"FilterExpression":{const J=B,se=_t(J.operand,1/0);return J.filter.type==="CallExpression"?`${se} | ${_t(J.filter)}`:`${se} | ${J.filter.value}`}case"SelectExpression":{const J=B;return`${_t(J.lhs)} if ${_t(J.test)}`}case"TestExpression":{const J=B;return`${_t(J.operand)} is${J.negate?" not":""} ${J.test.value}`}case"ArrayLiteral":case"TupleLiteral":{const J=B.value.map(_t),se=B.type==="ArrayLiteral"?"[]":"()";return`${se[0]}${J.join(", ")}${se[1]}`}case"ObjectLiteral":return`{${Array.from(B.value.entries()).map(([se,ge])=>`${_t(se)}: ${_t(ge)}`).join(", ")}}`;case"SliceExpression":{const J=B,se=J.start?_t(J.start):"",ge=J.stop?_t(J.stop):"",Fe=J.step?`:${_t(J.step)}`:"";return`${se}:${ge}${Fe}`}case"KeywordArgumentExpression":{const J=B;return`${J.key.value}=${_t(J.value)}`}case"Ternary":{const J=B,se=`${_t(J.trueExpr)} if ${_t(J.condition,0)} else ${_t(J.falseExpr)}`;return le>-1?`(${se})`:se}default:throw new Error(`Unknown expression type: ${B.type}`)}}var an=class{constructor(B){Ce(this,"parsed");const le=h(B,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=et(le)}render(B){const le=new lt;if(Mt(le),B)for(const[ge,Fe]of Object.entries(B))le.set(ge,Fe);return new wn(le).run(this.parsed).value}format(B){return Vi(this.parsed,(B==null?void 0:B.indent)||"	")}}},"./src/backends/onnx.js":(e,n,t)=>{var i;t.r(n),t.d(n,{Tensor:()=>u.Tensor,createInferenceSession:()=>D,deviceToExecutionProviders:()=>v,isONNXProxy:()=>L,isONNXTensor:()=>E,runInferenceSession:()=>F});var r=t("./src/env.js"),a=t("?2ce3"),c=t("onnxruntime-web"),u=t("onnxruntime-common");const l=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),f=[];let m,h;const p=Symbol.for("onnxruntime");if(p in globalThis)h=globalThis[p];else if(r.apis.IS_NODE_ENV){switch(h=a??(i||(i=t.t(a,2))),process.platform){case"win32":f.push("dml");break;case"linux":process.arch==="x64"&&f.push("cuda");break}f.push("cpu"),m=["cpu"]}else h=c,r.apis.IS_WEBNN_AVAILABLE&&f.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),r.apis.IS_WEBGPU_AVAILABLE&&f.push("webgpu"),f.push("wasm"),m=["wasm"];const _=h.InferenceSession;function v(I=null){if(!I)return m;switch(I){case"auto":return f;case"gpu":return f.filter(R=>["webgpu","cuda","dml","webnn-gpu"].includes(R))}if(f.includes(I))return[l[I]??I];throw new Error(`Unsupported device: "${I}". Should be one of: ${f.join(", ")}.`)}let S=null;async function D(I,R,N){S&&await S;const q=_.create(I,R);S??(S=q);const ne=await q;return ne.config=N,ne}let w=Promise.resolve();const T=r.apis.IS_BROWSER_ENV||r.apis.IS_WEBWORKER_ENV;async function F(I,R){const N=()=>I.run(R);return await(T?w=w.then(N):N())}function E(I){return I instanceof h.Tensor}const A=h==null?void 0:h.env;A!=null&&A.wasm&&(!(typeof ServiceWorkerGlobalScope<"u"&&self instanceof ServiceWorkerGlobalScope)&&!A.wasm.wasmPaths&&(A.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${r.env.version}/dist/`),A.wasm.proxy=!1),A!=null&&A.webgpu&&(A.webgpu.powerPreference="high-performance");function L(){var I;return(I=A==null?void 0:A.wasm)==null?void 0:I.proxy}r.env.backends.onnx=A},"./src/base/feature_extraction_utils.js":(e,n,t)=>{t.r(n),t.d(n,{FeatureExtractor:()=>c,validate_audio_inputs:()=>u});var i=t("./src/utils/constants.js"),r=t("./src/utils/generic.js"),a=t("./src/utils/hub.js");class c extends r.Callable{constructor(f){super(),this.config=f}static async from_pretrained(f,m={}){const h=await(0,a.getModelJSON)(f,i.FEATURE_EXTRACTOR_NAME,!0,m);return new this(h)}}function u(l,f){var m;if(!(l instanceof Float32Array||l instanceof Float64Array))throw new Error(`${f} expects input to be a Float32Array or a Float64Array, but got ${((m=l==null?void 0:l.constructor)==null?void 0:m.name)??typeof l} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}},"./src/base/image_processors_utils.js":(e,n,t)=>{t.r(n),t.d(n,{ImageProcessor:()=>E,center_to_corners_format:()=>h,post_process_instance_segmentation:()=>F,post_process_object_detection:()=>p,post_process_panoptic_segmentation:()=>T,post_process_semantic_segmentation:()=>_});var i=t("./src/utils/generic.js"),r=t("./src/utils/tensor.js"),a=t("./src/utils/maths.js");t("./src/utils/image.js");var c=t("./src/utils/core.js"),u=t("./src/utils/hub.js"),l=t("./src/utils/constants.js");function f(A,L,I=0,R=null){const N=A/L;let q=(0,a.bankers_round)(N)*L;return R!==null&&q>R&&(q=Math.floor(N)*L),q<I&&(q=Math.ceil(N)*L),q}function m([A,L],I){return[Math.max(Math.floor(A/I),1)*I,Math.max(Math.floor(L/I),1)*I]}function h([A,L,I,R]){return[A-I/2,L-R/2,A+I/2,L+R/2]}function p(A,L=.5,I=null,R=!1){const N=A.logits,q=A.pred_boxes,[ne,Q,W]=N.dims;if(I!==null&&I.length!==ne)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let te=[];for(let K=0;K<ne;++K){let pe=I!==null?I[K]:null,be={boxes:[],classes:[],scores:[]},Ee=N[K],Ge=q[K];for(let _e=0;_e<Q;++_e){let De=Ee[_e],he=[],Z;if(R){Z=De.sigmoid().data;for(let me=0;me<Z.length;++me)Z[me]>L&&he.push(me)}else{let me=(0,a.max)(De.data)[1];if(me===W-1||(Z=(0,a.softmax)(De.data),Z[me]<L))continue;he.push(me)}for(const me of he){let we=Ge[_e].data;we=h(we),pe!==null&&(we=we.map((xe,et)=>xe*pe[(et+1)%2])),be.boxes.push(we),be.classes.push(me),be.scores.push(Z[me])}}te.push(be)}return te}function _(A,L=null){const I=A.logits,R=I.dims[0];if(L!==null&&L.length!==R)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const N=[];for(let q=0;q<R;++q){const ne=L!==null?L[q]:null;let Q=I[q];ne!==null&&(Q=(0,r.interpolate)(Q,ne,"bilinear",!1));const[W,te]=ne??Q.dims.slice(-2),K=new r.Tensor("int32",new Int32Array(W*te),[W,te]),pe=Q[0].data,be=K.data;for(let _e=1;_e<Q.dims[0];++_e){const De=Q[_e].data;for(let he=0;he<De.length;++he)De[he]>pe[he]&&(pe[he]=De[he],be[he]=_e)}const Ee=new Array(Q.dims[0]);for(let _e=0;_e<be.length;++_e){const De=be[_e];Ee[De]=De}const Ge=Ee.filter(_e=>_e!==void 0);N.push({segmentation:K,labels:Ge})}return N}function v(A,L,I,R){const N=[],q=[],ne=[];for(let Q=0;Q<A.dims[0];++Q){const W=A[Q],te=L[Q],K=(0,a.max)(W.data)[1];if(K===R)continue;const be=(0,a.softmax)(W.data)[K];be>I&&(N.push(te),q.push(be),ne.push(K))}return[N,q,ne]}function S(A,L,I,R=.5,N=.8){const q=[];let ne=0,Q=0;const W=L[I].data;for(let K=0;K<A.length;++K)A[K]===I&&(q.push(K),++ne),W[K]>=R&&++Q;let te=ne>0&&Q>0;return te&&(te=ne/Q>N),[te,q]}function D(A,L,I,R,N,q=null,ne=null){const[Q,W]=ne??A[0].dims,te=new r.Tensor("int32",new Int32Array(Q*W),[Q,W]),K=[];if(ne!==null)for(let _e=0;_e<A.length;++_e)A[_e]=(0,r.interpolate)(A[_e],ne,"bilinear",!1);const pe=new Int32Array(A[0].data.length),be=new Float32Array(A[0].data.length);for(let _e=0;_e<A.length;++_e){let De=L[_e];const he=A[_e].data;for(let Z=0;Z<he.length;++Z)he[Z]*=De,he[Z]>be[Z]&&(pe[Z]=_e,be[Z]=he[Z])}let Ee=0;const Ge=te.data;for(let _e=0;_e<I.length;++_e){const De=I[_e],[he,Z]=S(pe,A,_e,R,N);if(he){++Ee;for(const me of Z)Ge[me]=Ee;K.push({id:Ee,label_id:De,score:L[_e]})}}return[te,K]}function w(A,L,I=28,R=56*56,N=14*14*4*1280){if(A<I||L<I)throw new Error(`height:${A} or width:${L} must be larger than factor:${I}`);if(Math.max(A,L)/Math.min(A,L)>200)throw new Error(`absolute aspect ratio must be smaller than 200, got ${Math.max(A,L)/Math.min(A,L)}`);let q=Math.round(A/I)*I,ne=Math.round(L/I)*I;if(q*ne>N){const Q=Math.sqrt(A*L/N);q=Math.floor(A/Q/I)*I,ne=Math.floor(L/Q/I)*I}else if(q*ne<R){const Q=Math.sqrt(R/(A*L));q=Math.ceil(A*Q/I)*I,ne=Math.ceil(L*Q/I)*I}return[q,ne]}function T(A,L=.5,I=.5,R=.8,N=null,q=null){N===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),N=new Set);const ne=A.class_queries_logits??A.logits,W=(A.masks_queries_logits??A.pred_masks).sigmoid();let[te,K,pe]=ne.dims;if(pe-=1,q!==null&&q.length!==te)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let be=[];for(let Ee=0;Ee<te;++Ee){let Ge=q!==null?q[Ee]:null,_e=ne[Ee],De=W[Ee],[he,Z,me]=v(_e,De,L,pe);if(me.length===0){let[et,Ve]=Ge??De.dims.slice(-2),nt=new r.Tensor("int32",new Int32Array(et*Ve).fill(-1),[et,Ve]);be.push({segmentation:nt,segments_info:[]});continue}let[we,xe]=D(he,Z,me,I,R,N,Ge);be.push({segmentation:we,segments_info:xe})}return be}function F(A,L=.5,I=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class E extends i.Callable{constructor(L){super(),this.image_mean=L.image_mean??L.mean,this.image_std=L.image_std??L.std,this.resample=L.resample??2,this.do_rescale=L.do_rescale??!0,this.rescale_factor=L.rescale_factor??1/255,this.do_normalize=L.do_normalize,this.do_thumbnail=L.do_thumbnail,this.size=L.size??L.image_size,this.do_resize=L.do_resize??this.size!==void 0,this.size_divisibility=L.size_divisibility??L.size_divisor,this.do_center_crop=L.do_center_crop,this.crop_size=L.crop_size,this.do_convert_rgb=L.do_convert_rgb??!0,this.do_crop_margin=L.do_crop_margin,this.pad_size=L.pad_size,this.do_pad=L.do_pad,this.min_pixels=L.min_pixels,this.max_pixels=L.max_pixels,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=L.do_flip_channel_order??!1,this.config=L}async thumbnail(L,I,R=2){const N=L.height,q=L.width,ne=I.height,Q=I.width;let W=Math.min(N,ne),te=Math.min(q,Q);return W===N&&te===q?L:(N>q?te=Math.floor(q*W/N):q>N&&(W=Math.floor(N*te/q)),await L.resize(te,W,{resample:R}))}async crop_margin(L,I=200){const R=L.clone().grayscale(),N=(0,a.min)(R.data)[0],ne=(0,a.max)(R.data)[0]-N;if(ne===0)return L;const Q=I/255;let W=R.width,te=R.height,K=0,pe=0;const be=R.data;for(let Ee=0;Ee<R.height;++Ee){const Ge=Ee*R.width;for(let _e=0;_e<R.width;++_e)(be[Ge+_e]-N)/ne<Q&&(W=Math.min(W,_e),te=Math.min(te,Ee),K=Math.max(K,_e),pe=Math.max(pe,Ee))}return L=await L.crop([W,te,K,pe]),L}pad_image(L,I,R,{mode:N="constant",center:q=!1,constant_values:ne=0}={}){const[Q,W,te]=I;let K,pe;if(typeof R=="number"?(K=R,pe=R):R==="square"?K=pe=Math.max(Q,W):(K=R.width,pe=R.height),K!==W||pe!==Q){const be=new Float32Array(K*pe*te);if(Array.isArray(ne))for(let _e=0;_e<be.length;++_e)be[_e]=ne[_e%te];else ne!==0&&be.fill(ne);const[Ee,Ge]=q?[Math.floor((K-W)/2),Math.floor((pe-Q)/2)]:[0,0];for(let _e=0;_e<Q;++_e){const De=(_e+Ge)*K,he=_e*W;for(let Z=0;Z<W;++Z){const me=(De+Z+Ee)*te,we=(he+Z)*te;for(let xe=0;xe<te;++xe)be[me+xe]=L[we+xe]}}if(N==="symmetric"){if(q)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const _e=Q-1,De=W-1;for(let he=0;he<pe;++he){const Z=he*K,me=(0,c.calculateReflectOffset)(he,_e)*W;for(let we=0;we<K;++we){if(he<Q&&we<W)continue;const xe=(Z+we)*te,et=(me+(0,c.calculateReflectOffset)(we,De))*te;for(let Ve=0;Ve<te;++Ve)be[xe+Ve]=L[et+Ve]}}}L=be,I=[pe,K,te]}return[L,I]}rescale(L){for(let I=0;I<L.length;++I)L[I]=this.rescale_factor*L[I]}get_resize_output_image_size(L,I){const[R,N]=L.size;let q,ne;if(this.do_thumbnail){const{height:Q,width:W}=I;q=Math.min(Q,W)}else Number.isInteger(I)?(q=I,ne=this.config.max_size??q):I!==void 0&&(q=I.shortest_edge,ne=I.longest_edge);if(q!==void 0||ne!==void 0){const Q=q===void 0?1:Math.max(q/R,q/N),W=R*Q,te=N*Q,K=ne===void 0?1:Math.min(ne/W,ne/te);let pe=Math.floor(Number((W*K).toFixed(2))),be=Math.floor(Number((te*K).toFixed(2)));return this.size_divisibility!==void 0&&([pe,be]=m([pe,be],this.size_divisibility)),[pe,be]}else if(I!==void 0&&I.width!==void 0&&I.height!==void 0){let Q=I.width,W=I.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let te=W/N,K=Q/R;Math.abs(1-K)<Math.abs(1-te)?te=K:K=te,W=f(te*N,this.config.ensure_multiple_of),Q=f(K*R,this.config.ensure_multiple_of)}return[Q,W]}else{if(this.size_divisibility!==void 0)return m([R,N],this.size_divisibility);if(this.min_pixels!==void 0&&this.max_pixels!==void 0){const Q=this.config.patch_size*this.config.merge_size;return w(N,R,Q,this.min_pixels,this.max_pixels)}else throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(I)}`)}}async resize(L){const[I,R]=this.get_resize_output_image_size(L,this.size);return await L.resize(I,R,{resample:this.resample})}async preprocess(L,{do_normalize:I=null,do_pad:R=null,do_convert_rgb:N=null,do_convert_grayscale:q=null,do_flip_channel_order:ne=null}={}){this.do_crop_margin&&(L=await this.crop_margin(L));const[Q,W]=L.size;if(N??this.do_convert_rgb?L=L.rgb():q&&(L=L.grayscale()),this.do_resize&&(L=await this.resize(L)),this.do_thumbnail&&(L=await this.thumbnail(L,this.size,this.resample)),this.do_center_crop){let Ee,Ge;Number.isInteger(this.crop_size)?(Ee=this.crop_size,Ge=this.crop_size):(Ee=this.crop_size.width,Ge=this.crop_size.height),L=await L.center_crop(Ee,Ge)}const te=[L.height,L.width];let K=Float32Array.from(L.data),pe=[L.height,L.width,L.channels];if(this.do_rescale&&this.rescale(K),I??this.do_normalize){let Ee=this.image_mean;Array.isArray(this.image_mean)||(Ee=new Array(L.channels).fill(Ee));let Ge=this.image_std;if(Array.isArray(this.image_std)||(Ge=new Array(L.channels).fill(Ge)),Ee.length!==L.channels||Ge.length!==L.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${Ee.length}) and \`image_std\` (${Ge.length}) must match the number of channels in the image (${L.channels}).`);for(let _e=0;_e<K.length;_e+=L.channels)for(let De=0;De<L.channels;++De)K[_e+De]=(K[_e+De]-Ee[De])/Ge[De]}if(R??this.do_pad){if(this.pad_size)[K,pe]=this.pad_image(K,[L.height,L.width,L.channels],this.pad_size);else if(this.size_divisibility){const[Ee,Ge]=m([pe[1],pe[0]],this.size_divisibility);[K,pe]=this.pad_image(K,pe,{width:Ee,height:Ge})}}if(ne??this.do_flip_channel_order){if(pe[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let Ee=0;Ee<K.length;Ee+=3){const Ge=K[Ee];K[Ee]=K[Ee+2],K[Ee+2]=Ge}}const be=new r.Tensor("float32",K,pe).permute(2,0,1);return{original_size:[W,Q],reshaped_input_size:te,pixel_values:be}}async _call(L,...I){Array.isArray(L)||(L=[L]);const R=await Promise.all(L.map(q=>this.preprocess(q)));return{pixel_values:(0,r.stack)(R.map(q=>q.pixel_values),0),original_sizes:R.map(q=>q.original_size),reshaped_input_sizes:R.map(q=>q.reshaped_input_size)}}static async from_pretrained(L,I={}){const R=await(0,u.getModelJSON)(L,l.IMAGE_PROCESSOR_NAME,!0,I);return new this(R)}}},"./src/base/processing_utils.js":(e,n,t)=>{t.r(n),t.d(n,{Processor:()=>c});var i=t("./src/utils/constants.js"),r=t("./src/utils/generic.js"),a=t("./src/utils/hub.js");class c extends r.Callable{constructor(l,f,m){super(),this.config=l,this.components=f,this.chat_template=m}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(l,f={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(l,{tokenize:!1,chat_template:this.chat_template??void 0,...f})}batch_decode(...l){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...l)}decode(...l){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.decode(...l)}async _call(l,...f){for(const m of[this.image_processor,this.feature_extractor,this.tokenizer])if(m)return m(l,...f);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(l,f={}){const[m,h,p]=await Promise.all([this.uses_processor_config?(0,a.getModelJSON)(l,i.PROCESSOR_NAME,!0,f):{},Promise.all(this.classes.filter(_=>_ in this).map(async _=>{const v=await this[_].from_pretrained(l,f);return[_.replace(/_class$/,""),v]})).then(Object.fromEntries),this.uses_chat_template_file?(0,a.getModelText)(l,i.CHAT_TEMPLATE_NAME,!0,f):null]);return new this(m,h,p)}}Ce(c,"classes",["image_processor_class","tokenizer_class","feature_extractor_class"]),Ce(c,"uses_processor_config",!1),Ce(c,"uses_chat_template_file",!1)},"./src/configs.js":(e,n,t)=>{t.r(n),t.d(n,{AutoConfig:()=>m,PretrainedConfig:()=>f,getCacheShapes:()=>u});var i=t("./src/utils/core.js"),r=t("./src/utils/hub.js");async function a(h,p){return await(0,r.getModelJSON)(h,"config.json",!0,p)}function c(h){const p={};let _={};switch(h.model_type){case"llava":case"paligemma":case"gemma3":case"florence2":case"llava_onevision":case"idefics3":case"ultravox":case"voxtral":case"smolvlm":case"gemma3n":case"mistral3":_=c(h.text_config);break;case"moondream1":_=c(h.phi_config);break;case"musicgen":_=c(h.decoder);break;case"multi_modality":_=c(h.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":p.num_heads="n_head",p.num_layers="n_layer",p.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":case"modernbert-decoder":p.num_heads="num_attention_heads",p.num_layers="num_hidden_layers",p.hidden_size="hidden_size";break;case"llama":case"llama4_text":case"nanochat":case"arcee":case"lfm2":case"smollm3":case"olmo":case"olmo2":case"mobilellm":case"granite":case"granitemoehybrid":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":case"llava_qwen2":p.num_heads="num_key_value_heads",p.num_layers="num_hidden_layers",p.hidden_size="hidden_size",p.num_attention_heads="num_attention_heads",p.dim_kv="head_dim";break;case"qwen3":case"gemma":case"gemma2":case"vaultgemma":case"gemma3_text":case"gemma3n_text":case"glm":case"helium":case"ernie4_5":case"ministral":case"ministral3":p.num_heads="num_key_value_heads",p.num_layers="num_hidden_layers",p.dim_kv="head_dim";break;case"openelm":p.num_heads="num_kv_heads",p.num_layers="num_transformer_layers",p.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":p.num_heads="num_heads",p.num_layers="num_layers",p.hidden_size="hidden_size";break;case"bloom":p.num_heads="n_head",p.num_layers="n_layer",p.hidden_size="hidden_size";break;case"mpt":p.num_heads="n_heads",p.num_layers="n_layers",p.hidden_size="d_model";break;case"exaone":p.num_heads="num_key_value_heads",p.num_layers="num_layers",p.dim_kv="head_dim",p.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":p.num_decoder_layers="num_decoder_layers",p.num_decoder_heads="num_heads",p.decoder_dim_kv="d_kv",p.num_encoder_layers="num_layers",p.num_encoder_heads="num_heads",p.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"lite-whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":p.num_decoder_layers="decoder_layers",p.num_decoder_heads="decoder_attention_heads",p.decoder_hidden_size="d_model",p.num_encoder_layers="encoder_layers",p.num_encoder_heads="encoder_attention_heads",p.encoder_hidden_size="d_model";break;case"speecht5":p.num_decoder_layers="decoder_layers",p.num_decoder_heads="decoder_attention_heads",p.decoder_hidden_size="hidden_size",p.num_encoder_layers="encoder_layers",p.num_encoder_heads="encoder_attention_heads",p.encoder_hidden_size="hidden_size";break;case"trocr":p.num_encoder_layers=p.num_decoder_layers="decoder_layers",p.num_encoder_heads=p.num_decoder_heads="decoder_attention_heads",p.encoder_hidden_size=p.decoder_hidden_size="d_model";break;case"musicgen_decoder":p.num_encoder_layers=p.num_decoder_layers="num_hidden_layers",p.num_encoder_heads=p.num_decoder_heads="num_attention_heads",p.encoder_hidden_size=p.decoder_hidden_size="hidden_size";break;case"moonshine":p.num_decoder_layers="decoder_num_hidden_layers",p.num_decoder_heads="decoder_num_key_value_heads",p.num_encoder_layers="encoder_num_hidden_layers",p.num_encoder_heads="encoder_num_key_value_heads",p.encoder_hidden_size=p.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const S=c(h.decoder),D="num_decoder_layers"in S,w=(0,i.pick)(h,["model_type","is_encoder_decoder"]);return D?(w.num_decoder_layers=S.num_decoder_layers,w.num_decoder_heads=S.num_decoder_heads,w.decoder_hidden_size=S.decoder_hidden_size,w.num_encoder_layers=S.num_encoder_layers,w.num_encoder_heads=S.num_encoder_heads,w.encoder_hidden_size=S.encoder_hidden_size):(w.num_layers=S.num_layers,w.num_heads=S.num_heads,w.hidden_size=S.hidden_size),w}const v={..._,...(0,i.pick)(h,["model_type","multi_query","is_encoder_decoder"])};for(const S in p)v[S]=h[p[S]];return v}function u(h,p){if(h.model_type==="lfm2"){const _=(p==null?void 0:p.prefix)??"past_key_values",v=_==="present"?"present":"past",S={},{layer_types:D,num_attention_heads:w,num_key_value_heads:T,hidden_size:F,conv_L_cache:E}=h,A=F/w,L=(p==null?void 0:p.batch_size)??1;for(let I=0;I<D.length;++I)if(D[I]==="full_attention")for(const R of["key","value"])S[`${_}.${I}.${R}`]=[L,T,0,A];else if(D[I]==="conv")S[`${v}_conv.${I}`]=[L,F,E];else throw new Error(`Unsupported layer type: ${D[I]}`);return S}return l(h,p)}function l(h,{prefix:p="past_key_values",batch_size:_=1}={}){const v={},S=h.normalized_config;if(S.is_encoder_decoder&&"num_encoder_heads"in S&&"num_decoder_heads"in S){const D=S.encoder_dim_kv??S.encoder_hidden_size/S.num_encoder_heads,w=S.decoder_dim_kv??S.decoder_hidden_size/S.num_decoder_heads,T=[_,S.num_encoder_heads,0,D],F=[_,S.num_decoder_heads,0,w];for(let E=0;E<S.num_decoder_layers;++E)v[`${p}.${E}.encoder.key`]=T,v[`${p}.${E}.encoder.value`]=T,v[`${p}.${E}.decoder.key`]=F,v[`${p}.${E}.decoder.value`]=F}else{const D=S.num_heads,w=S.num_layers,T=S.dim_kv??S.hidden_size/(S.num_attention_heads??D);if(S.model_type==="falcon"){const F=[_*D,0,T];for(let E=0;E<w;++E)v[`${p}.${E}.key`]=F,v[`${p}.${E}.value`]=F}else if(S.multi_query){const F=[_*D,0,2*T];for(let E=0;E<w;++E)v[`${p}.${E}.key_value`]=F}else if(S.model_type==="bloom"){const F=[_*D,T,0],E=[_*D,0,T];for(let A=0;A<w;++A)v[`${p}.${A}.key`]=F,v[`${p}.${A}.value`]=E}else if(S.model_type==="openelm")for(let F=0;F<w;++F){const E=[_,D[F],0,T];v[`${p}.${F}.key`]=E,v[`${p}.${F}.value`]=E}else{const F=[_,D,0,T];for(let E=0;E<w;++E)v[`${p}.${E}.key`]=F,v[`${p}.${E}.value`]=F}}return v}class f{constructor(p){Ce(this,"model_type",null);Ce(this,"is_encoder_decoder",!1);Ce(this,"max_position_embeddings");Ce(this,"transformers.js_config");Object.assign(this,p),this.normalized_config=c(this)}static async from_pretrained(p,{progress_callback:_=null,config:v=null,cache_dir:S=null,local_files_only:D=!1,revision:w="main"}={}){v&&!(v instanceof f)&&(v=new f(v));const T=v??await a(p,{progress_callback:_,config:v,cache_dir:S,local_files_only:D,revision:w});return new this(T)}}class m{static async from_pretrained(...p){return f.from_pretrained(...p)}}},"./src/env.js":(e,n,t)=>{var N,q;t.r(n),t.d(n,{apis:()=>w,env:()=>I});var i=t("?db59"),r=t("?383f"),a=t("?fa4b");const c="3.8.1",u=typeof window<"u"&&typeof window.document<"u",l=typeof self<"u"&&["DedicatedWorkerGlobalScope","ServiceWorkerGlobalScope","SharedWorkerGlobalScope"].includes((N=self.constructor)==null?void 0:N.name),f=typeof self<"u"&&"caches"in self,m=typeof navigator<"u"&&"gpu"in navigator,h=typeof navigator<"u"&&"ml"in navigator,p=typeof process<"u",_=p&&((q=process==null?void 0:process.release)==null?void 0:q.name)==="node",v=!R(i),S=!R(r),D=typeof globalThis.Deno<"u",w=Object.freeze({IS_BROWSER_ENV:u,IS_WEBWORKER_ENV:l,IS_WEB_CACHE_AVAILABLE:f,IS_WEBGPU_AVAILABLE:m,IS_WEBNN_AVAILABLE:h,IS_PROCESS_AVAILABLE:p,IS_NODE_ENV:_,IS_FS_AVAILABLE:v,IS_PATH_AVAILABLE:S}),T=v&&S;let F="./";if(T){const ne=Object({url:typeof document>"u"&&typeof location>"u"?require("url").pathToFileURL(__filename).href:typeof document>"u"?location.href:document.currentScript&&document.currentScript.src||new URL("geocam-viewer.umd.cjs",document.baseURI).href}).url;ne?F=r.dirname(r.dirname(a.fileURLToPath(ne))):typeof __dirname<"u"&&(F=r.dirname(__dirname))}const E=T?r.join(F,"/.cache/"):null,A="/models/",L=T?r.join(F,A):A,I={version:c,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(u||l),localModelPath:L,useFS:v,useBrowserCache:f&&!D,useFSCache:v,cacheDir:E,useCustomCache:!1,customCache:null};function R(ne){return Object.keys(ne).length===0}},"./src/generation/configuration_utils.js":(e,n,t)=>{t.r(n),t.d(n,{GenerationConfig:()=>r});var i=t("./src/utils/core.js");class r{constructor(c){Ce(this,"max_length",20);Ce(this,"max_new_tokens",null);Ce(this,"min_length",0);Ce(this,"min_new_tokens",null);Ce(this,"early_stopping",!1);Ce(this,"max_time",null);Ce(this,"do_sample",!1);Ce(this,"num_beams",1);Ce(this,"num_beam_groups",1);Ce(this,"penalty_alpha",null);Ce(this,"use_cache",!0);Ce(this,"temperature",1);Ce(this,"top_k",50);Ce(this,"top_p",1);Ce(this,"typical_p",1);Ce(this,"epsilon_cutoff",0);Ce(this,"eta_cutoff",0);Ce(this,"diversity_penalty",0);Ce(this,"repetition_penalty",1);Ce(this,"encoder_repetition_penalty",1);Ce(this,"length_penalty",1);Ce(this,"no_repeat_ngram_size",0);Ce(this,"bad_words_ids",null);Ce(this,"force_words_ids",null);Ce(this,"renormalize_logits",!1);Ce(this,"constraints",null);Ce(this,"forced_bos_token_id",null);Ce(this,"forced_eos_token_id",null);Ce(this,"remove_invalid_values",!1);Ce(this,"exponential_decay_length_penalty",null);Ce(this,"suppress_tokens",null);Ce(this,"streamer",null);Ce(this,"begin_suppress_tokens",null);Ce(this,"forced_decoder_ids",null);Ce(this,"guidance_scale",null);Ce(this,"num_return_sequences",1);Ce(this,"output_attentions",!1);Ce(this,"output_hidden_states",!1);Ce(this,"output_scores",!1);Ce(this,"return_dict_in_generate",!1);Ce(this,"pad_token_id",null);Ce(this,"bos_token_id",null);Ce(this,"eos_token_id",null);Ce(this,"encoder_no_repeat_ngram_size",0);Ce(this,"decoder_start_token_id",null);Ce(this,"generation_kwargs",{});Object.assign(this,(0,i.pick)(c,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":(e,n,t)=>{t.r(n),t.d(n,{ClassifierFreeGuidanceLogitsProcessor:()=>w,ForcedBOSTokenLogitsProcessor:()=>l,ForcedEOSTokenLogitsProcessor:()=>f,LogitsProcessor:()=>a,LogitsProcessorList:()=>u,LogitsWarper:()=>c,MinLengthLogitsProcessor:()=>v,MinNewTokensLengthLogitsProcessor:()=>S,NoBadWordsLogitsProcessor:()=>D,NoRepeatNGramLogitsProcessor:()=>p,RepetitionPenaltyLogitsProcessor:()=>_,SuppressTokensAtBeginLogitsProcessor:()=>m,TemperatureLogitsWarper:()=>T,TopKLogitsWarper:()=>E,TopPLogitsWarper:()=>F,WhisperTimeStampLogitsProcessor:()=>h});var i=t("./src/utils/generic.js");t("./src/utils/tensor.js");var r=t("./src/utils/maths.js");class a extends i.Callable{_call(L,I){throw Error("`_call` should be implemented in a subclass")}}class c extends i.Callable{_call(L,I){throw Error("`_call` should be implemented in a subclass")}}class u extends i.Callable{constructor(){super(),this.processors=[]}push(L){this.processors.push(L)}extend(L){this.processors.push(...L)}_call(L,I){let R=I;for(const N of this.processors)R=N(L,R);return R}[Symbol.iterator](){return this.processors.values()}}class l extends a{constructor(L){super(),this.bos_token_id=L}_call(L,I){for(let R=0;R<L.length;++R)if(L[R].length===1){const N=I[R].data;N.fill(-1/0),N[this.bos_token_id]=0}return I}}class f extends a{constructor(L,I){super(),this.max_length=L,this.eos_token_id=Array.isArray(I)?I:[I]}_call(L,I){for(let R=0;R<L.length;++R)if(L[R].length===this.max_length-1){const N=I[R].data;N.fill(-1/0);for(const q of this.eos_token_id)N[q]=0}return I}}class m extends a{constructor(L,I){super(),this.begin_suppress_tokens=L,this.begin_index=I}_call(L,I){for(let R=0;R<L.length;++R)if(L[R].length===this.begin_index){const N=I[R].data;for(const q of this.begin_suppress_tokens)N[q]=-1/0}return I}}class h extends a{constructor(L,I){super(),this.eos_token_id=Array.isArray(L.eos_token_id)?L.eos_token_id[0]:L.eos_token_id,this.no_timestamps_token_id=L.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=I.length,I.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=L.max_initial_timestamp_index}_call(L,I){for(let R=0;R<L.length;++R){const N=I[R].data;if(N[this.no_timestamps_token_id]=-1/0,L[R].length===this.begin_index-1){N.fill(-1/0),N[this.timestamp_begin]=0;continue}const q=L[R].slice(this.begin_index),ne=q.length>=1&&q[q.length-1]>=this.timestamp_begin,Q=q.length<2||q[q.length-2]>=this.timestamp_begin;if(ne&&(Q?N.subarray(this.timestamp_begin).fill(-1/0):N.subarray(0,this.eos_token_id).fill(-1/0)),L[R].length===this.begin_index&&this.max_initial_timestamp_index!==null){const pe=this.timestamp_begin+this.max_initial_timestamp_index;N.subarray(pe+1).fill(-1/0)}const W=(0,r.log_softmax)(N),te=Math.log(W.subarray(this.timestamp_begin).map(Math.exp).reduce((pe,be)=>pe+be)),K=(0,r.max)(W.subarray(0,this.timestamp_begin))[0];te>K&&N.subarray(0,this.timestamp_begin).fill(-1/0)}return I}}class p extends a{constructor(L){super(),this.no_repeat_ngram_size=L}getNgrams(L){const I=L.length,R=[];for(let q=0;q<I+1-this.no_repeat_ngram_size;++q){const ne=[];for(let Q=0;Q<this.no_repeat_ngram_size;++Q)ne.push(L[q+Q]);R.push(ne.map(Number))}const N=new Map;for(const q of R){const ne=q.slice(0,q.length-1),Q=JSON.stringify(ne),W=N.get(Q)??[];W.push(q[q.length-1]),N.set(Q,W)}return N}getGeneratedNgrams(L,I){const R=I.slice(I.length+1-this.no_repeat_ngram_size,I.length);return L.get(JSON.stringify(R.map(Number)))??[]}calcBannedNgramTokens(L){const I=[];if(L.length+1<this.no_repeat_ngram_size)return I;{const R=this.getNgrams(L);return this.getGeneratedNgrams(R,L)}}_call(L,I){for(let R=0;R<L.length;++R){const N=I[R].data,q=this.calcBannedNgramTokens(L[R]);for(const ne of q)N[ne]=-1/0}return I}}class _ extends a{constructor(L){super(),this.penalty=L}_call(L,I){for(let R=0;R<L.length;++R){const N=I[R].data;for(const q of new Set(L[R])){const ne=Number(q);N[ne]<0?N[ne]*=this.penalty:N[ne]/=this.penalty}}return I}}class v extends a{constructor(L,I){super(),this.min_length=L,this.eos_token_id=Array.isArray(I)?I:[I]}_call(L,I){for(let R=0;R<L.length;++R)if(L[R].length<this.min_length){const N=I[R].data;for(const q of this.eos_token_id)N[q]=-1/0}return I}}class S extends a{constructor(L,I,R){super(),this.prompt_length_to_skip=L,this.min_new_tokens=I,this.eos_token_id=Array.isArray(R)?R:[R]}_call(L,I){for(let R=0;R<L.length;++R)if(L[R].length-this.prompt_length_to_skip<this.min_new_tokens){const q=I[R].data;for(const ne of this.eos_token_id)q[ne]=-1/0}return I}}class D extends a{constructor(L,I){super(),this.bad_words_ids=L,this.eos_token_id=Array.isArray(I)?I:[I]}_call(L,I){for(let R=0;R<L.length;++R){const N=I[R].data,q=L[R];for(const ne of this.bad_words_ids){if(q.length<ne.length-1)continue;let Q=!0;for(let W=1;W<=ne.length-1;++W)if(ne.at(-W-1)!=q.at(-W)){Q=!1;break}Q&&(N[ne.at(-1)]=-1/0)}}return I}}class w extends a{constructor(L){if(super(),L<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${L}.`);this.guidance_scale=L}_call(L,I){if(I.dims[0]!==2*L.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${I.dims[0]} for the logits and ${L.length} for the input ids.`);const R=L.length,N=I.slice([0,R],null),q=I.slice([R,I.dims[0]],null);for(let ne=0;ne<q.data.length;++ne)q.data[ne]+=(N.data[ne]-q.data[ne])*this.guidance_scale;return q}}class T extends c{constructor(L){super(),this.temperature=L}_call(L,I){const R=I.data;for(let N=0;N<R.length;++N)R[N]/=this.temperature;return I}}class F extends c{constructor(L,{filter_value:I=-1/0,min_tokens_to_keep:R=1}={}){if(super(),L<0||L>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${L}`);if(!Number.isInteger(R)||R<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${R}`);this.top_p=L,this.filter_value=I,this.min_tokens_to_keep=R}}class E extends c{constructor(L,{filter_value:I=-1/0,min_tokens_to_keep:R=1}={}){if(super(),!Number.isInteger(L)||L<0)throw new Error(`\`top_k\` must be a positive integer, but is ${L}`);this.top_k=Math.max(L,R),this.filter_value=I}}},"./src/generation/logits_sampler.js":(e,n,t)=>{t.r(n),t.d(n,{LogitsSampler:()=>c});var i=t("./src/utils/generic.js"),r=t("./src/utils/tensor.js"),a=t("./src/utils/maths.js");t("./src/generation/configuration_utils.js");class c extends i.Callable{constructor(h){super(),this.generation_config=h}async _call(h){return this.sample(h)}async sample(h){throw Error("sample should be implemented in subclasses.")}getLogits(h,p){let _=h.dims.at(-1),v=h.data;if(p===-1)v=v.slice(-_);else{let S=p*_;v=v.slice(S,S+_)}return v}randomSelect(h){let p=0;for(let v=0;v<h.length;++v)p+=h[v];let _=Math.random()*p;for(let v=0;v<h.length;++v)if(_-=h[v],_<=0)return v;return 0}static getSampler(h){if(h.do_sample)return new l(h);if(h.num_beams>1)return new f(h);if(h.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${h.num_return_sequences}.`);return new u(h)}}class u extends c{async sample(h){const p=(0,a.max)(h.data)[1];return[[BigInt(p),0]]}}class l extends c{async sample(h){let p=h.dims.at(-1);this.generation_config.top_k>0&&(p=Math.min(this.generation_config.top_k,p));const[_,v]=await(0,r.topk)(h,p),S=(0,a.softmax)(_.data);return Array.from({length:this.generation_config.num_beams},()=>{const D=this.randomSelect(S);return[v.data[D],Math.log(S[D])]})}}class f extends c{async sample(h){let p=h.dims.at(-1);this.generation_config.top_k>0&&(p=Math.min(this.generation_config.top_k,p));const[_,v]=await(0,r.topk)(h,p),S=(0,a.softmax)(_.data);return Array.from({length:this.generation_config.num_beams},(D,w)=>[v.data[w],Math.log(S[w])])}}},"./src/generation/stopping_criteria.js":(e,n,t)=>{t.r(n),t.d(n,{EosTokenCriteria:()=>u,InterruptableStoppingCriteria:()=>l,MaxLengthCriteria:()=>c,StoppingCriteria:()=>r,StoppingCriteriaList:()=>a});var i=t("./src/utils/generic.js");class r extends i.Callable{_call(m,h){throw Error("StoppingCriteria needs to be subclassed")}}class a extends i.Callable{constructor(){super(),this.criteria=[]}push(m){this.criteria.push(m)}extend(m){m instanceof a?m=m.criteria:m instanceof r&&(m=[m]),this.criteria.push(...m)}_call(m,h){const p=new Array(m.length).fill(!1);for(const _ of this.criteria){const v=_(m,h);for(let S=0;S<p.length;++S)p[S]||(p[S]=v[S])}return p}[Symbol.iterator](){return this.criteria.values()}}class c extends r{constructor(m,h=null){super(),this.max_length=m,this.max_position_embeddings=h}_call(m){return m.map(h=>h.length>=this.max_length)}}class u extends r{constructor(m){super(),Array.isArray(m)||(m=[m]),this.eos_token_id=m}_call(m,h){return m.map(p=>{const _=p.at(-1);return this.eos_token_id.some(v=>_==v)})}}class l extends r{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(m,h){return new Array(m.length).fill(this.interrupted)}}},"./src/generation/streamers.js":(e,n,t)=>{t.r(n),t.d(n,{BaseStreamer:()=>c,TextStreamer:()=>l,WhisperTextStreamer:()=>f});var i=t("./src/utils/core.js"),r=t("./src/tokenizers.js"),a=t("./src/env.js");class c{put(h){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const u=a.apis.IS_PROCESS_AVAILABLE?m=>process.stdout.write(m):m=>console.log(m);class l extends c{constructor(h,{skip_prompt:p=!1,callback_function:_=null,token_callback_function:v=null,skip_special_tokens:S=!0,decode_kwargs:D={},...w}={}){super(),this.tokenizer=h,this.skip_prompt=p,this.callback_function=_??u,this.token_callback_function=v,this.decode_kwargs={skip_special_tokens:S,...D,...w},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(h){var D;if(h.length>1)throw Error("TextStreamer only supports batch size of 1");const p=this.next_tokens_are_prompt;if(p&&(this.next_tokens_are_prompt=!1,this.skip_prompt))return;const _=h[0];(D=this.token_callback_function)==null||D.call(this,_),this.token_cache=(0,i.mergeArrays)(this.token_cache,_);const v=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let S;p||v.endsWith(`
`)?(S=v.slice(this.print_len),this.token_cache=[],this.print_len=0):v.length>0&&(0,r.is_chinese_char)(v.charCodeAt(v.length-1))?(S=v.slice(this.print_len),this.print_len+=S.length):(S=v.slice(this.print_len,v.lastIndexOf(" ")+1),this.print_len+=S.length),this.on_finalized_text(S,!1)}end(){let h;this.token_cache.length>0?(h=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):h="",this.next_tokens_are_prompt=!0,this.on_finalized_text(h,!0)}on_finalized_text(h,p){var _,v;h.length>0&&((_=this.callback_function)==null||_.call(this,h)),p&&this.callback_function===u&&a.apis.IS_PROCESS_AVAILABLE&&((v=this.callback_function)==null||v.call(this,`
`))}}class f extends l{constructor(h,{skip_prompt:p=!1,callback_function:_=null,token_callback_function:v=null,on_chunk_start:S=null,on_chunk_end:D=null,on_finalize:w=null,time_precision:T=.02,skip_special_tokens:F=!0,decode_kwargs:E={}}={}){super(h,{skip_prompt:p,skip_special_tokens:F,callback_function:_,token_callback_function:v,decode_kwargs:E}),this.timestamp_begin=h.timestamp_begin,this.on_chunk_start=S,this.on_chunk_end=D,this.on_finalize=w,this.time_precision=T,this.waiting_for_timestamp=!1}put(h){var _,v,S;if(h.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const p=h[0];if(p.length===1){const D=Number(p[0])-this.timestamp_begin;if(D>=0){const w=D*this.time_precision;this.waiting_for_timestamp?(_=this.on_chunk_end)==null||_.call(this,w):(v=this.on_chunk_start)==null||v.call(this,w),this.waiting_for_timestamp=!this.waiting_for_timestamp,(S=this.token_callback_function)==null||S.call(this,p);return}}return super.put(h)}end(){var h;super.end(),(h=this.on_finalize)==null||h.call(this)}}},"./src/models.js":(e,n,t)=>{t.r(n),t.d(n,{ASTForAudioClassification:()=>Gd,ASTModel:()=>Ud,ASTPreTrainedModel:()=>Go,AlbertForMaskedLM:()=>kt,AlbertForQuestionAnswering:()=>At,AlbertForSequenceClassification:()=>It,AlbertModel:()=>Et,AlbertPreTrainedModel:()=>ot,ArceeForCausalLM:()=>Ch,ArceeModel:()=>Ah,ArceePreTrainedModel:()=>Ph,AutoModel:()=>Pu,AutoModelForAudioClassification:()=>$y,AutoModelForAudioFrameClassification:()=>o,AutoModelForAudioTextToText:()=>$,AutoModelForCTC:()=>zy,AutoModelForCausalLM:()=>ug,AutoModelForDepthEstimation:()=>x,AutoModelForDocumentQuestionAnswering:()=>d,AutoModelForImageClassification:()=>Ry,AutoModelForImageFeatureExtraction:()=>k,AutoModelForImageMatting:()=>g,AutoModelForImageSegmentation:()=>fg,AutoModelForImageTextToText:()=>O,AutoModelForImageToImage:()=>y,AutoModelForMaskGeneration:()=>mg,AutoModelForMaskedLM:()=>Au,AutoModelForNormalEstimation:()=>b,AutoModelForObjectDetection:()=>pg,AutoModelForPoseEstimation:()=>P,AutoModelForQuestionAnswering:()=>dg,AutoModelForSemanticSegmentation:()=>Cu,AutoModelForSeq2SeqLM:()=>og,AutoModelForSequenceClassification:()=>sg,AutoModelForSpeechSeq2Seq:()=>ag,AutoModelForTextToSpectrogram:()=>lg,AutoModelForTextToWaveform:()=>cg,AutoModelForTokenClassification:()=>rg,AutoModelForUniversalSegmentation:()=>Iu,AutoModelForVision2Seq:()=>hg,AutoModelForXVector:()=>s,AutoModelForZeroShotObjectDetection:()=>By,BartForConditionalGeneration:()=>In,BartForSequenceClassification:()=>Wn,BartModel:()=>Ps,BartPretrainedModel:()=>ti,BaseModelOutput:()=>ze,BeitForImageClassification:()=>Ff,BeitModel:()=>Of,BeitPreTrainedModel:()=>kf,BertForMaskedLM:()=>H,BertForQuestionAnswering:()=>Ie,BertForSequenceClassification:()=>Y,BertForTokenClassification:()=>$e,BertModel:()=>Ye,BertPreTrainedModel:()=>Oe,BlenderbotForConditionalGeneration:()=>qn,BlenderbotModel:()=>Hn,BlenderbotPreTrainedModel:()=>Qn,BlenderbotSmallForConditionalGeneration:()=>cs,BlenderbotSmallModel:()=>mn,BlenderbotSmallPreTrainedModel:()=>Jt,BloomForCausalLM:()=>mf,BloomModel:()=>pf,BloomPreTrainedModel:()=>hc,CLIPModel:()=>nh,CLIPPreTrainedModel:()=>lr,CLIPSegForImageSegmentation:()=>Ki,CLIPSegModel:()=>uh,CLIPSegPreTrainedModel:()=>Fl,CLIPTextModel:()=>z0,CLIPTextModelWithProjection:()=>Hi,CLIPVisionModel:()=>ty,CLIPVisionModelWithProjection:()=>Wo,CamembertForMaskedLM:()=>Fe,CamembertForQuestionAnswering:()=>Pt,CamembertForSequenceClassification:()=>Ke,CamembertForTokenClassification:()=>pt,CamembertModel:()=>ge,CamembertPreTrainedModel:()=>se,CausalLMOutput:()=>ue,CausalLMOutputWithPast:()=>ce,ChineseCLIPModel:()=>oh,ChineseCLIPPreTrainedModel:()=>rh,ClapAudioModelWithProjection:()=>pm,ClapModel:()=>fm,ClapPreTrainedModel:()=>fa,ClapTextModelWithProjection:()=>Ty,CodeGenForCausalLM:()=>xh,CodeGenModel:()=>wh,CodeGenPreTrainedModel:()=>jl,CohereForCausalLM:()=>Xh,CohereModel:()=>Kh,CoherePreTrainedModel:()=>tc,ConvBertForMaskedLM:()=>qt,ConvBertForQuestionAnswering:()=>rt,ConvBertForSequenceClassification:()=>Me,ConvBertForTokenClassification:()=>at,ConvBertModel:()=>bs,ConvBertPreTrainedModel:()=>Di,ConvNextForImageClassification:()=>pp,ConvNextModel:()=>fp,ConvNextPreTrainedModel:()=>Uc,ConvNextV2ForImageClassification:()=>_p,ConvNextV2Model:()=>gp,ConvNextV2PreTrainedModel:()=>mp,DFineForObjectDetection:()=>jf,DFineModel:()=>Ic,DFinePreTrainedModel:()=>Cc,DINOv3ConvNextModel:()=>As,DINOv3ConvNextPreTrainedModel:()=>hs,DINOv3ViTModel:()=>my,DINOv3ViTPreTrainedModel:()=>xp,DPTForDepthEstimation:()=>ep,DPTModel:()=>Zf,DPTPreTrainedModel:()=>zc,DacDecoderModel:()=>Cy,DacDecoderOutput:()=>Hm,DacEncoderModel:()=>Km,DacEncoderOutput:()=>Wm,DacModel:()=>qm,DacPreTrainedModel:()=>mo,DebertaForMaskedLM:()=>Dt,DebertaForQuestionAnswering:()=>nn,DebertaForSequenceClassification:()=>tn,DebertaForTokenClassification:()=>Vt,DebertaModel:()=>en,DebertaPreTrainedModel:()=>Tt,DebertaV2ForMaskedLM:()=>ui,DebertaV2ForQuestionAnswering:()=>ki,DebertaV2ForSequenceClassification:()=>Bi,DebertaV2ForTokenClassification:()=>gi,DebertaV2Model:()=>bi,DebertaV2PreTrainedModel:()=>Tn,DecisionTransformerModel:()=>Lm,DecisionTransformerPreTrainedModel:()=>Im,DeiTForImageClassification:()=>qf,DeiTModel:()=>ay,DeiTPreTrainedModel:()=>Dc,DepthAnythingForDepthEstimation:()=>tp,DepthAnythingPreTrainedModel:()=>cy,DepthProForDepthEstimation:()=>rp,DepthProPreTrainedModel:()=>uy,DetrForObjectDetection:()=>ta,DetrForSegmentation:()=>Ec,DetrModel:()=>Rf,DetrObjectDetectionOutput:()=>lo,DetrPreTrainedModel:()=>Tc,DetrSegmentationOutput:()=>Sc,Dinov2ForImageClassification:()=>py,Dinov2Model:()=>yp,Dinov2PreTrainedModel:()=>Gc,Dinov2WithRegistersForImageClassification:()=>wp,Dinov2WithRegistersModel:()=>vp,Dinov2WithRegistersPreTrainedModel:()=>Vc,DistilBertForMaskedLM:()=>Wt,DistilBertForQuestionAnswering:()=>zi,DistilBertForSequenceClassification:()=>Ts,DistilBertForTokenClassification:()=>zs,DistilBertModel:()=>Ms,DistilBertPreTrainedModel:()=>Mi,DonutSwinModel:()=>hp,DonutSwinPreTrainedModel:()=>fy,EdgeTamModel:()=>gy,EfficientNetForImageClassification:()=>vm,EfficientNetModel:()=>ou,EfficientNetPreTrainedModel:()=>ma,ElectraForMaskedLM:()=>an,ElectraForQuestionAnswering:()=>J,ElectraForSequenceClassification:()=>B,ElectraForTokenClassification:()=>le,ElectraModel:()=>_t,ElectraPreTrainedModel:()=>mt,Ernie4_5ForCausalLM:()=>lm,Ernie4_5Model:()=>am,Ernie4_5PreTrainedModel:()=>ua,EsmForMaskedLM:()=>$s,EsmForSequenceClassification:()=>Ns,EsmForTokenClassification:()=>Us,EsmModel:()=>or,EsmPreTrainedModel:()=>ji,ExaoneForCausalLM:()=>zh,ExaoneModel:()=>Bh,ExaonePreTrainedModel:()=>Yl,FalconForCausalLM:()=>hm,FalconModel:()=>dm,FalconPreTrainedModel:()=>ha,FastViTForImageClassification:()=>wc,FastViTModel:()=>Tf,FastViTPreTrainedModel:()=>Qo,Florence2ForConditionalGeneration:()=>Xd,Florence2PreTrainedModel:()=>Kd,GLPNForDepthEstimation:()=>dp,GLPNModel:()=>up,GLPNPreTrainedModel:()=>Nc,GPT2LMHeadModel:()=>hh,GPT2Model:()=>dh,GPT2PreTrainedModel:()=>Rl,GPTBigCodeForCausalLM:()=>Ko,GPTBigCodeModel:()=>vh,GPTBigCodePreTrainedModel:()=>yh,GPTJForCausalLM:()=>Vl,GPTJModel:()=>_h,GPTJPreTrainedModel:()=>Gl,GPTNeoForCausalLM:()=>gh,GPTNeoModel:()=>mh,GPTNeoPreTrainedModel:()=>zl,GPTNeoXForCausalLM:()=>Ul,GPTNeoXModel:()=>Nl,GPTNeoXPreTrainedModel:()=>$l,Gemma2ForCausalLM:()=>Qh,Gemma2Model:()=>sc,Gemma2PreTrainedModel:()=>ic,Gemma3ForCausalLM:()=>tf,Gemma3Model:()=>ef,Gemma3PreTrainedModel:()=>oc,Gemma3nForConditionalGeneration:()=>Dl,Gemma3nPreTrainedModel:()=>Zd,GemmaForCausalLM:()=>Jh,GemmaModel:()=>Yh,GemmaPreTrainedModel:()=>nc,GlmForCausalLM:()=>Rh,GlmModel:()=>Fh,GlmPreTrainedModel:()=>Xl,GraniteForCausalLM:()=>Wh,GraniteModel:()=>jh,GraniteMoeHybridForCausalLM:()=>qh,GraniteMoeHybridModel:()=>Hh,GraniteMoeHybridPreTrainedModel:()=>ec,GranitePreTrainedModel:()=>Zl,GroundingDinoForObjectDetection:()=>pr,GroundingDinoPreTrainedModel:()=>fr,GroupViTModel:()=>vc,GroupViTPreTrainedModel:()=>Mf,HeliumForCausalLM:()=>Oh,HeliumModel:()=>kh,HeliumPreTrainedModel:()=>Kl,HieraForImageClassification:()=>Xf,HieraModel:()=>Kf,HieraPreTrainedModel:()=>kc,HubertForCTC:()=>wy,HubertForSequenceClassification:()=>qp,HubertModel:()=>Hp,HubertPreTrainedModel:()=>vy,IJepaForImageClassification:()=>mc,IJepaModel:()=>ur,IJepaPreTrainedModel:()=>Vs,Idefics3ForConditionalGeneration:()=>jo,Idefics3PreTrainedModel:()=>eh,ImageMattingOutput:()=>ke,JAISLMHeadModel:()=>ph,JAISModel:()=>fh,JAISPreTrainedModel:()=>Bl,JinaCLIPModel:()=>ah,JinaCLIPPreTrainedModel:()=>qo,JinaCLIPTextModel:()=>lh,JinaCLIPVisionModel:()=>ch,Lfm2ForCausalLM:()=>Ih,Lfm2Model:()=>ny,Lfm2PreTrainedModel:()=>ql,LiteWhisperForConditionalGeneration:()=>jd,Llama4ForCausalLM:()=>Th,Llama4PreTrainedModel:()=>Wl,LlamaForCausalLM:()=>Mh,LlamaModel:()=>bh,LlamaPreTrainedModel:()=>kr,LlavaForConditionalGeneration:()=>Vo,LlavaOnevisionForConditionalGeneration:()=>Hd,LlavaPreTrainedModel:()=>Ll,LlavaQwen2ForCausalLM:()=>$i,LongT5ForConditionalGeneration:()=>Un,LongT5Model:()=>En,LongT5PreTrainedModel:()=>Bn,M2M100ForConditionalGeneration:()=>Lp,M2M100Model:()=>uo,M2M100PreTrainedModel:()=>qc,MBartForCausalLM:()=>ls,MBartForConditionalGeneration:()=>as,MBartForSequenceClassification:()=>oi,MBartModel:()=>os,MBartPreTrainedModel:()=>ri,MPNetForMaskedLM:()=>it,MPNetForQuestionAnswering:()=>Xe,MPNetForSequenceClassification:()=>Es,MPNetForTokenClassification:()=>ro,MPNetModel:()=>Wi,MPNetPreTrainedModel:()=>yn,MT5ForConditionalGeneration:()=>Ss,MT5Model:()=>Ti,MT5PreTrainedModel:()=>di,MarianMTModel:()=>Hc,MarianModel:()=>Ip,MarianPreTrainedModel:()=>Wc,MaskFormerForInstanceSegmentation:()=>hy,MaskFormerModel:()=>cp,MaskFormerPreTrainedModel:()=>$c,MaskedLMOutput:()=>re,Metric3DForDepthEstimation:()=>dy,Metric3DPreTrainedModel:()=>op,Metric3Dv2ForDepthEstimation:()=>lp,Metric3Dv2PreTrainedModel:()=>ap,MgpstrForSceneTextRecognition:()=>Fm,MgpstrModelOutput:()=>km,MgpstrPreTrainedModel:()=>Om,MimiDecoderModel:()=>Ay,MimiDecoderOutput:()=>Gm,MimiEncoderModel:()=>jm,MimiEncoderOutput:()=>Um,MimiModel:()=>Vm,MimiPreTrainedModel:()=>pu,Ministral3ForCausalLM:()=>iu,Ministral3Model:()=>om,Ministral3PreTrainedModel:()=>nu,MinistralForCausalLM:()=>tu,MinistralModel:()=>eu,MinistralPreTrainedModel:()=>ca,Mistral3ForConditionalGeneration:()=>Qd,MistralForCausalLM:()=>Zc,MistralModel:()=>fo,MistralPreTrainedModel:()=>rm,MobileBertForMaskedLM:()=>bt,MobileBertForQuestionAnswering:()=>Lt,MobileBertForSequenceClassification:()=>ct,MobileBertModel:()=>_i,MobileBertPreTrainedModel:()=>rs,MobileLLMForCausalLM:()=>Nh,MobileLLMModel:()=>$h,MobileLLMPreTrainedModel:()=>Jl,MobileNetV1ForImageClassification:()=>cu,MobileNetV1ForSemanticSegmentation:()=>xm,MobileNetV1Model:()=>wm,MobileNetV1PreTrainedModel:()=>ga,MobileNetV2ForImageClassification:()=>Mm,MobileNetV2ForSemanticSegmentation:()=>Tm,MobileNetV2Model:()=>bm,MobileNetV2PreTrainedModel:()=>_a,MobileNetV3ForImageClassification:()=>Sm,MobileNetV3ForSemanticSegmentation:()=>uu,MobileNetV3Model:()=>Em,MobileNetV3PreTrainedModel:()=>ya,MobileNetV4ForImageClassification:()=>Am,MobileNetV4ForSemanticSegmentation:()=>Cm,MobileNetV4Model:()=>Pm,MobileNetV4PreTrainedModel:()=>va,MobileViTForImageClassification:()=>Pf,MobileViTModel:()=>Sf,MobileViTPreTrainedModel:()=>ea,MobileViTV2ForImageClassification:()=>xc,MobileViTV2Model:()=>Cf,MobileViTV2PreTrainedModel:()=>Af,ModelOutput:()=>Se,ModernBertDecoderForCausalLM:()=>wn,ModernBertDecoderModel:()=>Xt,ModernBertDecoderPreTrainedModel:()=>Rt,ModernBertForMaskedLM:()=>je,ModernBertForSequenceClassification:()=>lt,ModernBertForTokenClassification:()=>Mt,ModernBertModel:()=>He,ModernBertPreTrainedModel:()=>tt,Moondream1ForConditionalGeneration:()=>qd,MoonshineForConditionalGeneration:()=>Wd,MoonshineModel:()=>ar,MoonshinePreTrainedModel:()=>Cl,MptForCausalLM:()=>yf,MptModel:()=>_f,MptPreTrainedModel:()=>gf,MultiModalityCausalLM:()=>Py,MultiModalityPreTrainedModel:()=>Dm,MusicgenForCausalLM:()=>N0,MusicgenForConditionalGeneration:()=>lu,MusicgenModel:()=>Sy,MusicgenPreTrainedModel:()=>au,NanoChatForCausalLM:()=>Sh,NanoChatModel:()=>Eh,NanoChatPreTrainedModel:()=>Hl,NeoBertForMaskedLM:()=>Ne,NeoBertForQuestionAnswering:()=>qe,NeoBertForSequenceClassification:()=>ut,NeoBertForTokenClassification:()=>de,NeoBertModel:()=>Qe,NeoBertPreTrainedModel:()=>fe,NomicBertModel:()=>cn,NomicBertPreTrainedModel:()=>xn,OPTForCausalLM:()=>wf,OPTModel:()=>vf,OPTPreTrainedModel:()=>fc,Olmo2ForCausalLM:()=>Vh,Olmo2Model:()=>Gh,Olmo2PreTrainedModel:()=>Ql,OlmoForCausalLM:()=>Xo,OlmoModel:()=>Uh,OlmoPreTrainedModel:()=>Or,OpenELMForCausalLM:()=>lc,OpenELMModel:()=>nf,OpenELMPreTrainedModel:()=>ac,OwlViTForObjectDetection:()=>bc,OwlViTModel:()=>If,OwlViTPreTrainedModel:()=>Fr,Owlv2ForObjectDetection:()=>Df,Owlv2Model:()=>Lf,Owlv2PreTrainedModel:()=>Mc,PaliGemmaForConditionalGeneration:()=>Jd,PaliGemmaPreTrainedModel:()=>Yd,ParakeetForCTC:()=>Rp,ParakeetPreTrainedModel:()=>Kc,PatchTSMixerForPrediction:()=>zm,PatchTSMixerModel:()=>hu,PatchTSMixerPreTrainedModel:()=>du,PatchTSTForPrediction:()=>po,PatchTSTModel:()=>Bm,PatchTSTPreTrainedModel:()=>Rm,Phi3ForCausalLM:()=>ff,Phi3Model:()=>hf,Phi3PreTrainedModel:()=>dc,Phi3VForCausalLM:()=>Ol,Phi3VPreTrainedModel:()=>th,PhiForCausalLM:()=>df,PhiModel:()=>uf,PhiPreTrainedModel:()=>uc,PreTrainedModel:()=>U,PretrainedMixin:()=>gn,PvtForImageClassification:()=>xf,PvtModel:()=>_c,PvtPreTrainedModel:()=>gc,PyAnnoteForAudioFrameClassification:()=>zp,PyAnnoteModel:()=>Bp,PyAnnotePreTrainedModel:()=>Xc,QuestionAnsweringModelOutput:()=>Te,Qwen2ForCausalLM:()=>rf,Qwen2Model:()=>sf,Qwen2PreTrainedModel:()=>cc,Qwen2VLForConditionalGeneration:()=>cf,Qwen2VLPreTrainedModel:()=>Xi,Qwen3ForCausalLM:()=>lf,Qwen3Model:()=>af,Qwen3PreTrainedModel:()=>of,RFDetrForObjectDetection:()=>Ac,RFDetrModel:()=>Gf,RFDetrObjectDetectionOutput:()=>Vf,RFDetrPreTrainedModel:()=>Pc,RTDetrForObjectDetection:()=>zf,RTDetrModel:()=>Bf,RTDetrObjectDetectionOutput:()=>Rr,RTDetrPreTrainedModel:()=>na,RTDetrV2ForObjectDetection:()=>ry,RTDetrV2Model:()=>Nf,RTDetrV2ObjectDetectionOutput:()=>Uf,RTDetrV2PreTrainedModel:()=>$f,ResNetForImageClassification:()=>ia,ResNetModel:()=>ly,ResNetPreTrainedModel:()=>Oc,RoFormerForMaskedLM:()=>ss,RoFormerForQuestionAnswering:()=>Mn,RoFormerForSequenceClassification:()=>Vi,RoFormerForTokenClassification:()=>Cn,RoFormerModel:()=>ci,RoFormerPreTrainedModel:()=>jn,RobertaForMaskedLM:()=>hi,RobertaForQuestionAnswering:()=>Sl,RobertaForSequenceClassification:()=>Gt,RobertaForTokenClassification:()=>kn,RobertaModel:()=>Zn,RobertaPreTrainedModel:()=>us,Sam2ImageSegmentationOutput:()=>Ap,Sam2Model:()=>sa,Sam2PreTrainedModel:()=>Cp,Sam3TrackerModel:()=>yi,SamImageSegmentationOutput:()=>Pp,SamModel:()=>Sp,SamPreTrainedModel:()=>Ep,SapiensForDepthEstimation:()=>ip,SapiensForNormalEstimation:()=>sp,SapiensForSemanticSegmentation:()=>np,SapiensPreTrainedModel:()=>co,SegformerForImageClassification:()=>gm,SegformerForSemanticSegmentation:()=>_m,SegformerModel:()=>$0,SegformerPreTrainedModel:()=>pa,Seq2SeqLMOutput:()=>V,SequenceClassifierOutput:()=>G,SiglipModel:()=>qi,SiglipPreTrainedModel:()=>Ho,SiglipTextModel:()=>ih,SiglipVisionModel:()=>sh,SmolLM3ForCausalLM:()=>Dh,SmolLM3Model:()=>Lh,SmolLM3PreTrainedModel:()=>hn,SmolVLMForConditionalGeneration:()=>kl,SnacDecoderModel:()=>Iy,SnacEncoderModel:()=>Ym,SnacModel:()=>Xm,SnacPreTrainedModel:()=>wa,SpeechT5ForSpeechToText:()=>Zp,SpeechT5ForTextToSpeech:()=>em,SpeechT5HifiGan:()=>tm,SpeechT5Model:()=>My,SpeechT5PreTrainedModel:()=>la,SqueezeBertForMaskedLM:()=>Ae,SqueezeBertForQuestionAnswering:()=>We,SqueezeBertForSequenceClassification:()=>Re,SqueezeBertModel:()=>ie,SqueezeBertPreTrainedModel:()=>j,StableLmForCausalLM:()=>ym,StableLmModel:()=>Ey,StableLmPreTrainedModel:()=>ru,Starcoder2ForCausalLM:()=>um,Starcoder2Model:()=>cm,Starcoder2PreTrainedModel:()=>da,StyleTextToSpeech2Model:()=>by,StyleTextToSpeech2PreTrainedModel:()=>Qp,SupertonicForConditionalGeneration:()=>Qc,SupertonicPreTrainedModel:()=>nm,Swin2SRForImageSuperResolution:()=>Bc,Swin2SRModel:()=>Qf,Swin2SRPreTrainedModel:()=>Rc,SwinForImageClassification:()=>Yf,SwinForSemanticSegmentation:()=>Jf,SwinModel:()=>Fc,SwinPreTrainedModel:()=>hr,T5ForConditionalGeneration:()=>_n,T5Model:()=>pn,T5PreTrainedModel:()=>Yt,TableTransformerForObjectDetection:()=>Wf,TableTransformerModel:()=>oy,TableTransformerObjectDetectionOutput:()=>Hf,TableTransformerPreTrainedModel:()=>Lc,TokenClassifierOutput:()=>X,TrOCRForCausalLM:()=>sm,TrOCRPreTrainedModel:()=>im,UltravoxModel:()=>fu,UltravoxPreTrainedModel:()=>$m,UniSpeechForCTC:()=>Up,UniSpeechForSequenceClassification:()=>Yc,UniSpeechModel:()=>Np,UniSpeechPreTrainedModel:()=>oa,UniSpeechSatForAudioFrameClassification:()=>Vp,UniSpeechSatForCTC:()=>_y,UniSpeechSatForSequenceClassification:()=>Jc,UniSpeechSatModel:()=>Gp,UniSpeechSatPreTrainedModel:()=>ho,VaultGemmaForCausalLM:()=>Zh,VaultGemmaModel:()=>rc,VaultGemmaPreTrainedModel:()=>Yo,ViTForImageClassification:()=>cr,ViTMAEModel:()=>ao,ViTMAEPreTrainedModel:()=>sy,ViTMSNForImageClassification:()=>bf,ViTMSNModel:()=>yc,ViTMSNPreTrainedModel:()=>Jo,ViTModel:()=>iy,ViTPreTrainedModel:()=>pc,VisionEncoderDecoderModel:()=>Il,VitMatteForImageMatting:()=>Zo,VitMattePreTrainedModel:()=>Ef,VitPoseForPoseEstimation:()=>ni,VitPosePreTrainedModel:()=>dr,VitsModel:()=>su,VitsModelOutput:()=>Le,VitsPreTrainedModel:()=>mm,VoxtralForConditionalGeneration:()=>Nm,Wav2Vec2BertForCTC:()=>yy,Wav2Vec2BertForSequenceClassification:()=>Wp,Wav2Vec2BertModel:()=>jp,Wav2Vec2BertPreTrainedModel:()=>aa,Wav2Vec2ForAudioFrameClassification:()=>Fp,Wav2Vec2ForCTC:()=>kp,Wav2Vec2ForSequenceClassification:()=>Op,Wav2Vec2Model:()=>Dp,Wav2Vec2PreTrainedModel:()=>js,WavLMForAudioFrameClassification:()=>Jp,WavLMForCTC:()=>Kp,WavLMForSequenceClassification:()=>Xp,WavLMForXVector:()=>Yp,WavLMModel:()=>xy,WavLMPreTrainedModel:()=>Br,WeSpeakerResNetModel:()=>$p,WeSpeakerResNetPreTrainedModel:()=>ra,WhisperForConditionalGeneration:()=>Ei,WhisperModel:()=>Vd,WhisperPreTrainedModel:()=>Al,XLMForQuestionAnswering:()=>$t,XLMForSequenceClassification:()=>oo,XLMForTokenClassification:()=>dt,XLMModel:()=>Gs,XLMPreTrainedModel:()=>ds,XLMRobertaForMaskedLM:()=>zd,XLMRobertaForQuestionAnswering:()=>Nd,XLMRobertaForSequenceClassification:()=>$d,XLMRobertaForTokenClassification:()=>sn,XLMRobertaModel:()=>Pl,XLMRobertaPreTrainedModel:()=>Dr,XLMWithLMHeadModel:()=>Nt,XVectorOutput:()=>ee,YolosForObjectDetection:()=>Mp,YolosModel:()=>bp,YolosObjectDetectionOutput:()=>Tp,YolosPreTrainedModel:()=>jc});var i=t("./src/configs.js"),r=t("./src/backends/onnx.js"),a=t("./src/utils/dtypes.js"),c=t("./src/utils/generic.js"),u=t("./src/utils/core.js"),l=t("./src/utils/hub.js"),f=t("./src/utils/constants.js"),m=t("./src/generation/logits_process.js"),h=t("./src/generation/configuration_utils.js"),p=t("./src/utils/tensor.js"),_=t("./src/utils/image.js"),v=t("./src/utils/maths.js"),S=t("./src/generation/stopping_criteria.js"),D=t("./src/generation/logits_sampler.js"),w=t("./src/env.js"),T=t("./src/models/whisper/generation_whisper.js"),F=t("./src/models/whisper/common_whisper.js");const E={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7,MultiModality:8,Phi3V:9,AudioTextToText:10,AutoEncoder:11,ImageAudioTextToText:12,Supertonic:13},A=new Map,L=new Map,I=new Map;async function R(M,C,z){var On;let oe=((On=z.config)==null?void 0:On["transformers.js_config"])??{},ve=z.device??oe.device;ve&&typeof ve!="string"&&(ve.hasOwnProperty(C)?ve=ve[C]:(console.warn(`device not specified for "${C}". Using the default device.`),ve=null));const Pe=ve??(w.apis.IS_NODE_ENV?"cpu":"wasm"),Ue=(0,r.deviceToExecutionProviders)(Pe),Je=oe.device_config??{};Je.hasOwnProperty(Pe)&&(oe={...oe,...Je[Pe]});let st=z.dtype??oe.dtype;if(typeof st!="string"&&(st&&st.hasOwnProperty(C)?st=st[C]:(st=a.DEFAULT_DEVICE_DTYPE_MAPPING[Pe]??a.DATA_TYPES.fp32,console.warn(`dtype not specified for "${C}". Using the default dtype (${st}) for this device (${Pe}).`))),st===a.DATA_TYPES.auto){let Zt=oe.dtype;typeof Zt!="string"&&(Zt=Zt==null?void 0:Zt[C]),Zt&&Zt!==a.DATA_TYPES.auto&&a.DATA_TYPES.hasOwnProperty(Zt)?st=Zt:st=a.DEFAULT_DEVICE_DTYPE_MAPPING[Pe]??a.DATA_TYPES.fp32}const gt=st;if(a.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(gt)){if(gt===a.DATA_TYPES.fp16&&Pe==="webgpu"&&!await(0,a.isWebGpuFp16Supported)())throw new Error(`The device (${Pe}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${gt}. Should be one of: ${Object.keys(a.DATA_TYPES).join(", ")}`);const wt=oe.kv_cache_dtype,yt=wt?typeof wt=="string"?wt:wt[gt]??"float32":void 0;if(yt&&!["float32","float16"].includes(yt))throw new Error(`Invalid kv_cache_dtype: ${yt}. Should be one of: float32, float16`);const ht={dtype:gt,kv_cache_dtype:yt,device:Pe},Ft=a.DEFAULT_DTYPE_SUFFIX_MAPPING[gt],xt=`${C}${Ft}.onnx`,Ct=`${z.subfolder??""}/${xt}`,Ze={...z.session_options};Ze.executionProviders??(Ze.executionProviders=Ue);const ft=oe.free_dimension_overrides;ft?Ze.freeDimensionOverrides??(Ze.freeDimensionOverrides=ft):Pe.startsWith("webnn")&&!Ze.freeDimensionOverrides&&console.warn(`WebNN does not currently support dynamic shapes and requires 'free_dimension_overrides' to be set in config.json, preferably as a field within config["transformers.js_config"]["device_config"]["${Pe}"]. When 'free_dimension_overrides' is not set, you may experience significant performance degradation.`);const St=w.apis.IS_NODE_ENV&&w.env.useFSCache,Ht=(0,l.getModelFile)(M,Ct,!0,z,St),un=z.use_external_data_format??oe.use_external_data_format;let Sn=[];if(un){let Zt;typeof un=="object"?un.hasOwnProperty(xt)?Zt=un[xt]:un.hasOwnProperty(C)?Zt=un[C]:Zt=!1:Zt=un;const Nn=+Zt;if(Nn>l.MAX_EXTERNAL_DATA_CHUNKS)throw new Error(`The number of external data chunks (${Nn}) exceeds the maximum allowed value (${l.MAX_EXTERNAL_DATA_CHUNKS}).`);for(let Pn=0;Pn<Nn;++Pn){const Fn=`${xt}_data${Pn===0?"":"_"+Pn}`,Xn=`${z.subfolder??""}/${Fn}`;Sn.push(new Promise(async(Yi,Lu)=>{const Ta=await(0,l.getModelFile)(M,Xn,!0,z,St);Yi(Ta instanceof Uint8Array?{path:Fn,data:Ta}:Fn)}))}}else Ze.externalData!==void 0&&(Sn=Ze.externalData.map(async Zt=>{if(typeof Zt.data=="string"){const Nn=await(0,l.getModelFile)(M,Zt.data,!0,z);return{...Zt,data:Nn}}return Zt}));if(Sn.length>0){const Zt=await Promise.all(Sn);w.apis.IS_NODE_ENV||(Ze.externalData=Zt)}if(Pe==="webgpu"){const Zt=(0,i.getCacheShapes)(z.config,{prefix:"present"});if(Object.keys(Zt).length>0&&!(0,r.isONNXProxy)()){const Nn={};for(const Pn in Zt)Nn[Pn]="gpu-buffer";Ze.preferredOutputLocation=Nn}}return{buffer_or_path:await Ht,session_options:Ze,session_config:ht}}async function N(M,C,z){return Object.fromEntries(await Promise.all(Object.keys(C).map(async oe=>{const{buffer_or_path:ve,session_options:Pe,session_config:Ue}=await R(M,C[oe],z),Je=await(0,r.createInferenceSession)(ve,Pe,Ue);return[oe,Je]})))}async function q(M,C,z){return Object.fromEntries(await Promise.all(Object.keys(C).map(async oe=>{const ve=await(0,l.getModelJSON)(M,C[oe],!1,z);return[oe,ve]})))}function ne(M,C){const z=Object.create(null),oe=[];for(const Ue of M.inputNames){const Je=C[Ue];if(!(Je instanceof p.Tensor)){oe.push(Ue);continue}z[Ue]=(0,r.isONNXProxy)()?Je.clone():Je}if(oe.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${oe.join(", ")}.`);const ve=Object.keys(C).length,Pe=M.inputNames.length;if(ve>Pe){let Ue=Object.keys(C).filter(Je=>!M.inputNames.includes(Je));console.warn(`WARNING: Too many inputs were provided (${ve} > ${Pe}). The following inputs will be ignored: "${Ue.join(", ")}".`)}return z}async function Q(M,C){const z=ne(M,C);try{const oe=Object.fromEntries(Object.entries(z).map(([Pe,Ue])=>[Pe,Ue.ort_tensor])),ve=await(0,r.runInferenceSession)(M,oe);return W(ve)}catch(oe){const ve=Object.fromEntries(Object.entries(z).map(([Pe,Ue])=>{const Je={type:Ue.type,dims:Ue.dims,location:Ue.location};return Je.location!=="gpu-buffer"&&(Je.data=Ue.data),[Pe,Je]}));throw console.error(`An error occurred during model execution: "${oe}".`),console.error("Inputs given to model:",ve),oe}}function W(M){for(let C in M)(0,r.isONNXTensor)(M[C])?M[C]=new p.Tensor(M[C]):typeof M[C]=="object"&&W(M[C]);return M}function te(M){if(M instanceof p.Tensor)return M;if(M.length===0)throw Error("items must be non-empty");if(Array.isArray(M[0])){if(M.some(C=>C.length!==M[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new p.Tensor("int64",BigInt64Array.from(M.flat().map(C=>BigInt(C))),[M.length,M[0].length])}else return new p.Tensor("int64",BigInt64Array.from(M.map(C=>BigInt(C))),[1,M.length])}function K(M){return new p.Tensor("bool",[M],[1])}async function pe(M,C){let{encoder_outputs:z,input_ids:oe,decoder_input_ids:ve,...Pe}=C;if(!z){const Je=(0,u.pick)(C,M.sessions.model.inputNames);z=(await be(M,Je)).last_hidden_state}return Pe.input_ids=ve,Pe.encoder_hidden_states=z,M.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(Pe.encoder_attention_mask=C.attention_mask),await Ge(M,Pe,!0)}async function be(M,C){const z=M.sessions.model,oe=(0,u.pick)(C,z.inputNames);if(z.inputNames.includes("inputs_embeds")&&!oe.inputs_embeds){if(!C.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");oe.inputs_embeds=await M.encode_text({input_ids:C.input_ids})}if(z.inputNames.includes("token_type_ids")&&!oe.token_type_ids){if(!oe.input_ids)throw new Error("Both `input_ids` and `token_type_ids` are missing in the model inputs.");oe.token_type_ids=(0,p.zeros_like)(oe.input_ids)}if(z.inputNames.includes("pixel_mask")&&!oe.pixel_mask){if(!oe.pixel_values)throw new Error("Both `pixel_values` and `pixel_mask` are missing in the model inputs.");const ve=oe.pixel_values.dims;oe.pixel_mask=(0,p.ones)([ve[0],ve[2],ve[3]])}return await Q(z,oe)}async function Ee(M,C){const z=await M.encode(C);return await M.decode(z)}async function Ge(M,C,z=!1){const oe=M.sessions[z?"decoder_model_merged":"model"],{past_key_values:ve,...Pe}=C;if(oe.inputNames.includes("use_cache_branch")&&(Pe.use_cache_branch=K(!!ve)),oe.inputNames.includes("position_ids")&&Pe.attention_mask&&!Pe.position_ids){const Je=["paligemma","gemma3_text","gemma3"].includes(M.config.model_type)?1:0;Pe.position_ids=et(Pe,ve,Je)}M.addPastKeyValues(Pe,ve);const Ue=(0,u.pick)(Pe,oe.inputNames);return await Q(oe,Ue)}function _e({modality_token_id:M,inputs_embeds:C,modality_features:z,input_ids:oe,attention_mask:ve}){const Pe=oe.tolist().map(gt=>gt.reduce((wt,yt,ht)=>(yt==M&&wt.push(ht),wt),[])),Ue=Pe.reduce((gt,wt)=>gt+wt.length,0),Je=z.dims[0];if(Ue!==Je)throw new Error(`Number of tokens and features do not match: tokens: ${Ue}, features ${Je}`);let st=0;for(let gt=0;gt<Pe.length;++gt){const wt=Pe[gt],yt=C[gt];for(let ht=0;ht<wt.length;++ht)yt[wt[ht]].data.set(z[st++].data)}return{inputs_embeds:C,attention_mask:ve}}function De({image_token_id:M,inputs_embeds:C,image_features:z,input_ids:oe,attention_mask:ve}){return _e({modality_token_id:M,inputs_embeds:C,modality_features:z,input_ids:oe,attention_mask:ve})}function he({audio_token_id:M,inputs_embeds:C,audio_features:z,input_ids:oe,attention_mask:ve}){return _e({modality_token_id:M,inputs_embeds:C,modality_features:z,input_ids:oe,attention_mask:ve})}async function Z(M,{encode_function:C,merge_function:z,modality_input_name:oe,modality_output_name:ve,input_ids:Pe=null,attention_mask:Ue=null,position_ids:Je=null,inputs_embeds:st=null,past_key_values:gt=null,generation_config:wt=null,logits_processor:yt=null,...ht}){const Ft=ht[oe];if(!st){if(st=await M.encode_text({input_ids:Pe,...ht}),Ft&&Pe.dims[1]!==1){const Ct=await C({[oe]:Ft,...ht});({inputs_embeds:st,attention_mask:Ue}=z({[ve]:Ct,inputs_embeds:st,input_ids:Pe,attention_mask:Ue}))}else if(gt&&Ft&&Pe.dims[1]===1){const Ct=Pe.dims[1],Ze=Object.values(gt)[0].dims.at(-2);Ue=(0,p.cat)([(0,p.ones)([Pe.dims[0],Ze]),Ue.slice(null,[Ue.dims[1]-Ct,Ue.dims[1]])],1)}}if(!Je&&M.config.model_type==="qwen2_vl"){const{image_grid_thw:Ct,video_grid_thw:Ze}=ht;[Je]=M.get_rope_index(Pe,Ct,Ze,Ue)}return await Ge(M,{inputs_embeds:st,past_key_values:gt,attention_mask:Ue,position_ids:Je,generation_config:wt,logits_processor:yt},!0)}async function me(M,C){return await Z(M,{...C,modality_input_name:"audio_values",modality_output_name:"audio_features",encode_function:M.encode_audio.bind(M),merge_function:M._merge_input_ids_with_audio_features.bind(M)})}async function we(M,C){return await Z(M,{...C,modality_input_name:"pixel_values",modality_output_name:"image_features",encode_function:M.encode_image.bind(M),merge_function:M._merge_input_ids_with_image_features.bind(M)})}function xe(M,C=0){const[z,oe]=M.dims,ve=M.data,Pe=new BigInt64Array(ve.length);for(let Ue=0;Ue<z;++Ue){const Je=Ue*oe;let st=BigInt(C);for(let gt=0;gt<oe;++gt){const wt=Je+gt;ve[wt]===0n?Pe[wt]=BigInt(1):(Pe[wt]=st,st+=ve[wt])}}return{data:Pe,dims:M.dims}}function et(M,C=null,z=0){const{input_ids:oe,inputs_embeds:ve,attention_mask:Pe}=M,{data:Ue,dims:Je}=xe(Pe,z);let st=new p.Tensor("int64",Ue,Je);if(C){const gt=-(oe??ve).dims.at(1);st=st.slice(null,[gt,null])}return st}function Ve(M,C,z,oe){const ve=z.past_key_values?Object.values(z.past_key_values)[0].dims.at(-2):0;if(!z.attention_mask){let Pe;for(const Ue of["input_ids","inputs_embeds","position_ids"])if(z[Ue]){Pe=z[Ue].dims;break}if(!Pe)throw new Error("attention_mask is not provided, and unable to infer its shape from model inputs.");z.attention_mask=(0,p.ones)([Pe[0],ve+Pe[1]])}if(z.past_key_values){const{input_ids:Pe,attention_mask:Ue}=z;Ue&&Ue.dims[1]>Pe.dims[1]||ve<Pe.dims[1]&&(z.input_ids=Pe.slice(null,[ve,null]))}return z}function nt(M,C,z,oe){return z.past_key_values&&(C=C.map(ve=>[ve.at(-1)])),{...z,decoder_input_ids:te(C)}}function Be(M,...C){return M.config.is_encoder_decoder?nt(M,...C):Ve(M,...C)}function ae(M,C,z,oe){const ve=!!z.past_key_values;return oe.guidance_scale!==null&&oe.guidance_scale>1&&(ve?z.input_ids=(0,p.cat)([z.input_ids,z.input_ids],0):(z.input_ids=(0,p.cat)([z.input_ids,(0,p.full_like)(z.input_ids,BigInt(oe.pad_token_id))],0),z.attention_mask=(0,p.cat)([z.attention_mask,(0,p.full_like)(z.attention_mask,0n)],0))),(ve||!z.pixel_values)&&(z.pixel_values=(0,p.full)([0,0,3,384,384],1)),ve&&(z.images_seq_mask=new p.Tensor("bool",new Array(0+1).fill(!0).fill(!1,0,1),[1,0+1]),z.images_emb_mask=new p.Tensor("bool",new Array(0).fill(!1),[1,1,0])),z}class U extends c.Callable{constructor(z,oe,ve){super();Ce(this,"main_input_name","input_ids");Ce(this,"forward_params",["input_ids","attention_mask"]);this.config=z,this.sessions=oe,this.configs=ve;const Pe=I.get(this.constructor),Ue=A.get(Pe);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,Ue){case E.DecoderOnly:this.can_generate=!0,this._forward=Ge,this._prepare_inputs_for_generation=Ve;break;case E.Seq2Seq:case E.Vision2Seq:case E.Musicgen:this.can_generate=!0,this._forward=pe,this._prepare_inputs_for_generation=nt;break;case E.EncoderDecoder:this._forward=pe;break;case E.ImageTextToText:this.can_generate=!0,this._forward=we,this._prepare_inputs_for_generation=Be;break;case E.AudioTextToText:this.can_generate=!0,this._forward=me,this._prepare_inputs_for_generation=Be;break;case E.Phi3V:case E.ImageAudioTextToText:this.can_generate=!0,this._prepare_inputs_for_generation=Be;break;case E.MultiModality:this.can_generate=!0,this._prepare_inputs_for_generation=ae;break;case E.AutoEncoder:this._forward=Ee;break;default:this._forward=be;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){var oe;const z=[];for(const ve of Object.values(this.sessions))(oe=ve==null?void 0:ve.handler)!=null&&oe.dispose&&z.push(ve.handler.dispose());return await Promise.all(z)}static async from_pretrained(z,{progress_callback:oe=null,config:ve=null,cache_dir:Pe=null,local_files_only:Ue=!1,revision:Je="main",model_file_name:st=null,subfolder:gt="onnx",device:wt=null,dtype:yt=null,use_external_data_format:ht=null,session_options:Ft={}}={}){let xt={progress_callback:oe,config:ve,cache_dir:Pe,local_files_only:Ue,revision:Je,model_file_name:st,subfolder:gt,device:wt,dtype:yt,use_external_data_format:ht,session_options:Ft};const Ct=I.get(this),Ze=A.get(Ct);ve=xt.config=await i.AutoConfig.from_pretrained(z,xt);let ft;if(Ze===E.DecoderOnly)ft=await Promise.all([N(z,{model:xt.model_file_name??"model"},xt),q(z,{generation_config:"generation_config.json"},xt)]);else if(Ze===E.Seq2Seq||Ze===E.Vision2Seq)ft=await Promise.all([N(z,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},xt),q(z,{generation_config:"generation_config.json"},xt)]);else if(Ze===E.MaskGeneration)ft=await Promise.all([N(z,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},xt)]);else if(Ze===E.EncoderDecoder)ft=await Promise.all([N(z,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},xt)]);else if(Ze===E.ImageTextToText){const St={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};ve.is_encoder_decoder&&(St.model="encoder_model"),ft=await Promise.all([N(z,St,xt),q(z,{generation_config:"generation_config.json"},xt)])}else if(Ze===E.AudioTextToText){const St={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",decoder_model_merged:"decoder_model_merged"};ft=await Promise.all([N(z,St,xt),q(z,{generation_config:"generation_config.json"},xt)])}else if(Ze===E.ImageAudioTextToText){const St={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};ft=await Promise.all([N(z,St,xt),q(z,{generation_config:"generation_config.json"},xt)])}else if(Ze===E.Musicgen)ft=await Promise.all([N(z,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},xt),q(z,{generation_config:"generation_config.json"},xt)]);else if(Ze===E.MultiModality)ft=await Promise.all([N(z,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},xt),q(z,{generation_config:"generation_config.json"},xt)]);else if(Ze===E.Phi3V)ft=await Promise.all([N(z,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},xt),q(z,{generation_config:"generation_config.json"},xt)]);else if(Ze===E.AutoEncoder)ft=await Promise.all([N(z,{encoder_model:"encoder_model",decoder_model:"decoder_model"},xt)]);else if(Ze===E.Supertonic)ft=await Promise.all([N(z,{text_encoder:"text_encoder",latent_denoiser:"latent_denoiser",voice_decoder:"voice_decoder"},xt)]);else{if(Ze!==E.EncoderOnly){const St=Ct??(ve==null?void 0:ve.model_type);St!=="custom"&&console.warn(`Model type for '${St}' not found, assuming encoder-only architecture. Please report this at ${f.GITHUB_ISSUE_URL}.`)}ft=await Promise.all([N(z,{model:xt.model_file_name??"model"},xt)])}return new this(ve,...ft)}async _call(z){return await this.forward(z)}async forward(z){return await this._forward(this,z)}get generation_config(){var z;return((z=this.configs)==null?void 0:z.generation_config)??null}_get_logits_processor(z,oe,ve=null){const Pe=new m.LogitsProcessorList;if(z.repetition_penalty!==null&&z.repetition_penalty!==1&&Pe.push(new m.RepetitionPenaltyLogitsProcessor(z.repetition_penalty)),z.no_repeat_ngram_size!==null&&z.no_repeat_ngram_size>0&&Pe.push(new m.NoRepeatNGramLogitsProcessor(z.no_repeat_ngram_size)),z.bad_words_ids!==null&&Pe.push(new m.NoBadWordsLogitsProcessor(z.bad_words_ids,z.eos_token_id)),z.min_length!==null&&z.eos_token_id!==null&&z.min_length>0&&Pe.push(new m.MinLengthLogitsProcessor(z.min_length,z.eos_token_id)),z.min_new_tokens!==null&&z.eos_token_id!==null&&z.min_new_tokens>0&&Pe.push(new m.MinNewTokensLengthLogitsProcessor(oe,z.min_new_tokens,z.eos_token_id)),z.forced_bos_token_id!==null&&Pe.push(new m.ForcedBOSTokenLogitsProcessor(z.forced_bos_token_id)),z.forced_eos_token_id!==null&&Pe.push(new m.ForcedEOSTokenLogitsProcessor(z.max_length,z.forced_eos_token_id)),z.begin_suppress_tokens!==null){const Ue=oe>1||z.forced_bos_token_id===null?oe:oe+1;Pe.push(new m.SuppressTokensAtBeginLogitsProcessor(z.begin_suppress_tokens,Ue))}return z.guidance_scale!==null&&z.guidance_scale>1&&Pe.push(new m.ClassifierFreeGuidanceLogitsProcessor(z.guidance_scale)),z.temperature===0&&z.do_sample&&(console.warn("`do_sample` changed to false because `temperature: 0` implies greedy sampling (always selecting the most likely token), which is incompatible with `do_sample: true`."),z.do_sample=!1),z.do_sample&&z.temperature!==null&&z.temperature!==1&&Pe.push(new m.TemperatureLogitsWarper(z.temperature)),ve!==null&&Pe.extend(ve),Pe}_prepare_generation_config(z,oe,ve=h.GenerationConfig){const Pe={...this.config};for(const Je of["decoder","generator","text_config"])Je in Pe&&Object.assign(Pe,Pe[Je]);const Ue=new ve(Pe);return Object.assign(Ue,this.generation_config??{}),z&&Object.assign(Ue,z),oe&&Object.assign(Ue,(0,u.pick)(oe,Object.getOwnPropertyNames(Ue))),Ue}_get_stopping_criteria(z,oe=null){const ve=new S.StoppingCriteriaList;return z.max_length!==null&&ve.push(new S.MaxLengthCriteria(z.max_length,this.config.max_position_embeddings??null)),z.eos_token_id!==null&&ve.push(new S.EosTokenCriteria(z.eos_token_id)),oe&&ve.extend(oe),ve}_validate_model_class(){if(!this.can_generate){const z=[go,_u,gu,mu],oe=I.get(this.constructor),ve=new Set,Pe=this.config.model_type;for(const Je of z){const st=Je.get(Pe);st&&ve.add(st[0])}let Ue=`The current model class (${oe}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw ve.size>0&&(Ue+=` Please use the following class instead: ${[...ve].join(", ")}`),Error(Ue)}}prepare_inputs_for_generation(...z){return this._prepare_inputs_for_generation(this,...z)}_update_model_kwargs_for_generation({generated_input_ids:z,outputs:oe,model_inputs:ve,is_encoder_decoder:Pe}){return ve.past_key_values=this.getPastKeyValues(oe,ve.past_key_values),ve.input_ids=new p.Tensor("int64",z.flat(),[z.length,1]),Pe||(ve.attention_mask=(0,p.cat)([ve.attention_mask,(0,p.ones)([ve.attention_mask.dims[0],1])],1)),ve.position_ids=null,ve}_prepare_model_inputs({inputs:z,bos_token_id:oe,model_kwargs:ve}){const Pe=(0,u.pick)(ve,this.forward_params),Ue=this.main_input_name;if(Ue in Pe){if(z)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else Pe[Ue]=z;return{inputs_tensor:Pe[Ue],model_inputs:Pe,model_input_name:Ue}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:z,model_inputs:oe,model_input_name:ve,generation_config:Pe}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!oe.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:Je,pixel_values:st,attention_mask:gt,...wt}=oe,yt=await this._prepare_inputs_embeds(oe);oe={...wt,...(0,u.pick)(yt,["inputs_embeds","attention_mask"])}}let{last_hidden_state:Ue}=await be(this,oe);if(Pe.guidance_scale!==null&&Pe.guidance_scale>1)Ue=(0,p.cat)([Ue,(0,p.full_like)(Ue,0)],0),"attention_mask"in oe&&(oe.attention_mask=(0,p.cat)([oe.attention_mask,(0,p.zeros_like)(oe.attention_mask)],0));else if(oe.decoder_input_ids){const Je=te(oe.decoder_input_ids).dims[0];if(Je!==Ue.dims[0]){if(Ue.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${Ue.dims[0]}) than the decoder inputs (${Je}).`);Ue=(0,p.cat)(Array.from({length:Je},()=>Ue),0)}}return oe.encoder_outputs=Ue,oe}_prepare_decoder_input_ids_for_generation({batch_size:z,model_input_name:oe,model_kwargs:ve,decoder_start_token_id:Pe,bos_token_id:Ue,generation_config:Je}){let{decoder_input_ids:st,...gt}=ve;if(!(st instanceof p.Tensor)){if(st)Array.isArray(st[0])||(st=Array.from({length:z},()=>st));else if(Pe??(Pe=Ue),this.config.model_type==="musicgen")st=Array.from({length:z*this.config.decoder.num_codebooks},()=>[Pe]);else if(Array.isArray(Pe)){if(Pe.length!==z)throw new Error(`\`decoder_start_token_id\` expcted to have length ${z} but got ${Pe.length}`);st=Pe}else st=Array.from({length:z},()=>[Pe]);st=te(st)}return ve.decoder_attention_mask=(0,p.ones_like)(st),{input_ids:st,model_inputs:gt}}async generate({inputs:z=null,generation_config:oe=null,logits_processor:ve=null,stopping_criteria:Pe=null,streamer:Ue=null,...Je}){this._validate_model_class(),oe=this._prepare_generation_config(oe,Je);let{inputs_tensor:st,model_inputs:gt,model_input_name:wt}=this._prepare_model_inputs({inputs:z,model_kwargs:Je});const yt=this.config.is_encoder_decoder;yt&&("encoder_outputs"in gt||(gt=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:st,model_inputs:gt,model_input_name:wt,generation_config:oe})));let ht;yt?{input_ids:ht,model_inputs:gt}=this._prepare_decoder_input_ids_for_generation({batch_size:gt[wt].dims.at(0),model_input_name:wt,model_kwargs:gt,decoder_start_token_id:oe.decoder_start_token_id,bos_token_id:oe.bos_token_id,generation_config:oe}):ht=gt[wt];let Ft=ht.dims.at(-1);oe.max_new_tokens!==null&&(oe.max_length=Ft+oe.max_new_tokens);const xt=this._get_logits_processor(oe,Ft,ve),Ct=this._get_stopping_criteria(oe,Pe),Ze=gt[wt].dims.at(0),ft=D.LogitsSampler.getSampler(oe),St=new Array(Ze).fill(0),Ht=ht.tolist();Ue&&Ue.put(Ht);let un,Sn={};for(;;){if(gt=this.prepare_inputs_for_generation(Ht,gt,oe),un=await this.forward(gt),oe.output_attentions&&oe.return_dict_in_generate){const Xn=this.getAttentions(un);for(const Yi in Xn)Yi in Sn||(Sn[Yi]=[]),Sn[Yi].push(Xn[Yi])}const Zt=un.logits.slice(null,-1,null),Nn=xt(Ht,Zt),Pn=[];for(let Xn=0;Xn<Nn.dims.at(0);++Xn){const Yi=Nn[Xn],Lu=await ft(Yi);for(const[Ta,Ny]of Lu){const Uy=BigInt(Ta);St[Xn]+=Ny,Ht[Xn].push(Uy),Pn.push([Uy]);break}}if(Ue&&Ue.put(Pn),Ct(Ht).every(Xn=>Xn))break;gt=this._update_model_kwargs_for_generation({generated_input_ids:Pn,outputs:un,model_inputs:gt,is_encoder_decoder:yt})}Ue&&Ue.end();const Kn=this.getPastKeyValues(un,gt.past_key_values,!0),On=new p.Tensor("int64",Ht.flat(),[Ht.length,Ht[0].length]);if(oe.return_dict_in_generate)return{sequences:On,past_key_values:Kn,...Sn};for(const Zt of Object.values(un))Zt.location==="gpu-buffer"&&Zt.dispose();return On}getPastKeyValues(z,oe,ve=!1){const Pe=Object.create(null);for(const Ue in z)if(Ue.startsWith("present")){const Je=Ue.replace("present_conv","past_conv").replace("present","past_key_values"),st=Ue.includes("encoder");if(st&&oe?Pe[Je]=oe[Je]:Pe[Je]=z[Ue],oe&&(!st||ve)){const gt=oe[Je];gt.location==="gpu-buffer"&&gt.dispose()}}return Pe}getAttentions(z){const oe={};for(const ve of["cross_attentions","encoder_attentions","decoder_attentions"])for(const Pe in z)Pe.startsWith(ve)&&(ve in oe||(oe[ve]=[]),oe[ve].push(z[Pe]));return oe}addPastKeyValues(z,oe){var ve,Pe,Ue;if(oe)Object.assign(z,oe);else{const Je=this.sessions.decoder_model_merged??this.sessions.model,st=((Pe=(ve=z[this.main_input_name]??z.attention_mask)==null?void 0:ve.dims)==null?void 0:Pe[0])??1,gt=((Ue=Je==null?void 0:Je.config)==null?void 0:Ue.kv_cache_dtype)??"float32",wt=gt==="float16"?p.DataTypeMap.float16:p.DataTypeMap.float32,yt=(0,i.getCacheShapes)(this.config,{batch_size:st});for(const ht in yt){const Ft=yt[ht].reduce((xt,Ct)=>xt*Ct,1);z[ht]=new p.Tensor(gt,new wt(Ft),yt[ht])}}}async encode_image({pixel_values:z}){return(await Q(this.sessions.vision_encoder,{pixel_values:z})).image_features}async encode_text({input_ids:z}){return(await Q(this.sessions.embed_tokens,{input_ids:z})).inputs_embeds}async encode_audio({audio_values:z}){return(await Q(this.sessions.audio_encoder,{audio_values:z})).audio_features}}class Se{}class ze extends Se{constructor({last_hidden_state:C,hidden_states:z=null,attentions:oe=null}){super(),this.last_hidden_state=C,this.hidden_states=z,this.attentions=oe}}class Oe extends U{}class Ye extends Oe{}class H extends Oe{async _call(C){return new re(await super._call(C))}}class Y extends Oe{async _call(C){return new G(await super._call(C))}}class $e extends Oe{async _call(C){return new X(await super._call(C))}}class Ie extends Oe{async _call(C){return new Te(await super._call(C))}}class fe extends U{}class Qe extends fe{}class Ne extends fe{async _call(C){return new re(await super._call(C))}}class ut extends fe{async _call(C){return new G(await super._call(C))}}class de extends fe{async _call(C){return new X(await super._call(C))}}class qe extends fe{async _call(C){return new Te(await super._call(C))}}class tt extends U{}class He extends tt{}class je extends tt{async _call(C){return new re(await super._call(C))}}class lt extends tt{async _call(C){return new G(await super._call(C))}}class Mt extends tt{async _call(C){return new X(await super._call(C))}}class Rt extends U{}class Xt extends Rt{}class wn extends Rt{}class xn extends U{}class cn extends xn{}class jn extends U{}class ci extends jn{}class ss extends jn{async _call(C){return new re(await super._call(C))}}class Vi extends jn{async _call(C){return new G(await super._call(C))}}class Cn extends jn{async _call(C){return new X(await super._call(C))}}class Mn extends jn{async _call(C){return new Te(await super._call(C))}}class Di extends U{}class bs extends Di{}class qt extends Di{async _call(C){return new re(await super._call(C))}}class Me extends Di{async _call(C){return new G(await super._call(C))}}class at extends Di{async _call(C){return new X(await super._call(C))}}class rt extends Di{async _call(C){return new Te(await super._call(C))}}class mt extends U{}class _t extends mt{}class an extends mt{async _call(C){return new re(await super._call(C))}}class B extends mt{async _call(C){return new G(await super._call(C))}}class le extends mt{async _call(C){return new X(await super._call(C))}}class J extends mt{async _call(C){return new Te(await super._call(C))}}class se extends U{}class ge extends se{}class Fe extends se{async _call(C){return new re(await super._call(C))}}class Ke extends se{async _call(C){return new G(await super._call(C))}}class pt extends se{async _call(C){return new X(await super._call(C))}}class Pt extends se{async _call(C){return new Te(await super._call(C))}}class Tt extends U{}class en extends Tt{}class Dt extends Tt{async _call(C){return new re(await super._call(C))}}class tn extends Tt{async _call(C){return new G(await super._call(C))}}class Vt extends Tt{async _call(C){return new X(await super._call(C))}}class nn extends Tt{async _call(C){return new Te(await super._call(C))}}class Tn extends U{}class bi extends Tn{}class ui extends Tn{async _call(C){return new re(await super._call(C))}}class Bi extends Tn{async _call(C){return new G(await super._call(C))}}class gi extends Tn{async _call(C){return new X(await super._call(C))}}class ki extends Tn{async _call(C){return new Te(await super._call(C))}}class Mi extends U{}class Ms extends Mi{}class Ts extends Mi{async _call(C){return new G(await super._call(C))}}class zs extends Mi{async _call(C){return new X(await super._call(C))}}class zi extends Mi{async _call(C){return new Te(await super._call(C))}}class Wt extends Mi{async _call(C){return new re(await super._call(C))}}class ji extends U{}class or extends ji{}class $s extends ji{async _call(C){return new re(await super._call(C))}}class Ns extends ji{async _call(C){return new G(await super._call(C))}}class Us extends ji{async _call(C){return new X(await super._call(C))}}class rs extends U{}class _i extends rs{}class bt extends rs{async _call(C){return new re(await super._call(C))}}class ct extends rs{async _call(C){return new G(await super._call(C))}}class Lt extends rs{async _call(C){return new Te(await super._call(C))}}class yn extends U{}class Wi extends yn{}class it extends yn{async _call(C){return new re(await super._call(C))}}class Es extends yn{async _call(C){return new G(await super._call(C))}}class ro extends yn{async _call(C){return new X(await super._call(C))}}class Xe extends yn{async _call(C){return new Te(await super._call(C))}}class j extends U{}class ie extends j{}class Ae extends j{async _call(C){return new re(await super._call(C))}}class Re extends j{async _call(C){return new G(await super._call(C))}}class We extends j{async _call(C){return new Te(await super._call(C))}}class ot extends U{}class Et extends ot{}class It extends ot{async _call(C){return new G(await super._call(C))}}class At extends ot{async _call(C){return new Te(await super._call(C))}}class kt extends ot{async _call(C){return new re(await super._call(C))}}class Yt extends U{constructor(){super(...arguments);Ce(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class pn extends Yt{}class _n extends Yt{}class Bn extends U{}class En extends Bn{}class Un extends Bn{}class di extends U{}class Ti extends di{}class Ss extends di{}class ti extends U{}class Ps extends ti{}class In extends ti{}class Wn extends ti{async _call(C){return new G(await super._call(C))}}class ri extends U{}class os extends ri{}class as extends ri{}class oi extends ri{async _call(C){return new G(await super._call(C))}}class ls extends ri{}class Qn extends U{}class Hn extends Qn{}class qn extends Qn{}class Jt extends U{}class mn extends Jt{}class cs extends Jt{}class us extends U{}class Zn extends us{}class hi extends us{async _call(C){return new re(await super._call(C))}}class Gt extends us{async _call(C){return new G(await super._call(C))}}class kn extends us{async _call(C){return new X(await super._call(C))}}class Sl extends us{async _call(C){return new Te(await super._call(C))}}class ds extends U{}class Gs extends ds{}class Nt extends ds{async _call(C){return new re(await super._call(C))}}class oo extends ds{async _call(C){return new G(await super._call(C))}}class dt extends ds{async _call(C){return new X(await super._call(C))}}class $t extends ds{async _call(C){return new Te(await super._call(C))}}class Dr extends U{}class Pl extends Dr{}class zd extends Dr{async _call(C){return new re(await super._call(C))}}class $d extends Dr{async _call(C){return new G(await super._call(C))}}class sn extends Dr{async _call(C){return new X(await super._call(C))}}class Nd extends Dr{async _call(C){return new Te(await super._call(C))}}class Go extends U{}class Ud extends Go{}class Gd extends Go{}class Al extends U{constructor(){super(...arguments);Ce(this,"requires_attention_mask",!1);Ce(this,"main_input_name","input_features");Ce(this,"forward_params",["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class Vd extends Al{}class Ei extends Al{_prepare_generation_config(C,z){return super._prepare_generation_config(C,z,T.WhisperGenerationConfig)}_retrieve_init_tokens(C){const z=[C.decoder_start_token_id];let oe=C.language;const ve=C.task;if(C.is_multilingual){oe||(console.warn("No language specified - defaulting to English (en)."),oe="en");const Ue=`<|${(0,F.whisper_language_to_code)(oe)}|>`;z.push(C.lang_to_id[Ue]),z.push(C.task_to_id[ve??"transcribe"])}else if(oe||ve)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!C.return_timestamps&&C.no_timestamps_token_id&&z.at(-1)!==C.no_timestamps_token_id?z.push(C.no_timestamps_token_id):C.return_timestamps&&z.at(-1)===C.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),z.pop()),z.filter(Pe=>Pe!=null)}async generate({inputs:C=null,generation_config:z=null,logits_processor:oe=null,stopping_criteria:ve=null,...Pe}){z=this._prepare_generation_config(z,Pe);const Ue=Pe.decoder_input_ids??this._retrieve_init_tokens(z);if(z.return_timestamps&&(oe??(oe=new m.LogitsProcessorList),oe.push(new m.WhisperTimeStampLogitsProcessor(z,Ue))),z.begin_suppress_tokens&&(oe??(oe=new m.LogitsProcessorList),oe.push(new m.SuppressTokensAtBeginLogitsProcessor(z.begin_suppress_tokens,Ue.length))),z.return_token_timestamps){if(!z.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");z.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),z.output_attentions=!0,z.return_dict_in_generate=!0}const Je=await super.generate({inputs:C,generation_config:z,logits_processor:oe,decoder_input_ids:Ue,...Pe});return z.return_token_timestamps&&(Je.token_timestamps=this._extract_token_timestamps(Je,z.alignment_heads,z.num_frames)),Je}_extract_token_timestamps(C,z,oe=null,ve=.02){if(!C.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");oe==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let Pe=this.config.median_filter_width;Pe===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),Pe=7);const Ue=C.cross_attentions,Je=Array.from({length:this.config.decoder_layers},(Ct,Ze)=>(0,p.cat)(Ue.map(ft=>ft[Ze]),2)),st=(0,p.stack)(z.map(([Ct,Ze])=>{if(Ct>=Je.length)throw new Error(`Layer index ${Ct} is out of bounds for cross attentions (length ${Je.length}).`);return oe?Je[Ct].slice(null,Ze,null,[0,oe]):Je[Ct].slice(null,Ze)})).transpose(1,0,2,3),[gt,wt]=(0,p.std_mean)(st,-2,0,!0),yt=st.clone();for(let Ct=0;Ct<yt.dims[0];++Ct){const Ze=yt[Ct];for(let ft=0;ft<Ze.dims[0];++ft){const St=Ze[ft],Ht=gt[Ct][ft][0].data,un=wt[Ct][ft][0].data;for(let Sn=0;Sn<St.dims[0];++Sn){let Kn=St[Sn].data;for(let On=0;On<Kn.length;++On)Kn[On]=(Kn[On]-un[On])/Ht[On];Kn.set((0,v.medianFilter)(Kn,Pe))}}}const ht=[(0,p.mean)(yt,1)],Ft=C.sequences.dims,xt=new p.Tensor("float32",new Float32Array(Ft[0]*Ft[1]),Ft);for(let Ct=0;Ct<Ft[0];++Ct){const Ze=ht[Ct].neg().squeeze_(0),[ft,St]=(0,v.dynamic_time_warping)(Ze.tolist()),Ht=Array.from({length:ft.length-1},(Kn,On)=>ft[On+1]-ft[On]),un=(0,u.mergeArrays)([1],Ht).map(Kn=>!!Kn),Sn=[];for(let Kn=0;Kn<un.length;++Kn)un[Kn]&&Sn.push(St[Kn]*ve);xt[Ct].data.set(Sn,1)}return xt}}class jd extends Ei{}class Cl extends U{constructor(){super(...arguments);Ce(this,"requires_attention_mask",!1);Ce(this,"main_input_name","input_values");Ce(this,"forward_params",["input_values","decoder_input_ids","past_key_values"])}}class ar extends Cl{}class Wd extends Cl{}class Il extends U{constructor(){super(...arguments);Ce(this,"main_input_name","pixel_values");Ce(this,"forward_params",["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"])}}class Ll extends U{constructor(){super(...arguments);Ce(this,"forward_params",["input_ids","attention_mask","pixel_values","position_ids","past_key_values"])}}class Vo extends Ll{_merge_input_ids_with_image_features(C){const z=C.image_features.dims.at(-1),oe=C.image_features.view(-1,z);return De({image_token_id:this.config.image_token_index,...C,image_features:oe})}}class Hd extends Vo{}class qd extends Vo{}class Kd extends U{constructor(){super(...arguments);Ce(this,"forward_params",["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"]);Ce(this,"main_input_name","inputs_embeds")}}class Xd extends Kd{_merge_input_ids_with_image_features({inputs_embeds:C,image_features:z,input_ids:oe,attention_mask:ve}){return{inputs_embeds:(0,p.cat)([z,C],1),attention_mask:(0,p.cat)([(0,p.ones)(z.dims.slice(0,2)),ve],1)}}async _prepare_inputs_embeds({input_ids:C,pixel_values:z,inputs_embeds:oe,attention_mask:ve}){if(!C&&!z)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let Pe,Ue;return C&&(Pe=await this.encode_text({input_ids:C})),z&&(Ue=await this.encode_image({pixel_values:z})),Pe&&Ue?{inputs_embeds:oe,attention_mask:ve}=this._merge_input_ids_with_image_features({inputs_embeds:Pe,image_features:Ue,input_ids:C,attention_mask:ve}):oe=Pe||Ue,{inputs_embeds:oe,attention_mask:ve}}async forward({input_ids:C,pixel_values:z,attention_mask:oe,decoder_input_ids:ve,decoder_attention_mask:Pe,encoder_outputs:Ue,past_key_values:Je,inputs_embeds:st,decoder_inputs_embeds:gt}){if(st||({inputs_embeds:st,attention_mask:oe}=await this._prepare_inputs_embeds({input_ids:C,pixel_values:z,inputs_embeds:st,attention_mask:oe})),!Ue){let{last_hidden_state:ht}=await be(this,{inputs_embeds:st,attention_mask:oe});Ue=ht}if(!gt){if(!ve)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");gt=await this.encode_text({input_ids:ve})}return await Ge(this,{inputs_embeds:gt,attention_mask:Pe,encoder_attention_mask:oe,encoder_hidden_states:Ue,past_key_values:Je},!0)}}class Yd extends U{constructor(){super(...arguments);Ce(this,"forward_params",["input_ids","attention_mask","pixel_values","position_ids","past_key_values"])}}class Jd extends Yd{_merge_input_ids_with_image_features(C){const z=C.image_features.dims.at(-1),oe=C.image_features.view(-1,z);return De({image_token_id:this.config.image_token_index,...C,image_features:oe})}}class $i extends Ll{_merge_input_ids_with_image_features(C){const z=C.image_features.dims.at(-1),oe=C.image_features.view(-1,z);return De({image_token_id:this.config.image_token_index,...C,image_features:oe})}}class Qd extends $i{}class Zd extends U{constructor(){super(...arguments);Ce(this,"forward_params",["input_ids","attention_mask","inputs_embeds","per_layer_inputs","position_ids","pixel_values","input_features","input_features_mask","past_key_values"])}}class Dl extends Zd{async forward({input_ids:C=null,attention_mask:z=null,pixel_values:oe=null,input_features:ve=null,input_features_mask:Pe=null,position_ids:Ue=null,inputs_embeds:Je=null,per_layer_inputs:st=null,past_key_values:gt=null,generation_config:wt=null,logits_processor:yt=null,...ht}){if((!Je||!st)&&({inputs_embeds:Je,per_layer_inputs:st}=await Q(this.sessions.embed_tokens,{input_ids:C}),C.dims[1]!==1)){if(oe){const{image_features:xt}=await Q(this.sessions.vision_encoder,{pixel_values:oe});({inputs_embeds:Je,attention_mask:z}=this._merge_input_ids_with_image_features({image_features:xt,inputs_embeds:Je,input_ids:C,attention_mask:z}))}if(ve){const{audio_features:xt}=await Q(this.sessions.audio_encoder,{input_features:ve,input_features_mask:Pe});({inputs_embeds:Je,attention_mask:z}=this._merge_input_ids_with_audio_features({audio_features:xt,inputs_embeds:Je,input_ids:C,attention_mask:z}))}}return await Ge(this,{inputs_embeds:Je,per_layer_inputs:st,past_key_values:gt,attention_mask:z,position_ids:Ue,generation_config:wt,logits_processor:yt},!0)}_merge_input_ids_with_image_features(C){const z=C.image_features.dims.at(-1),oe=C.image_features.view(-1,z);return De({image_token_id:this.config.image_token_id,...C,image_features:oe})}_merge_input_ids_with_audio_features(C){const z=C.audio_features.dims.at(-1),oe=C.audio_features.view(-1,z);return he({audio_token_id:this.config.audio_token_id,...C,audio_features:oe})}}class eh extends U{constructor(){super(...arguments);Ce(this,"forward_params",["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"])}}class jo extends eh{async encode_image({pixel_values:C,pixel_attention_mask:z}){return(await Q(this.sessions.vision_encoder,{pixel_values:C,pixel_attention_mask:z})).image_features}_merge_input_ids_with_image_features(C){const z=C.image_features.dims.at(-1),oe=C.image_features.view(-1,z);return De({image_token_id:this.config.image_token_id,...C,image_features:oe})}}class kl extends jo{}class th extends U{constructor(){super(...arguments);Ce(this,"forward_params",["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"])}}class Ol extends th{async forward({input_ids:C=null,attention_mask:z=null,pixel_values:oe=null,image_sizes:ve=null,position_ids:Pe=null,inputs_embeds:Ue=null,past_key_values:Je=null,generation_config:st=null,logits_processor:gt=null,...wt}){if(!Ue){let ht;if(oe&&C.dims[1]!==1){if(!ve)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:ht}=await Q(this.sessions.vision_encoder,{pixel_values:oe,image_sizes:ve}))}else{const Ft=this.config.normalized_config.hidden_size;ht=new p.Tensor("float32",[],[0,Ft])}({inputs_embeds:Ue}=await Q(this.sessions.prepare_inputs_embeds,{input_ids:C,image_features:ht}))}return await Ge(this,{inputs_embeds:Ue,past_key_values:Je,attention_mask:z,position_ids:Pe,generation_config:st,logits_processor:gt},!1)}}class lr extends U{}class nh extends lr{}class z0 extends lr{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"text_model"})}}class Hi extends lr{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"text_model"})}}class ty extends lr{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"vision_model"})}}class Wo extends lr{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"vision_model"})}}class Ho extends U{}class qi extends Ho{}class ih extends Ho{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"text_model"})}}class sh extends lr{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"vision_model"})}}class rh extends U{}class oh extends rh{}class qo extends U{}class ah extends qo{async forward(C){const z=!C.input_ids,oe=!C.pixel_values;if(z&&oe)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(z&&(C.input_ids=(0,p.ones)([C.pixel_values.dims[0],1])),oe){const{image_size:gt}=this.config.vision_config;C.pixel_values=(0,p.full)([0,3,gt,gt],0)}const{text_embeddings:ve,image_embeddings:Pe,l2norm_text_embeddings:Ue,l2norm_image_embeddings:Je}=await super.forward(C),st={};return z||(st.text_embeddings=ve,st.l2norm_text_embeddings=Ue),oe||(st.image_embeddings=Pe,st.l2norm_image_embeddings=Je),st}}class lh extends qo{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"text_model"})}}class ch extends qo{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"vision_model"})}}class Fl extends U{}class uh extends Fl{}class Ki extends Fl{}class Rl extends U{}class dh extends Rl{}class hh extends Rl{}class Bl extends U{}class fh extends Bl{}class ph extends Bl{}class zl extends U{}class mh extends zl{}class gh extends zl{}class $l extends U{}class Nl extends $l{}class Ul extends $l{}class Gl extends U{}class _h extends Gl{}class Vl extends Gl{}class yh extends U{}class vh extends yh{}class Ko extends yh{}class jl extends U{}class wh extends jl{}class xh extends jl{}class kr extends U{}class bh extends kr{}class Mh extends kr{}class Wl extends U{}class Th extends Wl{}class Hl extends U{}class Eh extends Hl{}class Sh extends Hl{}class Ph extends U{}class Ah extends Ph{}class Ch extends Ph{}class ql extends U{}class ny extends ql{}class Ih extends ql{}class hn extends U{}class Lh extends hn{}class Dh extends hn{}class Kl extends U{}class kh extends Kl{}class Oh extends Kl{}class Xl extends U{}class Fh extends Xl{}class Rh extends Xl{}class Yl extends U{}class Bh extends Yl{}class zh extends Yl{}class Jl extends U{}class $h extends Jl{}class Nh extends Jl{}class Or extends U{}class Uh extends Or{}class Xo extends Or{}class Ql extends U{}class Gh extends Ql{}class Vh extends Ql{}class Zl extends U{}class jh extends Zl{}class Wh extends Zl{}class ec extends U{}class Hh extends ec{}class qh extends ec{}class tc extends U{}class Kh extends tc{}class Xh extends tc{}class nc extends U{}class Yh extends nc{}class Jh extends nc{}class ic extends U{}class sc extends ic{}class Qh extends ic{}class Yo extends U{}class rc extends Yo{}class Zh extends Yo{}class oc extends U{}class ef extends oc{}class tf extends oc{}class ac extends U{}class nf extends ac{}class lc extends ac{}class cc extends U{}class sf extends cc{}class rf extends cc{}class of extends U{}class af extends of{}class lf extends of{}class Xi extends U{constructor(){super(...arguments);Ce(this,"forward_params",["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"])}}class cf extends Xi{get_rope_index(C,z,oe,ve){const{vision_config:Pe,image_token_id:Ue,video_token_id:Je,vision_start_token_id:st}=this.config,gt=Pe.spatial_merge_size??2,wt=[];if(z||oe){let yt=C.tolist();ve||(ve=(0,p.ones_like)(C));const ht=ve.tolist(),Ft=Array.from({length:3},St=>Array.from({length:C.dims[0]},Ht=>Array.from({length:C.dims[1]},un=>1))),xt=z?z.tolist():[],Ct=oe?oe.tolist():[];let Ze=0,ft=0;for(let St=0;St<yt.length;++St){const Ht=yt[St].filter((zn,ai)=>ht[St][ai]==1),Sn=Ht.reduce((zn,ai,wo)=>(ai==st&&zn.push(wo),zn),[]).map(zn=>Ht[zn+1]),Kn=Sn.filter(zn=>zn==Ue).length,On=Sn.filter(zn=>zn==Je).length;let Zt=[],Nn=0,Pn=Kn,Fn=On;for(let zn=0;zn<Sn.length;++zn){const ai=Ht.findIndex((Sa,Hs)=>Hs>Nn&&Sa==Ue),wo=Ht.findIndex((Sa,Hs)=>Hs>Nn&&Sa==Je),Ea=Pn>0&&ai!==-1?ai:Ht.length+1,Du=Fn>0&&wo!==-1?wo:Ht.length+1;let Gy,V0,j0,W0;Ea<Du?([V0,j0,W0]=xt[Ze],++Ze,--Pn,Gy=Ea):([V0,j0,W0]=Ct[ft],++ft,--Fn,Gy=Du);const[JP,H0,Vy]=[Number(V0),Math.floor(Number(j0)/gt),Math.floor(Number(W0)/gt)],q0=Gy-Nn,Ob=Zt.length>0?(0,v.max)(Zt.at(-1))[0]+1:0;Zt.push(Array.from({length:3*q0},(Sa,Hs)=>Ob+Hs%q0));const K0=q0+Ob,jy=JP*H0*Vy,QP=Array.from({length:jy},(Sa,Hs)=>K0+Math.floor(Hs/(H0*Vy))),ZP=Array.from({length:jy},(Sa,Hs)=>K0+Math.floor(Hs/Vy)%H0),eA=Array.from({length:jy},(Sa,Hs)=>K0+Hs%Vy);Zt.push([QP,ZP,eA].flat()),Nn=Gy+jy}if(Nn<Ht.length){const zn=Zt.length>0?(0,v.max)(Zt.at(-1))[0]+1:0,ai=Ht.length-Nn;Zt.push(Array.from({length:3*ai},(wo,Ea)=>zn+Ea%ai))}const Xn=Zt.reduce((zn,ai)=>zn+ai.length,0),Yi=new Array(Xn);let Lu=0;for(let zn=0;zn<3;++zn)for(let ai=0;ai<Zt.length;++ai){const wo=Zt[ai],Ea=wo.length/3;for(let Du=zn*Ea;Du<(zn+1)*Ea;++Du)Yi[Lu++]=wo[Du]}let Ta=0;const Ny=ht[St];for(let zn=0;zn<Ny.length;++zn)if(Ny[zn]==1){for(let ai=0;ai<3;++ai)Ft[ai][St][zn]=Yi[ai*Xn/3+Ta];++Ta}const Uy=(0,v.max)(Yi)[0];wt.push(Uy+1-yt[St].length)}return[new p.Tensor("int64",Ft.flat(1/0),[3,C.dims[0],C.dims[1]]),new p.Tensor("int64",wt,[wt.length,1])]}else if(ve){const{data:yt,dims:ht}=xe(ve),Ft=BigInt64Array.from({length:3*yt.length},(Ct,Ze)=>yt[Ze%yt.length]),xt=Array.from({length:ht[0]},(Ct,Ze)=>(0,v.max)(yt.subarray(ht[1]*Ze,ht[1]*(Ze+1)))[0]+1n+BigInt(ht[1]));return[new p.Tensor("int64",Ft,[3,...ht]),new p.Tensor("int64",xt,[xt.length,1])]}else{const[yt,ht]=C.dims,Ft=BigInt64Array.from({length:3*yt*ht},(xt,Ct)=>BigInt(Math.floor(Ct%ht/yt)));return[new p.Tensor("int64",Ft,[3,...C.dims]),(0,p.zeros)([yt,1])]}}async encode_image({pixel_values:C,image_grid_thw:z}){return(await Q(this.sessions.vision_encoder,{pixel_values:C,grid_thw:z})).image_features}_merge_input_ids_with_image_features(C){return De({image_token_id:this.config.image_token_id,...C})}prepare_inputs_for_generation(C,z,oe){if(z.attention_mask&&!z.position_ids)if(!z.past_key_values)[z.position_ids,z.rope_deltas]=this.get_rope_index(z.input_ids,z.image_grid_thw,z.video_grid_thw,z.attention_mask);else{z.pixel_values=null;const ve=BigInt(Object.values(z.past_key_values)[0].dims.at(-2)),Pe=z.rope_deltas.map(Ue=>ve+Ue);z.position_ids=(0,p.stack)([Pe,Pe,Pe],0)}return z}}class uc extends U{}class uf extends uc{}class df extends uc{}class dc extends U{}class hf extends dc{}class ff extends dc{}class hc extends U{}class pf extends hc{}class mf extends hc{}class gf extends U{}class _f extends gf{}class yf extends gf{}class fc extends U{}class vf extends fc{}class wf extends fc{}class pc extends U{}class iy extends pc{}class cr extends pc{async _call(C){return new G(await super._call(C))}}class Vs extends U{}class ur extends Vs{}class mc extends Vs{async _call(C){return new G(await super._call(C))}}class dr extends U{}class ni extends dr{}class gc extends U{}class _c extends gc{}class xf extends gc{async _call(C){return new G(await super._call(C))}}class sy extends U{}class ao extends sy{}class Jo extends U{}class yc extends Jo{}class bf extends Jo{async _call(C){return new G(await super._call(C))}}class Mf extends U{}class vc extends Mf{}class Qo extends U{}class Tf extends Qo{}class wc extends Qo{async _call(C){return new G(await super._call(C))}}class Ef extends U{}class Zo extends Ef{async _call(C){return new ke(await super._call(C))}}class ea extends U{}class Sf extends ea{}class Pf extends ea{async _call(C){return new G(await super._call(C))}}class Af extends U{}class Cf extends Af{}class xc extends Af{async _call(C){return new G(await super._call(C))}}class Fr extends U{}class If extends Fr{}class bc extends Fr{}class Mc extends U{}class Lf extends Mc{}class Df extends Mc{}class kf extends U{}class Of extends kf{}class Ff extends kf{async _call(C){return new G(await super._call(C))}}class Tc extends U{}class Rf extends Tc{}class ta extends Tc{async _call(C){return new lo(await super._call(C))}}class Ec extends Tc{async _call(C){return new Sc(await super._call(C))}}class lo extends Se{constructor({logits:C,pred_boxes:z}){super(),this.logits=C,this.pred_boxes=z}}class Sc extends Se{constructor({logits:C,pred_boxes:z,pred_masks:oe}){super(),this.logits=C,this.pred_boxes=z,this.pred_masks=oe}}class na extends U{}class Bf extends na{}class zf extends na{async _call(C){return new Rr(await super._call(C))}}class Rr extends Se{constructor({logits:C,pred_boxes:z}){super(),this.logits=C,this.pred_boxes=z}}class $f extends U{}class Nf extends $f{}class ry extends $f{async _call(C){return new Uf(await super._call(C))}}class Uf extends Rr{}class Pc extends U{}class Gf extends Pc{}class Ac extends Pc{async _call(C){return new Vf(await super._call(C))}}class Vf extends Rr{}class Cc extends U{}class Ic extends Cc{}class jf extends Cc{async _call(C){return new Rr(await super._call(C))}}class Lc extends U{}class oy extends Lc{}class Wf extends Lc{async _call(C){return new Hf(await super._call(C))}}class Hf extends lo{}class Dc extends U{}class ay extends Dc{}class qf extends Dc{async _call(C){return new G(await super._call(C))}}class kc extends U{}class Kf extends kc{}class Xf extends kc{async _call(C){return new G(await super._call(C))}}class Oc extends U{}class ly extends Oc{}class ia extends Oc{async _call(C){return new G(await super._call(C))}}class hr extends U{}class Fc extends hr{}class Yf extends hr{async _call(C){return new G(await super._call(C))}}class Jf extends hr{}class Rc extends U{}class Qf extends Rc{}class Bc extends Rc{}class zc extends U{}class Zf extends zc{}class ep extends zc{}class cy extends U{}class tp extends cy{}class co extends U{}class np extends co{}class ip extends co{}class sp extends co{}class uy extends U{}class rp extends uy{}class op extends U{}class dy extends op{}class ap extends U{}class lp extends ap{}class $c extends U{}class cp extends $c{}class hy extends $c{}class Nc extends U{}class up extends Nc{}class dp extends Nc{}class fy extends U{}class hp extends fy{}class Uc extends U{}class fp extends Uc{}class pp extends Uc{async _call(C){return new G(await super._call(C))}}class mp extends U{}class gp extends mp{}class _p extends mp{async _call(C){return new G(await super._call(C))}}class Gc extends U{}class yp extends Gc{}class py extends Gc{async _call(C){return new G(await super._call(C))}}class Vc extends U{}class vp extends Vc{}class wp extends Vc{async _call(C){return new G(await super._call(C))}}class xp extends U{}class my extends xp{}class hs extends U{}class As extends hs{}class fr extends U{}class pr extends fr{}class jc extends U{}class bp extends jc{}class Mp extends jc{async _call(C){return new Tp(await super._call(C))}}class Tp extends Se{constructor({logits:C,pred_boxes:z}){super(),this.logits=C,this.pred_boxes=z}}class Ep extends U{}class Sp extends Ep{async get_image_embeddings({pixel_values:C}){return await be(this,{pixel_values:C})}async forward(C){!C.image_embeddings||!C.image_positional_embeddings?C={...C,...await this.get_image_embeddings(C)}:C={...C},C.input_labels??(C.input_labels=(0,p.ones)(C.input_points.dims.slice(0,-1)));const z={image_embeddings:C.image_embeddings,image_positional_embeddings:C.image_positional_embeddings};return C.input_points&&(z.input_points=C.input_points),C.input_labels&&(z.input_labels=C.input_labels),C.input_boxes&&(z.input_boxes=C.input_boxes),await Q(this.sessions.prompt_encoder_mask_decoder,z)}async _call(C){return new Pp(await super._call(C))}}class Pp extends Se{constructor({iou_scores:C,pred_masks:z}){super(),this.iou_scores=C,this.pred_masks=z}}class Ap extends Se{constructor({iou_scores:C,pred_masks:z,object_score_logits:oe}){super(),this.iou_scores=C,this.pred_masks=z,this.object_score_logits=oe}}class Cp extends U{}class sa extends Cp{async get_image_embeddings({pixel_values:C}){return await be(this,{pixel_values:C})}async forward(C){const{num_feature_levels:z}=this.config.vision_config;if(Array.from({length:z},(Ue,Je)=>`image_embeddings.${Je}`).some(Ue=>!C[Ue])?C={...C,...await this.get_image_embeddings(C)}:C={...C},C.input_points){if(C.input_boxes&&C.input_boxes.dims[1]!==1)throw new Error("When both `input_points` and `input_boxes` are provided, the number of boxes per image must be 1.");const Ue=C.input_points.dims;C.input_labels??(C.input_labels=(0,p.ones)(Ue.slice(0,-1))),C.input_boxes??(C.input_boxes=(0,p.full)([Ue[0],0,4],0))}else if(C.input_boxes){const Ue=C.input_boxes.dims;C.input_labels=(0,p.full)([Ue[0],Ue[1],0],-1n),C.input_points=(0,p.full)([Ue[0],1,0,2],0)}else throw new Error("At least one of `input_points` or `input_boxes` must be provided.");const ve=this.sessions.prompt_encoder_mask_decoder,Pe=(0,u.pick)(C,ve.inputNames);return await Q(ve,Pe)}async _call(C){return new Ap(await super._call(C))}}class gy extends sa{}class yi extends sa{}class Wc extends U{}class Ip extends Wc{}class Hc extends Wc{}class qc extends U{}class uo extends qc{}class Lp extends qc{}class js extends U{}class Dp extends js{}class kp extends js{async _call(C){return new ue(await super._call(C))}}class Op extends js{async _call(C){return new G(await super._call(C))}}class Fp extends js{async _call(C){return new X(await super._call(C))}}class Kc extends U{}class Rp extends Kc{async _call(C){return new ue(await super._call(C))}}class Xc extends U{}class Bp extends Xc{}class zp extends Xc{async _call(C){return new X(await super._call(C))}}class ra extends U{}class $p extends ra{}class oa extends U{}class Np extends oa{}class Up extends oa{async _call(C){return new ue(await super._call(C))}}class Yc extends oa{async _call(C){return new G(await super._call(C))}}class ho extends U{}class Gp extends ho{}class _y extends ho{async _call(C){return new ue(await super._call(C))}}class Jc extends ho{async _call(C){return new G(await super._call(C))}}class Vp extends ho{async _call(C){return new X(await super._call(C))}}class aa extends U{}class jp extends aa{}class yy extends aa{async _call(C){return new ue(await super._call(C))}}class Wp extends aa{async _call(C){return new G(await super._call(C))}}class vy extends U{}class Hp extends js{}class wy extends js{async _call(C){return new ue(await super._call(C))}}class qp extends js{async _call(C){return new G(await super._call(C))}}class Br extends U{}class xy extends Br{}class Kp extends Br{async _call(C){return new ue(await super._call(C))}}class Xp extends Br{async _call(C){return new G(await super._call(C))}}class Yp extends Br{async _call(C){return new ee(await super._call(C))}}class Jp extends Br{async _call(C){return new X(await super._call(C))}}class Qp extends U{}class by extends Qp{}class la extends U{}class My extends la{}class Zp extends la{}class em extends la{async generate_speech(C,z,{threshold:oe=.5,minlenratio:ve=0,maxlenratio:Pe=20,vocoder:Ue=null}={}){const Je={input_ids:C},{encoder_outputs:st,encoder_attention_mask:gt}=await be(this,Je),wt=st.dims[1]/this.config.reduction_factor,yt=Math.floor(wt*Pe),ht=Math.floor(wt*ve),Ft=this.config.num_mel_bins;let xt=[],Ct=null,Ze=null,ft=0;for(;;){++ft;const un=K(!!Ze);let Sn;Ze?Sn=Ze.output_sequence_out:Sn=new p.Tensor("float32",new Float32Array(Ft),[1,1,Ft]);let Kn={use_cache_branch:un,output_sequence:Sn,encoder_attention_mask:gt,speaker_embeddings:z,encoder_hidden_states:st};this.addPastKeyValues(Kn,Ct),Ze=await Q(this.sessions.decoder_model_merged,Kn),Ct=this.getPastKeyValues(Ze,Ct);const{prob:On,spectrum:Zt}=Ze;if(xt.push(Zt),ft>=ht&&(Array.from(On.data).filter(Nn=>Nn>=oe).length>0||ft>=yt))break}const St=(0,p.cat)(xt),{waveform:Ht}=await Q(Ue.sessions.model,{spectrogram:St});return{spectrogram:St,waveform:Ht}}}class tm extends U{constructor(){super(...arguments);Ce(this,"main_input_name","spectrogram")}}class nm extends U{}class Qc extends nm{async generate_speech({input_ids:C,attention_mask:z,style:oe,num_inference_steps:ve=5,speed:Pe=1.05}){const{sampling_rate:Ue,chunk_compress_factor:Je,base_chunk_size:st,latent_dim:gt}=this.config,{last_hidden_state:wt,durations:yt}=await Q(this.sessions.text_encoder,{input_ids:C,attention_mask:z,style:oe});yt.div_(Pe);const ht=yt.max().item()*Ue,Ft=st*Je,xt=Math.floor((ht+Ft-1)/Ft),Ct=C.dims[0],Ze=(0,p.ones)([Ct,xt]),ft=(0,p.full)([Ct],ve);let St=(0,p.randn)([Ct,gt*Je,xt]);for(let un=0;un<ve;++un){const Sn=(0,p.full)([Ct],un);({denoised_latents:St}=await Q(this.sessions.latent_denoiser,{style:oe,noisy_latents:St,latent_mask:Ze,encoder_outputs:wt,attention_mask:z,timestep:Sn,num_inference_steps:ft}))}const{waveform:Ht}=await Q(this.sessions.voice_decoder,{latents:St});return{waveform:Ht,durations:yt}}}class im extends U{}class sm extends im{}class rm extends U{}class fo extends rm{}class Zc extends rm{}class ca extends U{}class eu extends ca{}class tu extends ca{}class nu extends U{}class om extends nu{}class iu extends nu{}class ua extends U{}class am extends ua{}class lm extends ua{}class da extends U{}class cm extends da{}class um extends da{}class ha extends U{}class dm extends ha{}class hm extends ha{}class fa extends U{}class fm extends fa{}class Ty extends fa{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"text_model"})}}class pm extends fa{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"audio_model"})}}class mm extends U{}class su extends mm{async _call(C){return new Le(await super._call(C))}}class pa extends U{}class $0 extends pa{}class gm extends pa{}class _m extends pa{}class ru extends U{}class Ey extends ru{}class ym extends ru{}class ma extends U{}class ou extends ma{}class vm extends ma{async _call(C){return new G(await super._call(C))}}class au extends U{}class Sy extends au{}class N0 extends au{}class lu extends U{constructor(){super(...arguments);Ce(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}_apply_and_filter_by_delay_pattern_mask(z){const[oe,ve]=z.dims,Pe=this.config.decoder.num_codebooks,Ue=ve-Pe;let Je=0;for(let wt=0;wt<z.size;++wt){if(z.data[wt]===this.config.decoder.pad_token_id)continue;const yt=wt%ve,ht=Math.floor(wt/ve)%Pe,Ft=yt-ht;Ft>0&&Ft<=Ue&&(z.data[Je++]=z.data[wt])}const st=Math.floor(oe/Pe),gt=Je/(st*Pe);return new p.Tensor(z.type,z.data.slice(0,Je),[st,Pe,gt])}prepare_inputs_for_generation(z,oe,ve){let Pe=structuredClone(z);for(let Je=0;Je<Pe.length;++Je)for(let st=0;st<Pe[Je].length;++st)Je%this.config.decoder.num_codebooks>=st&&(Pe[Je][st]=BigInt(this.config.decoder.pad_token_id));return ve.guidance_scale!==null&&ve.guidance_scale>1&&(Pe=Pe.concat(Pe)),super.prepare_inputs_for_generation(Pe,oe,ve)}async generate(z){const oe=await super.generate(z),ve=this._apply_and_filter_by_delay_pattern_mask(oe).unsqueeze_(0),{audio_values:Pe}=await Q(this.sessions.encodec_decode,{audio_codes:ve});return Pe}}class ga extends U{}class wm extends ga{}class cu extends ga{async _call(C){return new G(await super._call(C))}}class xm extends ga{}class _a extends U{}class bm extends _a{}class Mm extends _a{async _call(C){return new G(await super._call(C))}}class Tm extends _a{}class ya extends U{}class Em extends ya{}class Sm extends ya{async _call(C){return new G(await super._call(C))}}class uu extends ya{}class va extends U{}class Pm extends va{}class Am extends va{async _call(C){return new G(await super._call(C))}}class Cm extends va{}class Im extends U{}class Lm extends Im{}class Dm extends U{}class Py extends Dm{constructor(...z){super(...z);Ce(this,"forward_params",["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"]);this._generation_mode="text"}async forward(z){const oe=this._generation_mode??"text";let ve;if(oe==="text"||!z.past_key_values){const gt=this.sessions.prepare_inputs_embeds,wt=(0,u.pick)(z,gt.inputNames);ve=await Q(gt,wt)}else{const gt=this.sessions.gen_img_embeds,wt=(0,u.pick)({image_ids:z.input_ids},gt.inputNames);ve=await Q(gt,wt)}const Pe={...z,...ve},Ue=await Ge(this,Pe),Je=this.sessions[oe==="text"?"lm_head":"gen_head"];if(!Je)throw new Error(`Unable to find "${Je}" generation head`);const st=await Q(Je,(0,u.pick)(Ue,Je.inputNames));return{...ve,...Ue,...st}}async generate(z){return this._generation_mode="text",super.generate(z)}async generate_images(z){this._generation_mode="image";const oe=(z.inputs??z[this.main_input_name]).dims[1],Pe=(await super.generate(z)).slice(null,[oe,null]),Ue=this.sessions.image_decode,{decoded_image:Je}=await Q(Ue,{generated_tokens:Pe}),st=Je.add_(1).mul_(255/2).clamp_(0,255).to("uint8"),gt=[];for(const wt of st){const yt=_.RawImage.fromTensor(wt);gt.push(yt)}return gt}}class km extends Se{constructor({char_logits:C,bpe_logits:z,wp_logits:oe}){super(),this.char_logits=C,this.bpe_logits=z,this.wp_logits=oe}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class Om extends U{}class Fm extends Om{async _call(C){return new km(await super._call(C))}}class Rm extends U{}class Bm extends Rm{}class po extends Rm{}class du extends U{}class hu extends du{}class zm extends du{}class $m extends U{constructor(){super(...arguments);Ce(this,"forward_params",["input_ids","attention_mask","position_ids","audio_values","past_key_values"])}}class fu extends $m{_merge_input_ids_with_audio_features(C){const z=C.audio_features.dims.at(-1),oe=C.audio_features.view(-1,z);return he({audio_token_id:this.config.ignore_index??this.config.audio_token_id,...C,audio_features:oe})}}class Nm extends fu{}class pu extends U{constructor(){super(...arguments);Ce(this,"main_input_name","input_values");Ce(this,"forward_params",["input_values"])}}class Um extends Se{constructor({audio_codes:C}){super(),this.audio_codes=C}}class Gm extends Se{constructor({audio_values:C}){super(),this.audio_values=C}}class Vm extends pu{async encode(C){return new Um(await Q(this.sessions.encoder_model,C))}async decode(C){return new Gm(await Q(this.sessions.decoder_model,C))}}class jm extends pu{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"encoder_model"})}}class Ay extends pu{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"decoder_model"})}}class mo extends U{constructor(){super(...arguments);Ce(this,"main_input_name","input_values");Ce(this,"forward_params",["input_values"])}}class Wm extends Se{constructor({audio_codes:C}){super(),this.audio_codes=C}}class Hm extends Se{constructor({audio_values:C}){super(),this.audio_values=C}}class qm extends mo{async encode(C){return new Wm(await Q(this.sessions.encoder_model,C))}async decode(C){return new Hm(await Q(this.sessions.decoder_model,C))}}class Km extends mo{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"encoder_model"})}}class Cy extends mo{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"decoder_model"})}}class wa extends U{constructor(){super(...arguments);Ce(this,"main_input_name","input_values");Ce(this,"forward_params",["input_values"])}}class Xm extends wa{async encode(C){return await Q(this.sessions.encoder_model,C)}async decode(C){return await Q(this.sessions.decoder_model,C)}}class Ym extends wa{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"encoder_model"})}}class Iy extends wa{static async from_pretrained(C,z={}){return super.from_pretrained(C,{...z,model_file_name:z.model_file_name??"decoder_model"})}}class gn{static async from_pretrained(C,{progress_callback:z=null,config:oe=null,cache_dir:ve=null,local_files_only:Pe=!1,revision:Ue="main",model_file_name:Je=null,subfolder:st="onnx",device:gt=null,dtype:wt=null,use_external_data_format:yt=null,session_options:ht={}}={}){const Ft={progress_callback:z,config:oe,cache_dir:ve,local_files_only:Pe,revision:Ue,model_file_name:Je,subfolder:st,device:gt,dtype:wt,use_external_data_format:yt,session_options:ht};if(Ft.config=await i.AutoConfig.from_pretrained(C,Ft),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);const xt=Ft.config.model_type;for(const Ct of this.MODEL_CLASS_MAPPINGS){let Ze=Ct.get(xt);if(!Ze){for(const ft of Ct.values())if(ft[0]===xt){Ze=ft;break}if(!Ze)continue}return await Ze[1].from_pretrained(C,Ft)}if(this.BASE_IF_FAIL)return ig.has(xt)||console.warn(`Unknown model class "${xt}", attempting to construct from base class.`),await U.from_pretrained(C,Ft);throw Error(`Unsupported model type: ${xt}`)}}Ce(gn,"MODEL_CLASS_MAPPINGS",null),Ce(gn,"BASE_IF_FAIL",!1);const U0=new Map([["bert",["BertModel",Ye]],["neobert",["NeoBertModel",Qe]],["modernbert",["ModernBertModel",He]],["nomic_bert",["NomicBertModel",cn]],["roformer",["RoFormerModel",ci]],["electra",["ElectraModel",_t]],["esm",["EsmModel",or]],["convbert",["ConvBertModel",bs]],["camembert",["CamembertModel",ge]],["deberta",["DebertaModel",en]],["deberta-v2",["DebertaV2Model",bi]],["mpnet",["MPNetModel",Wi]],["albert",["AlbertModel",Et]],["distilbert",["DistilBertModel",Ms]],["roberta",["RobertaModel",Zn]],["xlm",["XLMModel",Gs]],["xlm-roberta",["XLMRobertaModel",Pl]],["clap",["ClapModel",fm]],["clip",["CLIPModel",nh]],["clipseg",["CLIPSegModel",uh]],["chinese_clip",["ChineseCLIPModel",oh]],["siglip",["SiglipModel",qi]],["jina_clip",["JinaCLIPModel",ah]],["mobilebert",["MobileBertModel",_i]],["squeezebert",["SqueezeBertModel",ie]],["wav2vec2",["Wav2Vec2Model",Dp]],["wav2vec2-bert",["Wav2Vec2BertModel",jp]],["unispeech",["UniSpeechModel",Np]],["unispeech-sat",["UniSpeechSatModel",Gp]],["hubert",["HubertModel",Hp]],["wavlm",["WavLMModel",xy]],["audio-spectrogram-transformer",["ASTModel",Ud]],["vits",["VitsModel",su]],["pyannote",["PyAnnoteModel",Bp]],["wespeaker-resnet",["WeSpeakerResNetModel",$p]],["detr",["DetrModel",Rf]],["rt_detr",["RTDetrModel",Bf]],["rt_detr_v2",["RTDetrV2Model",Nf]],["rf_detr",["RFDetrModel",Gf]],["d_fine",["DFineModel",Ic]],["table-transformer",["TableTransformerModel",oy]],["vit",["ViTModel",iy]],["ijepa",["IJepaModel",ur]],["pvt",["PvtModel",_c]],["vit_msn",["ViTMSNModel",yc]],["vit_mae",["ViTMAEModel",ao]],["groupvit",["GroupViTModel",vc]],["fastvit",["FastViTModel",Tf]],["mobilevit",["MobileViTModel",Sf]],["mobilevitv2",["MobileViTV2Model",Cf]],["owlvit",["OwlViTModel",If]],["owlv2",["Owlv2Model",Lf]],["beit",["BeitModel",Of]],["deit",["DeiTModel",ay]],["hiera",["HieraModel",Kf]],["convnext",["ConvNextModel",fp]],["convnextv2",["ConvNextV2Model",gp]],["dinov2",["Dinov2Model",yp]],["dinov2_with_registers",["Dinov2WithRegistersModel",vp]],["dinov3_vit",["DINOv3ViTModel",my]],["dinov3_convnext",["DINOv3ConvNextModel",As]],["resnet",["ResNetModel",ly]],["swin",["SwinModel",Fc]],["swin2sr",["Swin2SRModel",Qf]],["donut-swin",["DonutSwinModel",hp]],["yolos",["YolosModel",bp]],["dpt",["DPTModel",Zf]],["glpn",["GLPNModel",up]],["hifigan",["SpeechT5HifiGan",tm]],["efficientnet",["EfficientNetModel",ou]],["decision_transformer",["DecisionTransformerModel",Lm]],["patchtst",["PatchTSTForPrediction",Bm]],["patchtsmixer",["PatchTSMixerForPrediction",hu]],["mobilenet_v1",["MobileNetV1Model",wm]],["mobilenet_v2",["MobileNetV2Model",bm]],["mobilenet_v3",["MobileNetV3Model",Em]],["mobilenet_v4",["MobileNetV4Model",Pm]],["maskformer",["MaskFormerModel",cp]],["mgp-str",["MgpstrForSceneTextRecognition",Fm]],["style_text_to_speech_2",["StyleTextToSpeech2Model",by]]]),Ly=new Map([["t5",["T5Model",pn]],["longt5",["LongT5Model",En]],["mt5",["MT5Model",Ti]],["bart",["BartModel",Ps]],["mbart",["MBartModel",os]],["marian",["MarianModel",Ip]],["whisper",["WhisperModel",Vd]],["m2m_100",["M2M100Model",uo]],["blenderbot",["BlenderbotModel",Hn]],["blenderbot-small",["BlenderbotSmallModel",mn]]]),G0=new Map([["mimi",["MimiModel",Vm]],["dac",["DacModel",qm]],["snac",["SnacModel",Xm]]]),Dy=new Map([["bloom",["BloomModel",pf]],["jais",["JAISModel",fh]],["gpt2",["GPT2Model",dh]],["gptj",["GPTJModel",_h]],["gpt_bigcode",["GPTBigCodeModel",vh]],["gpt_neo",["GPTNeoModel",mh]],["gpt_neox",["GPTNeoXModel",Nl]],["codegen",["CodeGenModel",wh]],["llama",["LlamaModel",bh]],["nanochat",["NanoChatModel",Eh]],["arcee",["ArceeModel",Ah]],["lfm2",["Lfm2Model",ny]],["smollm3",["SmolLM3Model",Lh]],["exaone",["ExaoneModel",Bh]],["olmo",["OlmoModel",Uh]],["olmo2",["Olmo2Model",Gh]],["mobilellm",["MobileLLMModel",$h]],["granite",["GraniteModel",jh]],["granitemoehybrid",["GraniteMoeHybridModel",Hh]],["cohere",["CohereModel",Kh]],["gemma",["GemmaModel",Yh]],["gemma2",["Gemma2Model",sc]],["vaultgemma",["VaultGemmaModel",rc]],["gemma3_text",["Gemma3Model",ef]],["helium",["HeliumModel",kh]],["glm",["GlmModel",Fh]],["openelm",["OpenELMModel",nf]],["qwen2",["Qwen2Model",sf]],["qwen3",["Qwen3Model",af]],["phi",["PhiModel",uf]],["phi3",["Phi3Model",hf]],["mpt",["MptModel",_f]],["opt",["OPTModel",vf]],["mistral",["MistralModel",fo]],["ministral",["MinistralModel",eu]],["ministral3",["Ministral3Model",om]],["ernie4_5",["Ernie4_5Model",am]],["starcoder2",["Starcoder2Model",cm]],["falcon",["FalconModel",dm]],["stablelm",["StableLmModel",Ey]],["modernbert-decoder",["ModernBertDecoderModel",Xt]]]),mu=new Map([["speecht5",["SpeechT5ForSpeechToText",Zp]],["whisper",["WhisperForConditionalGeneration",Ei]],["lite-whisper",["LiteWhisperForConditionalGeneration",jd]],["moonshine",["MoonshineForConditionalGeneration",Wd]]]),Jm=new Map([["speecht5",["SpeechT5ForTextToSpeech",em]]]),Qm=new Map([["vits",["VitsModel",su]],["musicgen",["MusicgenForConditionalGeneration",lu]],["supertonic",["SupertonicForConditionalGeneration",Qc]]]),Zm=new Map([["bert",["BertForSequenceClassification",Y]],["neobert",["NeoBertForSequenceClassification",ut]],["modernbert",["ModernBertForSequenceClassification",lt]],["roformer",["RoFormerForSequenceClassification",Vi]],["electra",["ElectraForSequenceClassification",B]],["esm",["EsmForSequenceClassification",Ns]],["convbert",["ConvBertForSequenceClassification",Me]],["camembert",["CamembertForSequenceClassification",Ke]],["deberta",["DebertaForSequenceClassification",tn]],["deberta-v2",["DebertaV2ForSequenceClassification",Bi]],["mpnet",["MPNetForSequenceClassification",Es]],["albert",["AlbertForSequenceClassification",It]],["distilbert",["DistilBertForSequenceClassification",Ts]],["roberta",["RobertaForSequenceClassification",Gt]],["xlm",["XLMForSequenceClassification",oo]],["xlm-roberta",["XLMRobertaForSequenceClassification",$d]],["bart",["BartForSequenceClassification",Wn]],["mbart",["MBartForSequenceClassification",oi]],["mobilebert",["MobileBertForSequenceClassification",ct]],["squeezebert",["SqueezeBertForSequenceClassification",Re]]]),ky=new Map([["bert",["BertForTokenClassification",$e]],["neobert",["NeoBertForTokenClassification",de]],["modernbert",["ModernBertForTokenClassification",Mt]],["roformer",["RoFormerForTokenClassification",Cn]],["electra",["ElectraForTokenClassification",le]],["esm",["EsmForTokenClassification",Us]],["convbert",["ConvBertForTokenClassification",at]],["camembert",["CamembertForTokenClassification",pt]],["deberta",["DebertaForTokenClassification",Vt]],["deberta-v2",["DebertaV2ForTokenClassification",gi]],["mpnet",["MPNetForTokenClassification",ro]],["distilbert",["DistilBertForTokenClassification",zs]],["roberta",["RobertaForTokenClassification",kn]],["xlm",["XLMForTokenClassification",dt]],["xlm-roberta",["XLMRobertaForTokenClassification",sn]]]),gu=new Map([["t5",["T5ForConditionalGeneration",_n]],["longt5",["LongT5ForConditionalGeneration",Un]],["mt5",["MT5ForConditionalGeneration",Ss]],["bart",["BartForConditionalGeneration",In]],["mbart",["MBartForConditionalGeneration",as]],["marian",["MarianMTModel",Hc]],["m2m_100",["M2M100ForConditionalGeneration",Lp]],["blenderbot",["BlenderbotForConditionalGeneration",qn]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",cs]]]),go=new Map([["bloom",["BloomForCausalLM",mf]],["gpt2",["GPT2LMHeadModel",hh]],["jais",["JAISLMHeadModel",ph]],["gptj",["GPTJForCausalLM",Vl]],["gpt_bigcode",["GPTBigCodeForCausalLM",Ko]],["gpt_neo",["GPTNeoForCausalLM",gh]],["gpt_neox",["GPTNeoXForCausalLM",Ul]],["codegen",["CodeGenForCausalLM",xh]],["llama",["LlamaForCausalLM",Mh]],["nanochat",["NanoChatForCausalLM",Sh]],["llama4_text",["Llama4ForCausalLM",Th]],["arcee",["ArceeForCausalLM",Ch]],["lfm2",["Lfm2ForCausalLM",Ih]],["smollm3",["SmolLM3ForCausalLM",Dh]],["exaone",["ExaoneForCausalLM",zh]],["olmo",["OlmoForCausalLM",Xo]],["olmo2",["Olmo2ForCausalLM",Vh]],["mobilellm",["MobileLLMForCausalLM",Nh]],["granite",["GraniteForCausalLM",Wh]],["granitemoehybrid",["GraniteMoeHybridForCausalLM",qh]],["cohere",["CohereForCausalLM",Xh]],["gemma",["GemmaForCausalLM",Jh]],["gemma2",["Gemma2ForCausalLM",Qh]],["vaultgemma",["VaultGemmaForCausalLM",Zh]],["gemma3_text",["Gemma3ForCausalLM",tf]],["helium",["HeliumForCausalLM",Oh]],["glm",["GlmForCausalLM",Rh]],["openelm",["OpenELMForCausalLM",lc]],["qwen2",["Qwen2ForCausalLM",rf]],["qwen3",["Qwen3ForCausalLM",lf]],["phi",["PhiForCausalLM",df]],["phi3",["Phi3ForCausalLM",ff]],["mpt",["MptForCausalLM",yf]],["opt",["OPTForCausalLM",wf]],["mbart",["MBartForCausalLM",ls]],["mistral",["MistralForCausalLM",Zc]],["ministral",["MinistralForCausalLM",tu]],["ministral3",["Ministral3ForCausalLM",iu]],["ernie4_5",["Ernie4_5ForCausalLM",lm]],["starcoder2",["Starcoder2ForCausalLM",um]],["falcon",["FalconForCausalLM",hm]],["trocr",["TrOCRForCausalLM",sm]],["stablelm",["StableLmForCausalLM",ym]],["modernbert-decoder",["ModernBertDecoderForCausalLM",wn]],["phi3_v",["Phi3VForCausalLM",Ol]]]),Oy=new Map([["multi_modality",["MultiModalityCausalLM",Py]]]),eg=new Map([["bert",["BertForMaskedLM",H]],["neobert",["NeoBertForMaskedLM",Ne]],["modernbert",["ModernBertForMaskedLM",je]],["roformer",["RoFormerForMaskedLM",ss]],["electra",["ElectraForMaskedLM",an]],["esm",["EsmForMaskedLM",$s]],["convbert",["ConvBertForMaskedLM",qt]],["camembert",["CamembertForMaskedLM",Fe]],["deberta",["DebertaForMaskedLM",Dt]],["deberta-v2",["DebertaV2ForMaskedLM",ui]],["mpnet",["MPNetForMaskedLM",it]],["albert",["AlbertForMaskedLM",kt]],["distilbert",["DistilBertForMaskedLM",Wt]],["roberta",["RobertaForMaskedLM",hi]],["xlm",["XLMWithLMHeadModel",Nt]],["xlm-roberta",["XLMRobertaForMaskedLM",zd]],["mobilebert",["MobileBertForMaskedLM",bt]],["squeezebert",["SqueezeBertForMaskedLM",Ae]]]),Fy=new Map([["bert",["BertForQuestionAnswering",Ie]],["neobert",["NeoBertForQuestionAnswering",qe]],["roformer",["RoFormerForQuestionAnswering",Mn]],["electra",["ElectraForQuestionAnswering",J]],["convbert",["ConvBertForQuestionAnswering",rt]],["camembert",["CamembertForQuestionAnswering",Pt]],["deberta",["DebertaForQuestionAnswering",nn]],["deberta-v2",["DebertaV2ForQuestionAnswering",ki]],["mpnet",["MPNetForQuestionAnswering",Xe]],["albert",["AlbertForQuestionAnswering",At]],["distilbert",["DistilBertForQuestionAnswering",zi]],["roberta",["RobertaForQuestionAnswering",Sl]],["xlm",["XLMForQuestionAnswering",$t]],["xlm-roberta",["XLMRobertaForQuestionAnswering",Nd]],["mobilebert",["MobileBertForQuestionAnswering",Lt]],["squeezebert",["SqueezeBertForQuestionAnswering",We]]]),_u=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Il]],["idefics3",["Idefics3ForConditionalGeneration",jo]],["smolvlm",["SmolVLMForConditionalGeneration",kl]]]),yu=new Map([["llava",["LlavaForConditionalGeneration",Vo]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",Hd]],["moondream1",["Moondream1ForConditionalGeneration",qd]],["florence2",["Florence2ForConditionalGeneration",Xd]],["qwen2-vl",["Qwen2VLForConditionalGeneration",cf]],["idefics3",["Idefics3ForConditionalGeneration",jo]],["smolvlm",["SmolVLMForConditionalGeneration",kl]],["paligemma",["PaliGemmaForConditionalGeneration",Jd]],["llava_qwen2",["LlavaQwen2ForCausalLM",$i]],["gemma3n",["Gemma3nForConditionalGeneration",Dl]],["mistral3",["Mistral3ForConditionalGeneration",Qd]]]),vu=new Map([["ultravox",["UltravoxModel",fu]],["voxtral",["VoxtralForConditionalGeneration",Nm]]]),mr=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Il]]]),tg=new Map([["vit",["ViTForImageClassification",cr]],["ijepa",["IJepaForImageClassification",mc]],["pvt",["PvtForImageClassification",xf]],["vit_msn",["ViTMSNForImageClassification",bf]],["fastvit",["FastViTForImageClassification",wc]],["mobilevit",["MobileViTForImageClassification",Pf]],["mobilevitv2",["MobileViTV2ForImageClassification",xc]],["beit",["BeitForImageClassification",Ff]],["deit",["DeiTForImageClassification",qf]],["hiera",["HieraForImageClassification",Xf]],["convnext",["ConvNextForImageClassification",pp]],["convnextv2",["ConvNextV2ForImageClassification",_p]],["dinov2",["Dinov2ForImageClassification",py]],["dinov2_with_registers",["Dinov2WithRegistersForImageClassification",wp]],["resnet",["ResNetForImageClassification",ia]],["swin",["SwinForImageClassification",Yf]],["segformer",["SegformerForImageClassification",gm]],["efficientnet",["EfficientNetForImageClassification",vm]],["mobilenet_v1",["MobileNetV1ForImageClassification",cu]],["mobilenet_v2",["MobileNetV2ForImageClassification",Mm]],["mobilenet_v3",["MobileNetV3ForImageClassification",Sm]],["mobilenet_v4",["MobileNetV4ForImageClassification",Am]]]),wu=new Map([["detr",["DetrForObjectDetection",ta]],["rt_detr",["RTDetrForObjectDetection",zf]],["rt_detr_v2",["RTDetrV2ForObjectDetection",ry]],["rf_detr",["RFDetrForObjectDetection",Ac]],["d_fine",["DFineForObjectDetection",jf]],["table-transformer",["TableTransformerForObjectDetection",Wf]],["yolos",["YolosForObjectDetection",Mp]]]),xa=new Map([["owlvit",["OwlViTForObjectDetection",bc]],["owlv2",["Owlv2ForObjectDetection",Df]],["grounding-dino",["GroundingDinoForObjectDetection",pr]]]),gr=new Map([["detr",["DetrForSegmentation",Ec]],["clipseg",["CLIPSegForImageSegmentation",Ki]]]),xu=new Map([["segformer",["SegformerForSemanticSegmentation",_m]],["sapiens",["SapiensForSemanticSegmentation",np]],["swin",["SwinForSemanticSegmentation",Jf]],["mobilenet_v1",["MobileNetV1ForSemanticSegmentation",xm]],["mobilenet_v2",["MobileNetV2ForSemanticSegmentation",Tm]],["mobilenet_v3",["MobileNetV3ForSemanticSegmentation",uu]],["mobilenet_v4",["MobileNetV4ForSemanticSegmentation",Cm]]]),bu=new Map([["detr",["DetrForSegmentation",Ec]],["maskformer",["MaskFormerForInstanceSegmentation",hy]]]),Mu=new Map([["sam",["SamModel",Sp]],["sam2",["Sam2Model",sa]],["edgetam",["EdgeTamModel",gy]],["sam3_tracker",["Sam3TrackerModel",yi]]]),Tu=new Map([["wav2vec2",["Wav2Vec2ForCTC",kp]],["wav2vec2-bert",["Wav2Vec2BertForCTC",yy]],["unispeech",["UniSpeechForCTC",Up]],["unispeech-sat",["UniSpeechSatForCTC",_y]],["wavlm",["WavLMForCTC",Kp]],["hubert",["HubertForCTC",wy]],["parakeet_ctc",["ParakeetForCTC",Rp]]]),Eu=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Op]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",Wp]],["unispeech",["UniSpeechForSequenceClassification",Yc]],["unispeech-sat",["UniSpeechSatForSequenceClassification",Jc]],["wavlm",["WavLMForSequenceClassification",Xp]],["hubert",["HubertForSequenceClassification",qp]],["audio-spectrogram-transformer",["ASTForAudioClassification",Gd]]]),ng=new Map([["wavlm",["WavLMForXVector",Yp]]]),Ws=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",Vp]],["wavlm",["WavLMForAudioFrameClassification",Jp]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",Fp]],["pyannote",["PyAnnoteForAudioFrameClassification",zp]]]),Si=new Map([["vitmatte",["VitMatteForImageMatting",Zo]]]),_o=new Map([["patchtst",["PatchTSTForPrediction",po]],["patchtsmixer",["PatchTSMixerForPrediction",zm]]]),yo=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Bc]]]),vo=new Map([["dpt",["DPTForDepthEstimation",ep]],["depth_anything",["DepthAnythingForDepthEstimation",tp]],["glpn",["GLPNForDepthEstimation",dp]],["sapiens",["SapiensForDepthEstimation",ip]],["depth_pro",["DepthProForDepthEstimation",rp]],["metric3d",["Metric3DForDepthEstimation",dy]],["metric3dv2",["Metric3Dv2ForDepthEstimation",lp]]]),ba=new Map([["sapiens",["SapiensForNormalEstimation",sp]]]),Su=new Map([["vitpose",["VitPoseForPoseEstimation",ni]]]),Ma=new Map([["clip",["CLIPVisionModelWithProjection",Wo]],["siglip",["SiglipVisionModel",sh]],["jina_clip",["JinaCLIPVisionModel",ch]]]),_r=[[U0,E.EncoderOnly],[Ly,E.EncoderDecoder],[Dy,E.DecoderOnly],[G0,E.AutoEncoder],[Zm,E.EncoderOnly],[ky,E.EncoderOnly],[gu,E.Seq2Seq],[mu,E.Seq2Seq],[go,E.DecoderOnly],[Oy,E.MultiModality],[eg,E.EncoderOnly],[Fy,E.EncoderOnly],[_u,E.Vision2Seq],[yu,E.ImageTextToText],[vu,E.AudioTextToText],[tg,E.EncoderOnly],[gr,E.EncoderOnly],[bu,E.EncoderOnly],[xu,E.EncoderOnly],[Si,E.EncoderOnly],[_o,E.EncoderOnly],[yo,E.EncoderOnly],[vo,E.EncoderOnly],[ba,E.EncoderOnly],[Su,E.EncoderOnly],[wu,E.EncoderOnly],[xa,E.EncoderOnly],[Mu,E.MaskGeneration],[Tu,E.EncoderOnly],[Eu,E.EncoderOnly],[Jm,E.Seq2Seq],[Qm,E.EncoderOnly],[ng,E.EncoderOnly],[Ws,E.EncoderOnly],[Ma,E.EncoderOnly]];for(const[M,C]of _r)for(const[z,oe]of M.values())A.set(z,C),I.set(oe,z),L.set(z,oe);const zr=[["MusicgenForConditionalGeneration",lu,E.Musicgen],["Phi3VForCausalLM",Ol,E.Phi3V],["CLIPTextModelWithProjection",Hi,E.EncoderOnly],["SiglipTextModel",ih,E.EncoderOnly],["JinaCLIPTextModel",lh,E.EncoderOnly],["ClapTextModelWithProjection",Ty,E.EncoderOnly],["ClapAudioModelWithProjection",pm,E.EncoderOnly],["DacEncoderModel",Km,E.EncoderOnly],["DacDecoderModel",Cy,E.EncoderOnly],["MimiEncoderModel",jm,E.EncoderOnly],["MimiDecoderModel",Ay,E.EncoderOnly],["SnacEncoderModel",Ym,E.EncoderOnly],["SnacDecoderModel",Iy,E.EncoderOnly],["Gemma3nForConditionalGeneration",Dl,E.ImageAudioTextToText],["SupertonicForConditionalGeneration",Qc,E.Supertonic]];for(const[M,C,z]of zr)A.set(M,z),I.set(C,M),L.set(M,C);const ig=new Map([["modnet",gr],["birefnet",gr],["isnet",gr],["ben",gr]]);for(const[M,C]of ig.entries())C.set(M,["PreTrainedModel",U]),A.set(M,E.EncoderOnly),I.set(U,M),L.set(M,U);class Pu extends gn{}Ce(Pu,"MODEL_CLASS_MAPPINGS",_r.map(C=>C[0])),Ce(Pu,"BASE_IF_FAIL",!0);class sg extends gn{}Ce(sg,"MODEL_CLASS_MAPPINGS",[Zm]);class rg extends gn{}Ce(rg,"MODEL_CLASS_MAPPINGS",[ky]);class og extends gn{}Ce(og,"MODEL_CLASS_MAPPINGS",[gu]);class ag extends gn{}Ce(ag,"MODEL_CLASS_MAPPINGS",[mu]);class lg extends gn{}Ce(lg,"MODEL_CLASS_MAPPINGS",[Jm]);class cg extends gn{}Ce(cg,"MODEL_CLASS_MAPPINGS",[Qm]);class ug extends gn{}Ce(ug,"MODEL_CLASS_MAPPINGS",[go]);class Au extends gn{}Ce(Au,"MODEL_CLASS_MAPPINGS",[eg]);class dg extends gn{}Ce(dg,"MODEL_CLASS_MAPPINGS",[Fy]);class hg extends gn{}Ce(hg,"MODEL_CLASS_MAPPINGS",[_u]);class Ry extends gn{}Ce(Ry,"MODEL_CLASS_MAPPINGS",[tg]);class fg extends gn{}Ce(fg,"MODEL_CLASS_MAPPINGS",[gr]);class Cu extends gn{}Ce(Cu,"MODEL_CLASS_MAPPINGS",[xu]);class Iu extends gn{}Ce(Iu,"MODEL_CLASS_MAPPINGS",[bu]);class pg extends gn{}Ce(pg,"MODEL_CLASS_MAPPINGS",[wu]);class By extends gn{}Ce(By,"MODEL_CLASS_MAPPINGS",[xa]);class mg extends gn{}Ce(mg,"MODEL_CLASS_MAPPINGS",[Mu]);class zy extends gn{}Ce(zy,"MODEL_CLASS_MAPPINGS",[Tu]);class $y extends gn{}Ce($y,"MODEL_CLASS_MAPPINGS",[Eu]);class s extends gn{}Ce(s,"MODEL_CLASS_MAPPINGS",[ng]);class o extends gn{}Ce(o,"MODEL_CLASS_MAPPINGS",[Ws]);class d extends gn{}Ce(d,"MODEL_CLASS_MAPPINGS",[mr]);class g extends gn{}Ce(g,"MODEL_CLASS_MAPPINGS",[Si]);class y extends gn{}Ce(y,"MODEL_CLASS_MAPPINGS",[yo]);class x extends gn{}Ce(x,"MODEL_CLASS_MAPPINGS",[vo]);class b extends gn{}Ce(b,"MODEL_CLASS_MAPPINGS",[ba]);class P extends gn{}Ce(P,"MODEL_CLASS_MAPPINGS",[Su]);class k extends gn{}Ce(k,"MODEL_CLASS_MAPPINGS",[Ma]);class O extends gn{}Ce(O,"MODEL_CLASS_MAPPINGS",[yu]);class $ extends gn{}Ce($,"MODEL_CLASS_MAPPINGS",[vu]);class V extends Se{constructor({logits:C,past_key_values:z,encoder_outputs:oe,decoder_attentions:ve=null,cross_attentions:Pe=null}){super(),this.logits=C,this.past_key_values=z,this.encoder_outputs=oe,this.decoder_attentions=ve,this.cross_attentions=Pe}}class G extends Se{constructor({logits:C,...z}){super(),this.logits=C;const oe=Object.values(z);oe.length>0&&(this.attentions=oe)}}class ee extends Se{constructor({logits:C,embeddings:z}){super(),this.logits=C,this.embeddings=z}}class X extends Se{constructor({logits:C}){super(),this.logits=C}}class re extends Se{constructor({logits:C}){super(),this.logits=C}}class Te extends Se{constructor({start_logits:C,end_logits:z}){super(),this.start_logits=C,this.end_logits=z}}class ue extends Se{constructor({logits:C}){super(),this.logits=C}}class ce extends Se{constructor({logits:C,past_key_values:z}){super(),this.logits=C,this.past_key_values=z}}class ke extends Se{constructor({alphas:C}){super(),this.alphas=C}}class Le extends Se{constructor({waveform:C,spectrogram:z}){super(),this.waveform=C,this.spectrogram=z}}},"./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js":(e,n,t)=>{t.r(n),t.d(n,{ASTFeatureExtractor:()=>a});var i=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var r=t("./src/utils/audio.js");class a extends i.FeatureExtractor{constructor(u){super(u);const l=this.config.sampling_rate,f=(0,r.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(l/2),l,null,"kaldi",!0);this.mel_filters=f,this.window=(0,r.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(u,l){return(0,r.spectrogram)(u,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:l,transpose:!0})}async _call(u){(0,i.validate_audio_inputs)(u,"ASTFeatureExtractor");const l=await this._extract_fbank_features(u,this.config.max_length);if(this.config.do_normalize){const f=this.std*2,m=l.data;for(let h=0;h<m.length;++h)m[h]=(m[h]-this.mean)/f}return{input_values:l.unsqueeze_(0)}}}},"./src/models/auto/feature_extraction_auto.js":(e,n,t)=>{t.r(n),t.d(n,{AutoFeatureExtractor:()=>c});var i=t("./src/utils/constants.js"),r=t("./src/utils/hub.js");t("./src/base/feature_extraction_utils.js");var a=t("./src/models/feature_extractors.js");class c{static async from_pretrained(l,f={}){const m=await(0,r.getModelJSON)(l,i.FEATURE_EXTRACTOR_NAME,!0,f),h=m.feature_extractor_type,p=a[h];if(!p)throw new Error(`Unknown feature_extractor_type: '${h}'. Please report this at ${i.GITHUB_ISSUE_URL}.`);return new p(m)}}},"./src/models/auto/image_processing_auto.js":(e,n,t)=>{t.r(n),t.d(n,{AutoImageProcessor:()=>u});var i=t("./src/utils/constants.js"),r=t("./src/utils/hub.js"),a=t("./src/base/image_processors_utils.js"),c=t("./src/models/image_processors.js");class u{static async from_pretrained(f,m={}){const h=await(0,r.getModelJSON)(f,i.IMAGE_PROCESSOR_NAME,!0,m),p=h.image_processor_type??h.feature_extractor_type;let _=c[p==null?void 0:p.replace(/Fast$/,"")];return _||(p!==void 0&&console.warn(`Image processor type '${p}' not found, assuming base ImageProcessor. Please report this at ${i.GITHUB_ISSUE_URL}.`),_=a.ImageProcessor),new _(h)}}},"./src/models/auto/processing_auto.js":(e,n,t)=>{t.r(n),t.d(n,{AutoProcessor:()=>f});var i=t("./src/utils/constants.js"),r=t("./src/utils/hub.js"),a=t("./src/base/processing_utils.js"),c=t("./src/models/processors.js"),u=t("./src/models/image_processors.js"),l=t("./src/models/feature_extractors.js");class f{static async from_pretrained(h,p={}){const _=await(0,r.getModelJSON)(h,i.IMAGE_PROCESSOR_NAME,!0,p),{image_processor_type:v,feature_extractor_type:S,processor_class:D}=_;if(D&&c[D])return c[D].from_pretrained(h,p);if(!v&&!S)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const w={};if(v){const F=u[v.replace(/Fast$/,"")];if(!F)throw new Error(`Unknown image_processor_type: '${v}'.`);w.image_processor=new F(_)}if(S){const F=u[S];if(F)w.image_processor=new F(_);else{const E=l[S];if(!E)throw new Error(`Unknown feature_extractor_type: '${S}'.`);w.feature_extractor=new E(_)}}const T={};return new a.Processor(T,w,null)}}},"./src/models/beit/image_processing_beit.js":(e,n,t)=>{t.r(n),t.d(n,{BeitFeatureExtractor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/bit/image_processing_bit.js":(e,n,t)=>{t.r(n),t.d(n,{BitImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/chinese_clip/image_processing_chinese_clip.js":(e,n,t)=>{t.r(n),t.d(n,{ChineseCLIPFeatureExtractor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/clap/feature_extraction_clap.js":(e,n,t)=>{t.r(n),t.d(n,{ClapFeatureExtractor:()=>a});var i=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var r=t("./src/utils/audio.js");class a extends i.FeatureExtractor{constructor(u){super(u),this.mel_filters=(0,r.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,r.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,r.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(u,l,f,m){let h;const p=u.length-l;if(p>0)if(f==="rand_trunc"){const _=Math.floor(Math.random()*(p+1));u=u.subarray(_,_+l),h=await this._extract_fbank_features(u,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${f}" not implemented`);else{if(p<0){let _=new Float64Array(l);if(_.set(u),m==="repeat")for(let v=u.length;v<l;v+=u.length)_.set(u.subarray(0,Math.min(u.length,l-v)),v);else if(m==="repeatpad")for(let v=u.length;v<-p;v+=u.length)_.set(u,v);u=_}if(f==="fusion")throw new Error(`Truncation strategy "${f}" not implemented`);h=await this._extract_fbank_features(u,this.mel_filters_slaney,this.config.nb_max_samples)}return h.unsqueeze_(0)}async _extract_fbank_features(u,l,f=null){return(0,r.spectrogram)(u,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:l,log_mel:"dB",max_num_frames:f,do_pad:!1,transpose:!0})}async _call(u,{max_length:l=null}={}){return(0,i.validate_audio_inputs)(u,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(u,l??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}},"./src/models/clip/image_processing_clip.js":(e,n,t)=>{t.r(n),t.d(n,{CLIPFeatureExtractor:()=>a,CLIPImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class a extends r{}},"./src/models/convnext/image_processing_convnext.js":(e,n,t)=>{t.r(n),t.d(n,{ConvNextFeatureExtractor:()=>a,ConvNextImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{constructor(u){super(u),this.crop_pct=this.config.crop_pct??224/256}async resize(u){var f;const l=(f=this.size)==null?void 0:f.shortest_edge;if(l===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(l<384){const m=Math.floor(l/this.crop_pct),[h,p]=this.get_resize_output_image_size(u,{shortest_edge:m});u=await u.resize(h,p,{resample:this.resample}),u=await u.center_crop(l,l)}else u=await u.resize(l,l,{resample:this.resample});return u}}class a extends r{}},"./src/models/dac/feature_extraction_dac.js":(e,n,t)=>{t.r(n),t.d(n,{DacFeatureExtractor:()=>r});var i=t("./src/models/encodec/feature_extraction_encodec.js");class r extends i.EncodecFeatureExtractor{}},"./src/models/deit/image_processing_deit.js":(e,n,t)=>{t.r(n),t.d(n,{DeiTFeatureExtractor:()=>a,DeiTImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class a extends r{}},"./src/models/detr/image_processing_detr.js":(e,n,t)=>{t.r(n),t.d(n,{DetrFeatureExtractor:()=>c,DetrImageProcessor:()=>a});var i=t("./src/base/image_processors_utils.js"),r=t("./src/utils/tensor.js");class a extends i.ImageProcessor{async _call(l){const f=await super._call(l),m=[f.pixel_values.dims[0],64,64],h=(0,r.full)(m,1n);return{...f,pixel_mask:h}}post_process_object_detection(...l){return(0,i.post_process_object_detection)(...l)}post_process_panoptic_segmentation(...l){return(0,i.post_process_panoptic_segmentation)(...l)}post_process_instance_segmentation(...l){return(0,i.post_process_instance_segmentation)(...l)}}class c extends a{}},"./src/models/dinov3_vit/image_processing_dinov3_vit.js":(e,n,t)=>{t.r(n),t.d(n,{DINOv3ViTImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/donut/image_processing_donut.js":(e,n,t)=>{t.r(n),t.d(n,{DonutFeatureExtractor:()=>a,DonutImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{pad_image(u,l,f,m={}){const[h,p,_]=l;let v=this.image_mean;Array.isArray(this.image_mean)||(v=new Array(_).fill(v));let S=this.image_std;Array.isArray(S)||(S=new Array(_).fill(v));const D=v.map((w,T)=>-w/S[T]);return super.pad_image(u,l,f,{center:!0,constant_values:D,...m})}}class a extends r{}},"./src/models/dpt/image_processing_dpt.js":(e,n,t)=>{t.r(n),t.d(n,{DPTFeatureExtractor:()=>a,DPTImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class a extends r{}},"./src/models/efficientnet/image_processing_efficientnet.js":(e,n,t)=>{t.r(n),t.d(n,{EfficientNetImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{constructor(c){super(c),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(u=>u*u))}}},"./src/models/encodec/feature_extraction_encodec.js":(e,n,t)=>{t.r(n),t.d(n,{EncodecFeatureExtractor:()=>a});var i=t("./src/base/feature_extraction_utils.js"),r=t("./src/utils/tensor.js");class a extends i.FeatureExtractor{async _call(u){(0,i.validate_audio_inputs)(u,"EncodecFeatureExtractor"),u instanceof Float64Array&&(u=new Float32Array(u));const l=this.config.feature_size;if(u.length%l!==0)throw new Error(`The length of the audio data must be a multiple of the number of channels (${l}).`);const f=[1,l,u.length/l];return{input_values:new r.Tensor("float32",u,f)}}}},"./src/models/feature_extractors.js":(e,n,t)=>{t.r(n),t.d(n,{ASTFeatureExtractor:()=>i.ASTFeatureExtractor,ClapFeatureExtractor:()=>a.ClapFeatureExtractor,DacFeatureExtractor:()=>c.DacFeatureExtractor,EncodecFeatureExtractor:()=>r.EncodecFeatureExtractor,Gemma3nAudioFeatureExtractor:()=>u.Gemma3nAudioFeatureExtractor,ImageFeatureExtractor:()=>w.ImageProcessor,MoonshineFeatureExtractor:()=>l.MoonshineFeatureExtractor,ParakeetFeatureExtractor:()=>f.ParakeetFeatureExtractor,PyAnnoteFeatureExtractor:()=>m.PyAnnoteFeatureExtractor,SeamlessM4TFeatureExtractor:()=>h.SeamlessM4TFeatureExtractor,SnacFeatureExtractor:()=>p.SnacFeatureExtractor,SpeechT5FeatureExtractor:()=>_.SpeechT5FeatureExtractor,Wav2Vec2FeatureExtractor:()=>v.Wav2Vec2FeatureExtractor,WeSpeakerFeatureExtractor:()=>S.WeSpeakerFeatureExtractor,WhisperFeatureExtractor:()=>D.WhisperFeatureExtractor});var i=t("./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js"),r=t("./src/models/encodec/feature_extraction_encodec.js"),a=t("./src/models/clap/feature_extraction_clap.js"),c=t("./src/models/dac/feature_extraction_dac.js"),u=t("./src/models/gemma3n/feature_extraction_gemma3n.js"),l=t("./src/models/moonshine/feature_extraction_moonshine.js"),f=t("./src/models/parakeet/feature_extraction_parakeet.js"),m=t("./src/models/pyannote/feature_extraction_pyannote.js"),h=t("./src/models/seamless_m4t/feature_extraction_seamless_m4t.js"),p=t("./src/models/snac/feature_extraction_snac.js"),_=t("./src/models/speecht5/feature_extraction_speecht5.js"),v=t("./src/models/wav2vec2/feature_extraction_wav2vec2.js"),S=t("./src/models/wespeaker/feature_extraction_wespeaker.js"),D=t("./src/models/whisper/feature_extraction_whisper.js"),w=t("./src/base/image_processors_utils.js")},"./src/models/florence2/processing_florence2.js":(e,n,t)=>{t.r(n),t.d(n,{Florence2Processor:()=>c});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),a=t("./src/tokenizers.js");class c extends i.Processor{constructor(l,f,m){super(l,f,m);const{tasks_answer_post_processing_type:h,task_prompts_without_inputs:p,task_prompts_with_input:_}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(h??{})),this.task_prompts_without_inputs=new Map(Object.entries(p??{})),this.task_prompts_with_input=new Map(Object.entries(_??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(l){typeof l=="string"&&(l=[l]);const f=[];for(const m of l)if(this.task_prompts_without_inputs.has(m))f.push(this.task_prompts_without_inputs.get(m));else{for(const[h,p]of this.task_prompts_with_input)if(m.includes(h)){f.push(p.replaceAll("{input}",m).replaceAll(h,""));break}f.length!==l.length&&f.push(m)}return f}post_process_generation(l,f,m){const h=this.tasks_answer_post_processing_type.get(f)??"pure_text";l=l.replaceAll("<s>","").replaceAll("</s>","");let p;switch(h){case"pure_text":p=l;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const _=h==="ocr"?"quad_boxes":"bboxes",v=l.matchAll(this.regexes[_]),S=[],D=[];for(const[w,T,...F]of v)S.push(T?T.trim():S.at(-1)??""),D.push(F.map((E,A)=>(Number(E)+.5)/this.size_per_bin*m[A%2]));p={labels:S,[_]:D};break;default:throw new Error(`Task "${f}" (of type "${h}") not yet implemented.`)}return{[f]:p}}async _call(l,f=null,m={}){if(!l&&!f)throw new Error("Either text or images must be provided");const h=await this.image_processor(l,m),p=f?this.tokenizer(this.construct_prompts(f),m):{};return{...h,...p}}}Ce(c,"tokenizer_class",a.AutoTokenizer),Ce(c,"image_processor_class",r.AutoImageProcessor)},"./src/models/gemma3n/feature_extraction_gemma3n.js":(e,n,t)=>{t.r(n),t.d(n,{Gemma3nAudioFeatureExtractor:()=>c});var i=t("./src/base/feature_extraction_utils.js"),r=t("./src/utils/tensor.js"),a=t("./src/utils/audio.js");class c extends i.FeatureExtractor{constructor(l){super(l);const{fft_length:f,feature_size:m,min_frequency:h,max_frequency:p,sampling_rate:_,frame_length:v}=this.config,S=(0,a.mel_filter_bank)(Math.floor(1+f/2),m,h,p,_,null,"htk",!1);this.mel_filters=S,this.window=(0,a.window_function)(v,"hann")}async _extract_fbank_features(l,f){return(0,a.spectrogram)(l,this.window,this.config.frame_length,this.config.hop_length,{fft_length:this.config.fft_length,center:!1,onesided:!0,preemphasis:this.config.preemphasis,preemphasis_htk_flavor:this.config.preemphasis_htk_flavor,mel_filters:this.mel_filters,log_mel:"log",mel_floor:this.config.mel_floor,remove_dc_offset:!1,transpose:!0})}async _call(l,{max_length:f=48e4,truncation:m=!0,padding:h=!0,pad_to_multiple_of:p=128}={}){if((0,i.validate_audio_inputs)(l,"Gemma3nAudioFeatureExtractor"),m&&l.length>f&&(l=l.slice(0,f)),h&&l.length%p!==0){const S=p-l.length%p,D=new Float64Array(l.length+S);D.set(l),this.config.padding_value!==0&&D.fill(this.config.padding_value,l.length),l=D}const _=await this._extract_fbank_features(l,this.config.max_length),v=(0,r.full)([1,_.dims[0]],!0);return{input_features:_.unsqueeze_(0),input_features_mask:v}}}},"./src/models/gemma3n/processing_gemma3n.js":(e,n,t)=>{t.r(n),t.d(n,{Gemma3nProcessor:()=>u});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),a=t("./src/models/auto/feature_extraction_auto.js"),c=t("./src/tokenizers.js");t("./src/utils/image.js"),t("./src/utils/audio.js");class u extends i.Processor{constructor(f,m,h){super(f,m,h),this.audio_seq_length=this.config.audio_seq_length,this.image_seq_length=this.config.image_seq_length;const{audio_token_id:p,boa_token:_,audio_token:v,eoa_token:S,image_token_id:D,boi_token:w,image_token:T,eoi_token:F}=this.tokenizer.config;this.audio_token_id=p,this.boa_token=_,this.audio_token=v;const E=v.repeat(this.audio_seq_length);this.full_audio_sequence=`

${_}${E}${S}

`,this.image_token_id=D,this.boi_token=w,this.image_token=T;const A=T.repeat(this.image_seq_length);this.full_image_sequence=`

${w}${A}${F}

`}async _call(f,m=null,h=null,p={}){typeof f=="string"&&(f=[f]);let _;h&&(_=await this.feature_extractor(h,p),f=f.map(D=>D.replaceAll(this.audio_token,this.full_audio_sequence)));let v;return m&&(v=await this.image_processor(m,p),f=f.map(D=>D.replaceAll(this.image_token,this.full_image_sequence))),{...this.tokenizer(f,p),...v,..._}}}Ce(u,"image_processor_class",r.AutoImageProcessor),Ce(u,"feature_extractor_class",a.AutoFeatureExtractor),Ce(u,"tokenizer_class",c.AutoTokenizer),Ce(u,"uses_processor_config",!0),Ce(u,"uses_chat_template_file",!0)},"./src/models/glpn/image_processing_glpn.js":(e,n,t)=>{t.r(n),t.d(n,{GLPNFeatureExtractor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/grounding_dino/image_processing_grounding_dino.js":(e,n,t)=>{t.r(n),t.d(n,{GroundingDinoImageProcessor:()=>a});var i=t("./src/base/image_processors_utils.js"),r=t("./src/utils/tensor.js");class a extends i.ImageProcessor{async _call(u){const l=await super._call(u),f=l.pixel_values.dims,m=(0,r.ones)([f[0],f[2],f[3]]);return{...l,pixel_mask:m}}}},"./src/models/grounding_dino/processing_grounding_dino.js":(e,n,t)=>{t.r(n),t.d(n,{GroundingDinoProcessor:()=>l});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),a=t("./src/tokenizers.js"),c=t("./src/base/image_processors_utils.js");function u(f,m){const p=f.dims.at(-1)-1,_=f.tolist();_.fill(!1,0,0+1),_.fill(!1,p);const v=m.tolist();return _.map((S,D)=>S?D:null).filter(S=>S!==null).map(S=>v[S])}class l extends i.Processor{async _call(m,h,p={}){const _=m?await this.image_processor(m,p):{};return{...h?this.tokenizer(h,p):{},..._}}post_process_grounded_object_detection(m,h,{box_threshold:p=.25,text_threshold:_=.25,target_sizes:v=null}={}){const{logits:S,pred_boxes:D}=m,w=S.dims[0];if(v!==null&&v.length!==w)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const T=S.dims.at(1),F=S.sigmoid(),E=F.max(-1).tolist(),A=D.tolist().map(I=>I.map(R=>(0,c.center_to_corners_format)(R))),L=[];for(let I=0;I<w;++I){const R=v!==null?v[I]:null;R!==null&&(A[I]=A[I].map(W=>W.map((te,K)=>te*R[(K+1)%2])));const N=E[I],q=[],ne=[],Q=[];for(let W=0;W<T;++W){const te=N[W];if(te<=p)continue;const K=A[I][W],pe=F[I][W];q.push(te),Q.push(K);const be=u(pe.gt(_),h[I]);ne.push(be)}L.push({scores:q,boxes:Q,labels:this.batch_decode(ne)})}return L}}Ce(l,"tokenizer_class",a.AutoTokenizer),Ce(l,"image_processor_class",r.AutoImageProcessor)},"./src/models/idefics3/image_processing_idefics3.js":(e,n,t)=>{t.r(n),t.d(n,{Idefics3ImageProcessor:()=>a});var i=t("./src/base/image_processors_utils.js"),r=t("./src/utils/tensor.js");class a extends i.ImageProcessor{constructor(u){super(u),this.do_image_splitting=u.do_image_splitting??!0,this.max_image_size=u.max_image_size}get_resize_for_vision_encoder(u,l){let[f,m]=u.dims.slice(-2);const h=m/f;return m>=f?(m=Math.ceil(m/l)*l,f=Math.floor(m/h),f=Math.ceil(f/l)*l):(f=Math.ceil(f/l)*l,m=Math.floor(f*h),m=Math.ceil(m/l)*l),{height:f,width:m}}async _call(u,{do_image_splitting:l=null,return_row_col_info:f=!1}={}){let m;if(!Array.isArray(u))m=[[u]];else{if(u.length===0||!u[0])throw new Error("No images provided.");Array.isArray(u[0])?m=u:m=[u]}let h=[],p=[],_=[];const v=[],S=[];for(const I of m){let R=await Promise.all(I.map(ne=>this.preprocess(ne)));v.push(...R.map(ne=>ne.original_size)),S.push(...R.map(ne=>ne.reshaped_input_size)),R.forEach(ne=>ne.pixel_values.unsqueeze_(0));const{longest_edge:N}=this.max_image_size;let q;if(l??this.do_image_splitting){let ne=new Array(R.length),Q=new Array(R.length);q=await Promise.all(R.map(async(W,te)=>{const K=this.get_resize_for_vision_encoder(W.pixel_values,N),pe=await(0,r.interpolate_4d)(W.pixel_values,{size:[K.height,K.width]}),{frames:be,num_splits_h:Ee,num_splits_w:Ge}=await this.split_image(pe,this.max_image_size);return ne[te]=Ee,Q[te]=Ge,(0,r.cat)(be,0)})),p.push(ne),_.push(Q)}else{const ne=[N,N];q=await Promise.all(R.map(Q=>(0,r.interpolate_4d)(Q.pixel_values,{size:ne}))),p.push(new Array(R.length).fill(0)),_.push(new Array(R.length).fill(0))}h.push((0,r.cat)(q,0))}const D=h.length,[w,T,F,E]=h[0].dims;let A,L;if(D===1)A=h[0].unsqueeze_(0),L=(0,r.full)([D,w,F,E],!0);else{const I=Math.max(...h.map(q=>q.dims.at(0)));L=(0,r.full)([D,I,F,E],!0);const R=L.data,N=I*F*E;for(let q=0;q<D;++q){const ne=h[q].dims[0];if(ne<I){h[q]=(0,r.cat)([h[q],(0,r.full)([I-ne,T,F,E],0)],0);const Q=q*N+ne*F*E,W=(q+1)*N;R.fill(!1,Q,W)}}A=(0,r.stack)(h,0)}return{pixel_values:A,pixel_attention_mask:L,original_sizes:v,reshaped_input_sizes:S,...f?{rows:p,cols:_}:{}}}async split_image(u,{longest_edge:l}){const f=l,m=l,h=[],[p,_]=u.dims.slice(-2);let v=0,S=0;if(p>f||_>m){v=Math.ceil(p/f),S=Math.ceil(_/m);const D=Math.ceil(p/v),w=Math.ceil(_/S);for(let E=0;E<v;++E)for(let A=0;A<S;++A){let L,I,R,N;E===v-1?(I=p-D,N=p):(I=E*D,N=(E+1)*D),A===S-1?(L=_-w,R=_):(L=A*w,R=(A+1)*w);const q=[I,L],ne=[N,R],Q=await(0,r.slice)(u,q,ne,[2,3]);h.push(Q)}const T=f,F=m;(p!==T||_!==F)&&(u=await(0,r.interpolate_4d)(u,{size:[T,F]}))}return h.push(u),{frames:h,num_splits_h:v,num_splits_w:S}}}},"./src/models/idefics3/processing_idefics3.js":(e,n,t)=>{t.r(n),t.d(n,{Idefics3Processor:()=>m});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),a=t("./src/tokenizers.js");t("./src/utils/image.js");var c=t("./src/utils/core.js");function u(h,p,_,v,S,D){let w="";for(let T=0;T<p;++T){for(let F=0;F<_;++F)w+=v+`<row_${T+1}_col_${F+1}>`+S.repeat(h);w+=`
`}return w+=`
${v}${D}`+S.repeat(h)+`${v}`,w}function l(h,p,_,v){return`${p}${v}`+_.repeat(h)+`${p}`}function f(h,p,_,v,S,D){return h===0&&p===0?l(_,v,S,D):u(_,h,p,v,S,D)}class m extends i.Processor{constructor(){super(...arguments);Ce(this,"fake_image_token","<fake_token_around_image>");Ce(this,"image_token","<image>");Ce(this,"global_img_token","<global-img>")}async _call(_,v=null,S={}){S.return_row_col_info??(S.return_row_col_info=!0);let D;v&&(D=await this.image_processor(v,S)),Array.isArray(_)||(_=[_]);const w=D.rows??[new Array(_.length).fill(0)],T=D.cols??[new Array(_.length).fill(0)],F=this.config.image_seq_len,E=[],A=[];for(let I=0;I<_.length;++I){const R=_[I],N=w[I],q=T[I];E.push((0,c.count)(R,this.image_token));const ne=N.map((te,K)=>f(te,q[K],F,this.fake_image_token,this.image_token,this.global_img_token)),Q=R.split(this.image_token);if(Q.length===0)throw new Error("The image token should be present in the text.");let W=Q[0];for(let te=0;te<ne.length;++te)W+=ne[te]+Q[te+1];A.push(W)}return{...this.tokenizer(A),...D}}}Ce(m,"image_processor_class",r.AutoImageProcessor),Ce(m,"tokenizer_class",a.AutoTokenizer),Ce(m,"uses_processor_config",!0)},"./src/models/image_processors.js":(e,n,t)=>{t.r(n),t.d(n,{BeitFeatureExtractor:()=>i.BeitFeatureExtractor,BitImageProcessor:()=>r.BitImageProcessor,CLIPFeatureExtractor:()=>c.CLIPFeatureExtractor,CLIPImageProcessor:()=>c.CLIPImageProcessor,ChineseCLIPFeatureExtractor:()=>a.ChineseCLIPFeatureExtractor,ConvNextFeatureExtractor:()=>u.ConvNextFeatureExtractor,ConvNextImageProcessor:()=>u.ConvNextImageProcessor,DINOv3ViTImageProcessor:()=>m.DINOv3ViTImageProcessor,DPTFeatureExtractor:()=>p.DPTFeatureExtractor,DPTImageProcessor:()=>p.DPTImageProcessor,DeiTFeatureExtractor:()=>l.DeiTFeatureExtractor,DeiTImageProcessor:()=>l.DeiTImageProcessor,DetrFeatureExtractor:()=>f.DetrFeatureExtractor,DetrImageProcessor:()=>f.DetrImageProcessor,DonutFeatureExtractor:()=>h.DonutFeatureExtractor,DonutImageProcessor:()=>h.DonutImageProcessor,EfficientNetImageProcessor:()=>_.EfficientNetImageProcessor,GLPNFeatureExtractor:()=>v.GLPNFeatureExtractor,GroundingDinoImageProcessor:()=>S.GroundingDinoImageProcessor,Idefics3ImageProcessor:()=>D.Idefics3ImageProcessor,JinaCLIPImageProcessor:()=>T.JinaCLIPImageProcessor,LlavaOnevisionImageProcessor:()=>F.LlavaOnevisionImageProcessor,Mask2FormerImageProcessor:()=>E.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>A.MaskFormerFeatureExtractor,MaskFormerImageProcessor:()=>A.MaskFormerImageProcessor,MobileNetV1FeatureExtractor:()=>L.MobileNetV1FeatureExtractor,MobileNetV1ImageProcessor:()=>L.MobileNetV1ImageProcessor,MobileNetV2FeatureExtractor:()=>I.MobileNetV2FeatureExtractor,MobileNetV2ImageProcessor:()=>I.MobileNetV2ImageProcessor,MobileNetV3FeatureExtractor:()=>R.MobileNetV3FeatureExtractor,MobileNetV3ImageProcessor:()=>R.MobileNetV3ImageProcessor,MobileNetV4FeatureExtractor:()=>N.MobileNetV4FeatureExtractor,MobileNetV4ImageProcessor:()=>N.MobileNetV4ImageProcessor,MobileViTFeatureExtractor:()=>q.MobileViTFeatureExtractor,MobileViTImageProcessor:()=>q.MobileViTImageProcessor,NougatImageProcessor:()=>ne.NougatImageProcessor,OwlViTFeatureExtractor:()=>W.OwlViTFeatureExtractor,OwlViTImageProcessor:()=>W.OwlViTImageProcessor,Owlv2ImageProcessor:()=>Q.Owlv2ImageProcessor,Phi3VImageProcessor:()=>te.Phi3VImageProcessor,PixtralImageProcessor:()=>K.PixtralImageProcessor,PvtImageProcessor:()=>pe.PvtImageProcessor,Qwen2VLImageProcessor:()=>be.Qwen2VLImageProcessor,RTDetrImageProcessor:()=>Ee.RTDetrImageProcessor,Sam2ImageProcessor:()=>_e.Sam2ImageProcessor,Sam3ImageProcessor:()=>De.Sam3ImageProcessor,SamImageProcessor:()=>Ge.SamImageProcessor,SegformerFeatureExtractor:()=>he.SegformerFeatureExtractor,SegformerImageProcessor:()=>he.SegformerImageProcessor,SiglipImageProcessor:()=>Z.SiglipImageProcessor,SmolVLMImageProcessor:()=>me.SmolVLMImageProcessor,Swin2SRImageProcessor:()=>we.Swin2SRImageProcessor,VLMImageProcessor:()=>w.VLMImageProcessor,ViTFeatureExtractor:()=>xe.ViTFeatureExtractor,ViTImageProcessor:()=>xe.ViTImageProcessor,VitMatteImageProcessor:()=>et.VitMatteImageProcessor,VitPoseImageProcessor:()=>Ve.VitPoseImageProcessor,YolosFeatureExtractor:()=>nt.YolosFeatureExtractor,YolosImageProcessor:()=>nt.YolosImageProcessor});var i=t("./src/models/beit/image_processing_beit.js"),r=t("./src/models/bit/image_processing_bit.js"),a=t("./src/models/chinese_clip/image_processing_chinese_clip.js"),c=t("./src/models/clip/image_processing_clip.js"),u=t("./src/models/convnext/image_processing_convnext.js"),l=t("./src/models/deit/image_processing_deit.js"),f=t("./src/models/detr/image_processing_detr.js"),m=t("./src/models/dinov3_vit/image_processing_dinov3_vit.js"),h=t("./src/models/donut/image_processing_donut.js"),p=t("./src/models/dpt/image_processing_dpt.js"),_=t("./src/models/efficientnet/image_processing_efficientnet.js"),v=t("./src/models/glpn/image_processing_glpn.js"),S=t("./src/models/grounding_dino/image_processing_grounding_dino.js"),D=t("./src/models/idefics3/image_processing_idefics3.js"),w=t("./src/models/janus/image_processing_janus.js"),T=t("./src/models/jina_clip/image_processing_jina_clip.js"),F=t("./src/models/llava_onevision/image_processing_llava_onevision.js"),E=t("./src/models/mask2former/image_processing_mask2former.js"),A=t("./src/models/maskformer/image_processing_maskformer.js"),L=t("./src/models/mobilenet_v1/image_processing_mobilenet_v1.js"),I=t("./src/models/mobilenet_v2/image_processing_mobilenet_v2.js"),R=t("./src/models/mobilenet_v3/image_processing_mobilenet_v3.js"),N=t("./src/models/mobilenet_v4/image_processing_mobilenet_v4.js"),q=t("./src/models/mobilevit/image_processing_mobilevit.js"),ne=t("./src/models/nougat/image_processing_nougat.js"),Q=t("./src/models/owlv2/image_processing_owlv2.js"),W=t("./src/models/owlvit/image_processing_owlvit.js"),te=t("./src/models/phi3_v/image_processing_phi3_v.js"),K=t("./src/models/pixtral/image_processing_pixtral.js"),pe=t("./src/models/pvt/image_processing_pvt.js"),be=t("./src/models/qwen2_vl/image_processing_qwen2_vl.js"),Ee=t("./src/models/rt_detr/image_processing_rt_detr.js"),Ge=t("./src/models/sam/image_processing_sam.js"),_e=t("./src/models/sam2/image_processing_sam2.js"),De=t("./src/models/sam3/image_processing_sam3.js"),he=t("./src/models/segformer/image_processing_segformer.js"),Z=t("./src/models/siglip/image_processing_siglip.js"),me=t("./src/models/smolvlm/image_processing_smolvlm.js"),we=t("./src/models/swin2sr/image_processing_swin2sr.js"),xe=t("./src/models/vit/image_processing_vit.js"),et=t("./src/models/vitmatte/image_processing_vitmatte.js"),Ve=t("./src/models/vitpose/image_processing_vitpose.js"),nt=t("./src/models/yolos/image_processing_yolos.js")},"./src/models/janus/image_processing_janus.js":(e,n,t)=>{t.r(n),t.d(n,{VLMImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{constructor(c){super({do_pad:!0,pad_size:{width:c.image_size,height:c.image_size},...c}),this.constant_values=this.config.background_color.map(u=>u*this.rescale_factor)}pad_image(c,u,l,f){return super.pad_image(c,u,l,{constant_values:this.constant_values,center:!0,...f})}}},"./src/models/janus/processing_janus.js":(e,n,t)=>{t.r(n),t.d(n,{VLChatProcessor:()=>f});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),a=t("./src/tokenizers.js"),c=t("./src/utils/core.js"),u=t("./src/utils/tensor.js"),l=t("./src/utils/image.js");class f extends i.Processor{constructor(h,p,_){super(h,p,_),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(h,{images:p=null,chat_template:_="default"}={}){p?Array.isArray(p)||(p=[p]):p=await Promise.all(h.filter(q=>q.images).flatMap(q=>q.images).map(q=>l.RawImage.read(q)));const v=this.tokenizer,S=v.apply_chat_template(h,{tokenize:!1,add_generation_prompt:!0,chat_template:_}),D=q=>v.encode(q,{add_special_tokens:!1}),w=S.split(this.image_tag),T=w.length-1;if(p.length!==T)throw new Error(`Number of images provided (${p.length}) does not match number of "${this.image_tag}" image tags (${T})`);const[F,E,A]=v.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let L=D(w[0]),I=new Array(L.length).fill(!1);for(let q=1;q<w.length;++q){const ne=new Array(this.num_image_tokens).fill(F),Q=D(w[q]);L=(0,c.mergeArrays)(L,[E],ne,[A],Q);const W=new Array(this.num_image_tokens).fill(!0);I=(0,c.mergeArrays)(I,[!1],W,[!1],new Array(Q.length).fill(!1))}const R=[1,L.length],N={input_ids:new u.Tensor("int64",L,R),attention_mask:new u.Tensor("int64",new Array(L.length).fill(1),R),images_seq_mask:new u.Tensor("bool",I,R),images_emb_mask:new u.Tensor("bool",new Array(T*this.num_image_tokens).fill(!0),[1,T,this.num_image_tokens])};if(p&&p.length>0){const q=await this.image_processor(p);return q.pixel_values.unsqueeze_(0),{...N,...q}}return N}}Ce(f,"image_processor_class",r.AutoImageProcessor),Ce(f,"tokenizer_class",a.AutoTokenizer),Ce(f,"uses_processor_config",!0)},"./src/models/jina_clip/image_processing_jina_clip.js":(e,n,t)=>{t.r(n),t.d(n,{JinaCLIPImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{constructor(c){const{resize_mode:u,fill_color:l,interpolation:f,size:m,...h}=c,p=u==="squash"?{width:m,height:m}:u==="shortest"?{shortest_edge:m}:{longest_edge:m},_=f==="bicubic"?3:2;super({...h,size:p,resample:_,do_center_crop:!0,crop_size:m,do_normalize:!0})}}},"./src/models/jina_clip/processing_jina_clip.js":(e,n,t)=>{t.r(n),t.d(n,{JinaCLIPProcessor:()=>c});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),a=t("./src/tokenizers.js");class c extends i.Processor{async _call(l=null,f=null,m={}){if(!l&&!f)throw new Error("Either text or images must be provided");const h=l?this.tokenizer(l,m):{},p=f?await this.image_processor(f,m):{};return{...h,...p}}}Ce(c,"tokenizer_class",a.AutoTokenizer),Ce(c,"image_processor_class",r.AutoImageProcessor)},"./src/models/llava/processing_llava.js":(e,n,t)=>{t.r(n),t.d(n,{LlavaProcessor:()=>c});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),a=t("./src/tokenizers.js");class c extends i.Processor{async _call(l,f=null,m={}){const h=await this.image_processor(l,m);if(f){const[_,v]=h.pixel_values.dims.slice(-2),{image_token:S,patch_size:D,num_additional_image_tokens:w}=this.config,T=Math.floor(_/D)*Math.floor(v/D)+w;f=structuredClone(f),Array.isArray(f)||(f=[f]);for(let F=0;F<f.length;++F)f[F]=f[F].replace(S,S.repeat(T))}const p=f?this.tokenizer(f,m):{};return{...h,...p}}}Ce(c,"tokenizer_class",a.AutoTokenizer),Ce(c,"image_processor_class",r.AutoImageProcessor),Ce(c,"uses_processor_config",!0)},"./src/models/llava_onevision/image_processing_llava_onevision.js":(e,n,t)=>{t.r(n),t.d(n,{LlavaOnevisionImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/mask2former/image_processing_mask2former.js":(e,n,t)=>{t.r(n),t.d(n,{Mask2FormerImageProcessor:()=>r});var i=t("./src/models/maskformer/image_processing_maskformer.js");class r extends i.MaskFormerImageProcessor{}},"./src/models/maskformer/image_processing_maskformer.js":(e,n,t)=>{t.r(n),t.d(n,{MaskFormerFeatureExtractor:()=>a,MaskFormerImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{post_process_panoptic_segmentation(...u){return(0,i.post_process_panoptic_segmentation)(...u)}post_process_instance_segmentation(...u){return(0,i.post_process_instance_segmentation)(...u)}}class a extends r{}},"./src/models/mgp_str/processing_mgp_str.js":(e,n,t)=>{t.r(n),t.d(n,{MgpstrProcessor:()=>l});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),a=t("./src/tokenizers.js"),c=t("./src/utils/maths.js");const u={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class l extends i.Processor{get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(m,h){if(!u.hasOwnProperty(h))throw new Error(`Format ${h} is not supported.`);const[p,_]=u[h],v=this[p].bind(this),[S,D]=m.dims,w=[],T=[],F=m.tolist();for(let A=0;A<S;++A){const L=F[A],I=[],R=[];for(let q=1;q<D;++q){const[ne,Q]=(0,c.max)((0,c.softmax)(L[q]));if(R.push(ne),Q==_)break;I.push(Q)}const N=R.length>0?R.reduce((q,ne)=>q*ne,1):0;T.push(I),w.push(N)}return[v(T),w]}char_decode(m){return this.char_tokenizer.batch_decode(m).map(h=>h.replaceAll(" ",""))}bpe_decode(m){return this.bpe_tokenizer.batch_decode(m)}wp_decode(m){return this.wp_tokenizer.batch_decode(m).map(h=>h.replaceAll(" ",""))}batch_decode([m,h,p]){const[_,v]=this._decode_helper(m,"char"),[S,D]=this._decode_helper(h,"bpe"),[w,T]=this._decode_helper(p,"wp"),F=[],E=[];for(let A=0;A<_.length;++A){const[L,I]=(0,c.max)([v[A],D[A],T[A]]);F.push([_[A],S[A],w[A]][I]),E.push(L)}return{generated_text:F,scores:E,char_preds:_,bpe_preds:S,wp_preds:w}}static async from_pretrained(...m){const h=await super.from_pretrained(...m),p=await a.AutoTokenizer.from_pretrained("Xenova/gpt2"),_=await a.AutoTokenizer.from_pretrained("Xenova/bert-base-uncased");return h.components={image_processor:h.image_processor,char_tokenizer:h.tokenizer,bpe_tokenizer:p,wp_tokenizer:_},h}async _call(m,h=null){const p=await this.image_processor(m);return h&&(p.labels=this.tokenizer(h).input_ids),p}}Ce(l,"tokenizer_class",a.AutoTokenizer),Ce(l,"image_processor_class",r.AutoImageProcessor)},"./src/models/mobilenet_v1/image_processing_mobilenet_v1.js":(e,n,t)=>{t.r(n),t.d(n,{MobileNetV1FeatureExtractor:()=>a,MobileNetV1ImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class a extends r{}},"./src/models/mobilenet_v2/image_processing_mobilenet_v2.js":(e,n,t)=>{t.r(n),t.d(n,{MobileNetV2FeatureExtractor:()=>a,MobileNetV2ImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class a extends r{}},"./src/models/mobilenet_v3/image_processing_mobilenet_v3.js":(e,n,t)=>{t.r(n),t.d(n,{MobileNetV3FeatureExtractor:()=>a,MobileNetV3ImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class a extends r{}},"./src/models/mobilenet_v4/image_processing_mobilenet_v4.js":(e,n,t)=>{t.r(n),t.d(n,{MobileNetV4FeatureExtractor:()=>a,MobileNetV4ImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class a extends r{}},"./src/models/mobilevit/image_processing_mobilevit.js":(e,n,t)=>{t.r(n),t.d(n,{MobileViTFeatureExtractor:()=>a,MobileViTImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class a extends r{}},"./src/models/moonshine/feature_extraction_moonshine.js":(e,n,t)=>{t.r(n),t.d(n,{MoonshineFeatureExtractor:()=>a});var i=t("./src/base/feature_extraction_utils.js"),r=t("./src/utils/tensor.js");class a extends i.FeatureExtractor{async _call(u){(0,i.validate_audio_inputs)(u,"MoonshineFeatureExtractor"),u instanceof Float64Array&&(u=new Float32Array(u));const l=[1,u.length];return{input_values:new r.Tensor("float32",u,l)}}}},"./src/models/moonshine/processing_moonshine.js":(e,n,t)=>{t.r(n),t.d(n,{MoonshineProcessor:()=>c});var i=t("./src/models/auto/feature_extraction_auto.js"),r=t("./src/tokenizers.js"),a=t("./src/base/processing_utils.js");class c extends a.Processor{async _call(l){return await this.feature_extractor(l)}}Ce(c,"tokenizer_class",r.AutoTokenizer),Ce(c,"feature_extractor_class",i.AutoFeatureExtractor)},"./src/models/nougat/image_processing_nougat.js":(e,n,t)=>{t.r(n),t.d(n,{NougatImageProcessor:()=>r});var i=t("./src/models/donut/image_processing_donut.js");class r extends i.DonutImageProcessor{}},"./src/models/owlv2/image_processing_owlv2.js":(e,n,t)=>{t.r(n),t.d(n,{Owlv2ImageProcessor:()=>r});var i=t("./src/models/owlvit/image_processing_owlvit.js");class r extends i.OwlViTImageProcessor{}},"./src/models/owlvit/image_processing_owlvit.js":(e,n,t)=>{t.r(n),t.d(n,{OwlViTFeatureExtractor:()=>a,OwlViTImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{post_process_object_detection(...u){return(0,i.post_process_object_detection)(...u)}}class a extends r{}},"./src/models/owlvit/processing_owlvit.js":(e,n,t)=>{t.r(n),t.d(n,{OwlViTProcessor:()=>c});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),a=t("./src/tokenizers.js");class c extends i.Processor{}Ce(c,"tokenizer_class",a.AutoTokenizer),Ce(c,"image_processor_class",r.AutoImageProcessor)},"./src/models/paligemma/processing_paligemma.js":(e,n,t)=>{t.r(n),t.d(n,{PaliGemmaProcessor:()=>l});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),a=t("./src/tokenizers.js");const c="<image>";function u(f,m,h,p,_){return`${p.repeat(h*_)}${m}${f}
`}class l extends i.Processor{async _call(m,h=null,p={}){h||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),h=""),Array.isArray(m)||(m=[m]),Array.isArray(h)||(h=[h]);const _=this.tokenizer.bos_token,v=this.image_processor.config.image_seq_length;let S;h.some(T=>T.includes(c))?S=h.map(T=>{const F=T.replaceAll(c,c.repeat(v)),E=F.lastIndexOf(c),A=E===-1?0:E+c.length;return F.slice(0,A)+_+F.slice(A)+`
`}):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),S=h.map(T=>u(T,_,v,c,m.length)));const D=this.tokenizer(S,p);return{...await this.image_processor(m,p),...D}}}Ce(l,"tokenizer_class",a.AutoTokenizer),Ce(l,"image_processor_class",r.AutoImageProcessor),Ce(l,"uses_processor_config",!1)},"./src/models/parakeet/feature_extraction_parakeet.js":(e,n,t)=>{t.r(n),t.d(n,{ParakeetFeatureExtractor:()=>u});var i=t("./src/base/feature_extraction_utils.js"),r=t("./src/utils/tensor.js"),a=t("./src/utils/audio.js");const c=1e-5;class u extends i.FeatureExtractor{constructor(f){var p;super(f),(p=this.config).mel_filters??(p.mel_filters=(0,a.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,this.config.sampling_rate/2,this.config.sampling_rate,"slaney","slaney"));const m=(0,a.window_function)(this.config.win_length,"hann",{periodic:!1});this.window=new Float64Array(this.config.n_fft);const h=Math.floor((this.config.n_fft-this.config.win_length)/2);this.window.set(m,h)}async _extract_fbank_features(f){const m=this.config.preemphasis;f=new Float64Array(f);for(let p=f.length-1;p>=1;--p)f[p]-=m*f[p-1];return await(0,a.spectrogram)(f,this.window,this.window.length,this.config.hop_length,{fft_length:this.config.n_fft,power:2,mel_filters:this.config.mel_filters,log_mel:"log",mel_floor:-1/0,pad_mode:"constant",center:!0,transpose:!0,mel_offset:2**-24})}async _call(f){(0,i.validate_audio_inputs)(f,"ParakeetFeatureExtractor");const m=await this._extract_fbank_features(f),h=Math.floor((f.length+Math.floor(this.config.n_fft/2)*2-this.config.n_fft)/this.config.hop_length),p=m.data;p.fill(0,h*m.dims[1]);const[_,v]=m.dims,S=new Float64Array(v),D=new Float64Array(v);for(let F=0;F<h;++F){const E=F*v;for(let A=0;A<v;++A){const L=p[E+A];S[A]+=L,D[A]+=L*L}}const w=h>1?h-1:1;for(let F=0;F<v;++F){const E=S[F]/h,A=(D[F]-h*E*E)/w,I=1/(Math.sqrt(A)+c);for(let R=0;R<h;++R){const N=R*v+F;p[N]=(p[N]-E)*I}}const T=new BigInt64Array(_);return T.fill(1n,0,h),{input_features:m.unsqueeze_(0),attention_mask:new r.Tensor("int64",T,[1,_])}}}},"./src/models/phi3_v/image_processing_phi3_v.js":(e,n,t)=>{t.r(n),t.d(n,{Phi3VImageProcessor:()=>m});var i=t("./src/base/image_processors_utils.js"),r=t("./src/utils/tensor.js");const a=336,c=[2,3],{ceil:u,floor:l,sqrt:f}=Math;class m extends i.ImageProcessor{constructor(p){super({...p,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=p.num_crops}calc_num_image_tokens_from_image_size(p,_){const{num_img_tokens:v}=this.config;return l((l(_/a)*l(p/a)+1)*v+1+(l(_/a)+1)*f(v))}get_resize_output_image_size(p,_){const v=this._num_crops,[S,D]=p.size;let w=S/D,T=1;for(;T*Math.ceil(T/w)<=v;)T+=1;T-=1;const F=Math.floor(T*336),E=Math.floor(F/w);return[F,E]}pad_image(p,_,v,S={}){const[D,w]=_,T=a*u(D/a),F=a*u(w/a),E=[1,1,1].map((A,L)=>(A-this.image_mean[L])/this.image_std[L]);return super.pad_image(p,_,{width:F,height:T},{center:!0,constant_values:E,...S})}async _call(p,{num_crops:_=null}={}){if(this._num_crops=_??(_=this.config.num_crops),_<4||f(_)%1!==0)throw new Error("num_crops must be a square number >= 4");Array.isArray(p)||(p=[p]);const v=p.length,S=await Promise.all(p.map(I=>this.preprocess(I))),D=S.map(I=>I.original_size),w=S.map(I=>I.reshaped_input_size),T=[];for(const{pixel_values:I}of S){I.unsqueeze_(0);const[R,N]=I.dims.slice(-2),q=await(0,r.interpolate_4d)(I,{size:[a,a],mode:"bicubic"});if(_>0){const ne=[],Q=f(_),W=l(N/Q),te=l(R/Q);for(let pe=0;pe<Q;++pe)for(let be=0;be<Q;++be){let Ee,Ge,_e,De;pe===Q-1?(Ge=R-te,De=R):(Ge=pe*te,De=(pe+1)*te),be===Q-1?(Ee=N-W,_e=N):(Ee=be*W,_e=(be+1)*W);const he=[Ge,Ee],Z=[De,_e],me=await(0,r.slice)(I,he,Z,c);ne.push(me)}const K=await(0,r.interpolate_4d)((0,r.cat)(ne,0),{size:[a,a],mode:"bicubic"});T.push((0,r.cat)([q,K],0))}else T.push(q)}const F=(0,r.stack)(T,0),E=w.map(I=>I.map(R=>a*u(R/a))),A=new r.Tensor("int64",E.flat(),[v,2]),L=E.map(([I,R])=>this.calc_num_image_tokens_from_image_size(R,I));return{pixel_values:F,original_sizes:D,reshaped_input_sizes:w,image_sizes:A,num_img_tokens:L}}}},"./src/models/phi3_v/processing_phi3_v.js":(e,n,t)=>{t.r(n),t.d(n,{Phi3VProcessor:()=>l});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),a=t("./src/tokenizers.js");t("./src/utils/image.js");const c="<|image|>",u=/<\|image_\d+\|>/g;class l extends i.Processor{async _call(m,h=null,{padding:p=!0,truncation:_=!0,num_crops:v=null}={}){Array.isArray(m)||(m=[m]);let S,D;if(h){D=await this.image_processor(h,{num_crops:v});const{num_img_tokens:w}=D,T=m.map((E,A)=>E.split(u).join(c.repeat(w[A])));S=this.tokenizer(T,{padding:p,truncation:_});const F=this.tokenizer.model.convert_tokens_to_ids([c])[0];S.input_ids.map_(E=>E==F?-E:E)}else S=this.tokenizer(m);return{...S,...D}}}Ce(l,"image_processor_class",r.AutoImageProcessor),Ce(l,"tokenizer_class",a.AutoTokenizer)},"./src/models/pixtral/image_processing_pixtral.js":(e,n,t)=>{t.r(n),t.d(n,{PixtralImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{get_resize_output_image_size(c,u){const{longest_edge:l}=u;if(l===void 0)throw new Error("size must contain 'longest_edge'");const[f,m]=c.size,h=Math.max(f,m)/l;let p=f,_=m;h>1&&(p=Math.floor(f/h),_=Math.floor(m/h));const{patch_size:v,spatial_merge_size:S}=this.config;if(!S)throw new Error("config must contain 'spatial_merge_size'");const D=v*S,w=Math.floor((p-1)/D)+1,T=Math.floor((_-1)/D)+1;return[w*D,T*D]}}},"./src/models/pixtral/processing_pixtral.js":(e,n,t)=>{t.r(n),t.d(n,{PixtralProcessor:()=>c});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),a=t("./src/tokenizers.js");class c extends i.Processor{async _call(l,f=null,m={}){const h=await this.image_processor(l,m);if(f){const[_,v]=h.pixel_values.dims.slice(-2),{image_token:S,image_break_token:D,image_end_token:w,patch_size:T,spatial_merge_size:F}=this.config,E=T*F,A=Math.floor(_/E),L=Math.floor(v/E);f=structuredClone(f),Array.isArray(f)||(f=[f]);for(let I=0;I<f.length;++I){const R=S.repeat(L),N=R+D,q=R+w,ne=N.repeat(A-1)+q;f[I]=f[I].replace(S,ne)}}const p=f?this.tokenizer(f,m):{};return{...h,...p}}}Ce(c,"tokenizer_class",a.AutoTokenizer),Ce(c,"image_processor_class",r.AutoImageProcessor),Ce(c,"uses_processor_config",!0)},"./src/models/processors.js":(e,n,t)=>{t.r(n),t.d(n,{Florence2Processor:()=>i.Florence2Processor,Gemma3nProcessor:()=>r.Gemma3nProcessor,GroundingDinoProcessor:()=>a.GroundingDinoProcessor,Idefics3Processor:()=>c.Idefics3Processor,JinaCLIPProcessor:()=>l.JinaCLIPProcessor,LlavaProcessor:()=>f.LlavaProcessor,MgpstrProcessor:()=>m.MgpstrProcessor,MoonshineProcessor:()=>h.MoonshineProcessor,OwlViTProcessor:()=>p.OwlViTProcessor,PaliGemmaProcessor:()=>_.PaliGemmaProcessor,Phi3VProcessor:()=>v.Phi3VProcessor,PixtralProcessor:()=>S.PixtralProcessor,PyAnnoteProcessor:()=>D.PyAnnoteProcessor,Qwen2VLProcessor:()=>w.Qwen2VLProcessor,Sam2Processor:()=>F.Sam2Processor,Sam2VideoProcessor:()=>F.Sam2VideoProcessor,SamProcessor:()=>T.SamProcessor,SmolVLMProcessor:()=>E.SmolVLMProcessor,SpeechT5Processor:()=>A.SpeechT5Processor,UltravoxProcessor:()=>L.UltravoxProcessor,VLChatProcessor:()=>u.VLChatProcessor,VoxtralProcessor:()=>I.VoxtralProcessor,Wav2Vec2Processor:()=>R.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>N.Wav2Vec2ProcessorWithLM,WhisperProcessor:()=>q.WhisperProcessor});var i=t("./src/models/florence2/processing_florence2.js"),r=t("./src/models/gemma3n/processing_gemma3n.js"),a=t("./src/models/grounding_dino/processing_grounding_dino.js"),c=t("./src/models/idefics3/processing_idefics3.js"),u=t("./src/models/janus/processing_janus.js"),l=t("./src/models/jina_clip/processing_jina_clip.js"),f=t("./src/models/llava/processing_llava.js"),m=t("./src/models/mgp_str/processing_mgp_str.js"),h=t("./src/models/moonshine/processing_moonshine.js"),p=t("./src/models/owlvit/processing_owlvit.js"),_=t("./src/models/paligemma/processing_paligemma.js"),v=t("./src/models/phi3_v/processing_phi3_v.js"),S=t("./src/models/pixtral/processing_pixtral.js"),D=t("./src/models/pyannote/processing_pyannote.js"),w=t("./src/models/qwen2_vl/processing_qwen2_vl.js"),T=t("./src/models/sam/processing_sam.js"),F=t("./src/models/sam2/processing_sam2.js"),E=t("./src/models/smolvlm/processing_smolvlm.js"),A=t("./src/models/speecht5/processing_speecht5.js"),L=t("./src/models/ultravox/processing_ultravox.js"),I=t("./src/models/voxtral/processing_voxtral.js"),R=t("./src/models/wav2vec2/processing_wav2vec2.js"),N=t("./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js"),q=t("./src/models/whisper/processing_whisper.js")},"./src/models/pvt/image_processing_pvt.js":(e,n,t)=>{t.r(n),t.d(n,{PvtImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/pyannote/feature_extraction_pyannote.js":(e,n,t)=>{t.r(n),t.d(n,{PyAnnoteFeatureExtractor:()=>c});var i=t("./src/base/feature_extraction_utils.js"),r=t("./src/utils/tensor.js"),a=t("./src/utils/maths.js");class c extends i.FeatureExtractor{async _call(l){(0,i.validate_audio_inputs)(l,"PyAnnoteFeatureExtractor"),l instanceof Float64Array&&(l=new Float32Array(l));const f=[1,1,l.length];return{input_values:new r.Tensor("float32",l,f)}}samples_to_frames(l){return(l-this.config.offset)/this.config.step}post_process_speaker_diarization(l,f){const m=f/this.samples_to_frames(f)/this.config.sampling_rate,h=[];for(const p of l.tolist()){const _=[];let v=-1;for(let S=0;S<p.length;++S){const D=(0,a.softmax)(p[S]),[w,T]=(0,a.max)(D),[F,E]=[S,S+1];T!==v?(v=T,_.push({id:T,start:F,end:E,score:w})):(_.at(-1).end=E,_.at(-1).score+=w)}h.push(_.map(({id:S,start:D,end:w,score:T})=>({id:S,start:D*m,end:w*m,confidence:T/(w-D)})))}return h}}},"./src/models/pyannote/processing_pyannote.js":(e,n,t)=>{t.r(n),t.d(n,{PyAnnoteProcessor:()=>a});var i=t("./src/base/processing_utils.js"),r=t("./src/models/pyannote/feature_extraction_pyannote.js");class a extends i.Processor{async _call(u){return await this.feature_extractor(u)}post_process_speaker_diarization(...u){return this.feature_extractor.post_process_speaker_diarization(...u)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}Ce(a,"feature_extractor_class",r.PyAnnoteFeatureExtractor)},"./src/models/qwen2_vl/image_processing_qwen2_vl.js":(e,n,t)=>{t.r(n),t.d(n,{Qwen2VLImageProcessor:()=>a});var i=t("./src/base/image_processors_utils.js"),r=t("./src/utils/tensor.js");class a extends i.ImageProcessor{async _call(u,...l){const{pixel_values:f,original_sizes:m,reshaped_input_sizes:h}=await super._call(u,...l);let p=f;const{temporal_patch_size:_,merge_size:v,patch_size:S}=this.config;p.dims[0]===1&&(p=(0,r.cat)(Array.from({length:_},()=>p),0));const D=p.dims[0]/_,w=p.dims[1],T=Math.floor(p.dims[2]/S),F=Math.floor(p.dims[3]/S),E=p.view(D,_,w,Math.floor(T/v),v,S,Math.floor(F/v),v,S).permute(0,3,6,4,7,2,1,5,8).view(D*T*F,w*_*S*S),A=new r.Tensor("int64",[D,T,F],[1,3]);return{pixel_values:E,image_grid_thw:A,original_sizes:m,reshaped_input_sizes:h}}}},"./src/models/qwen2_vl/processing_qwen2_vl.js":(e,n,t)=>{t.r(n),t.d(n,{Qwen2VLProcessor:()=>c});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),a=t("./src/tokenizers.js");t("./src/utils/image.js");class c extends i.Processor{async _call(l,f=null,...m){Array.isArray(l)||(l=[l]);let h,p;if(f&&(h=await this.image_processor(f),p=h.image_grid_thw),p){let v=this.image_processor.config.merge_size**2,S=0;const D=p.tolist();l=l.map(w=>{for(;w.includes("<|image_pad|>");){const T=Number(D[S++].reduce((F,E)=>F*E,1n));w=w.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(T/v)))}return w.replaceAll("<|placeholder|>","<|image_pad|>")})}return{...this.tokenizer(l),...h}}}Ce(c,"image_processor_class",r.AutoImageProcessor),Ce(c,"tokenizer_class",a.AutoTokenizer)},"./src/models/rt_detr/image_processing_rt_detr.js":(e,n,t)=>{t.r(n),t.d(n,{RTDetrImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{post_process_object_detection(...c){return(0,i.post_process_object_detection)(...c)}}},"./src/models/sam/image_processing_sam.js":(e,n,t)=>{t.r(n),t.d(n,{SamImageProcessor:()=>c});var i=t("./src/base/image_processors_utils.js"),r=t("./src/utils/core.js"),a=t("./src/utils/tensor.js");class c extends i.ImageProcessor{reshape_input_points(l,f,m,h=!1){l=structuredClone(l);let p=(0,r.calculateDimensions)(l);if(p.length===3)h||(p=[1,...p]),l=[l];else if(p.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let _=0;_<l.length;++_){const[v,S]=f[_],[D,w]=m[_],T=[w/S,D/v];for(let F=0;F<l[_].length;++F)for(let E=0;E<l[_][F].length;++E)for(let A=0;A<l[_][F][E].length;++A)l[_][F][E][A]*=T[A%2]}return new a.Tensor("float32",Float32Array.from(l.flat(1/0)),p)}add_input_labels(l,f){let m=(0,r.calculateDimensions)(l);if(m.length===2)m=[1,...m],l=[l];else if(m.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(m.some((h,p)=>h!==f.dims[p]))throw Error(`The first ${m.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new a.Tensor("int64",l.flat(1/0).map(BigInt),m)}async _call(l,{input_points:f=null,input_labels:m=null,input_boxes:h=null}={}){const p=await super._call(l);if(f&&(p.input_points=this.reshape_input_points(f,p.original_sizes,p.reshaped_input_sizes)),m){if(!p.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");p.input_labels=this.add_input_labels(m,p.input_points)}return h&&(p.input_boxes=this.reshape_input_points(h,p.original_sizes,p.reshaped_input_sizes,!0)),p}async post_process_masks(l,f,m,{mask_threshold:h=0,binarize:p=!0,pad_size:_=null}={}){const v=[];_=_??this.pad_size??this.size;const S=[_.height,_.width];for(let D=0;D<f.length;++D){const w=f[D],T=m[D];let F=await(0,a.interpolate_4d)(l[D],{mode:"bilinear",size:S});if(F=F.slice(null,null,[0,T[0]],[0,T[1]]),F=await(0,a.interpolate_4d)(F,{mode:"bilinear",size:w}),p){const E=F.data,A=new Uint8Array(E.length);for(let L=0;L<E.length;++L)E[L]>h&&(A[L]=1);F=new a.Tensor("bool",A,F.dims)}v.push(F)}return v}generate_crop_boxes(l,f,{crop_n_layers:m=0,overlap_ratio:h=512/1500,points_per_crop:p=32,crop_n_points_downscale_factor:_=1}={}){}}},"./src/models/sam/processing_sam.js":(e,n,t)=>{t.r(n),t.d(n,{SamProcessor:()=>a});var i=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js");class a extends i.Processor{async _call(...u){return await this.image_processor(...u)}post_process_masks(...u){return this.image_processor.post_process_masks(...u)}reshape_input_points(...u){return this.image_processor.reshape_input_points(...u)}}Ce(a,"image_processor_class",r.AutoImageProcessor)},"./src/models/sam2/image_processing_sam2.js":(e,n,t)=>{t.r(n),t.d(n,{Sam2ImageProcessor:()=>i.SamImageProcessor});var i=t("./src/models/sam/image_processing_sam.js")},"./src/models/sam2/processing_sam2.js":(e,n,t)=>{t.r(n),t.d(n,{Sam2Processor:()=>r,Sam2VideoProcessor:()=>a});var i=t("./src/models/sam/processing_sam.js");class r extends i.SamProcessor{}class a extends r{}},"./src/models/sam3/image_processing_sam3.js":(e,n,t)=>{t.r(n),t.d(n,{Sam3ImageProcessor:()=>i.Sam2ImageProcessor});var i=t("./src/models/sam2/image_processing_sam2.js")},"./src/models/seamless_m4t/feature_extraction_seamless_m4t.js":(e,n,t)=>{t.r(n),t.d(n,{SeamlessM4TFeatureExtractor:()=>c});var i=t("./src/base/feature_extraction_utils.js"),r=t("./src/utils/tensor.js"),a=t("./src/utils/audio.js");class c extends i.FeatureExtractor{constructor(l){super(l);const f=this.config.sampling_rate,m=(0,a.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(f/2),f,null,"kaldi",!0);this.mel_filters=m,this.window=(0,a.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(l,f){return l=l.map(m=>m*32768),(0,a.spectrogram)(l,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:f,transpose:!0})}async _call(l,{padding:f=!0,pad_to_multiple_of:m=2,do_normalize_per_mel_bins:h=!0,return_attention_mask:p=!0}={}){(0,i.validate_audio_inputs)(l,"SeamlessM4TFeatureExtractor");let _=await this._extract_fbank_features(l,this.config.max_length);if(h){const[A,L]=_.dims,I=_.data;for(let R=0;R<L;++R){let N=0;for(let W=0;W<A;++W)N+=I[W*L+R];const q=N/A;let ne=0;for(let W=0;W<A;++W)ne+=(I[W*L+R]-q)**2;ne/=A-1;const Q=Math.sqrt(ne+1e-7);for(let W=0;W<A;++W){const te=W*L+R;I[te]=(I[te]-q)/Q}}}let v;if(f){const[A,L]=_.dims,I=_.data,R=A%m;if(R>0){const N=new Float32Array(L*(A+R));N.set(I),N.fill(this.config.padding_value,I.length);const q=A+R;_=new r.Tensor(_.type,N,[q,L]),p&&(v=new r.Tensor("int64",new BigInt64Array(q),[1,q]),v.data.fill(1n,0,A))}}const[S,D]=_.dims,w=this.config.stride;if(S%w!==0)throw new Error(`The number of frames (${S}) must be a multiple of the stride (${w}).`);const F=_.view(1,Math.floor(S/w),D*w),E={input_features:F};if(p){const A=F.dims[1],L=new BigInt64Array(A);if(v){const I=v.data;for(let R=1,N=0;R<S;R+=w,++N)L[N]=I[R]}else L.fill(1n);E.attention_mask=new r.Tensor("int64",L,[1,A])}return E}}},"./src/models/segformer/image_processing_segformer.js":(e,n,t)=>{t.r(n),t.d(n,{SegformerFeatureExtractor:()=>a,SegformerImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{post_process_semantic_segmentation(...u){return(0,i.post_process_semantic_segmentation)(...u)}}class a extends r{}},"./src/models/siglip/image_processing_siglip.js":(e,n,t)=>{t.r(n),t.d(n,{SiglipImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}},"./src/models/smolvlm/image_processing_smolvlm.js":(e,n,t)=>{t.r(n),t.d(n,{SmolVLMImageProcessor:()=>i.Idefics3ImageProcessor});var i=t("./src/models/idefics3/image_processing_idefics3.js")},"./src/models/smolvlm/processing_smolvlm.js":(e,n,t)=>{t.r(n),t.d(n,{SmolVLMProcessor:()=>i.Idefics3Processor});var i=t("./src/models/idefics3/processing_idefics3.js")},"./src/models/snac/feature_extraction_snac.js":(e,n,t)=>{t.r(n),t.d(n,{SnacFeatureExtractor:()=>r});var i=t("./src/models/dac/feature_extraction_dac.js");class r extends i.DacFeatureExtractor{}},"./src/models/speecht5/feature_extraction_speecht5.js":(e,n,t)=>{t.r(n),t.d(n,{SpeechT5FeatureExtractor:()=>r});var i=t("./src/base/feature_extraction_utils.js");class r extends i.FeatureExtractor{}},"./src/models/speecht5/processing_speecht5.js":(e,n,t)=>{t.r(n),t.d(n,{SpeechT5Processor:()=>c});var i=t("./src/base/processing_utils.js"),r=t("./src/tokenizers.js"),a=t("./src/models/auto/feature_extraction_auto.js");class c extends i.Processor{async _call(l){return await this.feature_extractor(l)}}Ce(c,"tokenizer_class",r.AutoTokenizer),Ce(c,"feature_extractor_class",a.AutoFeatureExtractor)},"./src/models/swin2sr/image_processing_swin2sr.js":(e,n,t)=>{t.r(n),t.d(n,{Swin2SRImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{pad_image(c,u,l,f={}){const[m,h,p]=u;return super.pad_image(c,u,{width:h+(l-h%l)%l,height:m+(l-m%l)%l},{mode:"symmetric",center:!1,constant_values:-1,...f})}}},"./src/models/ultravox/processing_ultravox.js":(e,n,t)=>{t.r(n),t.d(n,{UltravoxProcessor:()=>c});var i=t("./src/models/auto/feature_extraction_auto.js"),r=t("./src/tokenizers.js"),a=t("./src/base/processing_utils.js");class c extends a.Processor{async _call(l,f=null,m={}){if(Array.isArray(l))throw new Error("Batched inputs are not supported yet.");let h={};if(f){const _=f.length,{input_features:v}=await this.feature_extractor(f,{...m,max_length:_}),S=Math.round(_/this.config.encoder_ds_factor+1e-4),D=1+Math.ceil(S/this.config.stack_factor);h.audio_token_len=[D],h.audio_values=v;const w=this.config.audio_placeholder;if(!l.includes(w))throw new Error(`The input text does not contain the image token ${w}.`);l=l.replaceAll(w,w.repeat(D))}return{...this.tokenizer(l,{add_special_tokens:!1,...m}),...h}}}Ce(c,"tokenizer_class",r.AutoTokenizer),Ce(c,"feature_extractor_class",i.AutoFeatureExtractor),Ce(c,"uses_processor_config",!0)},"./src/models/vit/image_processing_vit.js":(e,n,t)=>{t.r(n),t.d(n,{ViTFeatureExtractor:()=>a,ViTImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{}class a extends r{}},"./src/models/vitmatte/image_processing_vitmatte.js":(e,n,t)=>{t.r(n),t.d(n,{VitMatteImageProcessor:()=>a});var i=t("./src/base/image_processors_utils.js"),r=t("./src/utils/tensor.js");class a extends i.ImageProcessor{async _call(u,l){Array.isArray(u)||(u=[u]),Array.isArray(l)||(l=[l]);const f=await Promise.all(u.map(p=>this.preprocess(p))),m=await Promise.all(l.map(p=>this.preprocess(p,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,r.stack)(f.map((p,_)=>(0,r.cat)([p.pixel_values,m[_].pixel_values],0)),0),original_sizes:f.map(p=>p.original_size),reshaped_input_sizes:f.map(p=>p.reshaped_input_size)}}}},"./src/models/vitpose/image_processing_vitpose.js":(e,n,t)=>{t.r(n),t.d(n,{VitPoseImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{post_process_pose_estimation(c,u,{threshold:l=null}={}){const f=c.tolist(),[m,h,p,_]=c.dims,v=[];for(let S=0;S<m;++S){const D=f[S],w=u[S],T=[];for(let F=0;F<w.length;++F){const E=w[F],A=[],L=[],I=[],R=E.at(-2)/_,N=E.at(-1)/p;for(let q=0;q<D.length;++q){let[ne,Q]=[0,0],W=0,te=-1/0;const K=D[q];for(let be=0;be<K.length;++be){const Ee=K[be];for(let Ge=0;Ge<Ee.length;++Ge){const _e=Ee[Ge];W+=_e,te=Math.max(te,_e),ne+=(Ge+.5)*_e,Q+=be*_e}}if(l!=null&&te<l)continue;const pe=[R*ne/W,N*Q/W];A.push(pe),I.push(q),L.push(te)}T.push({bbox:E,scores:L,labels:I,keypoints:A})}v.push(T)}return v}}},"./src/models/voxtral/processing_voxtral.js":(e,n,t)=>{t.r(n),t.d(n,{VoxtralProcessor:()=>h});var i=t("./src/models/auto/feature_extraction_auto.js"),r=t("./src/tokenizers.js"),a=t("./src/base/processing_utils.js"),c=t("./src/utils/tensor.js");const u="[AUDIO]",l="[BEGIN_AUDIO]",f=375;function m(p,_){const v=[];for(let S=0;S<p.length;S+=_)v.push(p.subarray(S,Math.min(S+_,p.length)));return v}class h extends a.Processor{async _call(_,v=null,S={}){if(Array.isArray(_))throw new Error("Batched inputs are not supported yet.");const D={};if(v){if(!_.includes(u))throw new Error(`The input text does not contain the audio token ${u}.`);Array.isArray(v)||(v=[v]);const T=_.split(u),F=T.length-1;if(F!==v.length)throw new Error(`The number of audio inputs (${v.length}) does not match the number of audio tokens in the text (${F}).`);const E=this.feature_extractor.config.n_samples,A=v.map(q=>m(q,E)),L=A.map(q=>q.length),I=A.flat(),R=(await Promise.all(I.map(q=>this.feature_extractor(q,S)))).map(q=>q.input_features);D.audio_values=R.length>1?(0,c.cat)(R,0):R[0];let N=T[0];for(let q=0;q<L.length;++q){N+=l;for(let ne=0;ne<L[q];++ne)N+=u.repeat(f);N+=T[q+1]}_=N}return{...this.tokenizer(_,{add_special_tokens:!1,...S}),...D}}}Ce(h,"tokenizer_class",r.AutoTokenizer),Ce(h,"feature_extractor_class",i.AutoFeatureExtractor),Ce(h,"uses_processor_config",!1)},"./src/models/wav2vec2/feature_extraction_wav2vec2.js":(e,n,t)=>{t.r(n),t.d(n,{Wav2Vec2FeatureExtractor:()=>a});var i=t("./src/base/feature_extraction_utils.js"),r=t("./src/utils/tensor.js");class a extends i.FeatureExtractor{_zero_mean_unit_var_norm(u){const f=u.reduce((h,p)=>h+p,0)/u.length,m=u.reduce((h,p)=>h+(p-f)**2,0)/u.length;return u.map(h=>(h-f)/Math.sqrt(m+1e-7))}async _call(u){(0,i.validate_audio_inputs)(u,"Wav2Vec2FeatureExtractor"),u instanceof Float64Array&&(u=new Float32Array(u));let l=u;this.config.do_normalize&&(l=this._zero_mean_unit_var_norm(l));const f=[1,l.length];return{input_values:new r.Tensor("float32",l,f),attention_mask:new r.Tensor("int64",new BigInt64Array(l.length).fill(1n),f)}}}},"./src/models/wav2vec2/processing_wav2vec2.js":(e,n,t)=>{t.r(n),t.d(n,{Wav2Vec2Processor:()=>c});var i=t("./src/tokenizers.js"),r=t("./src/models/auto/feature_extraction_auto.js"),a=t("./src/base/processing_utils.js");class c extends a.Processor{async _call(l){return await this.feature_extractor(l)}}Ce(c,"tokenizer_class",i.AutoTokenizer),Ce(c,"feature_extractor_class",r.AutoFeatureExtractor)},"./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js":(e,n,t)=>{t.r(n),t.d(n,{Wav2Vec2ProcessorWithLM:()=>c});var i=t("./src/tokenizers.js"),r=t("./src/models/auto/feature_extraction_auto.js"),a=t("./src/base/processing_utils.js");class c extends a.Processor{async _call(l){return await this.feature_extractor(l)}}Ce(c,"tokenizer_class",i.AutoTokenizer),Ce(c,"feature_extractor_class",r.AutoFeatureExtractor)},"./src/models/wespeaker/feature_extraction_wespeaker.js":(e,n,t)=>{t.r(n),t.d(n,{WeSpeakerFeatureExtractor:()=>a});var i=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var r=t("./src/utils/audio.js");class a extends i.FeatureExtractor{constructor(u){super(u);const l=this.config.sampling_rate,f=(0,r.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(l/2),l,null,"kaldi",!0);this.mel_filters=f,this.window=(0,r.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(u){return u=u.map(l=>l*32768),(0,r.spectrogram)(u,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(u){(0,i.validate_audio_inputs)(u,"WeSpeakerFeatureExtractor");const l=(await this._extract_fbank_features(u)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const f=l.mean(1).data,m=l.data,[h,p,_]=l.dims;for(let v=0;v<h;++v){const S=v*p*_,D=v*_;for(let w=0;w<p;++w){const T=S+w*_;for(let F=0;F<_;++F)m[T+F]-=f[D+F]}}}return{input_features:l}}}},"./src/models/whisper/common_whisper.js":(e,n,t)=>{t.r(n),t.d(n,{WHISPER_LANGUAGE_MAPPING:()=>r,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>a,whisper_language_to_code:()=>c});const i=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],r=new Map(i),a=new Map([...i.map(([u,l])=>[l,u]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function c(u){u=u.toLowerCase();let l=a.get(u);if(l===void 0){const f=u.match(/^<\|([a-z]{2})\|>$/);if(f&&(u=f[1]),r.has(u))l=u;else{const h=u.length===2?r.keys():r.values();throw new Error(`Language "${u}" is not supported. Must be one of: ${JSON.stringify(Array.from(h))}`)}}return l}},"./src/models/whisper/feature_extraction_whisper.js":(e,n,t)=>{t.r(n),t.d(n,{WhisperFeatureExtractor:()=>c});var i=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var r=t("./src/utils/audio.js"),a=t("./src/utils/maths.js");class c extends i.FeatureExtractor{constructor(l){var f;super(l),(f=this.config).mel_filters??(f.mel_filters=(0,r.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney")),this.window=(0,r.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(l){const f=await(0,r.spectrogram)(l,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:Math.min(Math.floor(l.length/this.config.hop_length),this.config.nb_max_frames)}),m=f.data,h=(0,a.max)(m)[0];for(let p=0;p<m.length;++p)m[p]=(Math.max(m[p],h-8)+4)/4;return f}async _call(l,{max_length:f=null}={}){(0,i.validate_audio_inputs)(l,"WhisperFeatureExtractor");let m;const h=f??this.config.n_samples;return l.length>h?(l.length>this.config.n_samples&&console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),m=l.slice(0,h)):(m=new Float32Array(h),m.set(l)),{input_features:(await this._extract_fbank_features(m)).unsqueeze_(0)}}}},"./src/models/whisper/generation_whisper.js":(e,n,t)=>{t.r(n),t.d(n,{WhisperGenerationConfig:()=>r});var i=t("./src/generation/configuration_utils.js");class r extends i.GenerationConfig{constructor(){super(...arguments);Ce(this,"return_timestamps",null);Ce(this,"return_token_timestamps",null);Ce(this,"num_frames",null);Ce(this,"alignment_heads",null);Ce(this,"task",null);Ce(this,"language",null);Ce(this,"no_timestamps_token_id",null);Ce(this,"prompt_ids",null);Ce(this,"is_multilingual",null);Ce(this,"lang_to_id",null);Ce(this,"task_to_id",null);Ce(this,"max_initial_timestamp_index",1)}}},"./src/models/whisper/processing_whisper.js":(e,n,t)=>{t.r(n),t.d(n,{WhisperProcessor:()=>c});var i=t("./src/models/auto/feature_extraction_auto.js"),r=t("./src/tokenizers.js"),a=t("./src/base/processing_utils.js");class c extends a.Processor{async _call(l){return await this.feature_extractor(l)}}Ce(c,"tokenizer_class",r.AutoTokenizer),Ce(c,"feature_extractor_class",i.AutoFeatureExtractor)},"./src/models/yolos/image_processing_yolos.js":(e,n,t)=>{t.r(n),t.d(n,{YolosFeatureExtractor:()=>a,YolosImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js");class r extends i.ImageProcessor{post_process_object_detection(...u){return(0,i.post_process_object_detection)(...u)}}class a extends r{}},"./src/ops/registry.js":(e,n,t)=>{t.r(n),t.d(n,{TensorOpRegistry:()=>c});var i=t("./src/backends/onnx.js"),r=t("./src/utils/tensor.js");const a=async(u,l,f)=>{const m=await(0,i.createInferenceSession)(new Uint8Array(u),l);return async h=>{const p=(0,i.isONNXProxy)(),_=Object.fromEntries(Object.entries(h).map(([S,D])=>[S,(p?D.clone():D).ort_tensor])),v=await(0,i.runInferenceSession)(m,_);return Array.isArray(f)?f.map(S=>new r.Tensor(v[S])):new r.Tensor(v[f])}};class c{static get nearest_interpolate_4d(){return this._nearest_interpolate_4d||(this._nearest_interpolate_4d=a([8,10,18,0,58,129,1,10,41,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,18,10,4,109,111,100,101,34,7,110,101,97,114,101,115,116,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,21],this.session_options,"y")),this._nearest_interpolate_4d}static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=a([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=a([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=a([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=a([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=a([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=a([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=a([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}Ce(c,"session_options",{})},"./src/pipelines.js":(e,n,t)=>{t.r(n),t.d(n,{AudioClassificationPipeline:()=>Q,AutomaticSpeechRecognitionPipeline:()=>te,BackgroundRemovalPipeline:()=>Ee,DepthEstimationPipeline:()=>we,DocumentQuestionAnsweringPipeline:()=>he,FeatureExtractionPipeline:()=>q,FillMaskPipeline:()=>F,ImageClassificationPipeline:()=>pe,ImageFeatureExtractionPipeline:()=>ne,ImageSegmentationPipeline:()=>be,ImageToImagePipeline:()=>me,ImageToTextPipeline:()=>K,ObjectDetectionPipeline:()=>_e,Pipeline:()=>S,QuestionAnsweringPipeline:()=>T,SummarizationPipeline:()=>A,Text2TextGenerationPipeline:()=>E,TextClassificationPipeline:()=>D,TextGenerationPipeline:()=>R,TextToAudioPipeline:()=>Z,TokenClassificationPipeline:()=>w,TranslationPipeline:()=>L,ZeroShotAudioClassificationPipeline:()=>W,ZeroShotClassificationPipeline:()=>N,ZeroShotImageClassificationPipeline:()=>Ge,ZeroShotObjectDetectionPipeline:()=>De,pipeline:()=>Ve});var i=t("./src/tokenizers.js"),r=t("./src/models.js"),a=t("./src/models/auto/processing_auto.js");t("./src/base/processing_utils.js");var c=t("./src/utils/generic.js"),u=t("./src/utils/core.js"),l=t("./src/utils/maths.js"),f=t("./src/utils/audio.js"),m=t("./src/utils/tensor.js"),h=t("./src/utils/image.js");async function p(Be){return Array.isArray(Be)||(Be=[Be]),await Promise.all(Be.map(ae=>h.RawImage.read(ae)))}async function _(Be,ae){return Array.isArray(Be)||(Be=[Be]),await Promise.all(Be.map(U=>typeof U=="string"||U instanceof URL?(0,f.read_audio)(U,ae):U instanceof Float64Array?new Float32Array(U):U))}function v(Be,ae){ae&&(Be=Be.map(Ye=>Ye|0));const[U,Se,ze,Oe]=Be;return{xmin:U,ymin:Se,xmax:ze,ymax:Oe}}class S extends c.Callable{constructor({task:ae,model:U,tokenizer:Se=null,processor:ze=null}){super(),this.task=ae,this.model=U,this.tokenizer=Se,this.processor=ze}async dispose(){await this.model.dispose()}}class D extends S{constructor(ae){super(ae)}async _call(ae,{top_k:U=1}={}){const Se=this.tokenizer(ae,{padding:!0,truncation:!0}),ze=await this.model(Se),Oe=this.model.config.problem_type==="multi_label_classification"?Y=>Y.sigmoid():Y=>new m.Tensor("float32",(0,l.softmax)(Y.data),Y.dims),Ye=this.model.config.id2label,H=[];for(const Y of ze.logits){const $e=Oe(Y),Ie=await(0,m.topk)($e,U),fe=Ie[0].tolist(),Ne=Ie[1].tolist().map((ut,de)=>({label:Ye?Ye[ut]:`LABEL_${ut}`,score:fe[de]}));U===1?H.push(...Ne):H.push(Ne)}return Array.isArray(ae)||U===1?H:H[0]}}class w extends S{constructor(ae){super(ae)}async _call(ae,{ignore_labels:U=["O"]}={}){const Se=Array.isArray(ae),ze=this.tokenizer(Se?ae:[ae],{padding:!0,truncation:!0}),Ye=(await this.model(ze)).logits,H=this.model.config.id2label,Y=[];for(let $e=0;$e<Ye.dims[0];++$e){const Ie=ze.input_ids[$e],fe=Ye[$e],Qe=[];for(let Ne=0;Ne<fe.dims[0];++Ne){const ut=fe[Ne],de=(0,l.max)(ut.data)[1],qe=H?H[de]:`LABEL_${de}`;if(U.includes(qe))continue;const tt=this.tokenizer.decode([Ie[Ne].item()],{skip_special_tokens:!0});if(tt==="")continue;const He=(0,l.softmax)(ut.data);Qe.push({entity:qe,score:He[de],index:Ne,word:tt})}Y.push(Qe)}return Se?Y:Y[0]}}class T extends S{constructor(ae){super(ae)}async _call(ae,U,{top_k:Se=1}={}){const ze=this.tokenizer(ae,{text_pair:U,padding:!0,truncation:!0}),{start_logits:Oe,end_logits:Ye}=await this.model(ze),H=ze.input_ids.tolist(),Y=ze.attention_mask.tolist(),$e=this.tokenizer.all_special_ids,Ie=[];for(let fe=0;fe<Oe.dims[0];++fe){const Qe=H[fe],Ne=Qe.findIndex(je=>je==this.tokenizer.sep_token_id);Y[fe].map((je,lt)=>je==1&&(lt===0||lt>Ne&&$e.findIndex(Mt=>Mt==Qe[lt])===-1));const ut=Oe[fe].tolist(),de=Ye[fe].tolist();for(let je=1;je<ut.length;++je)(Y[fe]==0||je<=Ne||$e.findIndex(lt=>lt==Qe[je])!==-1)&&(ut[je]=-1/0,de[je]=-1/0);const qe=(0,l.softmax)(ut).map((je,lt)=>[je,lt]),tt=(0,l.softmax)(de).map((je,lt)=>[je,lt]);qe[0][0]=0,tt[0][0]=0;const He=(0,u.product)(qe,tt).filter(je=>je[0][1]<=je[1][1]).map(je=>[je[0][1],je[1][1],je[0][0]*je[1][0]]).sort((je,lt)=>lt[2]-je[2]);for(let je=0;je<Math.min(He.length,Se);++je){const[lt,Mt,Rt]=He[je],Xt=Qe.slice(lt,Mt+1),wn=this.tokenizer.decode(Xt,{skip_special_tokens:!0});Ie.push({answer:wn,score:Rt})}}return Se===1?Ie[0]:Ie}}class F extends S{constructor(ae){super(ae)}async _call(ae,{top_k:U=5}={}){const Se=this.tokenizer(ae,{padding:!0,truncation:!0}),{logits:ze}=await this.model(Se),Oe=[],Ye=Se.input_ids.tolist();for(let H=0;H<Ye.length;++H){const Y=Ye[H],$e=Y.findIndex(ut=>ut==this.tokenizer.mask_token_id);if($e===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const Ie=ze[H][$e],fe=await(0,m.topk)(new m.Tensor("float32",(0,l.softmax)(Ie.data),Ie.dims),U),Qe=fe[0].tolist(),Ne=fe[1].tolist();Oe.push(Ne.map((ut,de)=>{const qe=Y.slice();return qe[$e]=ut,{score:Qe[de],token:Number(ut),token_str:this.tokenizer.decode([ut]),sequence:this.tokenizer.decode(qe,{skip_special_tokens:!0})}}))}return Array.isArray(ae)?Oe:Oe[0]}}class E extends S{constructor(U){super(U);Ce(this,"_key","generated_text")}async _call(U,Se={}){Array.isArray(U)||(U=[U]),this.model.config.prefix&&(U=U.map($e=>this.model.config.prefix+$e));const ze=this.model.config.task_specific_params;ze&&ze[this.task]&&ze[this.task].prefix&&(U=U.map($e=>ze[this.task].prefix+$e));const Oe=this.tokenizer,Ye={padding:!0,truncation:!0};let H;this instanceof L&&"_build_translation_inputs"in Oe?H=Oe._build_translation_inputs(U,Ye,Se):H=Oe(U,Ye);const Y=await this.model.generate({...H,...Se});return Oe.batch_decode(Y,{skip_special_tokens:!0}).map($e=>({[this._key]:$e}))}}class A extends E{constructor(U){super(U);Ce(this,"_key","summary_text")}}class L extends E{constructor(U){super(U);Ce(this,"_key","translation_text")}}function I(Be){return Array.isArray(Be)&&Be.every(ae=>"role"in ae&&"content"in ae)}class R extends S{constructor(ae){super(ae)}async _call(ae,U={}){let Se=!1,ze=!1,Oe=U.add_special_tokens??(this.tokenizer.add_bos_token||this.tokenizer.add_eos_token)??!1,Ye;if(typeof ae=="string")Ye=ae=[ae];else if(Array.isArray(ae)&&ae.every(Ne=>typeof Ne=="string"))Se=!0,Ye=ae;else{if(I(ae))ae=[ae];else if(Array.isArray(ae)&&ae.every(I))Se=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");ze=!0,Ye=ae.map(Ne=>this.tokenizer.apply_chat_template(Ne,{tokenize:!1,add_generation_prompt:!0})),Oe=!1}const H=ze?!1:U.return_full_text??!0;this.tokenizer.padding_side="left";const Y=this.tokenizer(Ye,{add_special_tokens:Oe,padding:!0,truncation:!0}),$e=await this.model.generate({...Y,...U}),Ie=this.tokenizer.batch_decode($e,{skip_special_tokens:!0});let fe;!H&&Y.input_ids.dims.at(-1)>0&&(fe=this.tokenizer.batch_decode(Y.input_ids,{skip_special_tokens:!0}).map(Ne=>Ne.length));const Qe=Array.from({length:ae.length},Ne=>[]);for(let Ne=0;Ne<Ie.length;++Ne){const ut=Math.floor(Ne/$e.dims[0]*ae.length);fe&&(Ie[Ne]=Ie[Ne].slice(fe[ut])),Qe[ut].push({generated_text:ze?[...ae[ut],{role:"assistant",content:Ie[Ne]}]:Ie[Ne]})}return!Se&&Qe.length===1?Qe[0]:Qe}}class N extends S{constructor(ae){super(ae),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([U,Se])=>[U.toLowerCase(),Se])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(ae,U,{hypothesis_template:Se="This example is {}.",multi_label:ze=!1}={}){const Oe=Array.isArray(ae);Oe||(ae=[ae]),Array.isArray(U)||(U=[U]);const Ye=U.map($e=>Se.replace("{}",$e)),H=ze||U.length===1,Y=[];for(const $e of ae){const Ie=[];for(const Ne of Ye){const ut=this.tokenizer($e,{text_pair:Ne,padding:!0,truncation:!0}),de=await this.model(ut);H?Ie.push([de.logits.data[this.contradiction_id],de.logits.data[this.entailment_id]]):Ie.push(de.logits.data[this.entailment_id])}const Qe=(H?Ie.map(Ne=>(0,l.softmax)(Ne)[1]):(0,l.softmax)(Ie)).map((Ne,ut)=>[Ne,ut]).sort((Ne,ut)=>ut[0]-Ne[0]);Y.push({sequence:$e,labels:Qe.map(Ne=>U[Ne[1]]),scores:Qe.map(Ne=>Ne[0])})}return Oe?Y:Y[0]}}class q extends S{constructor(ae){super(ae)}async _call(ae,{pooling:U="none",normalize:Se=!1,quantize:ze=!1,precision:Oe="binary"}={}){const Ye=this.tokenizer(ae,{padding:!0,truncation:!0}),H=await this.model(Ye);let Y=H.last_hidden_state??H.logits??H.token_embeddings;switch(U){case"none":break;case"mean":Y=(0,m.mean_pooling)(Y,Ye.attention_mask);break;case"first_token":case"cls":Y=Y.slice(null,0);break;case"last_token":case"eos":Y=Y.slice(null,-1);break;default:throw Error(`Pooling method '${U}' not supported.`)}return Se&&(Y=Y.normalize(2,-1)),ze&&(Y=(0,m.quantize_embeddings)(Y,Oe)),Y}}class ne extends S{constructor(ae){super(ae)}async _call(ae,{pool:U=null}={}){const Se=await p(ae),{pixel_values:ze}=await this.processor(Se),Oe=await this.model({pixel_values:ze});let Ye;if(U){if(!("pooler_output"in Oe))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");Ye=Oe.pooler_output}else Ye=Oe.last_hidden_state??Oe.logits??Oe.image_embeds;return Ye}}class Q extends S{constructor(ae){super(ae)}async _call(ae,{top_k:U=5}={}){const Se=this.processor.feature_extractor.config.sampling_rate,ze=await _(ae,Se),Oe=this.model.config.id2label,Ye=[];for(const H of ze){const Y=await this.processor(H),Ie=(await this.model(Y)).logits[0],fe=await(0,m.topk)(new m.Tensor("float32",(0,l.softmax)(Ie.data),Ie.dims),U),Qe=fe[0].tolist(),ut=fe[1].tolist().map((de,qe)=>({label:Oe?Oe[de]:`LABEL_${de}`,score:Qe[qe]}));Ye.push(ut)}return Array.isArray(ae)?Ye:Ye[0]}}class W extends S{constructor(ae){super(ae)}async _call(ae,U,{hypothesis_template:Se="This is a sound of {}."}={}){const ze=!Array.isArray(ae);ze&&(ae=[ae]);const Oe=U.map(Ie=>Se.replace("{}",Ie)),Ye=this.tokenizer(Oe,{padding:!0,truncation:!0}),H=this.processor.feature_extractor.config.sampling_rate,Y=await _(ae,H),$e=[];for(const Ie of Y){const fe=await this.processor(Ie),Qe=await this.model({...Ye,...fe}),Ne=(0,l.softmax)(Qe.logits_per_audio.data);$e.push([...Ne].map((ut,de)=>({score:ut,label:U[de]})))}return ze?$e[0]:$e}}class te extends S{constructor(ae){super(ae)}async _call(ae,U={}){switch(this.model.config.model_type){case"whisper":case"lite-whisper":return this._call_whisper(ae,U);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":case"parakeet_ctc":return this._call_wav2vec2(ae,U);case"moonshine":return this._call_moonshine(ae,U);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(ae,U){U.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),U.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const Se=!Array.isArray(ae);Se&&(ae=[ae]);const ze=this.processor.feature_extractor.config.sampling_rate,Oe=await _(ae,ze),Ye=[];for(const H of Oe){const Y=await this.processor(H),Ie=(await this.model(Y)).logits[0],fe=[];for(const Ne of Ie)fe.push((0,l.max)(Ne.data)[1]);const Qe=this.tokenizer.decode(fe,{skip_special_tokens:!0}).trim();Ye.push({text:Qe})}return Se?Ye[0]:Ye}async _call_whisper(ae,U){const Se=U.return_timestamps??!1,ze=U.chunk_length_s??0,Oe=U.force_full_sequences??!1;let Ye=U.stride_length_s??null;const H={...U};Se==="word"&&(H.return_token_timestamps=!0,H.return_timestamps=!1);const Y=!Array.isArray(ae);Y&&(ae=[ae]);const $e=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,Ie=this.processor.feature_extractor.config.hop_length,fe=this.processor.feature_extractor.config.sampling_rate,Qe=await _(ae,fe),Ne=[];for(const ut of Qe){let de=[];if(ze>0){if(Ye===null)Ye=ze/6;else if(ze<=Ye)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const He=fe*ze,je=fe*Ye,lt=He-2*je;let Mt=0;for(;;){const Rt=Mt+He,Xt=ut.subarray(Mt,Rt),wn=await this.processor(Xt),xn=Mt===0,cn=Rt>=ut.length;if(de.push({stride:[Xt.length,xn?0:je,cn?0:je],input_features:wn.input_features,is_last:cn}),cn)break;Mt+=lt}}else de=[{stride:[ut.length,0,0],input_features:(await this.processor(ut)).input_features,is_last:!0}];for(const He of de){H.num_frames=Math.floor(He.stride[0]/Ie);const je=await this.model.generate({inputs:He.input_features,...H});Se==="word"?(He.tokens=je.sequences.tolist()[0],He.token_timestamps=je.token_timestamps.tolist()[0].map(lt=>(0,l.round)(lt,2))):He.tokens=je[0].tolist(),He.stride=He.stride.map(lt=>lt/fe)}const[qe,tt]=this.tokenizer._decode_asr(de,{time_precision:$e,return_timestamps:Se,force_full_sequences:Oe});Ne.push({text:qe,...tt})}return Y?Ne[0]:Ne}async _call_moonshine(ae,U){const Se=!Array.isArray(ae);Se&&(ae=[ae]);const ze=this.processor.feature_extractor.config.sampling_rate,Oe=await _(ae,ze),Ye=[];for(const H of Oe){const Y=await this.processor(H),$e=Math.floor(H.length/ze)*6,Ie=await this.model.generate({max_new_tokens:$e,...U,...Y}),fe=this.processor.batch_decode(Ie,{skip_special_tokens:!0})[0];Ye.push({text:fe})}return Se?Ye[0]:Ye}}class K extends S{constructor(ae){super(ae)}async _call(ae,U={}){const Se=Array.isArray(ae),ze=await p(ae),{pixel_values:Oe}=await this.processor(ze),Ye=[];for(const H of Oe){H.dims=[1,...H.dims];const Y=await this.model.generate({inputs:H,...U}),$e=this.tokenizer.batch_decode(Y,{skip_special_tokens:!0}).map(Ie=>({generated_text:Ie.trim()}));Ye.push($e)}return Se?Ye:Ye[0]}}class pe extends S{constructor(ae){super(ae)}async _call(ae,{top_k:U=5}={}){const Se=await p(ae),{pixel_values:ze}=await this.processor(Se),Oe=await this.model({pixel_values:ze}),Ye=this.model.config.id2label,H=[];for(const Y of Oe.logits){const $e=await(0,m.topk)(new m.Tensor("float32",(0,l.softmax)(Y.data),Y.dims),U),Ie=$e[0].tolist(),Qe=$e[1].tolist().map((Ne,ut)=>({label:Ye?Ye[Ne]:`LABEL_${Ne}`,score:Ie[ut]}));H.push(Qe)}return Array.isArray(ae)?H:H[0]}}class be extends S{constructor(ae){super(ae),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(ae,{threshold:U=.5,mask_threshold:Se=.5,overlap_mask_area_threshold:ze=.8,label_ids_to_fuse:Oe=null,target_sizes:Ye=null,subtask:H=null}={}){if(Array.isArray(ae)&&ae.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const $e=await p(ae),Ie=$e.map(He=>[He.height,He.width]),fe=await this.processor($e),{inputNames:Qe,outputNames:Ne}=this.model.sessions.model;if(!Qe.includes("pixel_values")){if(Qe.length!==1)throw Error(`Expected a single input name, but got ${Qe.length} inputs: ${Qe}.`);const He=Qe[0];if(He in fe)throw Error(`Input name ${He} already exists in the inputs.`);fe[He]=fe.pixel_values}const ut=await this.model(fe);let de=null;if(H!==null)de=this.subtasks_mapping[H];else if(this.processor.image_processor){for(const[He,je]of Object.entries(this.subtasks_mapping))if(je in this.processor.image_processor){de=this.processor.image_processor[je].bind(this.processor.image_processor),H=He;break}}const qe=this.model.config.id2label,tt=[];if(H)if(H==="panoptic"||H==="instance"){const He=de(ut,U,Se,ze,Oe,Ye??Ie)[0],je=He.segmentation;for(const lt of He.segments_info){const Mt=new Uint8ClampedArray(je.data.length);for(let Xt=0;Xt<je.data.length;++Xt)je.data[Xt]===lt.id&&(Mt[Xt]=255);const Rt=new h.RawImage(Mt,je.dims[1],je.dims[0],1);tt.push({score:lt.score,label:qe[lt.label_id],mask:Rt})}}else if(H==="semantic"){const{segmentation:He,labels:je}=de(ut,Ye??Ie)[0];for(const lt of je){const Mt=new Uint8ClampedArray(He.data.length);for(let Xt=0;Xt<He.data.length;++Xt)He.data[Xt]===lt&&(Mt[Xt]=255);const Rt=new h.RawImage(Mt,He.dims[1],He.dims[0],1);tt.push({score:null,label:qe[lt],mask:Rt})}}else throw Error(`Subtask ${H} not supported.`);else{const je=ut[Ne[0]];for(let lt=0;lt<Ie.length;++lt){const Mt=Ie[lt],Rt=je[lt];Rt.data.some(wn=>wn<-1e-5||wn>1+1e-5)&&Rt.sigmoid_();const Xt=await h.RawImage.fromTensor(Rt.mul_(255).to("uint8")).resize(Mt[1],Mt[0]);tt.push({label:null,score:null,mask:Xt})}}return tt}}class Ee extends be{constructor(ae){super(ae)}async _call(ae,U={}){if(Array.isArray(ae)&&ae.length!==1)throw Error("Background removal pipeline currently only supports a batch size of 1.");const ze=await p(ae),Oe=await super._call(ae,U);return ze.map((H,Y)=>{const $e=H.clone();return $e.putAlpha(Oe[Y].mask),$e})}}class Ge extends S{constructor(ae){super(ae)}async _call(ae,U,{hypothesis_template:Se="This is a photo of {}"}={}){const ze=Array.isArray(ae),Oe=await p(ae),Ye=U.map(Qe=>Se.replace("{}",Qe)),H=this.tokenizer(Ye,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:Y}=await this.processor(Oe),$e=await this.model({...H,pixel_values:Y}),Ie=this.model.config.model_type==="siglip"?Qe=>Qe.sigmoid().data:Qe=>(0,l.softmax)(Qe.data),fe=[];for(const Qe of $e.logits_per_image){const ut=[...Ie(Qe)].map((de,qe)=>({score:de,label:U[qe]}));ut.sort((de,qe)=>qe.score-de.score),fe.push(ut)}return ze?fe:fe[0]}}class _e extends S{constructor(ae){super(ae)}async _call(ae,{threshold:U=.9,percentage:Se=!1}={}){const ze=Array.isArray(ae);if(ze&&ae.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const Oe=await p(ae),Ye=Se?null:Oe.map(Ne=>[Ne.height,Ne.width]),{pixel_values:H,pixel_mask:Y}=await this.processor(Oe),$e=await this.model({pixel_values:H,pixel_mask:Y}),Ie=this.processor.image_processor.post_process_object_detection($e,U,Ye),fe=this.model.config.id2label,Qe=Ie.map(Ne=>Ne.boxes.map((ut,de)=>({score:Ne.scores[de],label:fe[Ne.classes[de]],box:v(ut,!Se)})));return ze?Qe:Qe[0]}}class De extends S{constructor(ae){super(ae)}async _call(ae,U,{threshold:Se=.1,top_k:ze=null,percentage:Oe=!1}={}){const Ye=Array.isArray(ae),H=await p(ae),Y=this.tokenizer(U,{padding:!0,truncation:!0}),$e=await this.processor(H),Ie=[];for(let fe=0;fe<H.length;++fe){const Qe=H[fe],Ne=Oe?null:[[Qe.height,Qe.width]],ut=$e.pixel_values[fe].unsqueeze_(0),de=await this.model({...Y,pixel_values:ut});let qe;if("post_process_grounded_object_detection"in this.processor){const tt=this.processor.post_process_grounded_object_detection(de,Y.input_ids,{box_threshold:Se,text_threshold:Se,target_sizes:Ne})[0];qe=tt.boxes.map((He,je)=>({score:tt.scores[je],label:tt.labels[je],box:v(He,!Oe)}))}else{const tt=this.processor.image_processor.post_process_object_detection(de,Se,Ne,!0)[0];qe=tt.boxes.map((He,je)=>({score:tt.scores[je],label:U[tt.classes[je]],box:v(He,!Oe)}))}qe.sort((tt,He)=>He.score-tt.score),ze!==null&&(qe=qe.slice(0,ze)),Ie.push(qe)}return Ye?Ie:Ie[0]}}class he extends S{constructor(ae){super(ae)}async _call(ae,U,Se={}){const ze=(await p(ae))[0],{pixel_values:Oe}=await this.processor(ze),Ye=`<s_docvqa><s_question>${U}</s_question><s_answer>`,H=this.tokenizer(Ye,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,Y=await this.model.generate({inputs:Oe,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:H,...Se}),Ie=this.tokenizer.batch_decode(Y)[0].match(/<s_answer>(.*?)<\/s_answer>/);let fe=null;return Ie&&Ie.length>=2&&(fe=Ie[1].trim()),[{answer:fe}]}}class Z extends S{constructor(U){super(U);Ce(this,"DEFAULT_VOCODER_ID","Xenova/speecht5_hifigan");this.vocoder=U.vocoder??null}async _prepare_speaker_embeddings(U){if((typeof U=="string"||U instanceof URL)&&(U=new Float32Array(await(await fetch(U)).arrayBuffer())),U instanceof Float32Array)U=new m.Tensor("float32",U,[U.length]);else if(!(U instanceof m.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");return U}async _call(U,{speaker_embeddings:Se=null,num_inference_steps:ze,speed:Oe}={}){return this.processor?this._call_text_to_spectrogram(U,{speaker_embeddings:Se}):this.model.config.model_type==="supertonic"?this._call_supertonic(U,{speaker_embeddings:Se,num_inference_steps:ze,speed:Oe}):this._call_text_to_waveform(U)}async _call_supertonic(U,{speaker_embeddings:Se,num_inference_steps:ze,speed:Oe}){if(!Se)throw new Error("Speaker embeddings must be provided for Supertonic models.");Se=await this._prepare_speaker_embeddings(Se);const{sampling_rate:Ye,style_dim:H}=this.model.config;Se=Se.view(1,-1,H);const Y=this.tokenizer(U,{padding:!0,truncation:!0}),{waveform:$e}=await this.model.generate_speech({...Y,style:Se,num_inference_steps:ze,speed:Oe});return new f.RawAudio($e.data,Ye)}async _call_text_to_waveform(U){const Se=this.tokenizer(U,{padding:!0,truncation:!0}),{waveform:ze}=await this.model(Se),Oe=this.model.config.sampling_rate;return new f.RawAudio(ze.data,Oe)}async _call_text_to_spectrogram(U,{speaker_embeddings:Se}){this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await r.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"}));const{input_ids:ze}=this.tokenizer(U,{padding:!0,truncation:!0});Se=await this._prepare_speaker_embeddings(Se),Se=Se.view(1,-1);const{waveform:Oe}=await this.model.generate_speech(ze,Se,{vocoder:this.vocoder}),Ye=this.processor.feature_extractor.config.sampling_rate;return new f.RawAudio(Oe.data,Ye)}}class me extends S{constructor(ae){super(ae)}async _call(ae){const U=await p(ae),Se=await this.processor(U),ze=await this.model(Se),Oe=[];for(const Ye of ze.reconstruction){const H=Ye.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");Oe.push(h.RawImage.fromTensor(H))}return Oe.length>1?Oe:Oe[0]}}class we extends S{constructor(ae){super(ae)}async _call(ae){const U=await p(ae),Se=await this.processor(U),{predicted_depth:ze}=await this.model(Se),Oe=[];for(let Ye=0;Ye<U.length;++Ye){const H=ze[Ye],[Y,$e]=H.dims.slice(-2),[Ie,fe]=U[Ye].size,Qe=(await(0,m.interpolate_4d)(H.view(1,1,Y,$e),{size:[fe,Ie],mode:"bilinear"})).view(fe,Ie),Ne=Qe.min().item(),ut=Qe.max().item(),de=Qe.sub(Ne).div_(ut-Ne).mul_(255).to("uint8").unsqueeze(0),qe=h.RawImage.fromTensor(de);Oe.push({predicted_depth:Qe,depth:qe})}return Oe.length>1?Oe:Oe[0]}}const xe=Object.freeze({"text-classification":{tokenizer:i.AutoTokenizer,pipeline:D,model:r.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:i.AutoTokenizer,pipeline:w,model:r.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:i.AutoTokenizer,pipeline:T,model:r.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:i.AutoTokenizer,pipeline:F,model:r.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:i.AutoTokenizer,pipeline:A,model:r.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:i.AutoTokenizer,pipeline:L,model:r.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:i.AutoTokenizer,pipeline:E,model:r.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:i.AutoTokenizer,pipeline:R,model:r.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:i.AutoTokenizer,pipeline:N,model:r.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:Q,model:r.AutoModelForAudioClassification,processor:a.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:i.AutoTokenizer,pipeline:W,model:r.AutoModel,processor:a.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:i.AutoTokenizer,pipeline:te,model:[r.AutoModelForSpeechSeq2Seq,r.AutoModelForCTC],processor:a.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:i.AutoTokenizer,pipeline:Z,model:[r.AutoModelForTextToWaveform,r.AutoModelForTextToSpectrogram],processor:[a.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:i.AutoTokenizer,pipeline:K,model:r.AutoModelForVision2Seq,processor:a.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:pe,model:r.AutoModelForImageClassification,processor:a.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:be,model:[r.AutoModelForImageSegmentation,r.AutoModelForSemanticSegmentation,r.AutoModelForUniversalSegmentation],processor:a.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"background-removal":{pipeline:Ee,model:[r.AutoModelForImageSegmentation,r.AutoModelForSemanticSegmentation,r.AutoModelForUniversalSegmentation],processor:a.AutoProcessor,default:{model:"Xenova/modnet"},type:"image"},"zero-shot-image-classification":{tokenizer:i.AutoTokenizer,pipeline:Ge,model:r.AutoModel,processor:a.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:_e,model:r.AutoModelForObjectDetection,processor:a.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:i.AutoTokenizer,pipeline:De,model:r.AutoModelForZeroShotObjectDetection,processor:a.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:i.AutoTokenizer,pipeline:he,model:r.AutoModelForDocumentQuestionAnswering,processor:a.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:me,model:r.AutoModelForImageToImage,processor:a.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:we,model:r.AutoModelForDepthEstimation,processor:a.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:i.AutoTokenizer,pipeline:q,model:r.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:a.AutoProcessor,pipeline:ne,model:[r.AutoModelForImageFeatureExtraction,r.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),et=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function Ve(Be,ae=null,{progress_callback:U=null,config:Se=null,cache_dir:ze=null,local_files_only:Oe=!1,revision:Ye="main",device:H=null,dtype:Y=null,subfolder:$e="onnx",use_external_data_format:Ie=null,model_file_name:fe=null,session_options:Qe={}}={}){Be=et[Be]??Be;const Ne=xe[Be.split("_",1)[0]];if(!Ne)throw Error(`Unsupported pipeline: ${Be}. Must be one of [${Object.keys(xe)}]`);ae||(ae=Ne.default.model,console.log(`No model specified. Using default model: "${ae}".`));const ut={progress_callback:U,config:Se,cache_dir:ze,local_files_only:Oe,revision:Ye,device:H,dtype:Y,subfolder:$e,use_external_data_format:Ie,model_file_name:fe,session_options:Qe},de=new Map([["tokenizer",Ne.tokenizer],["model",Ne.model],["processor",Ne.processor]]),qe=await nt(de,ae,ut);qe.task=Be,(0,u.dispatchCallback)(U,{status:"ready",task:Be,model:ae});const tt=Ne.pipeline;return new tt(qe)}async function nt(Be,ae,U){const Se=Object.create(null),ze=[];for(const[Oe,Ye]of Be.entries()){if(!Ye)continue;let H;Array.isArray(Ye)?H=new Promise(async(Y,$e)=>{var fe,Qe;let Ie;for(const Ne of Ye){if(Ne===null){Y(null);return}try{Y(await Ne.from_pretrained(ae,U));return}catch(ut){if((fe=ut.message)!=null&&fe.includes("Unsupported model type"))Ie=ut;else if((Qe=ut.message)!=null&&Qe.includes("Could not locate file"))Ie=ut;else{$e(ut);return}}}$e(Ie)}):H=Ye.from_pretrained(ae,U),Se[Oe]=H,ze.push(H)}await Promise.all(ze);for(const[Oe,Ye]of Object.entries(Se))Se[Oe]=await Ye;return Se}},"./src/tokenizers.js":(e,n,t)=>{t.r(n),t.d(n,{AlbertTokenizer:()=>at,AutoTokenizer:()=>ro,BartTokenizer:()=>Tt,BertTokenizer:()=>Me,BlenderbotSmallTokenizer:()=>ct,BlenderbotTokenizer:()=>bt,BloomTokenizer:()=>Vt,CLIPTokenizer:()=>Ns,CamembertTokenizer:()=>ge,CodeGenTokenizer:()=>$s,CodeLlamaTokenizer:()=>bi,CohereTokenizer:()=>it,ConvBertTokenizer:()=>le,DebertaTokenizer:()=>_t,DebertaV2Tokenizer:()=>an,DistilBertTokenizer:()=>se,ElectraTokenizer:()=>Ke,EsmTokenizer:()=>Mi,FalconTokenizer:()=>gi,GPT2Tokenizer:()=>Pt,GPTNeoXTokenizer:()=>ki,GemmaTokenizer:()=>Ts,Grok1Tokenizer:()=>zs,HerbertTokenizer:()=>B,LlamaTokenizer:()=>Tn,M2M100Tokenizer:()=>ji,MBart50Tokenizer:()=>Dt,MBartTokenizer:()=>en,MPNetTokenizer:()=>Bi,MarianTokenizer:()=>rs,MgpstrTokenizer:()=>Es,MobileBertTokenizer:()=>rt,NllbTokenizer:()=>Wt,NougatTokenizer:()=>yn,PreTrainedTokenizer:()=>qt,Qwen2Tokenizer:()=>Ms,RoFormerTokenizer:()=>J,RobertaTokenizer:()=>tn,SiglipTokenizer:()=>Us,SpeechT5Tokenizer:()=>Lt,SqueezeBertTokenizer:()=>mt,T5Tokenizer:()=>pt,TokenizerModel:()=>ne,VitsTokenizer:()=>Wi,Wav2Vec2CTCTokenizer:()=>_i,WhisperTokenizer:()=>or,XLMRobertaTokenizer:()=>ui,XLMTokenizer:()=>Fe,is_chinese_char:()=>F});var i=t("./src/utils/generic.js"),r=t("./src/utils/core.js"),a=t("./src/utils/hub.js"),c=t("./src/utils/maths.js"),u=t("./src/utils/tensor.js"),l=t("./src/utils/data-structures.js"),f=t("./node_modules/@huggingface/jinja/dist/index.js"),m=t("./src/models/whisper/common_whisper.js");async function h(Xe,j){const ie=await Promise.all([(0,a.getModelJSON)(Xe,"tokenizer.json",!0,j),(0,a.getModelJSON)(Xe,"tokenizer_config.json",!0,j)]);return j.legacy!==null&&(ie[1].legacy=j.legacy),ie}function p(Xe,j){const ie=[];let Ae=0;for(const Re of Xe.matchAll(j)){const We=Re[0];Ae<Re.index&&ie.push(Xe.slice(Ae,Re.index)),We.length>0&&ie.push(We),Ae=Re.index+We.length}return Ae<Xe.length&&ie.push(Xe.slice(Ae)),ie}function _(Xe,j=!0){if(Xe.Regex!==void 0){let ie=Xe.Regex.replace(/\\([#&~])/g,"$1");for(const[Ae,Re]of N)ie=ie.replaceAll(Ae,Re);return new RegExp(ie,"gu")}else if(Xe.String!==void 0){const ie=(0,r.escapeRegExp)(Xe.String);return new RegExp(j?ie:`(${ie})`,"gu")}else return console.warn("Unknown pattern type:",Xe),null}function v(Xe){return new Map(Object.entries(Xe))}function S(Xe){const j=Xe.dims;switch(j.length){case 1:return Xe.tolist();case 2:if(j[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return Xe.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${j.length}.`)}}function D(Xe){return Xe.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function w(Xe){return Xe.replace(/\p{M}/gu,"")}function T(Xe){return w(Xe.toLowerCase())}function F(Xe){return Xe>=19968&&Xe<=40959||Xe>=13312&&Xe<=19903||Xe>=131072&&Xe<=173791||Xe>=173824&&Xe<=177983||Xe>=177984&&Xe<=178207||Xe>=178208&&Xe<=183983||Xe>=63744&&Xe<=64255||Xe>=194560&&Xe<=195103}function E(Xe,j,ie){const Ae=[];let Re=0;for(;Re<Xe.length;){if(Ae.push(Xe[Re]),(j.get(Xe[Re])??ie)!==ie){++Re;continue}for(;++Re<Xe.length&&(j.get(Xe[Re])??ie)===ie;)j.get(Ae.at(-1))!==ie&&(Ae[Ae.length-1]+=Xe[Re])}return Ae}function A(Xe){return Xe.match(/\S+/g)||[]}const L="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",I=new RegExp(`^[${L}]+$`,"gu"),R=".,!?",N=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],["(?i:[sdmt]|ll|ve|re)","(?:[sS]|[dD]|[mM]|[tT]|[lL][lL]|[vV][eE]|[rR][eE])"],["[^\\r\\n\\p{L}\\p{N}]?+","[^\\r\\n\\p{L}\\p{N}]?"],["[^\\s\\p{L}\\p{N}]++","[^\\s\\p{L}\\p{N}]+"],[` ?[^(\\s|[${R}])]+`,` ?[^\\s${R}]+`]]);class q{constructor(j){this.content=j.content,this.id=j.id,this.single_word=j.single_word??!1,this.lstrip=j.lstrip??!1,this.rstrip=j.rstrip??!1,this.special=j.special??!1,this.normalized=j.normalized??null}}class ne extends i.Callable{constructor(j){super(),this.config=j,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(j,...ie){switch(j.type){case"WordPiece":return new Q(j);case"Unigram":return new W(j,...ie);case"BPE":return new pe(j);default:if(j.vocab)return Array.isArray(j.vocab)?new W(j,...ie):Object.hasOwn(j,"continuing_subword_prefix")&&Object.hasOwn(j,"unk_token")?Object.hasOwn(j,"merges")?new pe(j):new Q(j):new be(j,...ie);throw new Error(`Unknown TokenizerModel type: ${j.type}`)}}_call(j){return j=this.encode(j),this.fuse_unk&&(j=E(j,this.tokens_to_ids,this.unk_token_id)),j}encode(j){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(j){return j.map(ie=>this.tokens_to_ids.get(ie)??this.unk_token_id)}convert_ids_to_tokens(j){return j.map(ie=>this.vocab[ie]??this.unk_token)}}class Q extends ne{constructor(j){super(j),this.tokens_to_ids=v(j.vocab),this.unk_token_id=this.tokens_to_ids.get(j.unk_token),this.unk_token=j.unk_token,this.max_input_chars_per_word=j.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[ie,Ae]of this.tokens_to_ids)this.vocab[Ae]=ie}encode(j){const ie=[];for(const Ae of j){const Re=[...Ae];if(Re.length>this.max_input_chars_per_word){ie.push(this.unk_token);continue}let We=!1,ot=0;const Et=[];for(;ot<Re.length;){let It=Re.length,At=null;for(;ot<It;){let kt=Re.slice(ot,It).join("");if(ot>0&&(kt=this.config.continuing_subword_prefix+kt),this.tokens_to_ids.has(kt)){At=kt;break}--It}if(At===null){We=!0;break}Et.push(At),ot=It}We?ie.push(this.unk_token):ie.push(...Et)}return ie}}class W extends ne{constructor(j,ie){super(j);const Ae=j.vocab.length;this.vocab=new Array(Ae),this.scores=new Array(Ae);for(let Re=0;Re<Ae;++Re)[this.vocab[Re],this.scores[Re]]=j.vocab[Re];this.unk_token_id=j.unk_id,this.unk_token=this.vocab[j.unk_id],this.tokens_to_ids=new Map(this.vocab.map((Re,We)=>[Re,We])),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=ie.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,c.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new l.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(j){const ie=j.chars,Ae=1;let Re=0;for(;Re<ie.length;){let We=!1;const ot=ie.slice(Re).join(""),Et=this.trie.commonPrefixSearch(ot);for(const It of Et){const At=this.tokens_to_ids.get(It),kt=this.scores[At],Yt=(0,r.len)(It);j.insert(Re,Yt,kt,At),!We&&Yt===Ae&&(We=!0)}We||j.insert(Re,Ae,this.unk_score,this.unk_token_id),Re+=Ae}}tokenize(j){const ie=new l.TokenLattice(j,this.bos_token_id,this.eos_token_id);return this.populateNodes(ie),ie.tokens()}encode(j){const ie=[];for(const Ae of j){const Re=this.tokenize(Ae);ie.push(...Re)}return ie}}const te=(()=>{const Xe=[...Array.from({length:"~".charCodeAt(0)-"!".charCodeAt(0)+1},(Re,We)=>We+"!".charCodeAt(0)),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},(Re,We)=>We+"".charCodeAt(0)),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},(Re,We)=>We+"".charCodeAt(0))],j=Xe.slice();let ie=0;for(let Re=0;Re<256;++Re)Xe.includes(Re)||(Xe.push(Re),j.push(256+ie),ie+=1);const Ae=j.map(Re=>String.fromCharCode(Re));return Object.fromEntries(Xe.map((Re,We)=>[Re,Ae[We]]))})(),K=(0,r.reverseDictionary)(te);class pe extends ne{constructor(j){super(j),this.tokens_to_ids=v(j.vocab),this.unk_token_id=this.tokens_to_ids.get(j.unk_token),this.unk_token=j.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[Ae,Re]of this.tokens_to_ids)this.vocab[Re]=Ae;const ie=Array.isArray(j.merges[0]);this.merges=ie?j.merges:j.merges.map(Ae=>Ae.split(" ",2)),this.bpe_ranks=new Map(this.merges.map((Ae,Re)=>[JSON.stringify(Ae),Re])),this.end_of_word_suffix=j.end_of_word_suffix,this.continuing_subword_suffix=j.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.max_length_to_cache=256,this.cache_capacity=1e4,this.cache=new l.LRUCache(this.cache_capacity)}clear_cache(){this.cache.clear()}bpe(j){if(j.length===0)return[];const ie=this.cache.get(j);if(ie!==void 0)return ie;const Ae=Array.from(j);this.end_of_word_suffix&&(Ae[Ae.length-1]+=this.end_of_word_suffix);let Re=[];if(Ae.length>1){const We=new l.PriorityQueue((It,At)=>It.score<At.score);let ot={token:Ae[0],bias:0,prev:null,next:null},Et=ot;for(let It=1;It<Ae.length;++It){const At={bias:It/Ae.length,token:Ae[It],prev:Et,next:null};Et.next=At,this._add_node(We,Et),Et=At}for(;!We.isEmpty();){const It=We.pop();if(It.deleted||!It.next||It.next.deleted)continue;if(It.deleted=!0,It.next.deleted=!0,It.prev){const kt={...It.prev};It.prev.deleted=!0,It.prev=kt,kt.prev?kt.prev.next=kt:ot=kt}const At={token:It.token+It.next.token,bias:It.bias,prev:It.prev,next:It.next.next};At.prev?(At.prev.next=At,this._add_node(We,At.prev)):ot=At,At.next&&(At.next.prev=At,this._add_node(We,At))}for(let It=ot;It!==null;It=It.next)Re.push(It.token)}else Re=Ae;if(this.continuing_subword_suffix)for(let We=0;We<Re.length-1;++We)Re[We]+=this.continuing_subword_suffix;return j.length<this.max_length_to_cache&&this.cache.put(j,Re),Re}_add_node(j,ie){const Ae=this.bpe_ranks.get(JSON.stringify([ie.token,ie.next.token]));Ae!==void 0&&(ie.score=Ae+ie.bias,j.push(ie))}encode(j){const ie=[];for(const Ae of j){if(this.ignore_merges&&this.tokens_to_ids.has(Ae)){ie.push(Ae);continue}const Re=this.bpe(Ae);for(const We of Re)if(this.tokens_to_ids.has(We))ie.push(We);else if(this.byte_fallback){const ot=Array.from(this.text_encoder.encode(We)).map(Et=>`<0x${Et.toString(16).toUpperCase().padStart(2,"0")}>`);ot.every(Et=>this.tokens_to_ids.has(Et))?ie.push(...ot):ie.push(this.unk_token)}else ie.push(this.unk_token)}return ie}}class be extends ne{constructor(j,ie){super(j),this.tokens_to_ids=v(ie.target_lang?j.vocab[ie.target_lang]:j.vocab),this.bos_token=ie.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=ie.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=ie.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=ie.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[Ae,Re]of this.tokens_to_ids)this.vocab[Re]=Ae}encode(j){return j}}class Ee extends i.Callable{constructor(j){super(),this.config=j}static fromConfig(j){if(j===null)return null;switch(j.type){case"BertNormalizer":return new Be(j);case"Precompiled":return new cn(j);case"Sequence":return new nt(j);case"Replace":return new Ge(j);case"NFC":return new De(j);case"NFD":return new he(j);case"NFKC":return new Z(j);case"NFKD":return new me(j);case"Strip":return new we(j);case"StripAccents":return new xe(j);case"Lowercase":return new et(j);case"Prepend":return new Ve(j);default:throw new Error(`Unknown Normalizer type: ${j.type}`)}}normalize(j){throw Error("normalize should be implemented in subclass.")}_call(j){return this.normalize(j)}}class Ge extends Ee{normalize(j){const ie=_(this.config.pattern);return ie===null?j:j.replaceAll(ie,this.config.content)}}class _e extends Ee{constructor(){super(...arguments);Ce(this,"form")}normalize(ie){return ie=ie.normalize(this.form),ie}}class De extends _e{constructor(){super(...arguments);Ce(this,"form","NFC")}}class he extends _e{constructor(){super(...arguments);Ce(this,"form","NFD")}}class Z extends _e{constructor(){super(...arguments);Ce(this,"form","NFKC")}}class me extends _e{constructor(){super(...arguments);Ce(this,"form","NFKD")}}class we extends Ee{normalize(j){return this.config.strip_left&&this.config.strip_right?j=j.trim():(this.config.strip_left&&(j=j.trimStart()),this.config.strip_right&&(j=j.trimEnd())),j}}class xe extends Ee{normalize(j){return j=w(j),j}}class et extends Ee{normalize(j){return j=j.toLowerCase(),j}}class Ve extends Ee{normalize(j){return j=this.config.prepend+j,j}}class nt extends Ee{constructor(j){super(j),this.normalizers=j.normalizers.map(ie=>Ee.fromConfig(ie))}normalize(j){return this.normalizers.reduce((ie,Ae)=>Ae.normalize(ie),j)}}class Be extends Ee{_tokenize_chinese_chars(j){const ie=[];for(let Ae=0;Ae<j.length;++Ae){const Re=j[Ae],We=Re.charCodeAt(0);F(We)?(ie.push(" "),ie.push(Re),ie.push(" ")):ie.push(Re)}return ie.join("")}stripAccents(j){return j.normalize("NFD").replace(/\p{Mn}/gu,"")}_is_control(j){switch(j){case"	":case`
`:case"\r":return!1;default:return/^\p{Cc}|\p{Cf}|\p{Co}|\p{Cs}$/u.test(j)}}_clean_text(j){const ie=[];for(const Ae of j){const Re=Ae.charCodeAt(0);Re===0||Re===65533||this._is_control(Ae)||(/^\s$/.test(Ae)?ie.push(" "):ie.push(Ae))}return ie.join("")}normalize(j){return this.config.clean_text&&(j=this._clean_text(j)),this.config.handle_chinese_chars&&(j=this._tokenize_chinese_chars(j)),this.config.lowercase?(j=j.toLowerCase(),this.config.strip_accents!==!1&&(j=this.stripAccents(j))):this.config.strip_accents&&(j=this.stripAccents(j)),j}}class ae extends i.Callable{static fromConfig(j){if(j===null)return null;switch(j.type){case"BertPreTokenizer":return new U(j);case"Sequence":return new jn(j);case"Whitespace":return new ci(j);case"WhitespaceSplit":return new ss(j);case"Metaspace":return new wn(j);case"ByteLevel":return new Se(j);case"Split":return new ze(j);case"Punctuation":return new Oe(j);case"Digits":return new Ye(j);case"Replace":return new Vi(j);case"FixedLength":return new Cn(j);default:throw new Error(`Unknown PreTokenizer type: ${j.type}`)}}pre_tokenize_text(j,ie){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(j,ie){return(Array.isArray(j)?j.map(Ae=>this.pre_tokenize_text(Ae,ie)):this.pre_tokenize_text(j,ie)).flat()}_call(j,ie){return this.pre_tokenize(j,ie)}}class U extends ae{constructor(j){super(),this.pattern=new RegExp(`[^\\s${L}]+|[${L}]`,"gu")}pre_tokenize_text(j,ie){return j.trim().match(this.pattern)||[]}}class Se extends ae{constructor(j){super(),this.config=j,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=/'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu,this.byte_encoder=te,this.text_encoder=new TextEncoder}pre_tokenize_text(j,ie){return this.add_prefix_space&&!j.startsWith(" ")&&(j=" "+j),(this.use_regex?j.match(this.pattern)||[]:[j]).map(Re=>Array.from(this.text_encoder.encode(Re),We=>this.byte_encoder[We]).join(""))}}class ze extends ae{constructor(j){super(),this.config=j,this.pattern=_(this.config.pattern,this.config.invert)}pre_tokenize_text(j,ie){var Ae;return this.pattern===null?[]:this.config.invert?j.match(this.pattern)||[]:((Ae=this.config.behavior)==null?void 0:Ae.toLowerCase())==="removed"?j.split(this.pattern).filter(Re=>Re):p(j,this.pattern)}}class Oe extends ae{constructor(j){super(),this.config=j,this.pattern=new RegExp(`[^${L}]+|[${L}]+`,"gu")}pre_tokenize_text(j,ie){return j.match(this.pattern)||[]}}class Ye extends ae{constructor(j){super(),this.config=j;const ie=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(ie,"gu")}pre_tokenize_text(j,ie){return j.match(this.pattern)||[]}}class H extends i.Callable{constructor(j){super(),this.config=j}static fromConfig(j){if(j===null)return null;switch(j.type){case"TemplateProcessing":return new Ie(j);case"ByteLevel":return new fe(j);case"RobertaProcessing":return new $e(j);case"BertProcessing":return new Y(j);case"Sequence":return new Qe(j);default:throw new Error(`Unknown PostProcessor type: ${j.type}`)}}post_process(j,...ie){throw Error("post_process should be implemented in subclass.")}_call(j,...ie){return this.post_process(j,...ie)}}class Y extends H{constructor(j){super(j),this.cls=j.cls[0],this.sep=j.sep[0]}post_process(j,ie=null,{add_special_tokens:Ae=!0}={}){Ae&&(j=(0,r.mergeArrays)([this.cls],j,[this.sep]));let Re=new Array(j.length).fill(0);if(ie!==null){const We=Ae&&this instanceof $e?[this.sep]:[],ot=Ae?[this.sep]:[];j=(0,r.mergeArrays)(j,We,ie,ot),Re=(0,r.mergeArrays)(Re,new Array(ie.length+We.length+ot.length).fill(1))}return{tokens:j,token_type_ids:Re}}}class $e extends Y{}class Ie extends H{constructor(j){super(j),this.single=j.single,this.pair=j.pair}post_process(j,ie=null,{add_special_tokens:Ae=!0}={}){const Re=ie===null?this.single:this.pair;let We=[],ot=[];for(const Et of Re)"SpecialToken"in Et?Ae&&(We.push(Et.SpecialToken.id),ot.push(Et.SpecialToken.type_id)):"Sequence"in Et&&(Et.Sequence.id==="A"?(We=(0,r.mergeArrays)(We,j),ot=(0,r.mergeArrays)(ot,new Array(j.length).fill(Et.Sequence.type_id))):Et.Sequence.id==="B"&&(We=(0,r.mergeArrays)(We,ie),ot=(0,r.mergeArrays)(ot,new Array(ie.length).fill(Et.Sequence.type_id))));return{tokens:We,token_type_ids:ot}}}class fe extends H{post_process(j,ie=null){return ie&&(j=(0,r.mergeArrays)(j,ie)),{tokens:j}}}class Qe extends H{constructor(j){super(j),this.processors=j.processors.map(ie=>H.fromConfig(ie))}post_process(j,ie=null,Ae={}){let Re;for(const We of this.processors)if(We instanceof fe)j=We.post_process(j).tokens,ie&&(ie=We.post_process(ie).tokens);else{const ot=We.post_process(j,ie,Ae);j=ot.tokens,Re=ot.token_type_ids}return{tokens:j,token_type_ids:Re}}}class Ne extends i.Callable{constructor(j){super(),this.config=j,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=j.trim_offsets}static fromConfig(j){if(j===null)return null;switch(j.type){case"WordPiece":return new He(j);case"Metaspace":return new xn(j);case"ByteLevel":return new je(j);case"Replace":return new ut(j);case"ByteFallback":return new de(j);case"Fuse":return new qe(j);case"Strip":return new tt(j);case"Sequence":return new Mt(j);case"CTC":return new lt(j);case"BPEDecoder":return new Rt(j);default:throw new Error(`Unknown Decoder type: ${j.type}`)}}_call(j){return this.decode(j)}decode(j){return this.decode_chain(j).join("")}decode_chain(j){throw Error("`decode_chain` should be implemented in subclass.")}}class ut extends Ne{decode_chain(j){const ie=_(this.config.pattern);return ie===null?j:j.map(Ae=>Ae.replaceAll(ie,this.config.content))}}class de extends Ne{constructor(j){super(j),this.text_decoder=new TextDecoder}decode_chain(j){const ie=[];let Ae=[];for(const Re of j){let We=null;if(Re.length===6&&Re.startsWith("<0x")&&Re.endsWith(">")){const ot=parseInt(Re.slice(3,5),16);isNaN(ot)||(We=ot)}if(We!==null)Ae.push(We);else{if(Ae.length>0){const ot=this.text_decoder.decode(Uint8Array.from(Ae));ie.push(ot),Ae=[]}ie.push(Re)}}if(Ae.length>0){const Re=this.text_decoder.decode(Uint8Array.from(Ae));ie.push(Re),Ae=[]}return ie}}class qe extends Ne{decode_chain(j){return[j.join("")]}}class tt extends Ne{constructor(j){super(j),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(j){return j.map(ie=>{let Ae=0;for(let We=0;We<this.start&&ie[We]===this.content;++We){Ae=We+1;continue}let Re=ie.length;for(let We=0;We<this.stop;++We){const ot=ie.length-We-1;if(ie[ot]===this.content){Re=ot;continue}else break}return ie.slice(Ae,Re)})}}class He extends Ne{constructor(j){super(j),this.cleanup=j.cleanup}decode_chain(j){return j.map((ie,Ae)=>(Ae!==0&&(ie.startsWith(this.config.prefix)?ie=ie.replace(this.config.prefix,""):ie=" "+ie),this.cleanup&&(ie=D(ie)),ie))}}class je extends Ne{constructor(j){super(j),this.byte_decoder=K,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(j){const ie=j.join(""),Ae=new Uint8Array([...ie].map(We=>this.byte_decoder[We]));return this.text_decoder.decode(Ae)}decode_chain(j){const ie=[];let Ae=[];for(const Re of j)this.added_tokens.find(We=>We.content===Re)!==void 0?(Ae.length>0&&(ie.push(this.convert_tokens_to_string(Ae)),Ae=[]),ie.push(Re)):Ae.push(Re);return Ae.length>0&&ie.push(this.convert_tokens_to_string(Ae)),ie}}class lt extends Ne{constructor(j){super(j),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(j){if(j.length===0)return"";const ie=[j[0]];for(let We=1;We<j.length;++We)j[We]!==ie.at(-1)&&ie.push(j[We]);let Re=ie.filter(We=>We!==this.pad_token).join("");return this.cleanup&&(Re=D(Re).replaceAll(this.word_delimiter_token," ").trim()),Re}decode_chain(j){return[this.convert_tokens_to_string(j)]}}class Mt extends Ne{constructor(j){super(j),this.decoders=j.decoders.map(ie=>Ne.fromConfig(ie))}decode_chain(j){return this.decoders.reduce((ie,Ae)=>Ae.decode_chain(ie),j)}}class Rt extends Ne{constructor(j){super(j),this.suffix=this.config.suffix}decode_chain(j){return j.map((ie,Ae)=>ie.replaceAll(this.suffix,Ae===j.length-1?"":" "))}}class Xt extends Ne{decode_chain(j){let ie="";for(let Ae=1;Ae<j.length;Ae+=2)ie+=j[Ae];return[ie]}}class wn extends ae{constructor(j){super(),this.replacement=j.replacement,this.strRep=j.str_rep||this.replacement,this.prepend_scheme=j.prepend_scheme??"always"}pre_tokenize_text(j,{section_index:ie=void 0}={}){let Ae=j.replaceAll(" ",this.strRep);return!Ae.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&ie===0)&&(Ae=this.strRep+Ae),[Ae]}}class xn extends Ne{constructor(j){super(j),this.replacement=j.replacement}decode_chain(j){const ie=[];for(let Ae=0;Ae<j.length;++Ae){let Re=j[Ae].replaceAll(this.replacement," ");Ae==0&&Re.startsWith(" ")&&(Re=Re.substring(1)),ie.push(Re)}return ie}}class cn extends Ee{constructor(j){super(j),this.charsmap=j.precompiled_charsmap}normalize(j){return j=j.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),j=j.replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," "),j.includes("")?j=j.split("").map(Ae=>Ae.normalize("NFKC")).join(""):j=j.normalize("NFKC"),j}}class jn extends ae{constructor(j){super(),this.tokenizers=j.pretokenizers.map(ie=>ae.fromConfig(ie))}pre_tokenize_text(j,ie){return this.tokenizers.reduce((Ae,Re)=>Re.pre_tokenize(Ae,ie),[j])}}class ci extends ae{constructor(j){super()}pre_tokenize_text(j,ie){return j.match(/\w+|[^\w\s]+/g)||[]}}class ss extends ae{constructor(j){super()}pre_tokenize_text(j,ie){return A(j)}}class Vi extends ae{constructor(j){super(),this.config=j,this.pattern=_(this.config.pattern),this.content=this.config.content}pre_tokenize_text(j,ie){return this.pattern===null?[j]:[j.replaceAll(this.pattern,this.config.content)]}}class Cn extends ae{constructor(j){super(),this._length=j.length}pre_tokenize_text(j,ie){const Ae=[];for(let Re=0;Re<j.length;Re+=this._length)Ae.push(j.slice(Re,Re+this._length));return Ae}}const Mn=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function Di(Xe,j,ie,Ae){for(const Re of Object.keys(Xe)){const We=j-Xe[Re].length,ot=ie(Re),Et=new Array(We).fill(ot);Xe[Re]=Ae==="right"?(0,r.mergeArrays)(Xe[Re],Et):(0,r.mergeArrays)(Et,Xe[Re])}}function bs(Xe,j){for(const ie of Object.keys(Xe))Xe[ie].length=j}class qt extends i.Callable{constructor(ie,Ae){super();Ce(this,"return_token_type_ids",!1);Ce(this,"padding_side","right");this.config=Ae,this.normalizer=Ee.fromConfig(ie.normalizer),this.pre_tokenizer=ae.fromConfig(ie.pre_tokenizer),this.model=ne.fromConfig(ie.model,Ae),this.post_processor=H.fromConfig(ie.post_processor),this.decoder=Ne.fromConfig(ie.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const Re of ie.added_tokens){const We=new q(Re);this.added_tokens.push(We),this.model.tokens_to_ids.set(We.content,We.id),this.model.vocab[We.id]=We.content,We.special&&(this.special_tokens.push(We.content),this.all_special_ids.push(We.id))}if(this.additional_special_tokens=Ae.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_splitter=new l.DictionarySplitter(this.added_tokens.map(Re=>Re.content)),this.added_tokens_map=new Map(this.added_tokens.map(Re=>[Re.content,Re])),this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=Ae.model_max_length,this.remove_space=Ae.remove_space,this.clean_up_tokenization_spaces=Ae.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=Ae.do_lowercase_and_remove_accent??!1,Ae.padding_side&&(this.padding_side=Ae.padding_side),this.add_bos_token=Ae.add_bos_token,this.add_eos_token=Ae.add_eos_token,this.legacy=!1,this.chat_template=Ae.chat_template??null,Array.isArray(this.chat_template)){const Re=Object.create(null);for(const{name:We,template:ot}of this.chat_template){if(typeof We!="string"||typeof ot!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');Re[We]=ot}this.chat_template=Re}this._compiled_template_cache=new Map}getToken(...ie){for(const Ae of ie){const Re=this.config[Ae];if(Re)if(typeof Re=="object"){if(Re.__type==="AddedToken")return Re.content;throw Error(`Unknown token: ${Re}`)}else return Re}return null}static async from_pretrained(ie,{progress_callback:Ae=null,config:Re=null,cache_dir:We=null,local_files_only:ot=!1,revision:Et="main",legacy:It=null}={}){const At=await h(ie,{progress_callback:Ae,config:Re,cache_dir:We,local_files_only:ot,revision:Et,legacy:It});return new this(...At)}_call(ie,{text_pair:Ae=null,add_special_tokens:Re=!0,padding:We=!1,truncation:ot=null,max_length:Et=null,return_tensor:It=!0,return_token_type_ids:At=null}={}){const kt=Array.isArray(ie);let Yt;if(kt){if(ie.length===0)throw Error("text array must be non-empty");if(Ae!==null){if(Array.isArray(Ae)){if(ie.length!==Ae.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");Yt=ie.map((_n,Bn)=>this._encode_plus(_n,{text_pair:Ae[Bn],add_special_tokens:Re,return_token_type_ids:At}))}else Yt=ie.map(_n=>this._encode_plus(_n,{add_special_tokens:Re,return_token_type_ids:At}))}else{if(ie==null)throw Error("text may not be null or undefined");if(Array.isArray(Ae))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");Yt=[this._encode_plus(ie,{text_pair:Ae,add_special_tokens:Re,return_token_type_ids:At})]}if(Et===null?Et=this.model_max_length:ot===null&&(We===!0?(console.warn("`max_length` is ignored when `padding: true` and there is no truncation strategy. To pad to max length, use `padding: 'max_length'`."),Et=this.model_max_length):We===!1&&(console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation: true` to explicitly truncate examples to max length."),ot=!0)),We===!0&&(Et=Math.min((0,c.max)(Yt.map(_n=>_n.input_ids.length))[0],Et??1/0)),Et=Math.min(Et,this.model_max_length??1/0),We||ot)for(let _n=0;_n<Yt.length;++_n)Yt[_n].input_ids.length!==Et&&(Yt[_n].input_ids.length>Et?ot&&bs(Yt[_n],Et):We&&Di(Yt[_n],Et,Bn=>Bn==="input_ids"?this.pad_token_id:0,this.padding_side));const pn={};if(It){if(!(We&&ot)&&Yt.some(Bn=>{var En;for(const Un of Object.keys(Bn))if(Bn[Un].length!==((En=Yt[0][Un])==null?void 0:En.length))return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const _n=[Yt.length,Yt[0].input_ids.length];for(const Bn of Object.keys(Yt[0]))pn[Bn]=new u.Tensor("int64",BigInt64Array.from(Yt.flatMap(En=>En[Bn]).map(BigInt)),_n)}else{for(const _n of Object.keys(Yt[0]))pn[_n]=Yt.map(Bn=>Bn[_n]);if(!kt)for(const _n of Object.keys(pn))pn[_n]=pn[_n][0]}return pn}_encode_text(ie){if(ie===null)return null;const Ae=this.added_tokens_splitter.split(ie);for(let We=0;We<Ae.length;++We){const ot=this.added_tokens_map.get(Ae[We]);ot&&(ot.lstrip&&We>0&&(Ae[We-1]=Ae[We-1].trimEnd()),ot.rstrip&&We<Ae.length-1&&(Ae[We+1]=Ae[We+1].trimStart()))}return Ae.flatMap((We,ot)=>{if(We.length===0)return[];if(this.added_tokens_map.has(We))return[We];if(this.remove_space===!0&&(We=We.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(We=T(We)),this.normalizer!==null&&(We=this.normalizer(We)),We.length===0)return[];const Et=this.pre_tokenizer!==null?this.pre_tokenizer(We,{section_index:ot}):[We];return this.model(Et)})}_encode_plus(ie,{text_pair:Ae=null,add_special_tokens:Re=!0,return_token_type_ids:We=null}={}){const{tokens:ot,token_type_ids:Et}=this._tokenize_helper(ie,{pair:Ae,add_special_tokens:Re}),It=this.model.convert_tokens_to_ids(ot),At={input_ids:It,attention_mask:new Array(It.length).fill(1)};return(We??this.return_token_type_ids)&&Et&&(At.token_type_ids=Et),At}_tokenize_helper(ie,{pair:Ae=null,add_special_tokens:Re=!1}={}){const We=this._encode_text(ie),ot=this._encode_text(Ae);return this.post_processor?this.post_processor(We,ot,{add_special_tokens:Re}):{tokens:(0,r.mergeArrays)(We??[],ot??[])}}tokenize(ie,{pair:Ae=null,add_special_tokens:Re=!1}={}){return this._tokenize_helper(ie,{pair:Ae,add_special_tokens:Re}).tokens}encode(ie,{text_pair:Ae=null,add_special_tokens:Re=!0,return_token_type_ids:We=null}={}){return this._encode_plus(ie,{text_pair:Ae,add_special_tokens:Re,return_token_type_ids:We}).input_ids}batch_decode(ie,Ae={}){return ie instanceof u.Tensor&&(ie=ie.tolist()),ie.map(Re=>this.decode(Re,Ae))}decode(ie,Ae={}){if(ie instanceof u.Tensor&&(ie=S(ie)),!Array.isArray(ie)||ie.length===0||!(0,r.isIntegralNumber)(ie[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(ie,Ae)}decode_single(ie,{skip_special_tokens:Ae=!1,clean_up_tokenization_spaces:Re=null}){let We=this.model.convert_ids_to_tokens(ie);Ae&&(We=We.filter(Et=>!this.special_tokens.includes(Et)));let ot=this.decoder?this.decoder(We):We.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(ot=ot.replaceAll(this.decoder.end_of_word_suffix," "),Ae&&(ot=ot.trim())),(Re??this.clean_up_tokenization_spaces)&&(ot=D(ot)),ot}get_chat_template({chat_template:ie=null,tools:Ae=null}={}){if(this.chat_template&&typeof this.chat_template=="object"){const Re=this.chat_template;if(ie!==null&&Object.hasOwn(Re,ie))ie=Re[ie];else if(ie===null)if(Ae!==null&&"tool_use"in Re)ie=Re.tool_use;else if("default"in Re)ie=Re.default;else throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(Re).sort()}.`)}else if(ie===null)if(this.chat_template)ie=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");return ie}apply_chat_template(ie,{tools:Ae=null,documents:Re=null,chat_template:We=null,add_generation_prompt:ot=!1,tokenize:Et=!0,padding:It=!1,truncation:At=!1,max_length:kt=null,return_tensor:Yt=!0,return_dict:pn=!1,tokenizer_kwargs:_n={},...Bn}={}){if(We=this.get_chat_template({chat_template:We,tools:Ae}),typeof We!="string")throw Error(`chat_template must be a string, but got ${typeof We}`);let En=this._compiled_template_cache.get(We);En===void 0&&(En=new f.Template(We),this._compiled_template_cache.set(We,En));const Un=Object.create(null);for(const Ti of Mn){const Ss=this.getToken(Ti);Ss&&(Un[Ti]=Ss)}const di=En.render({messages:ie,add_generation_prompt:ot,tools:Ae,documents:Re,...Un,...Bn});if(Et){const Ti=this._call(di,{add_special_tokens:!1,padding:It,truncation:At,max_length:kt,return_tensor:Yt,..._n});return pn?Ti:Ti.input_ids}return di}}class Me extends qt{constructor(){super(...arguments);Ce(this,"return_token_type_ids",!0)}}class at extends qt{constructor(){super(...arguments);Ce(this,"return_token_type_ids",!0)}}class rt extends qt{constructor(){super(...arguments);Ce(this,"return_token_type_ids",!0)}}class mt extends qt{constructor(){super(...arguments);Ce(this,"return_token_type_ids",!0)}}class _t extends qt{constructor(){super(...arguments);Ce(this,"return_token_type_ids",!0)}}class an extends qt{constructor(){super(...arguments);Ce(this,"return_token_type_ids",!0)}}class B extends qt{constructor(){super(...arguments);Ce(this,"return_token_type_ids",!0)}}class le extends qt{constructor(){super(...arguments);Ce(this,"return_token_type_ids",!0)}}class J extends qt{constructor(){super(...arguments);Ce(this,"return_token_type_ids",!0)}}class se extends qt{}class ge extends qt{}class Fe extends qt{constructor(ie,Ae){super(ie,Ae);Ce(this,"return_token_type_ids",!0);console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class Ke extends qt{constructor(){super(...arguments);Ce(this,"return_token_type_ids",!0)}}class pt extends qt{}class Pt extends qt{}class Tt extends qt{}class en extends qt{constructor(j,ie){super(j,ie),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(Ae=>this.languageRegex.test(Ae)),this.lang_to_token=Ae=>Ae}_build_translation_inputs(j,ie,Ae){return zi(this,j,ie,Ae)}}class Dt extends en{}class tn extends qt{}class Vt extends qt{}const nn="";class Tn extends qt{constructor(ie,Ae){super(ie,Ae);Ce(this,"padding_side","left");this.legacy=Ae.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new wn({replacement:nn,prepend_scheme:"first"}))}_encode_text(ie){if(ie===null)return null;if(this.legacy||ie.length===0)return super._encode_text(ie);let Ae=super._encode_text(nn+ie.replaceAll(nn," "));return Ae.length>1&&Ae[0]===nn&&this.special_tokens.includes(Ae[1])&&(Ae=Ae.slice(1)),Ae}}class bi extends qt{}class ui extends qt{}class Bi extends qt{}class gi extends qt{}class ki extends qt{}class Mi extends qt{}class Ms extends qt{}class Ts extends qt{}class zs extends qt{}function zi(Xe,j,ie,Ae){if(!("language_codes"in Xe)||!Array.isArray(Xe.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in Xe)||!(Xe.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in Xe)||typeof Xe.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const Re=Ae.src_lang,We=Ae.tgt_lang;if(!Xe.language_codes.includes(We))throw new Error(`Target language code "${We}" is not valid. Must be one of: {${Xe.language_codes.join(", ")}}`);if(Re!==void 0){if(!Xe.language_codes.includes(Re))throw new Error(`Source language code "${Re}" is not valid. Must be one of: {${Xe.language_codes.join(", ")}}`);for(const ot of Xe.post_processor.config.single)if("SpecialToken"in ot&&Xe.languageRegex.test(ot.SpecialToken.id)){ot.SpecialToken.id=Xe.lang_to_token(Re);break}}return Ae.forced_bos_token_id=Xe.model.convert_tokens_to_ids([Xe.lang_to_token(We)])[0],Xe._call(j,ie)}class Wt extends qt{constructor(j,ie){super(j,ie),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(Ae=>this.languageRegex.test(Ae)),this.lang_to_token=Ae=>Ae}_build_translation_inputs(j,ie,Ae){return zi(this,j,ie,Ae)}}class ji extends qt{constructor(j,ie){super(j,ie),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(Ae=>this.languageRegex.test(Ae)).map(Ae=>Ae.slice(2,-2)),this.lang_to_token=Ae=>`__${Ae}__`}_build_translation_inputs(j,ie,Ae){return zi(this,j,ie,Ae)}}class or extends qt{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(j,{return_timestamps:ie=!1,return_language:Ae=!1,time_precision:Re=null,force_full_sequences:We=!0}={}){if(Re===null)throw Error("Must specify time_precision");let ot=null;const Et=ie==="word";function It(){return{language:ot,timestamp:[null,null],text:""}}const At=[];let kt=It(),Yt=0;const pn=this.timestamp_begin,Bn=pn+1500;let En=[],Un=[],di=!1,Ti=null;const Ss=new Set(this.all_special_ids);for(const In of j){const Wn=In.tokens,ri=Et?In.token_timestamps:null;let os=null,as=pn;if("stride"in In){const[Qn,Hn,qn]=In.stride;if(Yt-=Hn,Ti=Qn-qn,Hn&&(as=Hn/Re+pn),qn)for(let Jt=Wn.length-1;Jt>=0;--Jt){const mn=Number(Wn[Jt]);if(mn>=pn){if(os!==null&&(mn-pn)*Re<Ti)break;os=mn}}}let oi=[],ls=[];for(let Qn=0;Qn<Wn.length;++Qn){const Hn=Number(Wn[Qn]);if(Ss.has(Hn)){const qn=this.decode([Hn]),Jt=m.WHISPER_LANGUAGE_MAPPING.get(qn.slice(2,-2));if(Jt!==void 0){if(ot!==null&&Jt!==ot&&!ie){En.push(oi);const mn=this.findLongestCommonSequence(En)[0],cs=this.decode(mn);kt.text=cs,At.push(kt),En=[],oi=[],kt=It()}ot=kt.language=Jt}}else if(Hn>=pn&&Hn<=Bn){const qn=(Hn-pn)*Re+Yt,Jt=(0,c.round)(qn,2);if(os!==null&&Hn>=os)di=!0;else if(di||En.length>0&&Hn<as)di=!1;else if(kt.timestamp[0]===null)kt.timestamp[0]=Jt;else if(Jt!==kt.timestamp[0]){kt.timestamp[1]=Jt,En.push(oi),Et&&Un.push(ls);const[mn,cs]=this.findLongestCommonSequence(En,Un),us=this.decode(mn);kt.text=us,Et&&(kt.words=this.collateWordTimestamps(mn,cs,ot)),At.push(kt),En=[],oi=[],Un=[],ls=[],kt=It()}}else if(oi.push(Hn),Et){let qn=(0,c.round)(ri[Qn]+Yt,2),Jt;if(Qn+1<ri.length){Jt=(0,c.round)(ri[Qn+1]+Yt,2);const mn=this.decode([Hn]);I.test(mn)&&(Jt=(0,c.round)(Math.min(qn+Re,Jt),2))}else Jt=null;ls.push([qn,Jt])}}if("stride"in In){const[Qn,Hn,qn]=In.stride;Yt+=Qn-qn}oi.length>0?(En.push(oi),Et&&Un.push(ls)):En.every(Qn=>Qn.length===0)&&(kt=It(),En=[],oi=[],Un=[],ls=[])}if(En.length>0){if(We&&ie)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[In,Wn]=this.findLongestCommonSequence(En,Un),ri=this.decode(In);kt.text=ri,Et&&(kt.words=this.collateWordTimestamps(In,Wn,ot)),At.push(kt)}let ti=Object.create(null);const Ps=At.map(In=>In.text).join("");if(ie||Ae){for(let In=0;In<At.length;++In){const Wn=At[In];ie||delete Wn.timestamp,Ae||delete Wn.language}if(Et){const In=[];for(const Wn of At)for(const ri of Wn.words)In.push(ri);ti={chunks:In}}else ti={chunks:At}}return[Ps,ti]}findLongestCommonSequence(j,ie=null){let Ae=j[0],Re=Ae.length,We=[];const ot=Array.isArray(ie)&&ie.length>0;let Et=ot?[]:null,It=ot?ie[0]:null;for(let At=1;At<j.length;++At){const kt=j[At];let Yt=0,pn=[Re,Re,0,0];const _n=kt.length;for(let ti=1;ti<Re+_n;++ti){const Ps=Math.max(0,Re-ti),In=Math.min(Re,Re+_n-ti),Wn=Ae.slice(Ps,In),ri=Math.max(0,ti-Re),os=Math.min(_n,ti),as=kt.slice(ri,os);if(Wn.length!==as.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let oi;ot?oi=Wn.filter((Hn,qn)=>Hn===as[qn]&&It[Ps+qn]<=ie[At][ri+qn]).length:oi=Wn.filter((Hn,qn)=>Hn===as[qn]).length;const ls=ti/1e4,Qn=oi/ti+ls;oi>1&&Qn>Yt&&(Yt=Qn,pn=[Ps,In,ri,os])}const[Bn,En,Un,di]=pn,Ti=Math.floor((En+Bn)/2),Ss=Math.floor((di+Un)/2);We.push(...Ae.slice(0,Ti)),Ae=kt.slice(Ss),Re=Ae.length,ot&&(Et.push(...It.slice(0,Ti)),It=ie[At].slice(Ss))}return We.push(...Ae),ot?(Et.push(...It),[We,Et]):[We,[]]}collateWordTimestamps(j,ie,Ae){const[Re,We,ot]=this.combineTokensIntoWords(j,Ae),Et=[];for(let It=0;It<Re.length;++It){const At=ot[It];Et.push({text:Re[It],timestamp:[ie[At.at(0)][0],ie[At.at(-1)][1]]})}return Et}combineTokensIntoWords(j,ie,Ae=`"'([{-`,Re=`"'.,!?:)]}`){ie=ie??"english";let We,ot,Et;return["chinese","japanese","thai","lao","myanmar"].includes(ie)?[We,ot,Et]=this.splitTokensOnUnicode(j):[We,ot,Et]=this.splitTokensOnSpaces(j),this.mergePunctuations(We,ot,Et,Ae,Re)}decode(j,ie){let Ae;return ie!=null&&ie.decode_with_timestamps?(j instanceof u.Tensor&&(j=S(j)),Ae=this.decodeWithTimestamps(j,ie)):Ae=super.decode(j,ie),Ae}decodeWithTimestamps(j,ie){const Ae=(ie==null?void 0:ie.time_precision)??.02,Re=Array.from(this.all_special_ids).at(-1)+1;let We=[[]];for(let ot of j)if(ot=Number(ot),ot>=Re){const Et=((ot-Re)*Ae).toFixed(2);We.push(`<|${Et}|>`),We.push([])}else We[We.length-1].push(ot);return We=We.map(ot=>typeof ot=="string"?ot:super.decode(ot,ie)),We.join("")}splitTokensOnUnicode(j){const ie=this.decode(j,{decode_with_timestamps:!0}),Ae="",Re=[],We=[],ot=[];let Et=[],It=[],At=0;for(let kt=0;kt<j.length;++kt){const Yt=j[kt];Et.push(Yt),It.push(kt);const pn=this.decode(Et,{decode_with_timestamps:!0});(!pn.includes(Ae)||ie[At+pn.indexOf(Ae)]===Ae)&&(Re.push(pn),We.push(Et),ot.push(It),Et=[],It=[],At+=pn.length)}return[Re,We,ot]}splitTokensOnSpaces(j){const[ie,Ae,Re]=this.splitTokensOnUnicode(j),We=[],ot=[],Et=[],It=new RegExp(`^[${L}]$`,"gu");for(let At=0;At<ie.length;++At){const kt=ie[At],Yt=Ae[At],pn=Re[At],_n=Yt[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),Bn=kt.startsWith(" "),En=kt.trim(),Un=It.test(En);if(_n||Bn||Un||We.length===0)We.push(kt),ot.push(Yt),Et.push(pn);else{const di=We.length-1;We[di]+=kt,ot[di].push(...Yt),Et[di].push(...pn)}}return[We,ot,Et]}mergePunctuations(j,ie,Ae,Re,We){const ot=structuredClone(j),Et=structuredClone(ie),It=structuredClone(Ae);let At=ot.length-2,kt=ot.length-1;for(;At>=0;)ot[At].startsWith(" ")&&Re.includes(ot[At].trim())?(ot[kt]=ot[At]+ot[kt],Et[kt]=(0,r.mergeArrays)(Et[At],Et[kt]),It[kt]=(0,r.mergeArrays)(It[At],It[kt]),ot[At]="",Et[At]=[],It[At]=[]):kt=At,--At;for(At=0,kt=1;kt<ot.length;)!ot[At].endsWith(" ")&&We.includes(ot[kt])?(ot[At]+=ot[kt],Et[At]=(0,r.mergeArrays)(Et[At],Et[kt]),It[At]=(0,r.mergeArrays)(It[At],It[kt]),ot[kt]="",Et[kt]=[],It[kt]=[]):At=kt,++kt;return[ot.filter(Yt=>Yt),Et.filter(Yt=>Yt.length>0),It.filter(Yt=>Yt.length>0)]}}class $s extends qt{}class Ns extends qt{}class Us extends qt{}class rs extends qt{constructor(j,ie){super(j,ie),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(Ae=>this.languageRegex.test(Ae)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(j){if(j===null)return null;const[ie,...Ae]=j.trim().split(this.languageRegex);if(Ae.length===0)return super._encode_text(ie);if(Ae.length===2){const[Re,We]=Ae;return this.supported_language_codes.includes(Re)||console.warn(`Unsupported language code "${Re}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,r.mergeArrays)([Re],super._encode_text(We))}}}class _i extends qt{}class bt extends qt{}class ct extends qt{}class Lt extends qt{}class yn extends qt{}class Wi extends qt{constructor(j,ie){super(j,ie),this.decoder=new Xt({})}}class it extends qt{}class Es extends qt{}class ro{static async from_pretrained(j,{progress_callback:ie=null,config:Ae=null,cache_dir:Re=null,local_files_only:We=!1,revision:ot="main",legacy:Et=null}={}){var pn;const[It,At]=await h(j,{progress_callback:ie,config:Ae,cache_dir:Re,local_files_only:We,revision:ot,legacy:Et}),kt=((pn=At.tokenizer_class)==null?void 0:pn.replace(/Fast$/,""))??"PreTrainedTokenizer";let Yt=this.TOKENIZER_CLASS_MAPPING[kt];return Yt||(console.warn(`Unknown tokenizer class "${kt}", attempting to construct from base class.`),Yt=qt),new Yt(It,At)}}Ce(ro,"TOKENIZER_CLASS_MAPPING",{T5Tokenizer:pt,DistilBertTokenizer:se,CamembertTokenizer:ge,DebertaTokenizer:_t,DebertaV2Tokenizer:an,BertTokenizer:Me,HerbertTokenizer:B,ConvBertTokenizer:le,RoFormerTokenizer:J,XLMTokenizer:Fe,ElectraTokenizer:Ke,MobileBertTokenizer:rt,SqueezeBertTokenizer:mt,AlbertTokenizer:at,GPT2Tokenizer:Pt,BartTokenizer:Tt,MBartTokenizer:en,MBart50Tokenizer:Dt,RobertaTokenizer:tn,WhisperTokenizer:or,CodeGenTokenizer:$s,CLIPTokenizer:Ns,SiglipTokenizer:Us,MarianTokenizer:rs,BloomTokenizer:Vt,NllbTokenizer:Wt,M2M100Tokenizer:ji,LlamaTokenizer:Tn,CodeLlamaTokenizer:bi,XLMRobertaTokenizer:ui,MPNetTokenizer:Bi,FalconTokenizer:gi,GPTNeoXTokenizer:ki,EsmTokenizer:Mi,Wav2Vec2CTCTokenizer:_i,BlenderbotTokenizer:bt,BlenderbotSmallTokenizer:ct,SpeechT5Tokenizer:Lt,NougatTokenizer:yn,VitsTokenizer:Wi,Qwen2Tokenizer:Ms,GemmaTokenizer:Ts,Grok1Tokenizer:zs,CohereTokenizer:it,MgpstrTokenizer:Es,PreTrainedTokenizer:qt})},"./src/utils/audio.js":(e,n,t)=>{t.r(n),t.d(n,{RawAudio:()=>Q,hamming:()=>p,hanning:()=>h,mel_filter_bank:()=>F,read_audio:()=>f,spectrogram:()=>R,window_function:()=>N});var i=t("./src/utils/hub.js"),r=t("./src/utils/maths.js"),a=t("./src/utils/core.js"),c=t("./src/env.js"),u=t("./src/utils/tensor.js"),l=t("?7992");async function f(W,te){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const K=await(await(0,i.getFile)(W)).arrayBuffer(),pe=new AudioContext({sampleRate:te});typeof te>"u"&&console.warn(`No sampling rate provided, using default of ${pe.sampleRate}Hz.`);const be=await pe.decodeAudioData(K);let Ee;if(be.numberOfChannels===2){const Ge=Math.sqrt(2),_e=be.getChannelData(0),De=be.getChannelData(1);Ee=new Float32Array(_e.length);for(let he=0;he<be.length;++he)Ee[he]=Ge*(_e[he]+De[he])/2}else Ee=be.getChannelData(0);return Ee}function m(W,te){if(W<1)return new Float64Array;if(W===1)return new Float64Array([1]);const K=1-te,pe=2*Math.PI/(W-1),be=new Float64Array(W);for(let Ee=0;Ee<W;++Ee)be[Ee]=te-K*Math.cos(Ee*pe);return be}function h(W){return m(W,.5)}function p(W){return m(W,.54)}const _={htk:W=>2595*Math.log10(1+W/700),kaldi:W=>1127*Math.log(1+W/700),slaney:(W,te=1e3,K=15,pe=27/Math.log(6.4))=>W>=te?K+Math.log(W/te)*pe:3*W/200};function v(W,te="htk"){const K=_[te];if(!K)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof W=="number"?K(W):W.map(pe=>K(pe))}const S={htk:W=>700*(10**(W/2595)-1),kaldi:W=>700*(Math.exp(W/1127)-1),slaney:(W,te=1e3,K=15,pe=Math.log(6.4)/27)=>W>=K?te*Math.exp(pe*(W-K)):200*W/3};function D(W,te="htk"){const K=S[te];if(!K)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof W=="number"?K(W):W.map(pe=>K(pe))}function w(W,te){const K=Float64Array.from({length:te.length-1},(Ge,_e)=>te[_e+1]-te[_e]),pe=Array.from({length:W.length},()=>new Array(te.length));for(let Ge=0;Ge<W.length;++Ge){const _e=pe[Ge];for(let De=0;De<te.length;++De)_e[De]=te[De]-W[Ge]}const be=te.length-2,Ee=Array.from({length:be},()=>new Array(W.length));for(let Ge=0;Ge<W.length;++Ge){const _e=pe[Ge];for(let De=0;De<be;++De){const he=-_e[De]/K[De],Z=_e[De+2]/K[De+1];Ee[De][Ge]=Math.max(0,Math.min(he,Z))}}return Ee}function T(W,te,K){const pe=(te-W)/(K-1);return Float64Array.from({length:K},(be,Ee)=>W+pe*Ee)}function F(W,te,K,pe,be,Ee=null,Ge="htk",_e=!1){if(Ee!==null&&Ee!=="slaney")throw new Error('norm must be one of null or "slaney"');if(W<2)throw new Error(`Require num_frequency_bins: ${W} >= 2`);if(K>pe)throw new Error(`Require min_frequency: ${K} <= max_frequency: ${pe}`);const De=v(K,Ge),he=v(pe,Ge),Z=T(De,he,te+2);let me=D(Z,Ge),we;if(_e){const et=be/((W-1)*2);we=v(Float64Array.from({length:W},(Ve,nt)=>nt*et),Ge),me=Z}else we=T(0,Math.floor(be/2),W);const xe=w(we,me);if(Ee!==null&&Ee==="slaney")for(let et=0;et<te;++et){const Ve=xe[et],nt=2/(me[et+2]-me[et]);for(let Be=0;Be<W;++Be)Ve[Be]*=nt}return xe}function E(W,te,K){const pe=new W.constructor(W.length+te+K),be=W.length-1;for(let Ee=0;Ee<W.length;++Ee)pe[te+Ee]=W[Ee];for(let Ee=1;Ee<=te;++Ee)pe[te-Ee]=W[(0,a.calculateReflectOffset)(Ee,be)];for(let Ee=1;Ee<=K;++Ee)pe[be+te+Ee]=W[(0,a.calculateReflectOffset)(be-Ee,be)];return pe}function A(W,te,K,pe,be){if(K<=0)throw new Error("reference must be greater than zero");if(pe<=0)throw new Error("min_value must be greater than zero");K=Math.max(pe,K);const Ee=Math.log10(K);for(let Ge=0;Ge<W.length;++Ge)W[Ge]=te*Math.log10(Math.max(pe,W[Ge])-Ee);if(be!==null){if(be<=0)throw new Error("db_range must be greater than zero");const Ge=(0,r.max)(W)[0]-be;for(let _e=0;_e<W.length;++_e)W[_e]=Math.max(W[_e],Ge)}return W}function L(W,te=1,K=1e-5,pe=null){return A(W,20,te,K,pe)}function I(W,te=1,K=1e-10,pe=null){return A(W,10,te,K,pe)}async function R(W,te,K,pe,{fft_length:be=null,power:Ee=1,center:Ge=!0,pad_mode:_e="reflect",onesided:De=!0,preemphasis:he=null,preemphasis_htk_flavor:Z=!0,mel_filters:me=null,mel_floor:we=1e-10,log_mel:xe=null,reference:et=1,min_value:Ve=1e-10,db_range:nt=null,remove_dc_offset:Be=null,min_num_frames:ae=null,max_num_frames:U=null,do_pad:Se=!0,transpose:ze=!1,mel_offset:Oe=0}={}){const Ye=te.length;if(be===null&&(be=K),K>be)throw Error(`frame_length (${K}) may not be larger than fft_length (${be})`);if(Ye!==K)throw new Error(`Length of the window (${Ye}) must equal frame_length (${K})`);if(pe<=0)throw new Error("hop_length must be greater than zero");if(Ee===null&&me!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(!Z)throw new Error("`preemphasis_htk_flavor=false` is not currently supported.");if(Ge)switch(_e){case"reflect":{const He=Math.floor((be-1)/2)+1;W=E(W,He,He);break}case"constant":{const He=Math.floor(be/2),je=new W.constructor(W.length+2*He);je.set(W,He),W=je;break}default:throw new Error(`pad_mode="${_e}" not implemented yet.`)}let H=Math.floor(1+Math.floor((W.length-K)/pe));ae!==null&&H<ae&&(H=ae);const Y=De?Math.floor(be/2)+1:be;let $e=H,Ie=H;U!==null&&(U>H?Se&&(Ie=U):Ie=$e=U);const fe=new r.FFT(be),Qe=new Float64Array(be),Ne=new Float64Array(fe.outputBufferSize),ut=new Float32Array(Y*Ie);for(let He=0;He<$e;++He){const je=He*pe,lt=Math.min(W.length-je,K);lt!==K&&Qe.fill(0,0,K);for(let Mt=0;Mt<lt;++Mt)Qe[Mt]=W[je+Mt];if(Be){let Mt=0;for(let Xt=0;Xt<lt;++Xt)Mt+=Qe[Xt];const Rt=Mt/lt;for(let Xt=0;Xt<lt;++Xt)Qe[Xt]-=Rt}if(he!==null){for(let Mt=lt-1;Mt>=1;--Mt)Qe[Mt]-=he*Qe[Mt-1];Qe[0]*=1-he}for(let Mt=0;Mt<te.length;++Mt)Qe[Mt]*=te[Mt];fe.realTransform(Ne,Qe);for(let Mt=0;Mt<Y;++Mt){const Rt=Mt<<1;ut[Mt*Ie+He]=Ne[Rt]**2+Ne[Rt+1]**2}}if(Ee!==null&&Ee!==2){const He=Ee/2;for(let je=0;je<ut.length;++je)ut[je]**=He}const de=me.length;let qe=await(0,u.matmul)(new u.Tensor("float32",me.flat(),[de,Y]),new u.Tensor("float32",ut,[Y,Ie]));ze&&(qe=qe.transpose(1,0));const tt=qe.data;for(let He=0;He<tt.length;++He)tt[He]=Oe+Math.max(we,tt[He]);if(Ee!==null&&xe!==null){const He=Math.min(tt.length,$e*de);switch(xe){case"log":for(let je=0;je<He;++je)tt[je]=Math.log(tt[je]);break;case"log10":for(let je=0;je<He;++je)tt[je]=Math.log10(tt[je]);break;case"dB":if(Ee===1)L(tt,et,Ve,nt);else if(Ee===2)I(tt,et,Ve,nt);else throw new Error(`Cannot use log_mel option '${xe}' with power ${Ee}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${xe}'`)}}return qe}function N(W,te,{periodic:K=!0,frame_length:pe=null,center:be=!0}={}){const Ee=K?W+1:W;let Ge;switch(te){case"boxcar":Ge=new Float64Array(Ee).fill(1);break;case"hann":case"hann_window":Ge=h(Ee);break;case"hamming":Ge=p(Ee);break;case"povey":Ge=h(Ee).map(_e=>Math.pow(_e,.85));break;default:throw new Error(`Unknown window type ${te}.`)}if(K&&(Ge=Ge.subarray(0,W)),pe===null)return Ge;if(W>pe)throw new Error(`Length of the window (${W}) may not be larger than frame_length (${pe})`);return Ge}function q(W,te){let K=44;const pe=new ArrayBuffer(K+W.length*4),be=new DataView(pe);ne(be,0,"RIFF"),be.setUint32(4,36+W.length*4,!0),ne(be,8,"WAVE"),ne(be,12,"fmt "),be.setUint32(16,16,!0),be.setUint16(20,3,!0),be.setUint16(22,1,!0),be.setUint32(24,te,!0),be.setUint32(28,te*4,!0),be.setUint16(32,4,!0),be.setUint16(34,32,!0),ne(be,36,"data"),be.setUint32(40,W.length*4,!0);for(let Ee=0;Ee<W.length;++Ee,K+=4)be.setFloat32(K,W[Ee],!0);return pe}function ne(W,te,K){for(let pe=0;pe<K.length;++pe)W.setUint8(te+pe,K.charCodeAt(pe))}class Q{constructor(te,K){this.audio=te,this.sampling_rate=K}toWav(){return q(this.audio,this.sampling_rate)}toBlob(){const te=this.toWav();return new Blob([te],{type:"audio/wav"})}async save(te){let K;if(c.apis.IS_BROWSER_ENV){if(c.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save a file from a Web Worker.");K=a.saveBlob}else if(c.apis.IS_FS_AVAILABLE)K=async(pe,be)=>{let Ee=await be.arrayBuffer();l.writeFileSync(pe,Buffer.from(Ee))};else throw new Error("Unable to save because filesystem is disabled in this environment.");await K(te,this.toBlob())}}},"./src/utils/constants.js":(e,n,t)=>{t.r(n),t.d(n,{CHAT_TEMPLATE_NAME:()=>l,CONFIG_NAME:()=>r,FEATURE_EXTRACTOR_NAME:()=>a,GENERATION_CONFIG_NAME:()=>f,GITHUB_ISSUE_URL:()=>i,IMAGE_PROCESSOR_NAME:()=>c,PROCESSOR_NAME:()=>u});const i="https://github.com/huggingface/transformers.js/issues/new/choose",r="config.json",a="preprocessor_config.json",c=a,u="processor_config.json",l="chat_template.jinja",f="generation_config.json"},"./src/utils/core.js":(e,n,t)=>{t.r(n),t.d(n,{calculateDimensions:()=>f,calculateReflectOffset:()=>_,count:()=>w,dispatchCallback:()=>i,escapeRegExp:()=>a,isIntegralNumber:()=>u,isNullishDimension:()=>l,isTypedArray:()=>c,len:()=>D,mergeArrays:()=>h,pick:()=>S,pop:()=>m,product:()=>p,reverseDictionary:()=>r,saveBlob:()=>v});function i(T,F){T&&T(F)}function r(T){return Object.fromEntries(Object.entries(T).map(([F,E])=>[E,F]))}function a(T){return T.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function c(T){var F,E,A;return((A=(E=(F=T==null?void 0:T.prototype)==null?void 0:F.__proto__)==null?void 0:E.constructor)==null?void 0:A.name)==="TypedArray"}function u(T){return Number.isInteger(T)||typeof T=="bigint"}function l(T){return T==null||T===-1}function f(T){const F=[];let E=T;for(;Array.isArray(E);)F.push(E.length),E=E[0];return F}function m(T,F,E=void 0){const A=T[F];if(A!==void 0)return delete T[F],A;if(E===void 0)throw Error(`Key ${F} does not exist in object.`);return E}function h(...T){return Array.prototype.concat.apply([],T)}function p(...T){return T.reduce((F,E)=>F.flatMap(A=>E.map(L=>[A,L])))}function _(T,F){return Math.abs((T+F)%(2*F)-F)}function v(T,F){const E=URL.createObjectURL(F),A=document.createElement("a");A.href=E,A.download=T,A.click(),A.remove(),URL.revokeObjectURL(E)}function S(T,F){return Object.assign({},...F.map(E=>{if(T[E]!==void 0)return{[E]:T[E]}}))}function D(T){let F=0;for(const E of T)++F;return F}function w(T,F){let E=0;for(const A of T)A===F&&++E;return E}},"./src/utils/data-structures.js":(e,n,t)=>{t.r(n),t.d(n,{CharTrie:()=>r,DictionarySplitter:()=>l,LRUCache:()=>f,PriorityQueue:()=>i,TokenLattice:()=>c});class i{constructor(h=(_,v)=>_>v,p=1/0){this._heap=[],this._comparator=h,this._maxSize=p}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...h){return this.extend(h)}extend(h){for(const p of h)if(this.size<this._maxSize)this._heap.push(p),this._siftUp();else{const _=this._smallest();this._comparator(p,this._heap[_])&&(this._heap[_]=p,this._siftUpFrom(_))}return this.size}pop(){const h=this.peek(),p=this.size-1;return p>0&&this._swap(0,p),this._heap.pop(),this._siftDown(),h}replace(h){const p=this.peek();return this._heap[0]=h,this._siftDown(),p}_parent(h){return(h+1>>>1)-1}_left(h){return(h<<1)+1}_right(h){return h+1<<1}_greater(h,p){return this._comparator(this._heap[h],this._heap[p])}_swap(h,p){const _=this._heap[h];this._heap[h]=this._heap[p],this._heap[p]=_}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(h){for(;h>0&&this._greater(h,this._parent(h));)this._swap(h,this._parent(h)),h=this._parent(h)}_siftDown(){let h=0;for(;this._left(h)<this.size&&this._greater(this._left(h),h)||this._right(h)<this.size&&this._greater(this._right(h),h);){const p=this._right(h)<this.size&&this._greater(this._right(h),this._left(h))?this._right(h):this._left(h);this._swap(h,p),h=p}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class r{constructor(){this.root=a.default()}extend(h){for(const p of h)this.push(p)}push(h){let p=this.root;for(const _ of h){let v=p.children.get(_);v===void 0&&(v=a.default(),p.children.set(_,v)),p=v}p.isLeaf=!0}*commonPrefixSearch(h){let p=this.root;if(p===void 0)return;let _="";for(const v of h){if(_+=v,p=p.children.get(v),p===void 0)return;p.isLeaf&&(yield _)}}}class a{constructor(h,p){this.isLeaf=h,this.children=p}static default(){return new a(!1,new Map)}}class c{constructor(h,p,_){this.chars=Array.from(h),this.len=this.chars.length,this.bosTokenId=p,this.eosTokenId=_,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const v=new u(this.bosTokenId,0,0,0,0),S=new u(this.eosTokenId,1,this.len,0,0);this.nodes.push(v.clone()),this.nodes.push(S.clone()),this.beginNodes[this.len].push(S),this.endNodes[0].push(v)}insert(h,p,_,v){const S=this.nodes.length,D=new u(v,S,h,p,_);this.beginNodes[h].push(D),this.endNodes[h+p].push(D),this.nodes.push(D)}viterbi(){const h=this.len;let p=0;for(;p<=h;){if(this.beginNodes[p].length==0)return[];for(let w of this.beginNodes[p]){w.prev=null;let T=0,F=null;for(let E of this.endNodes[p]){const A=E.backtraceScore+w.score;(F===null||A>T)&&(F=E.clone(),T=A)}if(F!==null)w.prev=F,w.backtraceScore=T;else return[]}++p}const _=[],S=this.beginNodes[h][0].prev;if(S===null)return[];let D=S.clone();for(;D.prev!==null;)_.push(D.clone()),D=D.clone().prev.clone();return _.reverse(),_}piece(h){return this.chars.slice(h.pos,h.pos+h.length).join("")}tokens(){return this.viterbi().map(p=>this.piece(p))}tokenIds(){return this.viterbi().map(p=>p.tokenId)}}class u{constructor(h,p,_,v,S){this.tokenId=h,this.nodeId=p,this.pos=_,this.length=v,this.score=S,this.prev=null,this.backtraceScore=0}clone(){const h=new u(this.tokenId,this.nodeId,this.pos,this.length,this.score);return h.prev=this.prev,h.backtraceScore=this.backtraceScore,h}}class l{constructor(h){this.trie=this._buildTrie(h)}_buildTrie(h){var _;const p=Object.create(null);for(const v of h){let S=p;for(let D=0;D<v.length;++D)S=S[_=v[D]]??(S[_]=Object.create(null));S.end=v}return p}split(h){const p=[],_=h.length;let v=0,S=0;for(;S<_;){let D=this.trie,w=null,T=S;for(;T<_&&(D=D[h[T]]);)D.end&&(w=D.end),++T;w?(S>v&&p.push(h.slice(v,S)),p.push(w),S+=w.length,v=S):++S}return v<_&&p.push(h.slice(v)),p}}class f{constructor(h){this.capacity=h,this.cache=new Map}get(h){if(!this.cache.has(h))return;const p=this.cache.get(h);return this.cache.delete(h),this.cache.set(h,p),p}put(h,p){this.cache.has(h)&&this.cache.delete(h),this.cache.set(h,p),this.cache.size>this.capacity&&this.cache.delete(this.cache.keys().next().value)}clear(){this.cache.clear()}}},"./src/utils/devices.js":(e,n,t)=>{t.r(n),t.d(n,{DEVICE_TYPES:()=>i});const i=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":(e,n,t)=>{t.r(n),t.d(n,{DATA_TYPES:()=>c,DEFAULT_DEVICE_DTYPE_MAPPING:()=>u,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>l,isWebGpuFp16Supported:()=>a});var i=t("./src/env.js"),r=t("./src/utils/devices.js");const a=function(){let f;return async function(){if(f===void 0)if(!i.apis.IS_WEBGPU_AVAILABLE)f=!1;else try{f=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{f=!1}return f}}(),c=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),u=Object.freeze({[r.DEVICE_TYPES.wasm]:c.q8}),l=Object.freeze({[c.fp32]:"",[c.fp16]:"_fp16",[c.int8]:"_int8",[c.uint8]:"_uint8",[c.q8]:"_quantized",[c.q4]:"_q4",[c.q4f16]:"_q4f16",[c.bnb4]:"_bnb4"})},"./src/utils/generic.js":(e,n,t)=>{t.r(n),t.d(n,{Callable:()=>i});const i=class{constructor(){let r=function(...a){return r._call(...a)};return Object.setPrototypeOf(r,new.target.prototype)}_call(...r){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":(e,n,t)=>{t.r(n),t.d(n,{MAX_EXTERNAL_DATA_CHUNKS:()=>u,getFile:()=>_,getModelFile:()=>T,getModelJSON:()=>E,getModelText:()=>F});var i=t("?7992"),r=t("?5af5"),a=t("./src/env.js"),c=t("./src/utils/core.js");const u=100,l={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class f{constructor(R){if(this.filePath=R,this.headers=new Headers,this.exists=i.existsSync(R),this.exists){this.status=200,this.statusText="OK";let N=i.statSync(R);this.headers.set("content-length",N.size.toString()),this.updateContentType();const q=i.createReadStream(R);this.body=new ReadableStream({start(ne){q.on("data",Q=>ne.enqueue(Q)),q.on("end",()=>ne.close()),q.on("error",Q=>ne.error(Q))},cancel(){q.destroy()}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const R=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",l[R]??"application/octet-stream")}clone(){let R=new f(this.filePath);return R.exists=this.exists,R.status=this.status,R.statusText=this.statusText,R.headers=new Headers(this.headers),R}async arrayBuffer(){return(await i.promises.readFile(this.filePath)).buffer}async blob(){const R=await i.promises.readFile(this.filePath);return new Blob([R],{type:this.headers.get("content-type")})}async text(){return await i.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function m(I,R=null,N=null){let q;try{q=new URL(I)}catch{return!1}return!(R&&!R.includes(q.protocol)||N&&!N.includes(q.hostname))}const h=/^(\b[\w\-.]+\b\/)?\b[\w\-.]{1,96}\b$/;function p(I){return!(!h.test(I)||I.includes("..")||I.includes("--")||I.endsWith(".git")||I.endsWith(".ipynb"))}async function _(I){var R,N,q,ne;if(a.env.useFS&&!m(I,["http:","https:","blob:"]))return new f(I instanceof URL?I.protocol==="file:"?I.pathname:I.toString():I);if(typeof process<"u"&&((R=process==null?void 0:process.release)==null?void 0:R.name)==="node"){const Q=!!((N=process.env)!=null&&N.TESTING_REMOTELY),W=a.env.version,te=new Headers;if(te.set("User-Agent",`transformers.js/${W}; is_ci/${Q};`),m(I,["http:","https:"],["huggingface.co","hf.co"])){const pe=((q=process.env)==null?void 0:q.HF_TOKEN)??((ne=process.env)==null?void 0:ne.HF_ACCESS_TOKEN);pe&&te.set("Authorization",`Bearer ${pe}`)}return fetch(I,{headers:te})}else return fetch(I)}const v={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function S(I,R,N){if(!N)return null;const q=v[I]??`Error (${I}) occurred while trying to load file`;throw Error(`${q}: "${R}".`)}class D{constructor(R){this.path=R}async match(R){let N=r.join(this.path,R),q=new f(N);if(q.exists)return q}async put(R,N,q=void 0){let ne=r.join(this.path,R);try{const Q=N.headers.get("Content-Length"),W=parseInt(Q??"0");let te=0;await i.promises.mkdir(r.dirname(ne),{recursive:!0});const K=i.createWriteStream(ne),pe=N.body.getReader();for(;;){const{done:be,value:Ee}=await pe.read();if(be)break;await new Promise((_e,De)=>{K.write(Ee,he=>{if(he){De(he);return}_e()})}),te+=Ee.length;const Ge=W?te/W*100:0;q==null||q({progress:Ge,loaded:te,total:W})}K.close()}catch(Q){try{await i.promises.unlink(ne)}catch{}throw Q}}}async function w(I,...R){for(let N of R)try{let q=await I.match(N);if(q)return q}catch{continue}}async function T(I,R,N=!0,q={},ne=!1){if(!a.env.allowLocalModels){if(q.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!a.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,c.dispatchCallback)(q.progress_callback,{status:"initiate",name:I,file:R});let Q;if(!Q&&a.env.useCustomCache){if(!a.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!a.env.customCache.match||!a.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");Q=a.env.customCache}if(!Q&&a.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{Q=await caches.open("transformers-cache")}catch(we){console.warn("An error occurred while opening the browser cache:",we)}}if(!Q&&a.env.useFSCache){if(!a.apis.IS_FS_AVAILABLE)throw Error("File System Cache is not available in this environment.");Q=new D(q.cache_dir??a.env.cacheDir)}const W=q.revision??"main",te=L(I,R),K=p(I),pe=K?L(a.env.localModelPath,te):te,be=L(a.env.remoteHost,a.env.remotePathTemplate.replaceAll("{model}",I).replaceAll("{revision}",encodeURIComponent(W)),R);let Ee;const Ge=Q instanceof D?W==="main"?te:L(I,W,R):be;let _e=!1,De;Q&&(De=await w(Q,pe,Ge));const he=De!==void 0;if(De===void 0){if(a.env.allowLocalModels)if(m(te,["http:","https:"])){if(q.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${te}.`);if(!a.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${te}.`)}else try{De=await _(pe),Ee=pe}catch(xe){console.warn(`Unable to load from local path "${pe}": "${xe}"`)}if(De===void 0||De.status===404){if(q.local_files_only||!a.env.allowRemoteModels){if(N)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${pe}".`);return null}if(!K)throw Error(`Local file missing at "${pe}" and download aborted due to invalid model ID "${I}".`);if(De=await _(be),De.status!==200)return S(De.status,be,N);Ee=Ge}_e=Q&&typeof Response<"u"&&De instanceof Response&&De.status===200}(0,c.dispatchCallback)(q.progress_callback,{status:"download",name:I,file:R});let Z;if(!(a.apis.IS_NODE_ENV&&ne)){let we;q.progress_callback?he&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(we=new Uint8Array(await De.arrayBuffer()),(0,c.dispatchCallback)(q.progress_callback,{status:"progress",name:I,file:R,progress:100,loaded:we.length,total:we.length})):we=await A(De,xe=>{(0,c.dispatchCallback)(q.progress_callback,{status:"progress",name:I,file:R,...xe})}):we=new Uint8Array(await De.arrayBuffer()),Z=we}if(_e&&Ee&&await Q.match(Ee)===void 0)if(Z)await Q.put(Ee,new Response(Z,{headers:De.headers})).catch(we=>{console.warn(`Unable to add response to browser cache: ${we}.`)});else{const we=q.progress_callback?xe=>(0,c.dispatchCallback)(q.progress_callback,{status:"progress",name:I,file:R,...xe}):void 0;await Q.put(Ee,De,we)}if((0,c.dispatchCallback)(q.progress_callback,{status:"done",name:I,file:R}),Z){if(!a.apis.IS_NODE_ENV&&ne)throw new Error("Cannot return path in a browser environment.");return Z}if(De instanceof f)return De.filePath;const me=await(Q==null?void 0:Q.match(Ee));if(me instanceof f)return me.filePath;if(me instanceof Response)return new Uint8Array(await me.arrayBuffer());if(typeof me=="string")return me;throw new Error("Unable to get model file path or buffer.")}async function F(I,R,N=!0,q={}){const ne=await T(I,R,N,q,!1);return ne===null?null:new TextDecoder("utf-8").decode(ne)}async function E(I,R,N=!0,q={}){const ne=await F(I,R,N,q);return ne===null?{}:JSON.parse(ne)}async function A(I,R){const N=I.headers.get("Content-Length");N===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let q=parseInt(N??"0"),ne=new Uint8Array(q),Q=0;const W=I.body.getReader();async function te(){const{done:K,value:pe}=await W.read();if(K)return;const be=Q+pe.length;if(be>q){q=be;const Ge=new Uint8Array(q);Ge.set(ne),ne=Ge}ne.set(pe,Q),Q=be;const Ee=Q/q*100;return R({progress:Ee,loaded:Q,total:q}),te()}return await te(),ne}function L(...I){return I=I.map((R,N)=>(N&&(R=R.replace(new RegExp("^/"),"")),N!==I.length-1&&(R=R.replace(new RegExp("/$"),"")),R)),I.join("/")}},"./src/utils/image.js":(e,n,t)=>{t.r(n),t.d(n,{RawImage:()=>v,load_image:()=>S});var i=t("./src/utils/core.js"),r=t("./src/utils/hub.js"),a=t("./src/env.js"),c=t("./src/utils/tensor.js"),u=t("?2b25");let l,f,m;const h=a.apis.IS_BROWSER_ENV||a.apis.IS_WEBWORKER_ENV;if(h)l=(D,w)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(D,w)},m=self.createImageBitmap,f=self.ImageData;else if(u)m=async D=>{const T=(await D.metadata()).channels,{data:F,info:E}=await D.rotate().raw().toBuffer({resolveWithObject:!0}),A=new v(new Uint8ClampedArray(F),E.width,E.height,E.channels);return T!==void 0&&T!==E.channels&&A.convert(T),A};else throw new Error("Unable to load image processing library.");const p={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},_=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class v{constructor(w,T,F,E){this.data=w,this.width=T,this.height=F,this.channels=E}get size(){return[this.width,this.height]}static async read(w){if(w instanceof v)return w;if(typeof w=="string"||w instanceof URL)return await this.fromURL(w);if(w instanceof Blob)return await this.fromBlob(w);if(typeof HTMLCanvasElement<"u"&&w instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&w instanceof OffscreenCanvas)return this.fromCanvas(w);throw new Error(`Unsupported input type: ${typeof w}`)}static fromCanvas(w){if(!h)throw new Error("fromCanvas() is only supported in browser environments.");const F=w.getContext("2d").getImageData(0,0,w.width,w.height).data;return new v(F,w.width,w.height,4)}static async fromURL(w){const T=await(0,r.getFile)(w);if(T.status!==200)throw new Error(`Unable to read image from "${w}" (${T.status} ${T.statusText})`);const F=await T.blob();return this.fromBlob(F)}static async fromBlob(w){if(h){const T=await m(w),F=l(T.width,T.height).getContext("2d");return F.drawImage(T,0,0),new this(F.getImageData(0,0,T.width,T.height).data,T.width,T.height,4)}else{const T=u(await w.arrayBuffer());return await m(T)}}static fromTensor(w,T="CHW"){if(w.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${w.dims.length} dimensions.`);if(T==="CHW")w=w.transpose(1,2,0);else if(T!=="HWC")throw new Error(`Unsupported channel format: ${T}`);if(!(w.data instanceof Uint8ClampedArray||w.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${w.type}`);switch(w.dims[2]){case 1:case 2:case 3:case 4:return new v(w.data,w.dims[1],w.dims[0],w.dims[2]);default:throw new Error(`Unsupported number of channels: ${w.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const w=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let T=0,F=0;T<this.data.length;T+=this.channels){const E=this.data[T],A=this.data[T+1],L=this.data[T+2];w[F++]=Math.round(.2989*E+.587*A+.114*L)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(w,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const w=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let T=0,F=0;T<this.data.length;++T)w[F++]=this.data[T],w[F++]=this.data[T],w[F++]=this.data[T];break;case 4:for(let T=0,F=0;T<this.data.length;T+=4)w[F++]=this.data[T],w[F++]=this.data[T+1],w[F++]=this.data[T+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(w,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const w=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let T=0,F=0;T<this.data.length;++T)w[F++]=this.data[T],w[F++]=this.data[T],w[F++]=this.data[T],w[F++]=255;break;case 3:for(let T=0,F=0;T<this.data.length;T+=3)w[F++]=this.data[T],w[F++]=this.data[T+1],w[F++]=this.data[T+2],w[F++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(w,this.width,this.height,4)}putAlpha(w){if(w.width!==this.width||w.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${w.width}x${w.height}`);if(w.channels!==1)throw new Error(`Expected mask to have 1 channel, but got ${w.channels}`);const T=this.data,F=w.data,E=this.width*this.height;if(this.channels===3){const A=new Uint8ClampedArray(E*4);for(let L=0,I=0,R=0;L<E;++L)A[R++]=T[I++],A[R++]=T[I++],A[R++]=T[I++],A[R++]=F[L];return this._update(A,this.width,this.height,4)}else if(this.channels===4){for(let A=0;A<E;++A)T[4*A+3]=F[A];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(w,T,{resample:F=2}={}){if(this.width===w&&this.height===T)return this;let E=p[F]??F;const A=(0,i.isNullishDimension)(w),L=(0,i.isNullishDimension)(T);if(A&&L)return this;if(A?w=T/this.height*this.width:L&&(T=w/this.width*this.height),h){const I=this.channels,R=this.toCanvas(),N=l(w,T).getContext("2d");return N.drawImage(R,0,0,w,T),new v(N.getImageData(0,0,w,T).data,w,T,4).convert(I)}else{let I=this.toSharp();switch(E){case"box":case"hamming":(E==="box"||E==="hamming")&&(console.warn(`Resampling method ${E} is not yet supported. Using bilinear instead.`),E="bilinear");case"nearest":case"bilinear":case"bicubic":I=I.affine([w/this.width,0,0,T/this.height],{interpolator:E});break;case"lanczos":I=I.resize({width:w,height:T,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${E} is not supported.`)}return await m(I)}}async pad([w,T,F,E]){if(w=Math.max(w,0),T=Math.max(T,0),F=Math.max(F,0),E=Math.max(E,0),w===0&&T===0&&F===0&&E===0)return this;if(h){const A=this.channels,L=this.toCanvas(),I=this.width+w+T,R=this.height+F+E,N=l(I,R).getContext("2d");return N.drawImage(L,0,0,this.width,this.height,w,F,this.width,this.height),new v(N.getImageData(0,0,I,R).data,I,R,4).convert(A)}else{const A=this.toSharp().extend({left:w,right:T,top:F,bottom:E});return await m(A)}}async crop([w,T,F,E]){if(w=Math.max(w,0),T=Math.max(T,0),F=Math.min(F,this.width-1),E=Math.min(E,this.height-1),w===0&&T===0&&F===this.width-1&&E===this.height-1)return this;const A=F-w+1,L=E-T+1;if(h){const I=this.channels,R=this.toCanvas(),N=l(A,L).getContext("2d");return N.drawImage(R,w,T,A,L,0,0,A,L),new v(N.getImageData(0,0,A,L).data,A,L,4).convert(I)}else{const I=this.toSharp().extract({left:w,top:T,width:A,height:L});return await m(I)}}async center_crop(w,T){if(this.width===w&&this.height===T)return this;const F=(this.width-w)/2,E=(this.height-T)/2;if(h){const A=this.channels,L=this.toCanvas(),I=l(w,T).getContext("2d");let R=0,N=0,q=0,ne=0;return F>=0?R=F:q=-F,E>=0?N=E:ne=-E,I.drawImage(L,R,N,w,T,q,ne,w,T),new v(I.getImageData(0,0,w,T).data,w,T,4).convert(A)}else{let A=this.toSharp();if(F>=0&&E>=0)A=A.extract({left:Math.floor(F),top:Math.floor(E),width:w,height:T});else if(F<=0&&E<=0){const L=Math.floor(-E),I=Math.floor(-F);A=A.extend({top:L,left:I,right:w-this.width-I,bottom:T-this.height-L})}else{let L=[0,0],I=0;E<0?(L[0]=Math.floor(-E),L[1]=T-this.height-L[0]):I=Math.floor(E);let R=[0,0],N=0;F<0?(R[0]=Math.floor(-F),R[1]=w-this.width-R[0]):N=Math.floor(F),A=A.extend({top:L[0],bottom:L[1],left:R[0],right:R[1]}).extract({left:N,top:I,width:w,height:T})}return await m(A)}}async toBlob(w="image/png",T=1){if(!h)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:w,quality:T})}toTensor(w="CHW"){let T=new c.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(w!=="HWC")if(w==="CHW")T=T.permute(2,0,1);else throw new Error(`Unsupported channel format: ${w}`);return T}toCanvas(){if(!h)throw new Error("toCanvas() is only supported in browser environments.");const w=this.clone().rgba(),T=l(w.width,w.height),F=new f(w.data,w.width,w.height);return T.getContext("2d").putImageData(F,0,0),T}split(){const{data:w,width:T,height:F,channels:E}=this,A=w.constructor,L=w.length/E,I=Array.from({length:E},()=>new A(L));for(let R=0;R<L;++R){const N=E*R;for(let q=0;q<E;++q)I[q][R]=w[N+q]}return I.map(R=>new v(R,T,F,1))}_update(w,T,F,E=null){return this.data=w,this.width=T,this.height=F,E!==null&&(this.channels=E),this}clone(){return new v(this.data.slice(),this.width,this.height,this.channels)}convert(w){if(this.channels===w)return this;switch(w){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(w){if(h){if(a.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const T=w.split(".").pop().toLowerCase(),F=_.get(T)??"image/png",E=await this.toBlob(F);(0,i.saveBlob)(w,E)}else{if(a.apis.IS_FS_AVAILABLE)return await this.toSharp().toFile(w);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(h)throw new Error("toSharp() is only supported in server-side environments.");return u(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}const S=v.read.bind(v)},"./src/utils/maths.js":(e,n,t)=>{t.r(n),t.d(n,{FFT:()=>S,bankers_round:()=>T,cos_sim:()=>l,dot:()=>u,dynamic_time_warping:()=>F,interpolate_data:()=>i,log_softmax:()=>c,magnitude:()=>f,max:()=>h,medianFilter:()=>D,min:()=>m,permute_data:()=>r,round:()=>w,softmax:()=>a});function i(E,[A,L,I],[R,N],q="bilinear",ne=!1){const Q=N/I,W=R/L,te=new E.constructor(R*N*A),K=L*I,pe=R*N;for(let be=0;be<R;++be)for(let Ee=0;Ee<N;++Ee){const Ge=be*N+Ee,_e=(Ee+.5)/Q-.5,De=(be+.5)/W-.5;let he=Math.floor(_e),Z=Math.floor(De);const me=Math.min(he+1,I-1),we=Math.min(Z+1,L-1);he=Math.max(he,0),Z=Math.max(Z,0);const xe=_e-he,et=De-Z,Ve=(1-xe)*(1-et),nt=xe*(1-et),Be=(1-xe)*et,ae=xe*et,U=Z*I,Se=we*I,ze=U+he,Oe=U+me,Ye=Se+he,H=Se+me;for(let Y=0;Y<A;++Y){const $e=Y*K;te[Y*pe+Ge]=Ve*E[$e+ze]+nt*E[$e+Oe]+Be*E[$e+Ye]+ae*E[$e+H]}}return te}function r(E,A,L){const I=new Array(L.length),R=new Array(L.length);for(let ne=L.length-1,Q=1;ne>=0;--ne)R[ne]=Q,I[ne]=A[L[ne]],Q*=I[ne];const N=L.map((ne,Q)=>R[L.indexOf(Q)]),q=new E.constructor(E.length);for(let ne=0;ne<E.length;++ne){let Q=0;for(let W=A.length-1,te=ne;W>=0;--W)Q+=te%A[W]*N[W],te=Math.floor(te/A[W]);q[Q]=E[ne]}return[q,I]}function a(E){const A=h(E)[0],L=E.map(N=>Math.exp(N-A)),I=L.reduce((N,q)=>N+q,0);return L.map(N=>N/I)}function c(E){const A=h(E)[0];let L=0;for(let N=0;N<E.length;++N)L+=Math.exp(E[N]-A);const I=Math.log(L);return E.map(N=>N-A-I)}function u(E,A){let L=0;for(let I=0;I<E.length;++I)L+=E[I]*A[I];return L}function l(E,A){const L=u(E,A),I=f(E),R=f(A);return L/(I*R)}function f(E){return Math.sqrt(E.reduce((A,L)=>A+L*L,0))}function m(E){if(E.length===0)throw Error("Array must not be empty");let A=E[0],L=0;for(let I=1;I<E.length;++I)E[I]<A&&(A=E[I],L=I);return[A,L]}function h(E){if(E.length===0)throw Error("Array must not be empty");let A=E[0],L=0;for(let I=1;I<E.length;++I)E[I]>A&&(A=E[I],L=I);return[A,L]}function p(E){return E>0&&(E&E-1)===0}class _{constructor(A){if(this.size=A|0,this.size<=1||!p(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=A<<1,this.table=new Float64Array(this.size*2);for(let I=0;I<this.table.length;I+=2){const R=Math.PI*I/this.size;this.table[I]=Math.cos(R),this.table[I+1]=-Math.sin(R)}let L=0;for(let I=1;this.size>I;I<<=1)++L;this._width=L%2===0?L-1:L,this._bitrev=new Int32Array(1<<this._width);for(let I=0;I<this._bitrev.length;++I){this._bitrev[I]=0;for(let R=0;R<this._width;R+=2){const N=this._width-R-2;this._bitrev[I]|=(I>>>R&3)<<N}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(A,L){const I=L||new Array(A.length>>>1);for(let R=0;R<A.length;R+=2)I[R>>>1]=A[R];return I}toComplexArray(A,L){const I=L||this.createComplexArray();for(let R=0;R<I.length;R+=2)I[R]=A[R>>>1],I[R+1]=0;return I}transform(A,L){if(A===L)throw new Error("Input and output buffers must be different");this._transform4(A,L,1)}realTransform(A,L){if(A===L)throw new Error("Input and output buffers must be different");this._realTransform4(A,L,1)}inverseTransform(A,L){if(A===L)throw new Error("Input and output buffers must be different");this._transform4(A,L,-1);for(let I=0;I<A.length;++I)A[I]/=this.size}_transform4(A,L,I){const R=this._csize;let q=1<<this._width,ne=R/q<<1,Q,W;const te=this._bitrev;if(ne===4)for(Q=0,W=0;Q<R;Q+=ne,++W){const pe=te[W];this._singleTransform2(L,A,Q,pe,q)}else for(Q=0,W=0;Q<R;Q+=ne,++W){const pe=te[W];this._singleTransform4(L,A,Q,pe,q,I)}const K=this.table;for(q>>=2;q>=2;q>>=2){ne=R/q<<1;const pe=ne>>>2;for(Q=0;Q<R;Q+=ne){const be=Q+pe-1;for(let Ee=Q,Ge=0;Ee<be;Ee+=2,Ge+=q){const _e=Ee,De=_e+pe,he=De+pe,Z=he+pe,me=A[_e],we=A[_e+1],xe=A[De],et=A[De+1],Ve=A[he],nt=A[he+1],Be=A[Z],ae=A[Z+1],U=K[Ge],Se=I*K[Ge+1],ze=xe*U-et*Se,Oe=xe*Se+et*U,Ye=K[2*Ge],H=I*K[2*Ge+1],Y=Ve*Ye-nt*H,$e=Ve*H+nt*Ye,Ie=K[3*Ge],fe=I*K[3*Ge+1],Qe=Be*Ie-ae*fe,Ne=Be*fe+ae*Ie,ut=me+Y,de=we+$e,qe=me-Y,tt=we-$e,He=ze+Qe,je=Oe+Ne,lt=I*(ze-Qe),Mt=I*(Oe-Ne);A[_e]=ut+He,A[_e+1]=de+je,A[De]=qe+Mt,A[De+1]=tt-lt,A[he]=ut-He,A[he+1]=de-je,A[Z]=qe-Mt,A[Z+1]=tt+lt}}}}_singleTransform2(A,L,I,R,N){const q=A[R],ne=A[R+1],Q=A[R+N],W=A[R+N+1];L[I]=q+Q,L[I+1]=ne+W,L[I+2]=q-Q,L[I+3]=ne-W}_singleTransform4(A,L,I,R,N,q){const ne=N*2,Q=N*3,W=A[R],te=A[R+1],K=A[R+N],pe=A[R+N+1],be=A[R+ne],Ee=A[R+ne+1],Ge=A[R+Q],_e=A[R+Q+1],De=W+be,he=te+Ee,Z=W-be,me=te-Ee,we=K+Ge,xe=pe+_e,et=q*(K-Ge),Ve=q*(pe-_e);L[I]=De+we,L[I+1]=he+xe,L[I+2]=Z+Ve,L[I+3]=me-et,L[I+4]=De-we,L[I+5]=he-xe,L[I+6]=Z-Ve,L[I+7]=me+et}_realTransform4(A,L,I){const R=this._csize;let q=1<<this._width,ne=R/q<<1,Q,W;const te=this._bitrev;if(ne===4)for(Q=0,W=0;Q<R;Q+=ne,++W){const be=te[W];this._singleRealTransform2(L,A,Q,be>>>1,q>>>1)}else for(Q=0,W=0;Q<R;Q+=ne,++W){const be=te[W];this._singleRealTransform4(L,A,Q,be>>>1,q>>>1,I)}const K=this.table;for(q>>=2;q>=2;q>>=2){ne=R/q<<1;const be=ne>>>1,Ee=be>>>1,Ge=Ee>>>1;for(Q=0;Q<R;Q+=ne)for(let _e=0,De=0;_e<=Ge;_e+=2,De+=q){const he=Q+_e,Z=he+Ee,me=Z+Ee,we=me+Ee,xe=A[he],et=A[he+1],Ve=A[Z],nt=A[Z+1],Be=A[me],ae=A[me+1],U=A[we],Se=A[we+1],ze=xe,Oe=et,Ye=K[De],H=I*K[De+1],Y=Ve*Ye-nt*H,$e=Ve*H+nt*Ye,Ie=K[2*De],fe=I*K[2*De+1],Qe=Be*Ie-ae*fe,Ne=Be*fe+ae*Ie,ut=K[3*De],de=I*K[3*De+1],qe=U*ut-Se*de,tt=U*de+Se*ut,He=ze+Qe,je=Oe+Ne,lt=ze-Qe,Mt=Oe-Ne,Rt=Y+qe,Xt=$e+tt,wn=I*(Y-qe),xn=I*($e-tt);if(A[he]=He+Rt,A[he+1]=je+Xt,A[Z]=lt+xn,A[Z+1]=Mt-wn,_e===0){A[me]=He-Rt,A[me+1]=je-Xt;continue}if(_e===Ge)continue;const cn=Q+Ee-_e,jn=Q+be-_e;A[cn]=lt-I*xn,A[cn+1]=-Mt-I*wn,A[jn]=He-I*Rt,A[jn+1]=-je+I*Xt}}const pe=R>>>1;for(let be=2;be<pe;be+=2)A[R-be]=A[be],A[R-be+1]=-A[be+1]}_singleRealTransform2(A,L,I,R,N){const q=A[R],ne=A[R+N];L[I]=q+ne,L[I+1]=0,L[I+2]=q-ne,L[I+3]=0}_singleRealTransform4(A,L,I,R,N,q){const ne=N*2,Q=N*3,W=A[R],te=A[R+N],K=A[R+ne],pe=A[R+Q],be=W+K,Ee=W-K,Ge=te+pe,_e=q*(te-pe);L[I]=be+Ge,L[I+1]=0,L[I+2]=Ee,L[I+3]=-_e,L[I+4]=be-Ge,L[I+5]=0,L[I+6]=Ee,L[I+7]=_e}}class v{constructor(A){const L=2*(A-1),I=2*(2*A-1),R=2**Math.ceil(Math.log2(I));this.bufferSize=R,this._a=L;const N=new Float64Array(I),q=new Float64Array(R);this._chirpBuffer=new Float64Array(R),this._buffer1=new Float64Array(R),this._buffer2=new Float64Array(R),this._outBuffer1=new Float64Array(R),this._outBuffer2=new Float64Array(R);const ne=-2*Math.PI/A,Q=Math.cos(ne),W=Math.sin(ne);for(let te=0;te<I>>1;++te){const K=(te+1-A)**2/2,pe=Math.sqrt(Q**2+W**2)**K,be=K*Math.atan2(W,Q),Ee=2*te;N[Ee]=pe*Math.cos(be),N[Ee+1]=pe*Math.sin(be),q[Ee]=N[Ee],q[Ee+1]=-N[Ee+1]}this._slicedChirpBuffer=N.subarray(L,I),this._f=new _(R>>1),this._f.transform(this._chirpBuffer,q)}_transform(A,L,I){const R=this._buffer1,N=this._buffer2,q=this._outBuffer1,ne=this._outBuffer2,Q=this._chirpBuffer,W=this._slicedChirpBuffer,te=this._a;if(I)for(let K=0;K<W.length;K+=2){const pe=K+1,be=K>>1,Ee=L[be];R[K]=Ee*W[K],R[pe]=Ee*W[pe]}else for(let K=0;K<W.length;K+=2){const pe=K+1;R[K]=L[K]*W[K]-L[pe]*W[pe],R[pe]=L[K]*W[pe]+L[pe]*W[K]}this._f.transform(q,R);for(let K=0;K<Q.length;K+=2){const pe=K+1;N[K]=q[K]*Q[K]-q[pe]*Q[pe],N[pe]=q[K]*Q[pe]+q[pe]*Q[K]}this._f.inverseTransform(ne,N);for(let K=0;K<ne.length;K+=2){const pe=ne[K+te],be=ne[K+te+1],Ee=W[K],Ge=W[K+1];A[K]=pe*Ee-be*Ge,A[K+1]=pe*Ge+be*Ee}}transform(A,L){this._transform(A,L,!1)}realTransform(A,L){this._transform(A,L,!0)}}class S{constructor(A){this.fft_length=A,this.isPowerOfTwo=p(A),this.isPowerOfTwo?(this.fft=new _(A),this.outputBufferSize=2*A):(this.fft=new v(A),this.outputBufferSize=this.fft.bufferSize)}realTransform(A,L){this.fft.realTransform(A,L)}transform(A,L){this.fft.transform(A,L)}}function D(E,A){if(A%2===0||A<=0)throw new Error("Window size must be a positive odd number");const L=new E.constructor(E.length),I=new E.constructor(A),R=Math.floor(A/2);for(let N=0;N<E.length;++N){let q=0;for(let ne=-R;ne<=R;++ne){let Q=N+ne;Q<0?Q=Math.abs(Q):Q>=E.length&&(Q=2*(E.length-1)-Q),I[q++]=E[Q]}I.sort(),L[N]=I[R]}return L}function w(E,A){const L=Math.pow(10,A);return Math.round(E*L)/L}function T(E){const A=Math.round(E);return Math.abs(E)%1===.5?A%2===0?A:A-1:A}function F(E){const A=E.length,L=E[0].length,I=[A+1,L+1],R=Array.from({length:I[0]},()=>Array(I[1]).fill(1/0));R[0][0]=0;const N=Array.from({length:I[0]},()=>Array(I[1]).fill(-1));for(let te=1;te<I[1];++te)for(let K=1;K<I[0];++K){const pe=R[K-1][te-1],be=R[K-1][te],Ee=R[K][te-1];let Ge,_e;pe<be&&pe<Ee?(Ge=pe,_e=0):be<pe&&be<Ee?(Ge=be,_e=1):(Ge=Ee,_e=2),R[K][te]=E[K-1][te-1]+Ge,N[K][te]=_e}for(let te=0;te<I[1];++te)N[0][te]=2;for(let te=0;te<I[0];++te)N[te][0]=1;let q=A,ne=L,Q=[],W=[];for(;q>0||ne>0;)switch(Q.push(q-1),W.push(ne-1),N[q][ne]){case 0:--q,--ne;break;case 1:--q;break;case 2:--ne;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${q}, ${ne}]. Please file a bug report.`)}return Q.reverse(),W.reverse(),[Q,W]}},"./src/utils/tensor.js":(e,n,t)=>{t.r(n),t.d(n,{DataTypeMap:()=>c,Tensor:()=>u,cat:()=>L,full:()=>W,full_like:()=>te,interpolate:()=>m,interpolate_4d:()=>h,layer_norm:()=>T,matmul:()=>p,mean:()=>q,mean_pooling:()=>w,ones:()=>K,ones_like:()=>pe,permute:()=>f,quantize_embeddings:()=>De,rand:()=>Ge,randn:()=>_e,rfft:()=>_,slice:()=>D,stack:()=>I,std_mean:()=>N,topk:()=>v,zeros:()=>be,zeros_like:()=>Ee});var i=t("./src/utils/maths.js"),r=t("./src/backends/onnx.js"),a=t("./src/ops/registry.js");const c=Object.freeze({float32:Float32Array,float16:typeof Float16Array<"u"?Float16Array:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class u{constructor(...Z){Ce(this,"ort_tensor");return(0,r.isONNXTensor)(Z[0])?this.ort_tensor=Z[0]:this.ort_tensor=new r.Tensor(Z[0],Z[1],Z[2]),new Proxy(this,{get:(me,we)=>{if(typeof we=="string"){let xe=Number(we);if(Number.isInteger(xe))return me._getitem(xe)}return me[we]},set:(me,we,xe)=>me[we]=xe})}get dims(){return this.ort_tensor.dims}set dims(Z){this.ort_tensor.dims=Z}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[Z,...me]=this.dims;if(me.length>0){const we=me.reduce((xe,et)=>xe*et);for(let xe=0;xe<Z;++xe)yield this._subarray(xe,we,me)}else yield*this.data}_getitem(Z){const[me,...we]=this.dims;if(Z=A(Z,me),we.length>0){const xe=we.reduce((et,Ve)=>et*Ve);return this._subarray(Z,xe,we)}else return new u(this.type,[this.data[Z]],we)}indexOf(Z){const me=this.data;for(let we=0;we<me.length;++we)if(me[we]==Z)return we;return-1}_subarray(Z,me,we){const xe=Z*me,et=(Z+1)*me,Ve="subarray"in this.data?this.data.subarray(xe,et):this.data.slice(xe,et);return new u(this.type,Ve,we)}item(){const Z=this.data;if(Z.length!==1)throw new Error(`a Tensor with ${Z.length} elements cannot be converted to Scalar`);return Z[0]}tolist(){return l(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const Z=this.data;for(let me=0;me<Z.length;++me)Z[me]=1/(1+Math.exp(-Z[me]));return this}map(Z){return this.clone().map_(Z)}map_(Z){const me=this.data;for(let we=0;we<me.length;++we)me[we]=Z(me[we],we,me);return this}mul(Z){return this.clone().mul_(Z)}mul_(Z){const me=this.data;for(let we=0;we<me.length;++we)me[we]*=Z;return this}div(Z){return this.clone().div_(Z)}div_(Z){const me=this.data;for(let we=0;we<me.length;++we)me[we]/=Z;return this}add(Z){return this.clone().add_(Z)}add_(Z){const me=this.data;for(let we=0;we<me.length;++we)me[we]+=Z;return this}sub(Z){return this.clone().sub_(Z)}sub_(Z){const me=this.data;for(let we=0;we<me.length;++we)me[we]-=Z;return this}clone(){return new u(this.type,this.data.slice(),this.dims.slice())}slice(...Z){const me=[],we=[];for(let U=0;U<this.dims.length;++U){let Se=Z[U];if(Se==null)we.push([0,this.dims[U]]),me.push(this.dims[U]);else if(typeof Se=="number")Se=A(Se,this.dims[U],U),we.push([Se,Se+1]);else if(Array.isArray(Se)&&Se.length===2){let[ze,Oe]=Se;if(ze=ze===null?0:A(ze,this.dims[U],U,!1),Oe=Oe===null?this.dims[U]:A(Oe,this.dims[U],U,!1),ze>Oe)throw new Error(`Invalid slice: ${Se}`);const Ye=[Math.max(ze,0),Math.min(Oe,this.dims[U])];we.push(Ye),me.push(Ye[1]-Ye[0])}else throw new Error(`Invalid slice: ${Se}`)}const xe=we.map(([U,Se])=>Se-U),et=xe.reduce((U,Se)=>U*Se),Ve=this.data,nt=new Ve.constructor(et),Be=this.stride();let ae=!0;for(let U=1;U<xe.length;++U)if(we[U][0]!==0||we[U][1]!==this.dims[U]){ae=!1;break}if(ae){const U=we[0][0]*Be[0],Se=we[0][1]*Be[0];if(ArrayBuffer.isView(Ve))nt.set(Ve.subarray(U,Se));else if(Array.isArray(Ve)){const ze=Ve.slice(U,Se);for(let Oe=0;Oe<ze.length;++Oe)nt[Oe]=ze[Oe]}else throw new Error("Unsupported data type for slicing")}else for(let U=0;U<et;++U){let Se=0;for(let ze=xe.length-1,Oe=U;ze>=0;--ze){const Ye=xe[ze];Se+=(Oe%Ye+we[ze][0])*Be[ze],Oe=Math.floor(Oe/Ye)}nt[U]=Ve[Se]}return new u(this.type,nt,me)}permute(...Z){return f(this,Z)}transpose(...Z){return this.permute(...Z)}sum(Z=null,me=!1){return this.norm(1,Z,me)}norm(Z="fro",me=null,we=!1){if(Z==="fro")Z=2;else if(typeof Z=="string")throw Error(`Unsupported norm: ${Z}`);const xe=this.data,et=(ae,U)=>ae+U**Z;if(me===null){const ae=xe.reduce(et,0)**(1/Z);return new u(this.type,[ae],[])}const[Ve,nt,Be]=R(et,this,me,we);if(Z!==1)for(let ae=0;ae<nt.length;++ae)nt[ae]=nt[ae]**(1/Z);return new u(Ve,nt,Be)}normalize_(Z=2,me=1){me=A(me,this.dims.length);const we=this.norm(Z,me,!0),xe=this.data,et=we.data;for(let Ve=0;Ve<xe.length;++Ve){let nt=0;for(let Be=this.dims.length-1,ae=Ve,U=1;Be>=0;--Be){const Se=this.dims[Be];if(Be!==me){const ze=ae%Se;nt+=ze*U,U*=this.dims[Be]}ae=Math.floor(ae/Se)}xe[Ve]/=et[nt]}return this}normalize(Z=2,me=1){return this.clone().normalize_(Z,me)}stride(){return ne(this.dims)}squeeze(Z=null){return new u(this.type,this.data,F(this.dims,Z))}squeeze_(Z=null){return this.dims=F(this.dims,Z),this}unsqueeze(Z=null){return new u(this.type,this.data,E(this.dims,Z))}unsqueeze_(Z=null){return this.dims=E(this.dims,Z),this}flatten_(Z=0,me=-1){me=(me+this.dims.length)%this.dims.length;let we=this.dims.slice(0,Z),xe=this.dims.slice(Z,me+1),et=this.dims.slice(me+1);return this.dims=[...we,xe.reduce((Ve,nt)=>Ve*nt,1),...et],this}flatten(Z=0,me=-1){return this.clone().flatten_(Z,me)}view(...Z){let me=-1;for(let xe=0;xe<Z.length;++xe)if(Z[xe]===-1){if(me!==-1)throw new Error("Only one dimension can be inferred");me=xe}const we=this.data;if(me!==-1){const xe=Z.reduce((et,Ve,nt)=>nt!==me?et*Ve:et,1);Z[me]=we.length/xe}return new u(this.type,we,Z)}neg_(){const Z=this.data;for(let me=0;me<Z.length;++me)Z[me]=-Z[me];return this}neg(){return this.clone().neg_()}gt(Z){const me=new Uint8Array(this.data.length),we=this.data;for(let xe=0;xe<we.length;++xe)me[xe]=we[xe]>Z?1:0;return new u("bool",me,this.dims)}lt(Z){const me=new Uint8Array(this.data.length),we=this.data;for(let xe=0;xe<we.length;++xe)me[xe]=we[xe]<Z?1:0;return new u("bool",me,this.dims)}clamp_(Z,me){const we=this.data;for(let xe=0;xe<we.length;++xe)we[xe]=Math.min(Math.max(we[xe],Z),me);return this}clamp(Z,me){return this.clone().clamp_(Z,me)}round_(){const Z=this.data;for(let me=0;me<Z.length;++me)Z[me]=Math.round(Z[me]);return this}round(){return this.clone().round_()}mean(Z=null,me=!1){return q(this,Z,me)}min(Z=null,me=!1){if(Z===null){const Ve=(0,i.min)(this.data)[0];return new u(this.type,[Ve],[])}const[we,xe,et]=R((Ve,nt)=>Math.min(Ve,nt),this,Z,me,1/0);return new u(we,xe,et)}max(Z=null,me=!1){if(Z===null){const Ve=(0,i.max)(this.data)[0];return new u(this.type,[Ve],[])}const[we,xe,et]=R((Ve,nt)=>Math.max(Ve,nt),this,Z,me,-1/0);return new u(we,xe,et)}argmin(Z=null,me=!1){if(Z!==null)throw new Error("`dim !== null` not yet implemented.");const we=(0,i.min)(this.data)[1];return new u("int64",[BigInt(we)],[])}argmax(Z=null,me=!1){if(Z!==null)throw new Error("`dim !== null` not yet implemented.");const we=(0,i.max)(this.data)[1];return new u("int64",[BigInt(we)],[])}to(Z){if(this.type===Z)return this;if(!c.hasOwnProperty(Z))throw new Error(`Unsupported type: ${Z}`);let me;const we=["int64","uint64"].includes(this.type),xe=["int64","uint64"].includes(Z);return we&&!xe?me=Number:!we&&xe&&(["float16","float32","float64"].includes(this.type)?me=et=>BigInt(Math.floor(et)):me=BigInt),new u(Z,c[Z].from(this.data,me),this.dims)}}function l(he,Z){const me=he.length,we=Z.reduce((et,Ve)=>et*Ve);if(me!==we)throw Error(`cannot reshape array of size ${me} into shape (${Z})`);let xe=he;for(let et=Z.length-1;et>=0;et--)xe=xe.reduce((Ve,nt)=>{let Be=Ve[Ve.length-1];return Be.length<Z[et]?Be.push(nt):Ve.push([nt]),Ve},[[]]);return xe[0]}function f(he,Z){const[me,we]=(0,i.permute_data)(he.data,he.dims,Z);return new u(he.type,me,we)}function m(he,[Z,me],we="bilinear",xe=!1){const et=he.dims.at(-3)??1,Ve=he.dims.at(-2),nt=he.dims.at(-1);let Be=(0,i.interpolate_data)(he.data,[et,Ve,nt],[Z,me],we,xe);return new u(he.type,Be,[et,Z,me])}async function h(he,{size:Z=null,mode:me="bilinear"}={}){if(he.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!Z)throw new Error("`interpolate_4d` requires a `size` argument.");let we;if(Z.length===2)we=[...he.dims.slice(0,2),...Z];else if(Z.length===3)we=[he.dims[0],...Z];else if(Z.length===4)we=Z;else throw new Error("`size` must be of length 2, 3, or 4.");let xe;if(me==="nearest")xe=await a.TensorOpRegistry.nearest_interpolate_4d;else if(me==="bilinear")xe=await a.TensorOpRegistry.bilinear_interpolate_4d;else if(me==="bicubic")xe=await a.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${me}`);const et=new u("int64",new BigInt64Array(we.map(BigInt)),[we.length]);return await xe({x:he,s:et})}async function p(he,Z){return await(await a.TensorOpRegistry.matmul)({a:he,b:Z})}async function _(he,Z){return await(await a.TensorOpRegistry.rfft)({x:he,a:Z})}async function v(he,Z){const me=await a.TensorOpRegistry.top_k;return Z==null?Z=he.dims.at(-1):Z=Math.min(Z,he.dims.at(-1)),await me({x:he,k:new u("int64",[BigInt(Z)],[1])})}const S=he=>new u("int64",he,[he.length]);async function D(he,Z,me,we,xe){return await(await a.TensorOpRegistry.slice)({x:he,s:S(Z),e:S(me),a:S(we),t:S(xe??new Array(we.length).fill(1))})}function w(he,Z){const me=he.data,we=Z.data,xe=[he.dims[0],he.dims[2]],et=new me.constructor(xe[0]*xe[1]),[Ve,nt,Be]=he.dims;let ae=0;for(let U=0;U<Ve;++U){const Se=U*Be*nt;for(let ze=0;ze<Be;++ze){let Oe=0,Ye=0;const H=U*nt,Y=Se+ze;for(let Ie=0;Ie<nt;++Ie){const fe=Number(we[H+Ie]);Ye+=fe,Oe+=me[Y+Ie*Be]*fe}const $e=Oe/Ye;et[ae++]=$e}}return new u(he.type,et,xe)}function T(he,Z,{eps:me=1e-5}={}){if(he.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[we,xe]=he.dims;if(Z.length!==1&&Z[0]!==xe)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[et,Ve]=N(he,1,0,!0),nt=et.data,Be=Ve.data,ae=he.data,U=new ae.constructor(ae.length);for(let Se=0;Se<we;++Se){const ze=Se*xe;for(let Oe=0;Oe<xe;++Oe){const Ye=ze+Oe;U[Ye]=(ae[Ye]-Be[Se])/(nt[Se]+me)}}return new u(he.type,U,he.dims)}function F(he,Z){return he=he.slice(),Z===null?he=he.filter(me=>me!==1):typeof Z=="number"?he[Z]===1&&he.splice(Z,1):Array.isArray(Z)&&(he=he.filter((me,we)=>me!==1||!Z.includes(we))),he}function E(he,Z){return Z=A(Z,he.length+1),he=he.slice(),he.splice(Z,0,1),he}function A(he,Z,me=null,we=!0){if(he<-Z||he>=Z){if(we)throw new Error(`IndexError: index ${he} is out of bounds for dimension${me===null?"":" "+me} with size ${Z}`);return he<-Z?0:Z}return he<0&&(he=(he%Z+Z)%Z),he}function L(he,Z=0){Z=A(Z,he[0].dims.length);const me=he[0].dims.slice();me[Z]=he.reduce((Ve,nt)=>Ve+nt.dims[Z],0);const we=me.reduce((Ve,nt)=>Ve*nt,1),xe=new he[0].data.constructor(we),et=he[0].type;if(Z===0){let Ve=0;for(const nt of he){const Be=nt.data;xe.set(Be,Ve),Ve+=Be.length}}else{let Ve=0;for(let nt=0;nt<he.length;++nt){const{data:Be,dims:ae}=he[nt];for(let U=0;U<Be.length;++U){let Se=0;for(let ze=ae.length-1,Oe=U,Ye=1;ze>=0;--ze){const H=ae[ze];let Y=Oe%H;ze===Z&&(Y+=Ve),Se+=Y*Ye,Ye*=me[ze],Oe=Math.floor(Oe/H)}xe[Se]=Be[U]}Ve+=ae[Z]}}return new u(et,xe,me)}function I(he,Z=0){return L(he.map(me=>me.unsqueeze(Z)),Z)}function R(he,Z,me=null,we=!1,xe=null){const et=Z.data,Ve=Z.dims;me=A(me,Ve.length);const nt=Ve.slice();nt[me]=1;const Be=new et.constructor(et.length/Ve[me]);xe!==null&&Be.fill(xe);for(let ae=0;ae<et.length;++ae){let U=0;for(let Se=Ve.length-1,ze=ae,Oe=1;Se>=0;--Se){const Ye=Ve[Se];if(Se!==me){const H=ze%Ye;U+=H*Oe,Oe*=nt[Se]}ze=Math.floor(ze/Ye)}Be[U]=he(Be[U],et[ae],ae,U)}return we||nt.splice(me,1),[Z.type,Be,nt]}function N(he,Z=null,me=1,we=!1){const xe=he.data,et=he.dims;if(Z===null){const Oe=xe.reduce(($e,Ie)=>$e+Ie,0)/xe.length,Ye=Math.sqrt(xe.reduce(($e,Ie)=>$e+(Ie-Oe)**2,0)/(xe.length-me)),H=new u(he.type,[Oe],[]);return[new u(he.type,[Ye],[]),H]}Z=A(Z,et.length);const Ve=q(he,Z,we),nt=Ve.data,[Be,ae,U]=R((ze,Oe,Ye,H)=>ze+(Oe-nt[H])**2,he,Z,we);for(let ze=0;ze<ae.length;++ze)ae[ze]=Math.sqrt(ae[ze]/(et[Z]-me));return[new u(Be,ae,U),Ve]}function q(he,Z=null,me=!1){const we=he.dims,xe=he.data;if(Z===null){const Be=xe.reduce((ae,U)=>ae+U,0);return new u(he.type,[Be/xe.length],[])}Z=A(Z,we.length);const[et,Ve,nt]=R((Be,ae)=>Be+ae,he,Z,me);if(we[Z]!==1)for(let Be=0;Be<Ve.length;++Be)Ve[Be]/=we[Z];return new u(et,Ve,nt)}function ne(he){const Z=new Array(he.length);for(let me=he.length-1,we=1;me>=0;--me)Z[me]=we,we*=he[me];return Z}function Q(he,Z,me,we){const xe=he.reduce((et,Ve)=>et*Ve,1);return new u(me,new we(xe).fill(Z),he)}function W(he,Z){let me,we;if(typeof Z=="number")me="float32",we=Float32Array;else if(typeof Z=="bigint")me="int64",we=BigInt64Array;else if(typeof Z=="boolean")me="bool",we=Uint8Array;else throw new Error(`Unsupported data type: ${typeof Z}`);return Q(he,Z,me,we)}function te(he,Z){return W(he.dims,Z)}function K(he){return Q(he,1n,"int64",BigInt64Array)}function pe(he){return K(he.dims)}function be(he){return Q(he,0n,"int64",BigInt64Array)}function Ee(he){return be(he.dims)}function Ge(he){const Z=he.reduce((me,we)=>me*we,1);return new u("float32",Float32Array.from({length:Z},()=>Math.random()),he)}function _e(he){const Z=he.reduce((we,xe)=>we*xe,1);function me(){const we=1-Math.random(),xe=1-Math.random();return Math.sqrt(-2*Math.log(we))*Math.cos(2*Math.PI*xe)}return new u("float32",Float32Array.from({length:Z},()=>me()),he)}function De(he,Z){if(he.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(he.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(Z))throw new Error("The precision must be either 'binary' or 'ubinary'");const me=Z==="binary",we=me?"int8":"uint8",xe=me?Int8Array:Uint8Array,et=he.data,Ve=new xe(et.length/8);for(let nt=0;nt<et.length;++nt){const Be=et[nt]>0?1:0,ae=Math.floor(nt/8),U=nt%8;Ve[ae]|=Be<<7-U,me&&U===0&&(Ve[ae]-=128)}return new u(we,Ve,[he.dims[0],he.dims[1]/8])}},"./src/utils/video.js":(e,n,t)=>{t.r(n),t.d(n,{RawVideo:()=>c,RawVideoFrame:()=>a,load_video:()=>u});var i=t("./src/utils/image.js"),r=t("./src/env.js");class a{constructor(f,m){this.image=f,this.timestamp=m}}class c{constructor(f,m){f.length>0&&f[0]instanceof i.RawImage&&(f=f.map((h,p)=>new a(h,(p+1)/(f.length+1)*m))),this.frames=f,this.duration=m}get width(){return this.frames[0].image.width}get height(){return this.frames[0].image.height}get fps(){return this.frames.length/this.duration}}async function u(l,{num_frames:f=null,fps:m=null}={}){if(!r.apis.IS_BROWSER_ENV)throw new Error("`load_video` is currently only supported in browser environments.");if(f==null&&m==null)throw new Error("Either num_frames or fps must be provided.");const h=[],p=document.createElement("video");if(p.crossOrigin="anonymous",p.muted=!0,typeof l=="string")p.src=l;else if(l instanceof Blob)p.src=URL.createObjectURL(l);else if(l instanceof HTMLVideoElement)p.src=l.src;else throw new Error("Invalid URL or video element provided.");if(await new Promise(F=>p.onloadedmetadata=F),p.seekable.start(0)===p.seekable.end(0)){const E=await(await fetch(p.src)).blob();p.src=URL.createObjectURL(E),await new Promise(A=>p.onloadedmetadata=A)}const _=p.duration;let v,S;f!=null?(v=f,S=f===1?0:_/(f-1)):(S=1/m,v=Math.floor(_/S));let D=[];for(let F=0;F<v;++F)D.push(f===1?_/2:F*S);const w=document.createElement("canvas");w.width=p.videoWidth,w.height=p.videoHeight;const T=w.getContext("2d",{willReadFrequently:!0});for(const F of D){p.currentTime=F,await new Promise(I=>{p.onseeked=I}),T.drawImage(p,0,0,w.width,w.height);const E=T.getImageData(0,0,w.width,w.height),A=new i.RawImage(E.data,w.width,w.height,4),L=new a(A,F);h.push(L)}return p.remove(),new c(h,_)}}},Ib={};function vn(e){var n=Ib[e];if(n!==void 0)return n.exports;var t=Ib[e]={exports:{}};return HP[e](t,t.exports,vn),t.exports}(()=>{var e=Object.getPrototypeOf?t=>Object.getPrototypeOf(t):t=>t.__proto__,n;vn.t=function(t,i){if(i&1&&(t=this(t)),i&8||typeof t=="object"&&t&&(i&4&&t.__esModule||i&16&&typeof t.then=="function"))return t;var r=Object.create(null);vn.r(r);var a={};n=n||[null,e({}),e([]),e(e)];for(var c=i&2&&t;typeof c=="object"&&!~n.indexOf(c);c=e(c))Object.getOwnPropertyNames(c).forEach(u=>a[u]=()=>t[u]);return a.default=()=>t,vn.d(r,a),r}})(),vn.d=(e,n)=>{for(var t in n)vn.o(n,t)&&!vn.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},vn.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),vn.r=e=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var ey={};(()=>{/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/vn.r(ey),vn.d(ey,{ASTFeatureExtractor:()=>h.ASTFeatureExtractor,ASTForAudioClassification:()=>t.ASTForAudioClassification,ASTModel:()=>t.ASTModel,ASTPreTrainedModel:()=>t.ASTPreTrainedModel,AlbertForMaskedLM:()=>t.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>t.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>t.AlbertForSequenceClassification,AlbertModel:()=>t.AlbertModel,AlbertPreTrainedModel:()=>t.AlbertPreTrainedModel,AlbertTokenizer:()=>i.AlbertTokenizer,ArceeForCausalLM:()=>t.ArceeForCausalLM,ArceeModel:()=>t.ArceeModel,ArceePreTrainedModel:()=>t.ArceePreTrainedModel,AudioClassificationPipeline:()=>n.AudioClassificationPipeline,AutoConfig:()=>r.AutoConfig,AutoFeatureExtractor:()=>p.AutoFeatureExtractor,AutoImageProcessor:()=>S.AutoImageProcessor,AutoModel:()=>t.AutoModel,AutoModelForAudioClassification:()=>t.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>t.AutoModelForAudioFrameClassification,AutoModelForAudioTextToText:()=>t.AutoModelForAudioTextToText,AutoModelForCTC:()=>t.AutoModelForCTC,AutoModelForCausalLM:()=>t.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>t.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>t.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>t.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>t.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>t.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>t.AutoModelForImageSegmentation,AutoModelForImageTextToText:()=>t.AutoModelForImageTextToText,AutoModelForImageToImage:()=>t.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>t.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>t.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>t.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>t.AutoModelForObjectDetection,AutoModelForPoseEstimation:()=>t.AutoModelForPoseEstimation,AutoModelForQuestionAnswering:()=>t.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>t.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>t.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>t.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>t.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>t.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>t.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>t.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>t.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>t.AutoModelForVision2Seq,AutoModelForXVector:()=>t.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>t.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>T.AutoProcessor,AutoTokenizer:()=>i.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>n.AutomaticSpeechRecognitionPipeline,BackgroundRemovalPipeline:()=>n.BackgroundRemovalPipeline,BartForConditionalGeneration:()=>t.BartForConditionalGeneration,BartForSequenceClassification:()=>t.BartForSequenceClassification,BartModel:()=>t.BartModel,BartPretrainedModel:()=>t.BartPretrainedModel,BartTokenizer:()=>i.BartTokenizer,BaseModelOutput:()=>t.BaseModelOutput,BaseStreamer:()=>F.BaseStreamer,BeitFeatureExtractor:()=>v.BeitFeatureExtractor,BeitForImageClassification:()=>t.BeitForImageClassification,BeitModel:()=>t.BeitModel,BeitPreTrainedModel:()=>t.BeitPreTrainedModel,BertForMaskedLM:()=>t.BertForMaskedLM,BertForQuestionAnswering:()=>t.BertForQuestionAnswering,BertForSequenceClassification:()=>t.BertForSequenceClassification,BertForTokenClassification:()=>t.BertForTokenClassification,BertModel:()=>t.BertModel,BertPreTrainedModel:()=>t.BertPreTrainedModel,BertTokenizer:()=>i.BertTokenizer,BitImageProcessor:()=>v.BitImageProcessor,BlenderbotForConditionalGeneration:()=>t.BlenderbotForConditionalGeneration,BlenderbotModel:()=>t.BlenderbotModel,BlenderbotPreTrainedModel:()=>t.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>t.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>t.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>t.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>i.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>i.BlenderbotTokenizer,BloomForCausalLM:()=>t.BloomForCausalLM,BloomModel:()=>t.BloomModel,BloomPreTrainedModel:()=>t.BloomPreTrainedModel,BloomTokenizer:()=>i.BloomTokenizer,CLIPFeatureExtractor:()=>v.CLIPFeatureExtractor,CLIPImageProcessor:()=>v.CLIPImageProcessor,CLIPModel:()=>t.CLIPModel,CLIPPreTrainedModel:()=>t.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>t.CLIPSegForImageSegmentation,CLIPSegModel:()=>t.CLIPSegModel,CLIPSegPreTrainedModel:()=>t.CLIPSegPreTrainedModel,CLIPTextModel:()=>t.CLIPTextModel,CLIPTextModelWithProjection:()=>t.CLIPTextModelWithProjection,CLIPTokenizer:()=>i.CLIPTokenizer,CLIPVisionModel:()=>t.CLIPVisionModel,CLIPVisionModelWithProjection:()=>t.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>t.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>t.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>t.CamembertForSequenceClassification,CamembertForTokenClassification:()=>t.CamembertForTokenClassification,CamembertModel:()=>t.CamembertModel,CamembertPreTrainedModel:()=>t.CamembertPreTrainedModel,CamembertTokenizer:()=>i.CamembertTokenizer,CausalLMOutput:()=>t.CausalLMOutput,CausalLMOutputWithPast:()=>t.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>v.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>t.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>t.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>t.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>h.ClapFeatureExtractor,ClapModel:()=>t.ClapModel,ClapPreTrainedModel:()=>t.ClapPreTrainedModel,ClapTextModelWithProjection:()=>t.ClapTextModelWithProjection,ClassifierFreeGuidanceLogitsProcessor:()=>A.ClassifierFreeGuidanceLogitsProcessor,CodeGenForCausalLM:()=>t.CodeGenForCausalLM,CodeGenModel:()=>t.CodeGenModel,CodeGenPreTrainedModel:()=>t.CodeGenPreTrainedModel,CodeGenTokenizer:()=>i.CodeGenTokenizer,CodeLlamaTokenizer:()=>i.CodeLlamaTokenizer,CohereForCausalLM:()=>t.CohereForCausalLM,CohereModel:()=>t.CohereModel,CoherePreTrainedModel:()=>t.CoherePreTrainedModel,CohereTokenizer:()=>i.CohereTokenizer,ConvBertForMaskedLM:()=>t.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>t.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>t.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>t.ConvBertForTokenClassification,ConvBertModel:()=>t.ConvBertModel,ConvBertPreTrainedModel:()=>t.ConvBertPreTrainedModel,ConvBertTokenizer:()=>i.ConvBertTokenizer,ConvNextFeatureExtractor:()=>v.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>t.ConvNextForImageClassification,ConvNextImageProcessor:()=>v.ConvNextImageProcessor,ConvNextModel:()=>t.ConvNextModel,ConvNextPreTrainedModel:()=>t.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>t.ConvNextV2ForImageClassification,ConvNextV2Model:()=>t.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>t.ConvNextV2PreTrainedModel,DFineForObjectDetection:()=>t.DFineForObjectDetection,DFineModel:()=>t.DFineModel,DFinePreTrainedModel:()=>t.DFinePreTrainedModel,DINOv3ConvNextModel:()=>t.DINOv3ConvNextModel,DINOv3ConvNextPreTrainedModel:()=>t.DINOv3ConvNextPreTrainedModel,DINOv3ViTImageProcessor:()=>v.DINOv3ViTImageProcessor,DINOv3ViTModel:()=>t.DINOv3ViTModel,DINOv3ViTPreTrainedModel:()=>t.DINOv3ViTPreTrainedModel,DPTFeatureExtractor:()=>v.DPTFeatureExtractor,DPTForDepthEstimation:()=>t.DPTForDepthEstimation,DPTImageProcessor:()=>v.DPTImageProcessor,DPTModel:()=>t.DPTModel,DPTPreTrainedModel:()=>t.DPTPreTrainedModel,DacDecoderModel:()=>t.DacDecoderModel,DacDecoderOutput:()=>t.DacDecoderOutput,DacEncoderModel:()=>t.DacEncoderModel,DacEncoderOutput:()=>t.DacEncoderOutput,DacFeatureExtractor:()=>h.DacFeatureExtractor,DacModel:()=>t.DacModel,DacPreTrainedModel:()=>t.DacPreTrainedModel,DataTypeMap:()=>l.DataTypeMap,DebertaForMaskedLM:()=>t.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>t.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>t.DebertaForSequenceClassification,DebertaForTokenClassification:()=>t.DebertaForTokenClassification,DebertaModel:()=>t.DebertaModel,DebertaPreTrainedModel:()=>t.DebertaPreTrainedModel,DebertaTokenizer:()=>i.DebertaTokenizer,DebertaV2ForMaskedLM:()=>t.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>t.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>t.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>t.DebertaV2ForTokenClassification,DebertaV2Model:()=>t.DebertaV2Model,DebertaV2PreTrainedModel:()=>t.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>i.DebertaV2Tokenizer,DecisionTransformerModel:()=>t.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>t.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>v.DeiTFeatureExtractor,DeiTForImageClassification:()=>t.DeiTForImageClassification,DeiTImageProcessor:()=>v.DeiTImageProcessor,DeiTModel:()=>t.DeiTModel,DeiTPreTrainedModel:()=>t.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>t.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>t.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>n.DepthEstimationPipeline,DepthProForDepthEstimation:()=>t.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>t.DepthProPreTrainedModel,DetrFeatureExtractor:()=>v.DetrFeatureExtractor,DetrForObjectDetection:()=>t.DetrForObjectDetection,DetrForSegmentation:()=>t.DetrForSegmentation,DetrImageProcessor:()=>v.DetrImageProcessor,DetrModel:()=>t.DetrModel,DetrObjectDetectionOutput:()=>t.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>t.DetrPreTrainedModel,DetrSegmentationOutput:()=>t.DetrSegmentationOutput,Dinov2ForImageClassification:()=>t.Dinov2ForImageClassification,Dinov2Model:()=>t.Dinov2Model,Dinov2PreTrainedModel:()=>t.Dinov2PreTrainedModel,Dinov2WithRegistersForImageClassification:()=>t.Dinov2WithRegistersForImageClassification,Dinov2WithRegistersModel:()=>t.Dinov2WithRegistersModel,Dinov2WithRegistersPreTrainedModel:()=>t.Dinov2WithRegistersPreTrainedModel,DistilBertForMaskedLM:()=>t.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>t.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>t.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>t.DistilBertForTokenClassification,DistilBertModel:()=>t.DistilBertModel,DistilBertPreTrainedModel:()=>t.DistilBertPreTrainedModel,DistilBertTokenizer:()=>i.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>n.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>v.DonutFeatureExtractor,DonutImageProcessor:()=>v.DonutImageProcessor,DonutSwinModel:()=>t.DonutSwinModel,DonutSwinPreTrainedModel:()=>t.DonutSwinPreTrainedModel,EdgeTamModel:()=>t.EdgeTamModel,EfficientNetForImageClassification:()=>t.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>v.EfficientNetImageProcessor,EfficientNetModel:()=>t.EfficientNetModel,EfficientNetPreTrainedModel:()=>t.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>t.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>t.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>t.ElectraForSequenceClassification,ElectraForTokenClassification:()=>t.ElectraForTokenClassification,ElectraModel:()=>t.ElectraModel,ElectraPreTrainedModel:()=>t.ElectraPreTrainedModel,ElectraTokenizer:()=>i.ElectraTokenizer,EncodecFeatureExtractor:()=>h.EncodecFeatureExtractor,EosTokenCriteria:()=>E.EosTokenCriteria,Ernie4_5ForCausalLM:()=>t.Ernie4_5ForCausalLM,Ernie4_5Model:()=>t.Ernie4_5Model,Ernie4_5PreTrainedModel:()=>t.Ernie4_5PreTrainedModel,EsmForMaskedLM:()=>t.EsmForMaskedLM,EsmForSequenceClassification:()=>t.EsmForSequenceClassification,EsmForTokenClassification:()=>t.EsmForTokenClassification,EsmModel:()=>t.EsmModel,EsmPreTrainedModel:()=>t.EsmPreTrainedModel,EsmTokenizer:()=>i.EsmTokenizer,ExaoneForCausalLM:()=>t.ExaoneForCausalLM,ExaoneModel:()=>t.ExaoneModel,ExaonePreTrainedModel:()=>t.ExaonePreTrainedModel,FFT:()=>f.FFT,FalconForCausalLM:()=>t.FalconForCausalLM,FalconModel:()=>t.FalconModel,FalconPreTrainedModel:()=>t.FalconPreTrainedModel,FalconTokenizer:()=>i.FalconTokenizer,FastViTForImageClassification:()=>t.FastViTForImageClassification,FastViTModel:()=>t.FastViTModel,FastViTPreTrainedModel:()=>t.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>n.FeatureExtractionPipeline,FeatureExtractor:()=>m.FeatureExtractor,FillMaskPipeline:()=>n.FillMaskPipeline,Florence2ForConditionalGeneration:()=>t.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>t.Florence2PreTrainedModel,Florence2Processor:()=>w.Florence2Processor,ForcedBOSTokenLogitsProcessor:()=>A.ForcedBOSTokenLogitsProcessor,ForcedEOSTokenLogitsProcessor:()=>A.ForcedEOSTokenLogitsProcessor,GLPNFeatureExtractor:()=>v.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>t.GLPNForDepthEstimation,GLPNModel:()=>t.GLPNModel,GLPNPreTrainedModel:()=>t.GLPNPreTrainedModel,GPT2LMHeadModel:()=>t.GPT2LMHeadModel,GPT2Model:()=>t.GPT2Model,GPT2PreTrainedModel:()=>t.GPT2PreTrainedModel,GPT2Tokenizer:()=>i.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>t.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>t.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>t.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>t.GPTJForCausalLM,GPTJModel:()=>t.GPTJModel,GPTJPreTrainedModel:()=>t.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>t.GPTNeoForCausalLM,GPTNeoModel:()=>t.GPTNeoModel,GPTNeoPreTrainedModel:()=>t.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>t.GPTNeoXForCausalLM,GPTNeoXModel:()=>t.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>t.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>i.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>t.Gemma2ForCausalLM,Gemma2Model:()=>t.Gemma2Model,Gemma2PreTrainedModel:()=>t.Gemma2PreTrainedModel,Gemma3ForCausalLM:()=>t.Gemma3ForCausalLM,Gemma3Model:()=>t.Gemma3Model,Gemma3PreTrainedModel:()=>t.Gemma3PreTrainedModel,Gemma3nAudioFeatureExtractor:()=>h.Gemma3nAudioFeatureExtractor,Gemma3nForConditionalGeneration:()=>t.Gemma3nForConditionalGeneration,Gemma3nPreTrainedModel:()=>t.Gemma3nPreTrainedModel,Gemma3nProcessor:()=>w.Gemma3nProcessor,GemmaForCausalLM:()=>t.GemmaForCausalLM,GemmaModel:()=>t.GemmaModel,GemmaPreTrainedModel:()=>t.GemmaPreTrainedModel,GemmaTokenizer:()=>i.GemmaTokenizer,GlmForCausalLM:()=>t.GlmForCausalLM,GlmModel:()=>t.GlmModel,GlmPreTrainedModel:()=>t.GlmPreTrainedModel,GraniteForCausalLM:()=>t.GraniteForCausalLM,GraniteModel:()=>t.GraniteModel,GraniteMoeHybridForCausalLM:()=>t.GraniteMoeHybridForCausalLM,GraniteMoeHybridModel:()=>t.GraniteMoeHybridModel,GraniteMoeHybridPreTrainedModel:()=>t.GraniteMoeHybridPreTrainedModel,GranitePreTrainedModel:()=>t.GranitePreTrainedModel,Grok1Tokenizer:()=>i.Grok1Tokenizer,GroundingDinoForObjectDetection:()=>t.GroundingDinoForObjectDetection,GroundingDinoImageProcessor:()=>v.GroundingDinoImageProcessor,GroundingDinoPreTrainedModel:()=>t.GroundingDinoPreTrainedModel,GroundingDinoProcessor:()=>w.GroundingDinoProcessor,GroupViTModel:()=>t.GroupViTModel,GroupViTPreTrainedModel:()=>t.GroupViTPreTrainedModel,HeliumForCausalLM:()=>t.HeliumForCausalLM,HeliumModel:()=>t.HeliumModel,HeliumPreTrainedModel:()=>t.HeliumPreTrainedModel,HerbertTokenizer:()=>i.HerbertTokenizer,HieraForImageClassification:()=>t.HieraForImageClassification,HieraModel:()=>t.HieraModel,HieraPreTrainedModel:()=>t.HieraPreTrainedModel,HubertForCTC:()=>t.HubertForCTC,HubertForSequenceClassification:()=>t.HubertForSequenceClassification,HubertModel:()=>t.HubertModel,HubertPreTrainedModel:()=>t.HubertPreTrainedModel,IJepaForImageClassification:()=>t.IJepaForImageClassification,IJepaModel:()=>t.IJepaModel,IJepaPreTrainedModel:()=>t.IJepaPreTrainedModel,Idefics3ForConditionalGeneration:()=>t.Idefics3ForConditionalGeneration,Idefics3ImageProcessor:()=>v.Idefics3ImageProcessor,Idefics3PreTrainedModel:()=>t.Idefics3PreTrainedModel,Idefics3Processor:()=>w.Idefics3Processor,ImageClassificationPipeline:()=>n.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>n.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>h.ImageFeatureExtractor,ImageMattingOutput:()=>t.ImageMattingOutput,ImageProcessor:()=>_.ImageProcessor,ImageSegmentationPipeline:()=>n.ImageSegmentationPipeline,ImageToImagePipeline:()=>n.ImageToImagePipeline,ImageToTextPipeline:()=>n.ImageToTextPipeline,InterruptableStoppingCriteria:()=>E.InterruptableStoppingCriteria,JAISLMHeadModel:()=>t.JAISLMHeadModel,JAISModel:()=>t.JAISModel,JAISPreTrainedModel:()=>t.JAISPreTrainedModel,JinaCLIPImageProcessor:()=>v.JinaCLIPImageProcessor,JinaCLIPModel:()=>t.JinaCLIPModel,JinaCLIPPreTrainedModel:()=>t.JinaCLIPPreTrainedModel,JinaCLIPProcessor:()=>w.JinaCLIPProcessor,JinaCLIPTextModel:()=>t.JinaCLIPTextModel,JinaCLIPVisionModel:()=>t.JinaCLIPVisionModel,Lfm2ForCausalLM:()=>t.Lfm2ForCausalLM,Lfm2Model:()=>t.Lfm2Model,Lfm2PreTrainedModel:()=>t.Lfm2PreTrainedModel,LiteWhisperForConditionalGeneration:()=>t.LiteWhisperForConditionalGeneration,Llama4ForCausalLM:()=>t.Llama4ForCausalLM,Llama4PreTrainedModel:()=>t.Llama4PreTrainedModel,LlamaForCausalLM:()=>t.LlamaForCausalLM,LlamaModel:()=>t.LlamaModel,LlamaPreTrainedModel:()=>t.LlamaPreTrainedModel,LlamaTokenizer:()=>i.LlamaTokenizer,LlavaForConditionalGeneration:()=>t.LlavaForConditionalGeneration,LlavaOnevisionForConditionalGeneration:()=>t.LlavaOnevisionForConditionalGeneration,LlavaOnevisionImageProcessor:()=>v.LlavaOnevisionImageProcessor,LlavaPreTrainedModel:()=>t.LlavaPreTrainedModel,LlavaProcessor:()=>w.LlavaProcessor,LlavaQwen2ForCausalLM:()=>t.LlavaQwen2ForCausalLM,LogitsProcessor:()=>A.LogitsProcessor,LogitsProcessorList:()=>A.LogitsProcessorList,LogitsWarper:()=>A.LogitsWarper,LongT5ForConditionalGeneration:()=>t.LongT5ForConditionalGeneration,LongT5Model:()=>t.LongT5Model,LongT5PreTrainedModel:()=>t.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>t.M2M100ForConditionalGeneration,M2M100Model:()=>t.M2M100Model,M2M100PreTrainedModel:()=>t.M2M100PreTrainedModel,M2M100Tokenizer:()=>i.M2M100Tokenizer,MBart50Tokenizer:()=>i.MBart50Tokenizer,MBartForCausalLM:()=>t.MBartForCausalLM,MBartForConditionalGeneration:()=>t.MBartForConditionalGeneration,MBartForSequenceClassification:()=>t.MBartForSequenceClassification,MBartModel:()=>t.MBartModel,MBartPreTrainedModel:()=>t.MBartPreTrainedModel,MBartTokenizer:()=>i.MBartTokenizer,MPNetForMaskedLM:()=>t.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>t.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>t.MPNetForSequenceClassification,MPNetForTokenClassification:()=>t.MPNetForTokenClassification,MPNetModel:()=>t.MPNetModel,MPNetPreTrainedModel:()=>t.MPNetPreTrainedModel,MPNetTokenizer:()=>i.MPNetTokenizer,MT5ForConditionalGeneration:()=>t.MT5ForConditionalGeneration,MT5Model:()=>t.MT5Model,MT5PreTrainedModel:()=>t.MT5PreTrainedModel,MarianMTModel:()=>t.MarianMTModel,MarianModel:()=>t.MarianModel,MarianPreTrainedModel:()=>t.MarianPreTrainedModel,MarianTokenizer:()=>i.MarianTokenizer,Mask2FormerImageProcessor:()=>v.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>v.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>t.MaskFormerForInstanceSegmentation,MaskFormerImageProcessor:()=>v.MaskFormerImageProcessor,MaskFormerModel:()=>t.MaskFormerModel,MaskFormerPreTrainedModel:()=>t.MaskFormerPreTrainedModel,MaskedLMOutput:()=>t.MaskedLMOutput,MaxLengthCriteria:()=>E.MaxLengthCriteria,Metric3DForDepthEstimation:()=>t.Metric3DForDepthEstimation,Metric3DPreTrainedModel:()=>t.Metric3DPreTrainedModel,Metric3Dv2ForDepthEstimation:()=>t.Metric3Dv2ForDepthEstimation,Metric3Dv2PreTrainedModel:()=>t.Metric3Dv2PreTrainedModel,MgpstrForSceneTextRecognition:()=>t.MgpstrForSceneTextRecognition,MgpstrModelOutput:()=>t.MgpstrModelOutput,MgpstrPreTrainedModel:()=>t.MgpstrPreTrainedModel,MgpstrProcessor:()=>w.MgpstrProcessor,MgpstrTokenizer:()=>i.MgpstrTokenizer,MimiDecoderModel:()=>t.MimiDecoderModel,MimiDecoderOutput:()=>t.MimiDecoderOutput,MimiEncoderModel:()=>t.MimiEncoderModel,MimiEncoderOutput:()=>t.MimiEncoderOutput,MimiModel:()=>t.MimiModel,MimiPreTrainedModel:()=>t.MimiPreTrainedModel,MinLengthLogitsProcessor:()=>A.MinLengthLogitsProcessor,MinNewTokensLengthLogitsProcessor:()=>A.MinNewTokensLengthLogitsProcessor,Ministral3ForCausalLM:()=>t.Ministral3ForCausalLM,Ministral3Model:()=>t.Ministral3Model,Ministral3PreTrainedModel:()=>t.Ministral3PreTrainedModel,MinistralForCausalLM:()=>t.MinistralForCausalLM,MinistralModel:()=>t.MinistralModel,MinistralPreTrainedModel:()=>t.MinistralPreTrainedModel,Mistral3ForConditionalGeneration:()=>t.Mistral3ForConditionalGeneration,MistralForCausalLM:()=>t.MistralForCausalLM,MistralModel:()=>t.MistralModel,MistralPreTrainedModel:()=>t.MistralPreTrainedModel,MobileBertForMaskedLM:()=>t.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>t.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>t.MobileBertForSequenceClassification,MobileBertModel:()=>t.MobileBertModel,MobileBertPreTrainedModel:()=>t.MobileBertPreTrainedModel,MobileBertTokenizer:()=>i.MobileBertTokenizer,MobileLLMForCausalLM:()=>t.MobileLLMForCausalLM,MobileLLMModel:()=>t.MobileLLMModel,MobileLLMPreTrainedModel:()=>t.MobileLLMPreTrainedModel,MobileNetV1FeatureExtractor:()=>v.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>t.MobileNetV1ForImageClassification,MobileNetV1ForSemanticSegmentation:()=>t.MobileNetV1ForSemanticSegmentation,MobileNetV1ImageProcessor:()=>v.MobileNetV1ImageProcessor,MobileNetV1Model:()=>t.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>t.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>v.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>t.MobileNetV2ForImageClassification,MobileNetV2ForSemanticSegmentation:()=>t.MobileNetV2ForSemanticSegmentation,MobileNetV2ImageProcessor:()=>v.MobileNetV2ImageProcessor,MobileNetV2Model:()=>t.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>t.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>v.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>t.MobileNetV3ForImageClassification,MobileNetV3ForSemanticSegmentation:()=>t.MobileNetV3ForSemanticSegmentation,MobileNetV3ImageProcessor:()=>v.MobileNetV3ImageProcessor,MobileNetV3Model:()=>t.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>t.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>v.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>t.MobileNetV4ForImageClassification,MobileNetV4ForSemanticSegmentation:()=>t.MobileNetV4ForSemanticSegmentation,MobileNetV4ImageProcessor:()=>v.MobileNetV4ImageProcessor,MobileNetV4Model:()=>t.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>t.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>v.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>t.MobileViTForImageClassification,MobileViTImageProcessor:()=>v.MobileViTImageProcessor,MobileViTModel:()=>t.MobileViTModel,MobileViTPreTrainedModel:()=>t.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>t.MobileViTV2ForImageClassification,MobileViTV2Model:()=>t.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>t.MobileViTV2PreTrainedModel,ModelOutput:()=>t.ModelOutput,ModernBertDecoderForCausalLM:()=>t.ModernBertDecoderForCausalLM,ModernBertDecoderModel:()=>t.ModernBertDecoderModel,ModernBertDecoderPreTrainedModel:()=>t.ModernBertDecoderPreTrainedModel,ModernBertForMaskedLM:()=>t.ModernBertForMaskedLM,ModernBertForSequenceClassification:()=>t.ModernBertForSequenceClassification,ModernBertForTokenClassification:()=>t.ModernBertForTokenClassification,ModernBertModel:()=>t.ModernBertModel,ModernBertPreTrainedModel:()=>t.ModernBertPreTrainedModel,Moondream1ForConditionalGeneration:()=>t.Moondream1ForConditionalGeneration,MoonshineFeatureExtractor:()=>h.MoonshineFeatureExtractor,MoonshineForConditionalGeneration:()=>t.MoonshineForConditionalGeneration,MoonshineModel:()=>t.MoonshineModel,MoonshinePreTrainedModel:()=>t.MoonshinePreTrainedModel,MoonshineProcessor:()=>w.MoonshineProcessor,MptForCausalLM:()=>t.MptForCausalLM,MptModel:()=>t.MptModel,MptPreTrainedModel:()=>t.MptPreTrainedModel,MultiModalityCausalLM:()=>t.MultiModalityCausalLM,MultiModalityPreTrainedModel:()=>t.MultiModalityPreTrainedModel,MusicgenForCausalLM:()=>t.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>t.MusicgenForConditionalGeneration,MusicgenModel:()=>t.MusicgenModel,MusicgenPreTrainedModel:()=>t.MusicgenPreTrainedModel,NanoChatForCausalLM:()=>t.NanoChatForCausalLM,NanoChatModel:()=>t.NanoChatModel,NanoChatPreTrainedModel:()=>t.NanoChatPreTrainedModel,NeoBertForMaskedLM:()=>t.NeoBertForMaskedLM,NeoBertForQuestionAnswering:()=>t.NeoBertForQuestionAnswering,NeoBertForSequenceClassification:()=>t.NeoBertForSequenceClassification,NeoBertForTokenClassification:()=>t.NeoBertForTokenClassification,NeoBertModel:()=>t.NeoBertModel,NeoBertPreTrainedModel:()=>t.NeoBertPreTrainedModel,NllbTokenizer:()=>i.NllbTokenizer,NoBadWordsLogitsProcessor:()=>A.NoBadWordsLogitsProcessor,NoRepeatNGramLogitsProcessor:()=>A.NoRepeatNGramLogitsProcessor,NomicBertModel:()=>t.NomicBertModel,NomicBertPreTrainedModel:()=>t.NomicBertPreTrainedModel,NougatImageProcessor:()=>v.NougatImageProcessor,NougatTokenizer:()=>i.NougatTokenizer,OPTForCausalLM:()=>t.OPTForCausalLM,OPTModel:()=>t.OPTModel,OPTPreTrainedModel:()=>t.OPTPreTrainedModel,ObjectDetectionPipeline:()=>n.ObjectDetectionPipeline,Olmo2ForCausalLM:()=>t.Olmo2ForCausalLM,Olmo2Model:()=>t.Olmo2Model,Olmo2PreTrainedModel:()=>t.Olmo2PreTrainedModel,OlmoForCausalLM:()=>t.OlmoForCausalLM,OlmoModel:()=>t.OlmoModel,OlmoPreTrainedModel:()=>t.OlmoPreTrainedModel,OpenELMForCausalLM:()=>t.OpenELMForCausalLM,OpenELMModel:()=>t.OpenELMModel,OpenELMPreTrainedModel:()=>t.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>v.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>t.OwlViTForObjectDetection,OwlViTImageProcessor:()=>v.OwlViTImageProcessor,OwlViTModel:()=>t.OwlViTModel,OwlViTPreTrainedModel:()=>t.OwlViTPreTrainedModel,OwlViTProcessor:()=>w.OwlViTProcessor,Owlv2ForObjectDetection:()=>t.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>v.Owlv2ImageProcessor,Owlv2Model:()=>t.Owlv2Model,Owlv2PreTrainedModel:()=>t.Owlv2PreTrainedModel,PaliGemmaForConditionalGeneration:()=>t.PaliGemmaForConditionalGeneration,PaliGemmaPreTrainedModel:()=>t.PaliGemmaPreTrainedModel,PaliGemmaProcessor:()=>w.PaliGemmaProcessor,ParakeetFeatureExtractor:()=>h.ParakeetFeatureExtractor,ParakeetForCTC:()=>t.ParakeetForCTC,ParakeetPreTrainedModel:()=>t.ParakeetPreTrainedModel,PatchTSMixerForPrediction:()=>t.PatchTSMixerForPrediction,PatchTSMixerModel:()=>t.PatchTSMixerModel,PatchTSMixerPreTrainedModel:()=>t.PatchTSMixerPreTrainedModel,PatchTSTForPrediction:()=>t.PatchTSTForPrediction,PatchTSTModel:()=>t.PatchTSTModel,PatchTSTPreTrainedModel:()=>t.PatchTSTPreTrainedModel,Phi3ForCausalLM:()=>t.Phi3ForCausalLM,Phi3Model:()=>t.Phi3Model,Phi3PreTrainedModel:()=>t.Phi3PreTrainedModel,Phi3VForCausalLM:()=>t.Phi3VForCausalLM,Phi3VImageProcessor:()=>v.Phi3VImageProcessor,Phi3VPreTrainedModel:()=>t.Phi3VPreTrainedModel,Phi3VProcessor:()=>w.Phi3VProcessor,PhiForCausalLM:()=>t.PhiForCausalLM,PhiModel:()=>t.PhiModel,PhiPreTrainedModel:()=>t.PhiPreTrainedModel,Pipeline:()=>n.Pipeline,PixtralImageProcessor:()=>v.PixtralImageProcessor,PixtralProcessor:()=>w.PixtralProcessor,PreTrainedModel:()=>t.PreTrainedModel,PreTrainedTokenizer:()=>i.PreTrainedTokenizer,PretrainedConfig:()=>r.PretrainedConfig,PretrainedMixin:()=>t.PretrainedMixin,Processor:()=>D.Processor,PvtForImageClassification:()=>t.PvtForImageClassification,PvtImageProcessor:()=>v.PvtImageProcessor,PvtModel:()=>t.PvtModel,PvtPreTrainedModel:()=>t.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>h.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>t.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>t.PyAnnoteModel,PyAnnotePreTrainedModel:()=>t.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>w.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>t.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>n.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>t.Qwen2ForCausalLM,Qwen2Model:()=>t.Qwen2Model,Qwen2PreTrainedModel:()=>t.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>i.Qwen2Tokenizer,Qwen2VLForConditionalGeneration:()=>t.Qwen2VLForConditionalGeneration,Qwen2VLImageProcessor:()=>v.Qwen2VLImageProcessor,Qwen2VLPreTrainedModel:()=>t.Qwen2VLPreTrainedModel,Qwen2VLProcessor:()=>w.Qwen2VLProcessor,Qwen3ForCausalLM:()=>t.Qwen3ForCausalLM,Qwen3Model:()=>t.Qwen3Model,Qwen3PreTrainedModel:()=>t.Qwen3PreTrainedModel,RFDetrForObjectDetection:()=>t.RFDetrForObjectDetection,RFDetrModel:()=>t.RFDetrModel,RFDetrObjectDetectionOutput:()=>t.RFDetrObjectDetectionOutput,RFDetrPreTrainedModel:()=>t.RFDetrPreTrainedModel,RTDetrForObjectDetection:()=>t.RTDetrForObjectDetection,RTDetrImageProcessor:()=>v.RTDetrImageProcessor,RTDetrModel:()=>t.RTDetrModel,RTDetrObjectDetectionOutput:()=>t.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>t.RTDetrPreTrainedModel,RTDetrV2ForObjectDetection:()=>t.RTDetrV2ForObjectDetection,RTDetrV2Model:()=>t.RTDetrV2Model,RTDetrV2ObjectDetectionOutput:()=>t.RTDetrV2ObjectDetectionOutput,RTDetrV2PreTrainedModel:()=>t.RTDetrV2PreTrainedModel,RawAudio:()=>a.RawAudio,RawImage:()=>c.RawImage,RawVideo:()=>u.RawVideo,RawVideoFrame:()=>u.RawVideoFrame,RepetitionPenaltyLogitsProcessor:()=>A.RepetitionPenaltyLogitsProcessor,ResNetForImageClassification:()=>t.ResNetForImageClassification,ResNetModel:()=>t.ResNetModel,ResNetPreTrainedModel:()=>t.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>t.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>t.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>t.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>t.RoFormerForTokenClassification,RoFormerModel:()=>t.RoFormerModel,RoFormerPreTrainedModel:()=>t.RoFormerPreTrainedModel,RoFormerTokenizer:()=>i.RoFormerTokenizer,RobertaForMaskedLM:()=>t.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>t.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>t.RobertaForSequenceClassification,RobertaForTokenClassification:()=>t.RobertaForTokenClassification,RobertaModel:()=>t.RobertaModel,RobertaPreTrainedModel:()=>t.RobertaPreTrainedModel,RobertaTokenizer:()=>i.RobertaTokenizer,Sam2ImageProcessor:()=>v.Sam2ImageProcessor,Sam2ImageSegmentationOutput:()=>t.Sam2ImageSegmentationOutput,Sam2Model:()=>t.Sam2Model,Sam2PreTrainedModel:()=>t.Sam2PreTrainedModel,Sam2Processor:()=>w.Sam2Processor,Sam2VideoProcessor:()=>w.Sam2VideoProcessor,Sam3ImageProcessor:()=>v.Sam3ImageProcessor,Sam3TrackerModel:()=>t.Sam3TrackerModel,SamImageProcessor:()=>v.SamImageProcessor,SamImageSegmentationOutput:()=>t.SamImageSegmentationOutput,SamModel:()=>t.SamModel,SamPreTrainedModel:()=>t.SamPreTrainedModel,SamProcessor:()=>w.SamProcessor,SapiensForDepthEstimation:()=>t.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>t.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>t.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>t.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>h.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>v.SegformerFeatureExtractor,SegformerForImageClassification:()=>t.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>t.SegformerForSemanticSegmentation,SegformerImageProcessor:()=>v.SegformerImageProcessor,SegformerModel:()=>t.SegformerModel,SegformerPreTrainedModel:()=>t.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>t.Seq2SeqLMOutput,SequenceClassifierOutput:()=>t.SequenceClassifierOutput,SiglipImageProcessor:()=>v.SiglipImageProcessor,SiglipModel:()=>t.SiglipModel,SiglipPreTrainedModel:()=>t.SiglipPreTrainedModel,SiglipTextModel:()=>t.SiglipTextModel,SiglipTokenizer:()=>i.SiglipTokenizer,SiglipVisionModel:()=>t.SiglipVisionModel,SmolLM3ForCausalLM:()=>t.SmolLM3ForCausalLM,SmolLM3Model:()=>t.SmolLM3Model,SmolLM3PreTrainedModel:()=>t.SmolLM3PreTrainedModel,SmolVLMForConditionalGeneration:()=>t.SmolVLMForConditionalGeneration,SmolVLMImageProcessor:()=>v.SmolVLMImageProcessor,SmolVLMProcessor:()=>w.SmolVLMProcessor,SnacDecoderModel:()=>t.SnacDecoderModel,SnacEncoderModel:()=>t.SnacEncoderModel,SnacFeatureExtractor:()=>h.SnacFeatureExtractor,SnacModel:()=>t.SnacModel,SnacPreTrainedModel:()=>t.SnacPreTrainedModel,SpeechT5FeatureExtractor:()=>h.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>t.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>t.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>t.SpeechT5HifiGan,SpeechT5Model:()=>t.SpeechT5Model,SpeechT5PreTrainedModel:()=>t.SpeechT5PreTrainedModel,SpeechT5Processor:()=>w.SpeechT5Processor,SpeechT5Tokenizer:()=>i.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>t.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>t.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>t.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>t.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>t.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>i.SqueezeBertTokenizer,StableLmForCausalLM:()=>t.StableLmForCausalLM,StableLmModel:()=>t.StableLmModel,StableLmPreTrainedModel:()=>t.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>t.Starcoder2ForCausalLM,Starcoder2Model:()=>t.Starcoder2Model,Starcoder2PreTrainedModel:()=>t.Starcoder2PreTrainedModel,StoppingCriteria:()=>E.StoppingCriteria,StoppingCriteriaList:()=>E.StoppingCriteriaList,StyleTextToSpeech2Model:()=>t.StyleTextToSpeech2Model,StyleTextToSpeech2PreTrainedModel:()=>t.StyleTextToSpeech2PreTrainedModel,SummarizationPipeline:()=>n.SummarizationPipeline,SupertonicForConditionalGeneration:()=>t.SupertonicForConditionalGeneration,SupertonicPreTrainedModel:()=>t.SupertonicPreTrainedModel,SuppressTokensAtBeginLogitsProcessor:()=>A.SuppressTokensAtBeginLogitsProcessor,Swin2SRForImageSuperResolution:()=>t.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>v.Swin2SRImageProcessor,Swin2SRModel:()=>t.Swin2SRModel,Swin2SRPreTrainedModel:()=>t.Swin2SRPreTrainedModel,SwinForImageClassification:()=>t.SwinForImageClassification,SwinForSemanticSegmentation:()=>t.SwinForSemanticSegmentation,SwinModel:()=>t.SwinModel,SwinPreTrainedModel:()=>t.SwinPreTrainedModel,T5ForConditionalGeneration:()=>t.T5ForConditionalGeneration,T5Model:()=>t.T5Model,T5PreTrainedModel:()=>t.T5PreTrainedModel,T5Tokenizer:()=>i.T5Tokenizer,TableTransformerForObjectDetection:()=>t.TableTransformerForObjectDetection,TableTransformerModel:()=>t.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>t.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>t.TableTransformerPreTrainedModel,TemperatureLogitsWarper:()=>A.TemperatureLogitsWarper,Tensor:()=>l.Tensor,Text2TextGenerationPipeline:()=>n.Text2TextGenerationPipeline,TextClassificationPipeline:()=>n.TextClassificationPipeline,TextGenerationPipeline:()=>n.TextGenerationPipeline,TextStreamer:()=>F.TextStreamer,TextToAudioPipeline:()=>n.TextToAudioPipeline,TokenClassificationPipeline:()=>n.TokenClassificationPipeline,TokenClassifierOutput:()=>t.TokenClassifierOutput,TokenizerModel:()=>i.TokenizerModel,TopKLogitsWarper:()=>A.TopKLogitsWarper,TopPLogitsWarper:()=>A.TopPLogitsWarper,TrOCRForCausalLM:()=>t.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>t.TrOCRPreTrainedModel,TranslationPipeline:()=>n.TranslationPipeline,UltravoxModel:()=>t.UltravoxModel,UltravoxPreTrainedModel:()=>t.UltravoxPreTrainedModel,UltravoxProcessor:()=>w.UltravoxProcessor,UniSpeechForCTC:()=>t.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>t.UniSpeechForSequenceClassification,UniSpeechModel:()=>t.UniSpeechModel,UniSpeechPreTrainedModel:()=>t.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>t.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>t.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>t.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>t.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>t.UniSpeechSatPreTrainedModel,VLChatProcessor:()=>w.VLChatProcessor,VLMImageProcessor:()=>v.VLMImageProcessor,VaultGemmaForCausalLM:()=>t.VaultGemmaForCausalLM,VaultGemmaModel:()=>t.VaultGemmaModel,VaultGemmaPreTrainedModel:()=>t.VaultGemmaPreTrainedModel,ViTFeatureExtractor:()=>v.ViTFeatureExtractor,ViTForImageClassification:()=>t.ViTForImageClassification,ViTImageProcessor:()=>v.ViTImageProcessor,ViTMAEModel:()=>t.ViTMAEModel,ViTMAEPreTrainedModel:()=>t.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>t.ViTMSNForImageClassification,ViTMSNModel:()=>t.ViTMSNModel,ViTMSNPreTrainedModel:()=>t.ViTMSNPreTrainedModel,ViTModel:()=>t.ViTModel,ViTPreTrainedModel:()=>t.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>t.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>t.VitMatteForImageMatting,VitMatteImageProcessor:()=>v.VitMatteImageProcessor,VitMattePreTrainedModel:()=>t.VitMattePreTrainedModel,VitPoseForPoseEstimation:()=>t.VitPoseForPoseEstimation,VitPoseImageProcessor:()=>v.VitPoseImageProcessor,VitPosePreTrainedModel:()=>t.VitPosePreTrainedModel,VitsModel:()=>t.VitsModel,VitsModelOutput:()=>t.VitsModelOutput,VitsPreTrainedModel:()=>t.VitsPreTrainedModel,VitsTokenizer:()=>i.VitsTokenizer,VoxtralForConditionalGeneration:()=>t.VoxtralForConditionalGeneration,VoxtralProcessor:()=>w.VoxtralProcessor,Wav2Vec2BertForCTC:()=>t.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>t.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>t.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>t.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>i.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>h.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>t.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>t.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>t.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>t.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>t.Wav2Vec2PreTrainedModel,Wav2Vec2Processor:()=>w.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>w.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>t.WavLMForAudioFrameClassification,WavLMForCTC:()=>t.WavLMForCTC,WavLMForSequenceClassification:()=>t.WavLMForSequenceClassification,WavLMForXVector:()=>t.WavLMForXVector,WavLMModel:()=>t.WavLMModel,WavLMPreTrainedModel:()=>t.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>h.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>t.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>t.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>h.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>t.WhisperForConditionalGeneration,WhisperModel:()=>t.WhisperModel,WhisperPreTrainedModel:()=>t.WhisperPreTrainedModel,WhisperProcessor:()=>w.WhisperProcessor,WhisperTextStreamer:()=>F.WhisperTextStreamer,WhisperTimeStampLogitsProcessor:()=>A.WhisperTimeStampLogitsProcessor,WhisperTokenizer:()=>i.WhisperTokenizer,XLMForQuestionAnswering:()=>t.XLMForQuestionAnswering,XLMForSequenceClassification:()=>t.XLMForSequenceClassification,XLMForTokenClassification:()=>t.XLMForTokenClassification,XLMModel:()=>t.XLMModel,XLMPreTrainedModel:()=>t.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>t.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>t.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>t.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>t.XLMRobertaForTokenClassification,XLMRobertaModel:()=>t.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>t.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>i.XLMRobertaTokenizer,XLMTokenizer:()=>i.XLMTokenizer,XLMWithLMHeadModel:()=>t.XLMWithLMHeadModel,XVectorOutput:()=>t.XVectorOutput,YolosFeatureExtractor:()=>v.YolosFeatureExtractor,YolosForObjectDetection:()=>t.YolosForObjectDetection,YolosImageProcessor:()=>v.YolosImageProcessor,YolosModel:()=>t.YolosModel,YolosObjectDetectionOutput:()=>t.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>t.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>n.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>n.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>n.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>n.ZeroShotObjectDetectionPipeline,bankers_round:()=>f.bankers_round,cat:()=>l.cat,cos_sim:()=>f.cos_sim,dot:()=>f.dot,dynamic_time_warping:()=>f.dynamic_time_warping,env:()=>e.env,full:()=>l.full,full_like:()=>l.full_like,getCacheShapes:()=>r.getCacheShapes,hamming:()=>a.hamming,hanning:()=>a.hanning,interpolate:()=>l.interpolate,interpolate_4d:()=>l.interpolate_4d,interpolate_data:()=>f.interpolate_data,is_chinese_char:()=>i.is_chinese_char,layer_norm:()=>l.layer_norm,load_image:()=>c.load_image,load_video:()=>u.load_video,log_softmax:()=>f.log_softmax,magnitude:()=>f.magnitude,matmul:()=>l.matmul,max:()=>f.max,mean:()=>l.mean,mean_pooling:()=>l.mean_pooling,medianFilter:()=>f.medianFilter,mel_filter_bank:()=>a.mel_filter_bank,min:()=>f.min,ones:()=>l.ones,ones_like:()=>l.ones_like,permute:()=>l.permute,permute_data:()=>f.permute_data,pipeline:()=>n.pipeline,quantize_embeddings:()=>l.quantize_embeddings,rand:()=>l.rand,randn:()=>l.randn,read_audio:()=>a.read_audio,rfft:()=>l.rfft,round:()=>f.round,slice:()=>l.slice,softmax:()=>f.softmax,spectrogram:()=>a.spectrogram,stack:()=>l.stack,std_mean:()=>l.std_mean,topk:()=>l.topk,window_function:()=>a.window_function,zeros:()=>l.zeros,zeros_like:()=>l.zeros_like});var e=vn("./src/env.js"),n=vn("./src/pipelines.js"),t=vn("./src/models.js"),i=vn("./src/tokenizers.js"),r=vn("./src/configs.js"),a=vn("./src/utils/audio.js"),c=vn("./src/utils/image.js"),u=vn("./src/utils/video.js"),l=vn("./src/utils/tensor.js"),f=vn("./src/utils/maths.js"),m=vn("./src/base/feature_extraction_utils.js"),h=vn("./src/models/feature_extractors.js"),p=vn("./src/models/auto/feature_extraction_auto.js"),_=vn("./src/base/image_processors_utils.js"),v=vn("./src/models/image_processors.js"),S=vn("./src/models/auto/image_processing_auto.js"),D=vn("./src/base/processing_utils.js"),w=vn("./src/models/processors.js"),T=vn("./src/models/auto/processing_auto.js"),F=vn("./src/generation/streamers.js"),E=vn("./src/generation/stopping_criteria.js"),A=vn("./src/generation/logits_process.js")})();var Lb=ey.env,qP=ey.pipeline;Lb.allowLocalModels=!0,Lb.useBrowserCache=!0;class R0{constructor(n={}){this.modelId=n.modelId||"onnx-community/depth-anything-v2-small",this.device=n.device||"webgpu",this.pipeline=null,this.isLoading=!1,this.isReady=!1,this.depthCache=new Map,this.onProgress=n.onProgress||null,this.onReady=n.onReady||null,this.onError=n.onError||null}async initialize(){if(this.isReady)return!0;if(this.isLoading)return new Promise(n=>{const t=setInterval(()=>{this.isReady&&(clearInterval(t),n(!0))},100)});this.isLoading=!0;try{return console.log(`[DepthEstimator] Loading model: ${this.modelId} on ${this.device}`),this.pipeline=await qP("depth-estimation",this.modelId,{device:this.device,progress_callback:n=>{this.onProgress&&this.onProgress(n),console.log(`[DepthEstimator] Loading: ${n.status}`,n)}}),this.isReady=!0,this.isLoading=!1,console.log("[DepthEstimator] Model loaded successfully"),this.onReady&&this.onReady(),!0}catch(n){if(this.isLoading=!1,console.error("[DepthEstimator] Failed to load model:",n),this.device==="webgpu")return console.log("[DepthEstimator] Falling back to WASM..."),this.device="wasm",this.initialize();throw this.onError&&this.onError(n),n}}async estimateDepth(n,t=null){this.isReady||await this.initialize();const i=t||(typeof n=="string"?n:null);if(i&&this.depthCache.has(i))return console.log("[DepthEstimator] Returning cached depth map for:",i),this.depthCache.get(i);console.log("[DepthEstimator] Estimating depth for:",i||"image element");try{const r=await this.pipeline(n),a=new Db(r,n);return i&&this.depthCache.set(i,a),a}catch(r){throw console.error("[DepthEstimator] Depth estimation failed:",r),r}}clearCache(){this.depthCache.clear()}removeFromCache(n){this.depthCache.delete(n)}async dispose(){this.pipeline&&(this.pipeline=null),this.depthCache.clear(),this.isReady=!1}}class Db{constructor(n,t){this.raw=n,this.depthTensor=n.depth,this.width=this.depthTensor.width,this.height=this.depthTensor.height,this.data=this.depthTensor.data,this.sourceImage=t,this.minDepth=1/0,this.maxDepth=-1/0;for(let i=0;i<this.data.length;i++)this.data[i]<this.minDepth&&(this.minDepth=this.data[i]),this.data[i]>this.maxDepth&&(this.maxDepth=this.data[i])}getDepthAt(n,t){const i=Math.round(n),r=Math.round(t);if(i<0||i>=this.width||r<0||r>=this.height)return null;const a=r*this.width+i;return this.data[a]}getNormalizedDepthAt(n,t){const i=this.getDepthAt(n,t);return i===null?null:(i-this.minDepth)/(this.maxDepth-this.minDepth)}getDepthAtUV(n,t){const i=n*(this.width-1),r=t*(this.height-1);return this.getDepthAt(i,r)}sampleDepth(n,t){const i=Math.floor(n),r=Math.floor(t),a=Math.min(i+1,this.width-1),c=Math.min(r+1,this.height-1),u=n-i,l=t-r,f=this.getDepthAt(i,r)||0,m=this.getDepthAt(a,r)||0,h=this.getDepthAt(i,c)||0,p=this.getDepthAt(a,c)||0,_=f*(1-u)+m*u,v=h*(1-u)+p*u;return _*(1-l)+v*l}toCanvas(){const n=document.createElement("canvas");n.width=this.width,n.height=this.height;const t=n.getContext("2d"),i=t.createImageData(this.width,this.height);for(let r=0;r<this.data.length;r++){const a=(this.data[r]-this.minDepth)/(this.maxDepth-this.minDepth),c=Math.round(a*255);i.data[r*4]=c,i.data[r*4+1]=c,i.data[r*4+2]=c,i.data[r*4+3]=255}return t.putImageData(i,0,0),n}toImageData(){const n=new ImageData(this.width,this.height);for(let t=0;t<this.data.length;t++){const i=(this.data[t]-this.minDepth)/(this.maxDepth-this.minDepth),r=Math.round(i*255);n.data[t*4]=r,n.data[t*4+1]=r,n.data[t*4+2]=r,n.data[t*4+3]=255}return n}}let B0=null;function KP(e={}){return B0||(B0=new R0(e)),B0}const XP=`
  .point-tagger-marker {
    position: absolute;
    width: 20px;
    height: 20px;
    margin-left: -10px;
    margin-top: -10px;
    border: 2px solid #ff4444;
    border-radius: 50%;
    background: rgba(255, 68, 68, 0.3);
    cursor: pointer;
    pointer-events: auto;
    z-index: 100;
    transition: transform 0.1s;
  }

  .point-tagger-marker:hover {
    transform: scale(1.2);
    background: rgba(255, 68, 68, 0.5);
  }

  .point-tagger-marker.selected {
    border-color: #44ff44;
    background: rgba(68, 255, 68, 0.3);
  }

  .point-tagger-marker-label {
    position: absolute;
    top: -24px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 11px;
    white-space: nowrap;
    pointer-events: none;
  }

  .point-tagger-crosshair {
    position: absolute;
    pointer-events: none;
    z-index: 99;
  }

  .point-tagger-crosshair-h,
  .point-tagger-crosshair-v {
    position: absolute;
    background: rgba(255, 255, 255, 0.5);
  }

  .point-tagger-crosshair-h {
    width: 100%;
    height: 1px;
    top: 50%;
  }

  .point-tagger-crosshair-v {
    width: 1px;
    height: 100%;
    left: 50%;
  }

  .point-tagger-info {
    position: absolute;
    bottom: 16px;
    left: 16px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    font-family: monospace;
    pointer-events: none;
    z-index: 101;
  }

  .point-tagger-toolbar {
    display: flex;
    gap: 8px;
  }

  .point-tagger-btn {
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid #666;
    border-radius: 4px;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 12px;
  }

  .point-tagger-btn:hover {
    background: rgba(255, 255, 255, 1);
  }

  .point-tagger-btn.active {
    background: #4CAF50;
    color: white;
    border-color: #45a049;
  }
`,YP=function(e={}){let n=null,t=null,i=new Map,r=new Map,a=!1,c=null,u=null,l=null,f=null,m=null,h=null,p=!1;const _=e.onPointTagged||null,v=e.onTriangulated||null,S=e.onDepthReady||null,D=()=>{if(p)return;const _e=document.createElement("style");_e.textContent=XP,document.head.appendChild(_e),p=!0},w=()=>"pt_"+Date.now().toString(36)+Math.random().toString(36).substr(2,5),T=(_e,De)=>{const Z=n.renderer.domElement.getBoundingClientRect(),me=(_e-Z.left)/Z.width*2-1,we=-((De-Z.top)/Z.height)*2+1,xe=new w0;xe.setFromCamera(new vt(me,we),n.camera);const et=xe.ray.direction.clone(),Ve=(Math.atan2(et.x,et.y)*180/Math.PI+360)%360,nt=Math.asin(et.z)*180/Math.PI;return{normalizedX:me,normalizedY:we,azimuth:Ve,elevation:nt,direction:et.toArray()}},F=(_e,De)=>{const he=_e*Math.PI/180,Z=De*Math.PI/180,me=Math.cos(Z),we=new ye(Math.sin(he)*me,Math.cos(he)*me,Math.sin(Z));we.project(n.camera);const et=n.renderer.domElement.getBoundingClientRect(),Ve=(we.x+1)/2*et.width+et.left,nt=(-we.y+1)/2*et.height+et.top,Be=new ye;n.camera.getWorldDirection(Be);const U=new ye(Math.sin(he)*me,Math.cos(he)*me,Math.sin(Z)).dot(Be)>0;return{screenX:Ve,screenY:nt,isVisible:U}},E=async(_e,De)=>{if(!m)return console.warn("[PointTagger] No depth data available"),null;const Z=n.renderer.domElement.getBoundingClientRect(),me=(_e-Z.left)/Z.width,we=(De-Z.top)/Z.height,xe=m.getDepthAtUV(me,we),et=m.getNormalizedDepthAt(me*m.width,we*m.height);return{depth:xe,normalizedDepth:et}},A=_e=>{const De=document.createElement("div");De.className="point-tagger-marker",De.dataset.pointId=_e.id;const he=document.createElement("div");return he.className="point-tagger-marker-label",he.textContent=_e.name,De.appendChild(he),De.addEventListener("click",Z=>{Z.stopPropagation(),R(_e.id)}),De.addEventListener("contextmenu",Z=>{Z.preventDefault(),N(_e.id)}),De},L=()=>{if(!f)return;const _e=f.querySelectorAll(".point-tagger-marker"),De=new Map;_e.forEach(he=>De.set(he.dataset.pointId,he)),i.forEach((he,Z)=>{if(he.imageUrl!==h)return;const{screenX:me,screenY:we,isVisible:xe}=F(he.azimuth,he.elevation);let et=De.get(Z);if(et||(et=A(he),f.appendChild(et)),xe){const nt=n.renderer.domElement.getBoundingClientRect();et.style.display="block",et.style.left=`${me-nt.left}px`,et.style.top=`${we-nt.top}px`,et.classList.toggle("selected",Z===c)}else et.style.display="none";De.delete(Z)}),De.forEach(he=>he.remove())},I=async _e=>{var xe,et,Ve,nt,Be,ae,U,Se,ze,Oe,Ye,H;if(!a)return;const he=n.renderer.domElement.getBoundingClientRect();if(_e.clientX<he.left||_e.clientX>he.right||_e.clientY<he.top||_e.clientY>he.bottom)return;const Z=T(_e.clientX,_e.clientY),me=await E(_e.clientX,_e.clientY),we={id:w(),name:`Point ${i.size+1}`,screenX:_e.clientX-he.left,screenY:_e.clientY-he.top,normalizedX:Z.normalizedX,normalizedY:Z.normalizedY,azimuth:Z.azimuth,elevation:Z.elevation,direction:Z.direction,depth:(me==null?void 0:me.depth)||null,normalizedDepth:(me==null?void 0:me.normalizedDepth)||null,imageUrl:h,shotMetadata:{shot:(et=(xe=n.stores).shot)==null?void 0:et.call(xe),capture:(nt=(Ve=n.stores).capture)==null?void 0:nt.call(Ve),facing:(ae=(Be=n.stores).facing)==null?void 0:ae.call(Be),horizon:(Se=(U=n.stores).horizon)==null?void 0:Se.call(U),rotation:(Oe=(ze=n.stores).rotation)==null?void 0:Oe.call(ze),yaw:(H=(Ye=n.stores).yaw)==null?void 0:H.call(Ye)}};return i.set(we.id,we),L(),console.log("[PointTagger] Tagged point:",we),_&&_(we),we},R=_e=>{c=_e,L();const De=i.get(_e);De&&q(De)},N=_e=>{i.delete(_e),c===_e&&(c=null),L()},q=_e=>{var De,he;if(l){if(!_e){l.style.display="none";return}l.style.display="block",l.innerHTML=`
      <strong>${_e.name}</strong><br>
      Azimuth: ${_e.azimuth.toFixed(2)}&deg;<br>
      Elevation: ${_e.elevation.toFixed(2)}&deg;<br>
      Depth: ${((De=_e.depth)==null?void 0:De.toFixed(4))||"N/A"}<br>
      Normalized: ${((he=_e.normalizedDepth)==null?void 0:he.toFixed(4))||"N/A"}
    `}},ne=(_e,De,he)=>{var me,we;r.has(_e)||r.set(_e,{pointName:_e,views:[]});const Z=r.get(_e);return Z.views.push({point:{...De},cameraPosition:he||[0,0,0],rotation:((me=De.shotMetadata)==null?void 0:me.rotation)||[],yaw:((we=De.shotMetadata)==null?void 0:we.yaw)||0}),console.log(`[PointTagger] Added view to set "${_e}". Total views: ${Z.views.length}`),Z},Q=_e=>{const De=r.get(_e);if(!De||De.views.length<2)return console.warn("[PointTagger] Need at least 2 views for triangulation"),null;console.log(`[PointTagger] Triangulating "${_e}" with ${De.views.length} views`);const he=De.views.map(me=>{const{point:we,cameraPosition:xe}=me,et=we.azimuth*Math.PI/180,Ve=we.elevation*Math.PI/180,nt=Math.cos(Ve),Be=[Math.sin(et)*nt,Math.cos(et)*nt,Math.sin(Ve)];if(me.rotation&&me.rotation.length===9){const ae=me.rotation,U=[ae[0]*Be[0]+ae[1]*Be[1]+ae[2]*Be[2],ae[3]*Be[0]+ae[4]*Be[1]+ae[5]*Be[2],ae[6]*Be[0]+ae[7]*Be[1]+ae[8]*Be[2]];Be[0]=U[0],Be[1]=U[1],Be[2]=U[2]}return{origin:xe,direction:Be,depth:we.depth,normalizedDepth:we.normalizedDepth}}),Z=W(he);return v&&v(_e,Z),Z},W=_e=>{if(_e.length<2)return null;let De=_e.map(we=>{const xe=we.depth||1;return[we.origin[0]+we.direction[0]*xe,we.origin[1]+we.direction[1]*xe,we.origin[2]+we.direction[2]*xe]}),he=[0,0,0];De.forEach(we=>{he[0]+=we[0]/De.length,he[1]+=we[1]/De.length,he[2]+=we[2]/De.length});for(let we=0;we<10;we++){let xe=[0,0,0],et=0;_e.forEach(Ve=>{const nt=[he[0]-Ve.origin[0],he[1]-Ve.origin[1],he[2]-Ve.origin[2]],Be=nt[0]*Ve.direction[0]+nt[1]*Ve.direction[1]+nt[2]*Ve.direction[2],ae=[Ve.origin[0]+Ve.direction[0]*Be,Ve.origin[1]+Ve.direction[1]*Be,Ve.origin[2]+Ve.direction[2]*Be],U=Ve.normalizedDepth!==null?1-Ve.normalizedDepth*.5:1;xe[0]+=ae[0]*U,xe[1]+=ae[1]*U,xe[2]+=ae[2]*U,et+=U}),he=[xe[0]/et,xe[1]/et,xe[2]/et]}let Z=0;const me=_e.map(we=>{const xe=[he[0]-we.origin[0],he[1]-we.origin[1],he[2]-we.origin[2]],et=xe[0]*we.direction[0]+xe[1]*we.direction[1]+xe[2]*we.direction[2],Ve=[we.origin[0]+we.direction[0]*et,we.origin[1]+we.direction[1]*et,we.origin[2]+we.direction[2]*et],nt=Math.sqrt(Math.pow(he[0]-Ve[0],2)+Math.pow(he[1]-Ve[1],2)+Math.pow(he[2]-Ve[2],2));return Z+=nt,nt});return{position:he,averageError:Z/_e.length,maxError:Math.max(...me),viewCount:_e.length,confidence:1/(1+Z/_e.length)}};return{name:"point-tagger",init(_e){var he,Z,me,we,xe,et,Ve,nt;n=_e,u=n.wrapper,D(),f=document.createElement("div"),f.className="point-tagger-markers",f.style.cssText="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden;",u.appendChild(f),l=document.createElement("div"),l.className="point-tagger-info",l.style.display="none",u.appendChild(l),u.addEventListener("click",I);const De=()=>{requestAnimationFrame(L)};(Z=(he=n.stores).facing)==null||Z.call(he,De),(we=(me=n.stores).horizon)==null||we.call(me,De),(et=(xe=n.stores).fov)==null||et.call(xe,De),(nt=(Ve=n.stores).urls)==null||nt.call(Ve,Be=>{Be&&Be.length>0&&(h=Array.isArray(Be[0])?Be[0][0]:Be[0],m=null)}),console.log("[PointTagger] Plugin initialized")},destroy(){u&&u.removeEventListener("click",I),f&&f.remove(),l&&l.remove(),t&&t.dispose(),i.clear(),r.clear()},setTaggingMode:_e=>{a=_e,u&&(u.style.cursor=_e?"crosshair":"default"),console.log("[PointTagger] Tagging mode:",_e?"ON":"OFF")},estimateDepth:async()=>{var he,Z;t||(t=new R0({onProgress:me=>console.log("[PointTagger] Depth model loading:",me),onReady:()=>console.log("[PointTagger] Depth model ready")}));const _e=(Z=(he=n.stores).urls)==null?void 0:Z.call(he);if(!_e||_e.length===0)return console.warn("[PointTagger] No image loaded"),null;const De=Array.isArray(_e[0])?_e[0][0]:_e[0];h=De,console.log("[PointTagger] Estimating depth for:",De);try{return m=await t.estimateDepth(De),console.log("[PointTagger] Depth estimation complete:",{width:m.width,height:m.height,minDepth:m.minDepth,maxDepth:m.maxDepth}),S&&S(m),m}catch(me){throw console.error("[PointTagger] Depth estimation failed:",me),me}},getDepthEstimator:()=>t,getDepthResult:()=>m,tagPoint:I,getPoints:()=>Array.from(i.values()),getPointsForImage:_e=>Array.from(i.values()).filter(De=>De.imageUrl===_e),getPoint:_e=>i.get(_e),removePoint:N,selectPoint:R,addToTriangulationSet:ne,triangulate:Q,getTriangulationSet:_e=>r.get(_e),getAllTriangulationSets:()=>Object.fromEntries(r),exportData:()=>({points:Array.from(i.values()),triangulationSets:Object.fromEntries(Array.from(r.entries()).map(([_e,De])=>[_e,{...De,triangulatedPosition:Q(_e)}]))}),importData:_e=>{_e.points&&_e.points.forEach(De=>i.set(De.id,De)),_e.triangulationSets&&Object.entries(_e.triangulationSets).forEach(([De,he])=>{r.set(De,he)}),L()},updateMarkers:L}};class kb extends HTMLElement{static get observedAttributes(){return["fov","facing","horizon","src"]}constructor(){super(),this.viewer=null,console.log("init")}attributeChangedCallback(n,t,i){console.log("attribute changed",n,i);const r=this,a=function(c,u){if(console.log("debouceAttrChange",c,u),r.viewer){if(r.viewer[c])console.log("setting",c,u),r.viewer[c](u);else if(c=="src"){const[l,f]=u.split(".");r.viewer.show([[`${l}/0.${f}`],[`${l}/1.${f}`],[`${l}/2.${f}`]],0,[`${l}/0.obj`,`${l}/1.obj`,`${l}/2.obj`])}}else setTimeout(()=>a(c,u),100)};a(n,i)}connectedCallback(){console.log("connected");const n=this;this.style.display="block",this.viewer=new Mb(n,{plugins:[]})}updateViewer(){console.log("updating viewer"),this.viewer.show([["https://image.geocam.xyz/gc2-2022-10-28-5985_s-Boise_driving_v-Ben1027_n-2/0/0000/00002506.jpg?bytes=8431183872-8434173007&container=https%3A%2F%2Fs3proxy.geocam.xyz%2Fgc-raw-surveys-archive%2FNIST%2FBoiseDriving%2FBen_10-27%2Fgc2-2022-10-28-5985_s-Boise_driving_v-Ben1027_n-2_0.tar"],["https://image.geocam.xyz/gc2-2022-10-28-5985_s-Boise_driving_v-Ben1027_n-2/1/0000/00002506.jpg?bytes=8022497792-8025797203&container=https%3A%2F%2Fs3proxy.geocam.xyz%2Fgc-raw-surveys-archive%2FNIST%2FBoiseDriving%2FBen_10-27%2Fgc2-2022-10-28-5985_s-Boise_driving_v-Ben1027_n-2_1.tar"],["https://image.geocam.xyz/gc2-2022-10-28-5985_s-Boise_driving_v-Ben1027_n-2/2/0000/00002506.jpg?bytes=8256700416-8259564683&container=https%3A%2F%2Fs3proxy.geocam.xyz%2Fgc-raw-surveys-archive%2FNIST%2FBoiseDriving%2FBen_10-27%2Fgc2-2022-10-28-5985_s-Boise_driving_v-Ben1027_n-2_2.tar"]],0,["https://manager.geocam.xyz/calibration/717/hemisphere_0.obj","https://manager.geocam.xyz/calibration/717/hemisphere_1.obj","https://manager.geocam.xyz/calibration/717/hemisphere_2.obj"])}disconnectedCallback(){console.log("disconnected"),this.viewer=null}}window.customElements.define("geocam-viewer",kb),vi.DepthEstimator=R0,vi.DepthResult=Db,vi.GeocamViewer=kb,vi.PointTaggerPlugin=YP,vi.getDepthEstimator=KP,vi.viewer=Mb,Object.defineProperty(vi,Symbol.toStringTag,{value:"Module"})});
