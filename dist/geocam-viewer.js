function HO(t, e) {
  for (var n = 0; n < e.length; n++) {
    const s = e[n];
    if (typeof s != "string" && !Array.isArray(s)) {
      for (const i in s)
        if (i !== "default" && !(i in t)) {
          const r = Object.getOwnPropertyDescriptor(s, i);
          r && Object.defineProperty(t, i, r.get ? r : {
            enumerable: !0,
            get: () => s[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
Number.EPSILON === void 0 && (Number.EPSILON = Math.pow(2, -52));
Number.isInteger === void 0 && (Number.isInteger = function(t) {
  return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
});
Math.sign === void 0 && (Math.sign = function(t) {
  return t < 0 ? -1 : t > 0 ? 1 : +t;
});
"name" in Function.prototype || Object.defineProperty(Function.prototype, "name", {
  get: function() {
    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
  }
});
Object.assign === void 0 && (Object.assign = function(t) {
  if (t == null)
    throw new TypeError("Cannot convert undefined or null to object");
  const e = Object(t);
  for (let n = 1; n < arguments.length; n++) {
    const s = arguments[n];
    if (s != null)
      for (const i in s)
        Object.prototype.hasOwnProperty.call(s, i) && (e[i] = s[i]);
  }
  return e;
});
const jO = "119", qO = 0, VT = 1, XO = 2, kE = 1, KO = 2, ud = 3, Rf = 0, is = 1, ax = 2, AE = 1, ha = 0, vd = 1, UT = 2, GT = 3, WT = 4, YO = 5, Ll = 100, ZO = 101, JO = 102, HT = 103, jT = 104, QO = 200, eL = 201, tL = 202, nL = 203, ME = 204, RE = 205, sL = 206, iL = 207, rL = 208, oL = 209, aL = 210, cL = 0, lL = 1, uL = 2, Bv = 3, hL = 4, dL = 5, fL = 6, pL = 7, cx = 0, mL = 1, gL = 2, jl = 0, yL = 1, xL = 2, bL = 3, vL = 4, wL = 5, A1 = 300, M1 = 301, R1 = 302, DE = 303, D1 = 304, Df = 306, lx = 307, Gg = 1e3, hi = 1001, Wg = 1002, ps = 1003, zv = 1004, Vv = 1005, Vs = 1006, $E = 1007, ux = 1008, $f = 1009, SL = 1010, _L = 1011, Hg = 1012, TL = 1013, Fg = 1014, ra = 1015, jg = 1016, CL = 1017, IL = 1018, EL = 1019, wd = 1020, NL = 1021, xc = 1022, Zi = 1023, kL = 1024, AL = 1025, ML = Zi, ql = 1026, Ed = 1027, RL = 1028, DL = 1029, $L = 1030, OL = 1031, LL = 1032, FL = 1033, qT = 33776, XT = 33777, KT = 33778, YT = 33779, ZT = 35840, JT = 35841, QT = 35842, eC = 35843, PL = 36196, tC = 37492, nC = 37496, BL = 37808, zL = 37809, VL = 37810, UL = 37811, GL = 37812, WL = 37813, HL = 37814, jL = 37815, qL = 37816, XL = 37817, KL = 37818, YL = 37819, ZL = 37820, JL = 37821, QL = 36492, eF = 37840, tF = 37841, nF = 37842, sF = 37843, iF = 37844, rF = 37845, oF = 37846, aF = 37847, cF = 37848, lF = 37849, uF = 37850, hF = 37851, dF = 37852, fF = 37853, pF = 2200, mF = 2201, gF = 2202, qg = 2300, Pg = 2301, Fb = 2302, Ql = 2400, zl = 2401, Xg = 2402, $1 = 2500, OE = 2501, yF = 0, gi = 3e3, hx = 3001, O1 = 3007, L1 = 3002, xF = 3003, LE = 3004, FE = 3005, PE = 3006, bF = 3200, vF = 3201, Ru = 0, wF = 1, Pb = 7680, SF = 519, dx = 35044, Nd = 35048;
function Po() {
}
Object.assign(Po.prototype, {
  addEventListener: function(t, e) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
  },
  hasEventListener: function(t, e) {
    if (this._listeners === void 0)
      return !1;
    const n = this._listeners;
    return n[t] !== void 0 && n[t].indexOf(e) !== -1;
  },
  removeEventListener: function(t, e) {
    if (this._listeners === void 0)
      return;
    const s = this._listeners[t];
    if (s !== void 0) {
      const i = s.indexOf(e);
      i !== -1 && s.splice(i, 1);
    }
  },
  dispatchEvent: function(t) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[t.type];
    if (n !== void 0) {
      t.target = this;
      const s = n.slice(0);
      for (let i = 0, r = s.length; i < r; i++)
        s[i].call(this, t);
    }
  }
});
const Is = [];
for (let t = 0; t < 256; t++)
  Is[t] = (t < 16 ? "0" : "") + t.toString(16);
let Nm = 1234567;
const Et = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    const t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0;
    return (Is[t & 255] + Is[t >> 8 & 255] + Is[t >> 16 & 255] + Is[t >> 24 & 255] + "-" + Is[e & 255] + Is[e >> 8 & 255] + "-" + Is[e >> 16 & 15 | 64] + Is[e >> 24 & 255] + "-" + Is[n & 63 | 128] + Is[n >> 8 & 255] + "-" + Is[n >> 16 & 255] + Is[n >> 24 & 255] + Is[s & 255] + Is[s >> 8 & 255] + Is[s >> 16 & 255] + Is[s >> 24 & 255]).toUpperCase();
  },
  clamp: function(t, e, n) {
    return Math.max(e, Math.min(n, t));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo: function(t, e) {
    return (t % e + e) % e;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear: function(t, e, n, s, i) {
    return s + (t - e) * (i - s) / (n - e);
  },
  // https://en.wikipedia.org/wiki/Linear_interpolation
  lerp: function(t, e, n) {
    return (1 - n) * t + n * e;
  },
  // http://en.wikipedia.org/wiki/Smoothstep
  smoothstep: function(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * (3 - 2 * t));
  },
  smootherstep: function(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * t * (t * (t * 6 - 15) + 10));
  },
  // Random integer from <low, high> interval
  randInt: function(t, e) {
    return t + Math.floor(Math.random() * (e - t + 1));
  },
  // Random float from <low, high> interval
  randFloat: function(t, e) {
    return t + Math.random() * (e - t);
  },
  // Random float from <-range/2, range/2> interval
  randFloatSpread: function(t) {
    return t * (0.5 - Math.random());
  },
  // Deterministic pseudo-random float in the interval [ 0, 1 ]
  seededRandom: function(t) {
    return t !== void 0 && (Nm = t % 2147483647), Nm = Nm * 16807 % 2147483647, (Nm - 1) / 2147483646;
  },
  degToRad: function(t) {
    return t * Et.DEG2RAD;
  },
  radToDeg: function(t) {
    return t * Et.RAD2DEG;
  },
  isPowerOfTwo: function(t) {
    return (t & t - 1) === 0 && t !== 0;
  },
  ceilPowerOfTwo: function(t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
  },
  floorPowerOfTwo: function(t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
  },
  setQuaternionFromProperEuler: function(t, e, n, s, i) {
    const r = Math.cos, o = Math.sin, a = r(n / 2), c = o(n / 2), l = r((e + s) / 2), u = o((e + s) / 2), h = r((e - s) / 2), d = o((e - s) / 2), f = r((s - e) / 2), p = o((s - e) / 2);
    switch (i) {
      case "XYX":
        t.set(a * u, c * h, c * d, a * l);
        break;
      case "YZY":
        t.set(c * d, a * u, c * h, a * l);
        break;
      case "ZXZ":
        t.set(c * h, c * d, a * u, a * l);
        break;
      case "XZX":
        t.set(a * u, c * p, c * f, a * l);
        break;
      case "YXY":
        t.set(c * f, a * u, c * p, a * l);
        break;
      case "ZYZ":
        t.set(c * p, c * f, a * u, a * l);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
    }
  }
};
function Ce(t = 0, e = 0) {
  this.x = t, this.y = e;
}
Object.defineProperties(Ce.prototype, {
  width: {
    get: function() {
      return this.x;
    },
    set: function(t) {
      this.x = t;
    }
  },
  height: {
    get: function() {
      return this.y;
    },
    set: function(t) {
      this.y = t;
    }
  }
});
Object.assign(Ce.prototype, {
  isVector2: !0,
  set: function(t, e) {
    return this.x = t, this.y = e, this;
  },
  setScalar: function(t) {
    return this.x = t, this.y = t, this;
  },
  setX: function(t) {
    return this.x = t, this;
  },
  setY: function(t) {
    return this.y = t, this;
  },
  setComponent: function(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  },
  getComponent: function(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y);
  },
  copy: function(t) {
    return this.x = t.x, this.y = t.y, this;
  },
  add: function(t, e) {
    return e !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this);
  },
  addScalar: function(t) {
    return this.x += t, this.y += t, this;
  },
  addVectors: function(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this;
  },
  addScaledVector: function(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this;
  },
  sub: function(t, e) {
    return e !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this);
  },
  subScalar: function(t) {
    return this.x -= t, this.y -= t, this;
  },
  subVectors: function(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this;
  },
  multiply: function(t) {
    return this.x *= t.x, this.y *= t.y, this;
  },
  multiplyScalar: function(t) {
    return this.x *= t, this.y *= t, this;
  },
  divide: function(t) {
    return this.x /= t.x, this.y /= t.y, this;
  },
  divideScalar: function(t) {
    return this.multiplyScalar(1 / t);
  },
  applyMatrix3: function(t) {
    const e = this.x, n = this.y, s = t.elements;
    return this.x = s[0] * e + s[3] * n + s[6], this.y = s[1] * e + s[4] * n + s[7], this;
  },
  min: function(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
  },
  max: function(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
  },
  clamp: function(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
  },
  clampScalar: function(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
  },
  clampLength: function(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  },
  floor: function() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  },
  ceil: function() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  },
  round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  },
  roundToZero: function() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  },
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this;
  },
  dot: function(t) {
    return this.x * t.x + this.y * t.y;
  },
  cross: function(t) {
    return this.x * t.y - this.y * t.x;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  angle: function() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  },
  distanceTo: function(t) {
    return Math.sqrt(this.distanceToSquared(t));
  },
  distanceToSquared: function(t) {
    const e = this.x - t.x, n = this.y - t.y;
    return e * e + n * n;
  },
  manhattanDistanceTo: function(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  },
  setLength: function(t) {
    return this.normalize().multiplyScalar(t);
  },
  lerp: function(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
  },
  lerpVectors: function(t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this;
  },
  equals: function(t) {
    return t.x === this.x && t.y === this.y;
  },
  fromArray: function(t, e) {
    return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this;
  },
  toArray: function(t, e) {
    return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t;
  },
  fromBufferAttribute: function(t, e, n) {
    return n !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this;
  },
  rotateAround: function(t, e) {
    const n = Math.cos(e), s = Math.sin(e), i = this.x - t.x, r = this.y - t.y;
    return this.x = i * n - r * s + t.x, this.y = i * s + r * n + t.y, this;
  },
  random: function() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
});
function Js() {
  this.elements = [
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
  ], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
}
Object.assign(Js.prototype, {
  isMatrix3: !0,
  set: function(t, e, n, s, i, r, o, a, c) {
    const l = this.elements;
    return l[0] = t, l[1] = s, l[2] = o, l[3] = e, l[4] = i, l[5] = a, l[6] = n, l[7] = r, l[8] = c, this;
  },
  identity: function() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  },
  clone: function() {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function(t) {
    const e = this.elements, n = t.elements;
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this;
  },
  extractBasis: function(t, e, n) {
    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  },
  setFromMatrix4: function(t) {
    const e = t.elements;
    return this.set(
      e[0],
      e[4],
      e[8],
      e[1],
      e[5],
      e[9],
      e[2],
      e[6],
      e[10]
    ), this;
  },
  multiply: function(t) {
    return this.multiplyMatrices(this, t);
  },
  premultiply: function(t) {
    return this.multiplyMatrices(t, this);
  },
  multiplyMatrices: function(t, e) {
    const n = t.elements, s = e.elements, i = this.elements, r = n[0], o = n[3], a = n[6], c = n[1], l = n[4], u = n[7], h = n[2], d = n[5], f = n[8], p = s[0], y = s[3], g = s[6], m = s[1], x = s[4], v = s[7], b = s[2], w = s[5], S = s[8];
    return i[0] = r * p + o * m + a * b, i[3] = r * y + o * x + a * w, i[6] = r * g + o * v + a * S, i[1] = c * p + l * m + u * b, i[4] = c * y + l * x + u * w, i[7] = c * g + l * v + u * S, i[2] = h * p + d * m + f * b, i[5] = h * y + d * x + f * w, i[8] = h * g + d * v + f * S, this;
  },
  multiplyScalar: function(t) {
    const e = this.elements;
    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
  },
  determinant: function() {
    const t = this.elements, e = t[0], n = t[1], s = t[2], i = t[3], r = t[4], o = t[5], a = t[6], c = t[7], l = t[8];
    return e * r * l - e * o * c - n * i * l + n * o * a + s * i * c - s * r * a;
  },
  getInverse: function(t, e) {
    e !== void 0 && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
    const n = t.elements, s = this.elements, i = n[0], r = n[1], o = n[2], a = n[3], c = n[4], l = n[5], u = n[6], h = n[7], d = n[8], f = d * c - l * h, p = l * u - d * a, y = h * a - c * u, g = i * f + r * p + o * y;
    if (g === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / g;
    return s[0] = f * m, s[1] = (o * h - d * r) * m, s[2] = (l * r - o * c) * m, s[3] = p * m, s[4] = (d * i - o * u) * m, s[5] = (o * a - l * i) * m, s[6] = y * m, s[7] = (r * u - h * i) * m, s[8] = (c * i - r * a) * m, this;
  },
  transpose: function() {
    let t;
    const e = this.elements;
    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
  },
  getNormalMatrix: function(t) {
    return this.setFromMatrix4(t).getInverse(this).transpose();
  },
  transposeIntoArray: function(t) {
    const e = this.elements;
    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
  },
  setUvTransform: function(t, e, n, s, i, r, o) {
    const a = Math.cos(i), c = Math.sin(i);
    this.set(
      n * a,
      n * c,
      -n * (a * r + c * o) + r + t,
      -s * c,
      s * a,
      -s * (-c * r + a * o) + o + e,
      0,
      0,
      1
    );
  },
  scale: function(t, e) {
    const n = this.elements;
    return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this;
  },
  rotate: function(t) {
    const e = Math.cos(t), n = Math.sin(t), s = this.elements, i = s[0], r = s[3], o = s[6], a = s[1], c = s[4], l = s[7];
    return s[0] = e * i + n * a, s[3] = e * r + n * c, s[6] = e * o + n * l, s[1] = -n * i + e * a, s[4] = -n * r + e * c, s[7] = -n * o + e * l, this;
  },
  translate: function(t, e) {
    const n = this.elements;
    return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this;
  },
  equals: function(t) {
    const e = this.elements, n = t.elements;
    for (let s = 0; s < 9; s++)
      if (e[s] !== n[s])
        return !1;
    return !0;
  },
  fromArray: function(t, e) {
    e === void 0 && (e = 0);
    for (let n = 0; n < 9; n++)
      this.elements[n] = t[n + e];
    return this;
  },
  toArray: function(t, e) {
    t === void 0 && (t = []), e === void 0 && (e = 0);
    const n = this.elements;
    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t;
  }
});
let gl;
const Nc = {
  getDataURL: function(t) {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u")
      return t.src;
    let e;
    if (t instanceof HTMLCanvasElement)
      e = t;
    else {
      gl === void 0 && (gl = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), gl.width = t.width, gl.height = t.height;
      const n = gl.getContext("2d");
      t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = gl;
    }
    return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", 0.6) : e.toDataURL("image/png");
  }
};
let _F = 0;
function dn(t, e, n, s, i, r, o, a, c, l) {
  Object.defineProperty(this, "id", { value: _F++ }), this.uuid = Et.generateUUID(), this.name = "", this.image = t !== void 0 ? t : dn.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = e !== void 0 ? e : dn.DEFAULT_MAPPING, this.wrapS = n !== void 0 ? n : hi, this.wrapT = s !== void 0 ? s : hi, this.magFilter = i !== void 0 ? i : Vs, this.minFilter = r !== void 0 ? r : ux, this.anisotropy = c !== void 0 ? c : 1, this.format = o !== void 0 ? o : Zi, this.internalFormat = null, this.type = a !== void 0 ? a : $f, this.offset = new Ce(0, 0), this.repeat = new Ce(1, 1), this.center = new Ce(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Js(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = l !== void 0 ? l : gi, this.version = 0, this.onUpdate = null;
}
dn.DEFAULT_IMAGE = void 0;
dn.DEFAULT_MAPPING = A1;
dn.prototype = Object.assign(Object.create(Po.prototype), {
  constructor: dn,
  isTexture: !0,
  updateMatrix: function() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this;
  },
  toJSON: function(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.textures[this.uuid] !== void 0)
      return t.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const s = this.image;
      if (s.uuid === void 0 && (s.uuid = Et.generateUUID()), !e && t.images[s.uuid] === void 0) {
        let i;
        if (Array.isArray(s)) {
          i = [];
          for (let r = 0, o = s.length; r < o; r++)
            i.push(Nc.getDataURL(s[r]));
        } else
          i = Nc.getDataURL(s);
        t.images[s.uuid] = {
          uuid: s.uuid,
          url: i
        };
      }
      n.image = s.uuid;
    }
    return e || (t.textures[this.uuid] = n), n;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  },
  transformUv: function(t) {
    if (this.mapping !== A1)
      return t;
    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1)
      switch (this.wrapS) {
        case Gg:
          t.x = t.x - Math.floor(t.x);
          break;
        case hi:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case Wg:
          Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
          break;
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case Gg:
          t.y = t.y - Math.floor(t.y);
          break;
        case hi:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case Wg:
          Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
          break;
      }
    return this.flipY && (t.y = 1 - t.y), t;
  }
});
Object.defineProperty(dn.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
function en(t = 0, e = 0, n = 0, s = 1) {
  this.x = t, this.y = e, this.z = n, this.w = s;
}
Object.defineProperties(en.prototype, {
  width: {
    get: function() {
      return this.z;
    },
    set: function(t) {
      this.z = t;
    }
  },
  height: {
    get: function() {
      return this.w;
    },
    set: function(t) {
      this.w = t;
    }
  }
});
Object.assign(en.prototype, {
  isVector4: !0,
  set: function(t, e, n, s) {
    return this.x = t, this.y = e, this.z = n, this.w = s, this;
  },
  setScalar: function(t) {
    return this.x = t, this.y = t, this.z = t, this.w = t, this;
  },
  setX: function(t) {
    return this.x = t, this;
  },
  setY: function(t) {
    return this.y = t, this;
  },
  setZ: function(t) {
    return this.z = t, this;
  },
  setW: function(t) {
    return this.w = t, this;
  },
  setComponent: function(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  },
  getComponent: function(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
  },
  add: function(t, e) {
    return e !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this);
  },
  addScalar: function(t) {
    return this.x += t, this.y += t, this.z += t, this.w += t, this;
  },
  addVectors: function(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
  },
  addScaledVector: function(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
  },
  sub: function(t, e) {
    return e !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this);
  },
  subScalar: function(t) {
    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
  },
  subVectors: function(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
  },
  multiplyScalar: function(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  },
  applyMatrix4: function(t) {
    const e = this.x, n = this.y, s = this.z, i = this.w, r = t.elements;
    return this.x = r[0] * e + r[4] * n + r[8] * s + r[12] * i, this.y = r[1] * e + r[5] * n + r[9] * s + r[13] * i, this.z = r[2] * e + r[6] * n + r[10] * s + r[14] * i, this.w = r[3] * e + r[7] * n + r[11] * s + r[15] * i, this;
  },
  divideScalar: function(t) {
    return this.multiplyScalar(1 / t);
  },
  setAxisAngleFromQuaternion: function(t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
  },
  setAxisAngleFromRotationMatrix: function(t) {
    let e, n, s, i;
    const a = t.elements, c = a[0], l = a[4], u = a[8], h = a[1], d = a[5], f = a[9], p = a[2], y = a[6], g = a[10];
    if (Math.abs(l - h) < 0.01 && Math.abs(u - p) < 0.01 && Math.abs(f - y) < 0.01) {
      if (Math.abs(l + h) < 0.1 && Math.abs(u + p) < 0.1 && Math.abs(f + y) < 0.1 && Math.abs(c + d + g - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const x = (c + 1) / 2, v = (d + 1) / 2, b = (g + 1) / 2, w = (l + h) / 4, S = (u + p) / 4, _ = (f + y) / 4;
      return x > v && x > b ? x < 0.01 ? (n = 0, s = 0.707106781, i = 0.707106781) : (n = Math.sqrt(x), s = w / n, i = S / n) : v > b ? v < 0.01 ? (n = 0.707106781, s = 0, i = 0.707106781) : (s = Math.sqrt(v), n = w / s, i = _ / s) : b < 0.01 ? (n = 0.707106781, s = 0.707106781, i = 0) : (i = Math.sqrt(b), n = S / i, s = _ / i), this.set(n, s, i, e), this;
    }
    let m = Math.sqrt((y - f) * (y - f) + (u - p) * (u - p) + (h - l) * (h - l));
    return Math.abs(m) < 1e-3 && (m = 1), this.x = (y - f) / m, this.y = (u - p) / m, this.z = (h - l) / m, this.w = Math.acos((c + d + g - 1) / 2), this;
  },
  min: function(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
  },
  max: function(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
  },
  clamp: function(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
  },
  clampScalar: function(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
  },
  clampLength: function(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  },
  floor: function() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  },
  ceil: function() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  },
  round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  },
  roundToZero: function() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  },
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  },
  dot: function(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(t) {
    return this.normalize().multiplyScalar(t);
  },
  lerp: function(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
  },
  lerpVectors: function(t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this;
  },
  equals: function(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  },
  fromArray: function(t, e) {
    return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
  },
  toArray: function(t, e) {
    return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
  },
  fromBufferAttribute: function(t, e, n) {
    return n !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
  },
  random: function() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
});
function Ji(t, e, n) {
  this.width = t, this.height = e, this.scissor = new en(0, 0, t, e), this.scissorTest = !1, this.viewport = new en(0, 0, t, e), n = n || {}, this.texture = new dn(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Vs, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !0, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null;
}
Ji.prototype = Object.assign(Object.create(Po.prototype), {
  constructor: Ji,
  isWebGLRenderTarget: !0,
  setSize: function(t, e) {
    (this.width !== t || this.height !== e) && (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function sC(t, e, n) {
  Ji.call(this, t, e, n), this.samples = 4;
}
sC.prototype = Object.assign(Object.create(Ji.prototype), {
  constructor: sC,
  isWebGLMultisampleRenderTarget: !0,
  copy: function(t) {
    return Ji.prototype.copy.call(this, t), this.samples = t.samples, this;
  }
});
function xs(t = 0, e = 0, n = 0, s = 1) {
  this._x = t, this._y = e, this._z = n, this._w = s;
}
Object.assign(xs, {
  slerp: function(t, e, n, s) {
    return n.copy(t).slerp(e, s);
  },
  slerpFlat: function(t, e, n, s, i, r, o) {
    let a = n[s + 0], c = n[s + 1], l = n[s + 2], u = n[s + 3];
    const h = i[r + 0], d = i[r + 1], f = i[r + 2], p = i[r + 3];
    if (u !== p || a !== h || c !== d || l !== f) {
      let y = 1 - o, g = a * h + c * d + l * f + u * p, m = g >= 0 ? 1 : -1, x = 1 - g * g;
      if (x > Number.EPSILON) {
        const b = Math.sqrt(x), w = Math.atan2(b, g * m);
        y = Math.sin(y * w) / b, o = Math.sin(o * w) / b;
      }
      const v = o * m;
      if (a = a * y + h * v, c = c * y + d * v, l = l * y + f * v, u = u * y + p * v, y === 1 - o) {
        const b = 1 / Math.sqrt(a * a + c * c + l * l + u * u);
        a *= b, c *= b, l *= b, u *= b;
      }
    }
    t[e] = a, t[e + 1] = c, t[e + 2] = l, t[e + 3] = u;
  },
  multiplyQuaternionsFlat: function(t, e, n, s, i, r) {
    const o = n[s], a = n[s + 1], c = n[s + 2], l = n[s + 3], u = i[r], h = i[r + 1], d = i[r + 2], f = i[r + 3];
    return t[e] = o * f + l * u + a * d - c * h, t[e + 1] = a * f + l * h + c * u - o * d, t[e + 2] = c * f + l * d + o * h - a * u, t[e + 3] = l * f - o * u - a * h - c * d, t;
  }
});
Object.defineProperties(xs.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(t) {
      this._x = t, this._onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(t) {
      this._y = t, this._onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(t) {
      this._z = t, this._onChangeCallback();
    }
  },
  w: {
    get: function() {
      return this._w;
    },
    set: function(t) {
      this._w = t, this._onChangeCallback();
    }
  }
});
Object.assign(xs.prototype, {
  isQuaternion: !0,
  set: function(t, e, n, s) {
    return this._x = t, this._y = e, this._z = n, this._w = s, this._onChangeCallback(), this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function(t) {
    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
  },
  setFromEuler: function(t, e) {
    if (!(t && t.isEuler))
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    const n = t._x, s = t._y, i = t._z, r = t.order, o = Math.cos, a = Math.sin, c = o(n / 2), l = o(s / 2), u = o(i / 2), h = a(n / 2), d = a(s / 2), f = a(i / 2);
    switch (r) {
      case "XYZ":
        this._x = h * l * u + c * d * f, this._y = c * d * u - h * l * f, this._z = c * l * f + h * d * u, this._w = c * l * u - h * d * f;
        break;
      case "YXZ":
        this._x = h * l * u + c * d * f, this._y = c * d * u - h * l * f, this._z = c * l * f - h * d * u, this._w = c * l * u + h * d * f;
        break;
      case "ZXY":
        this._x = h * l * u - c * d * f, this._y = c * d * u + h * l * f, this._z = c * l * f + h * d * u, this._w = c * l * u - h * d * f;
        break;
      case "ZYX":
        this._x = h * l * u - c * d * f, this._y = c * d * u + h * l * f, this._z = c * l * f - h * d * u, this._w = c * l * u + h * d * f;
        break;
      case "YZX":
        this._x = h * l * u + c * d * f, this._y = c * d * u + h * l * f, this._z = c * l * f - h * d * u, this._w = c * l * u - h * d * f;
        break;
      case "XZY":
        this._x = h * l * u - c * d * f, this._y = c * d * u - h * l * f, this._z = c * l * f + h * d * u, this._w = c * l * u + h * d * f;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r);
    }
    return e !== !1 && this._onChangeCallback(), this;
  },
  setFromAxisAngle: function(t, e) {
    const n = e / 2, s = Math.sin(n);
    return this._x = t.x * s, this._y = t.y * s, this._z = t.z * s, this._w = Math.cos(n), this._onChangeCallback(), this;
  },
  setFromRotationMatrix: function(t) {
    const e = t.elements, n = e[0], s = e[4], i = e[8], r = e[1], o = e[5], a = e[9], c = e[2], l = e[6], u = e[10], h = n + o + u;
    if (h > 0) {
      const d = 0.5 / Math.sqrt(h + 1);
      this._w = 0.25 / d, this._x = (l - a) * d, this._y = (i - c) * d, this._z = (r - s) * d;
    } else if (n > o && n > u) {
      const d = 2 * Math.sqrt(1 + n - o - u);
      this._w = (l - a) / d, this._x = 0.25 * d, this._y = (s + r) / d, this._z = (i + c) / d;
    } else if (o > u) {
      const d = 2 * Math.sqrt(1 + o - n - u);
      this._w = (i - c) / d, this._x = (s + r) / d, this._y = 0.25 * d, this._z = (a + l) / d;
    } else {
      const d = 2 * Math.sqrt(1 + u - n - o);
      this._w = (r - s) / d, this._x = (i + c) / d, this._y = (a + l) / d, this._z = 0.25 * d;
    }
    return this._onChangeCallback(), this;
  },
  setFromUnitVectors: function(t, e) {
    let s = t.dot(e) + 1;
    return s < 1e-6 ? (s = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = s) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = s)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = s), this.normalize();
  },
  angleTo: function(t) {
    return 2 * Math.acos(Math.abs(Et.clamp(this.dot(t), -1, 1)));
  },
  rotateTowards: function(t, e) {
    const n = this.angleTo(t);
    if (n === 0)
      return this;
    const s = Math.min(1, e / n);
    return this.slerp(t, s), this;
  },
  identity: function() {
    return this.set(0, 0, 0, 1);
  },
  inverse: function() {
    return this.conjugate();
  },
  conjugate: function() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  },
  dot: function(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  },
  lengthSq: function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function() {
    let t = this.length();
    return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
  },
  multiply: function(t, e) {
    return e !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t);
  },
  premultiply: function(t) {
    return this.multiplyQuaternions(t, this);
  },
  multiplyQuaternions: function(t, e) {
    const n = t._x, s = t._y, i = t._z, r = t._w, o = e._x, a = e._y, c = e._z, l = e._w;
    return this._x = n * l + r * o + s * c - i * a, this._y = s * l + r * a + i * o - n * c, this._z = i * l + r * c + n * a - s * o, this._w = r * l - n * o - s * a - i * c, this._onChangeCallback(), this;
  },
  slerp: function(t, e) {
    if (e === 0)
      return this;
    if (e === 1)
      return this.copy(t);
    const n = this._x, s = this._y, i = this._z, r = this._w;
    let o = r * t._w + n * t._x + s * t._y + i * t._z;
    if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1)
      return this._w = r, this._x = n, this._y = s, this._z = i, this;
    const a = 1 - o * o;
    if (a <= Number.EPSILON) {
      const d = 1 - e;
      return this._w = d * r + e * this._w, this._x = d * n + e * this._x, this._y = d * s + e * this._y, this._z = d * i + e * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const c = Math.sqrt(a), l = Math.atan2(c, o), u = Math.sin((1 - e) * l) / c, h = Math.sin(e * l) / c;
    return this._w = r * u + this._w * h, this._x = n * u + this._x * h, this._y = s * u + this._y * h, this._z = i * u + this._z * h, this._onChangeCallback(), this;
  },
  equals: function(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
  },
  fromArray: function(t, e) {
    return e === void 0 && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
  },
  toArray: function(t, e) {
    return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
  },
  fromBufferAttribute: function(t, e) {
    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this;
  },
  _onChange: function(t) {
    return this._onChangeCallback = t, this;
  },
  _onChangeCallback: function() {
  }
});
const Bb = new P(), iC = new xs();
function P(t = 0, e = 0, n = 0) {
  this.x = t, this.y = e, this.z = n;
}
Object.assign(P.prototype, {
  isVector3: !0,
  set: function(t, e, n) {
    return n === void 0 && (n = this.z), this.x = t, this.y = e, this.z = n, this;
  },
  setScalar: function(t) {
    return this.x = t, this.y = t, this.z = t, this;
  },
  setX: function(t) {
    return this.x = t, this;
  },
  setY: function(t) {
    return this.y = t, this;
  },
  setZ: function(t) {
    return this.z = t, this;
  },
  setComponent: function(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  },
  getComponent: function(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  },
  add: function(t, e) {
    return e !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this);
  },
  addScalar: function(t) {
    return this.x += t, this.y += t, this.z += t, this;
  },
  addVectors: function(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
  },
  addScaledVector: function(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
  },
  sub: function(t, e) {
    return e !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this);
  },
  subScalar: function(t) {
    return this.x -= t, this.y -= t, this.z -= t, this;
  },
  subVectors: function(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
  },
  multiply: function(t, e) {
    return e !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this);
  },
  multiplyScalar: function(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  },
  multiplyVectors: function(t, e) {
    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
  },
  applyEuler: function(t) {
    return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(iC.setFromEuler(t));
  },
  applyAxisAngle: function(t, e) {
    return this.applyQuaternion(iC.setFromAxisAngle(t, e));
  },
  applyMatrix3: function(t) {
    const e = this.x, n = this.y, s = this.z, i = t.elements;
    return this.x = i[0] * e + i[3] * n + i[6] * s, this.y = i[1] * e + i[4] * n + i[7] * s, this.z = i[2] * e + i[5] * n + i[8] * s, this;
  },
  applyNormalMatrix: function(t) {
    return this.applyMatrix3(t).normalize();
  },
  applyMatrix4: function(t) {
    const e = this.x, n = this.y, s = this.z, i = t.elements, r = 1 / (i[3] * e + i[7] * n + i[11] * s + i[15]);
    return this.x = (i[0] * e + i[4] * n + i[8] * s + i[12]) * r, this.y = (i[1] * e + i[5] * n + i[9] * s + i[13]) * r, this.z = (i[2] * e + i[6] * n + i[10] * s + i[14]) * r, this;
  },
  applyQuaternion: function(t) {
    const e = this.x, n = this.y, s = this.z, i = t.x, r = t.y, o = t.z, a = t.w, c = a * e + r * s - o * n, l = a * n + o * e - i * s, u = a * s + i * n - r * e, h = -i * e - r * n - o * s;
    return this.x = c * a + h * -i + l * -o - u * -r, this.y = l * a + h * -r + u * -i - c * -o, this.z = u * a + h * -o + c * -r - l * -i, this;
  },
  project: function(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
  },
  unproject: function(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
  },
  transformDirection: function(t) {
    const e = this.x, n = this.y, s = this.z, i = t.elements;
    return this.x = i[0] * e + i[4] * n + i[8] * s, this.y = i[1] * e + i[5] * n + i[9] * s, this.z = i[2] * e + i[6] * n + i[10] * s, this.normalize();
  },
  divide: function(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
  },
  divideScalar: function(t) {
    return this.multiplyScalar(1 / t);
  },
  min: function(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
  },
  max: function(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
  },
  clamp: function(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
  },
  clampScalar: function(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
  },
  clampLength: function(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  },
  floor: function() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  },
  ceil: function() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  },
  round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  },
  roundToZero: function() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  },
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  },
  dot: function(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  },
  // TODO lengthSquared?
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(t) {
    return this.normalize().multiplyScalar(t);
  },
  lerp: function(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
  },
  lerpVectors: function(t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this;
  },
  cross: function(t, e) {
    return e !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t);
  },
  crossVectors: function(t, e) {
    const n = t.x, s = t.y, i = t.z, r = e.x, o = e.y, a = e.z;
    return this.x = s * a - i * o, this.y = i * r - n * a, this.z = n * o - s * r, this;
  },
  projectOnVector: function(t) {
    const e = t.lengthSq();
    if (e === 0)
      return this.set(0, 0, 0);
    const n = t.dot(this) / e;
    return this.copy(t).multiplyScalar(n);
  },
  projectOnPlane: function(t) {
    return Bb.copy(this).projectOnVector(t), this.sub(Bb);
  },
  reflect: function(t) {
    return this.sub(Bb.copy(t).multiplyScalar(2 * this.dot(t)));
  },
  angleTo: function(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const n = this.dot(t) / e;
    return Math.acos(Et.clamp(n, -1, 1));
  },
  distanceTo: function(t) {
    return Math.sqrt(this.distanceToSquared(t));
  },
  distanceToSquared: function(t) {
    const e = this.x - t.x, n = this.y - t.y, s = this.z - t.z;
    return e * e + n * n + s * s;
  },
  manhattanDistanceTo: function(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
  },
  setFromSpherical: function(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  },
  setFromSphericalCoords: function(t, e, n) {
    const s = Math.sin(e) * t;
    return this.x = s * Math.sin(n), this.y = Math.cos(e) * t, this.z = s * Math.cos(n), this;
  },
  setFromCylindrical: function(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  },
  setFromCylindricalCoords: function(t, e, n) {
    return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this;
  },
  setFromMatrixPosition: function(t) {
    const e = t.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this;
  },
  setFromMatrixScale: function(t) {
    const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), s = this.setFromMatrixColumn(t, 2).length();
    return this.x = e, this.y = n, this.z = s, this;
  },
  setFromMatrixColumn: function(t, e) {
    return this.fromArray(t.elements, e * 4);
  },
  setFromMatrix3Column: function(t, e) {
    return this.fromArray(t.elements, e * 3);
  },
  equals: function(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  },
  fromArray: function(t, e) {
    return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
  },
  toArray: function(t, e) {
    return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
  },
  fromBufferAttribute: function(t, e, n) {
    return n !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
  },
  random: function() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
});
const yl = new P(), cr = new Mt(), TF = new P(0, 0, 0), CF = new P(1, 1, 1), Yo = new P(), km = new P(), Ci = new P();
function Mt() {
  this.elements = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
}
Object.assign(Mt.prototype, {
  isMatrix4: !0,
  set: function(t, e, n, s, i, r, o, a, c, l, u, h, d, f, p, y) {
    const g = this.elements;
    return g[0] = t, g[4] = e, g[8] = n, g[12] = s, g[1] = i, g[5] = r, g[9] = o, g[13] = a, g[2] = c, g[6] = l, g[10] = u, g[14] = h, g[3] = d, g[7] = f, g[11] = p, g[15] = y, this;
  },
  identity: function() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  clone: function() {
    return new Mt().fromArray(this.elements);
  },
  copy: function(t) {
    const e = this.elements, n = t.elements;
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this;
  },
  copyPosition: function(t) {
    const e = this.elements, n = t.elements;
    return e[12] = n[12], e[13] = n[13], e[14] = n[14], this;
  },
  extractBasis: function(t, e, n) {
    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  },
  makeBasis: function(t, e, n) {
    return this.set(
      t.x,
      e.x,
      n.x,
      0,
      t.y,
      e.y,
      n.y,
      0,
      t.z,
      e.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  extractRotation: function(t) {
    const e = this.elements, n = t.elements, s = 1 / yl.setFromMatrixColumn(t, 0).length(), i = 1 / yl.setFromMatrixColumn(t, 1).length(), r = 1 / yl.setFromMatrixColumn(t, 2).length();
    return e[0] = n[0] * s, e[1] = n[1] * s, e[2] = n[2] * s, e[3] = 0, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = 0, e[8] = n[8] * r, e[9] = n[9] * r, e[10] = n[10] * r, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  },
  makeRotationFromEuler: function(t) {
    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    const e = this.elements, n = t.x, s = t.y, i = t.z, r = Math.cos(n), o = Math.sin(n), a = Math.cos(s), c = Math.sin(s), l = Math.cos(i), u = Math.sin(i);
    if (t.order === "XYZ") {
      const h = r * l, d = r * u, f = o * l, p = o * u;
      e[0] = a * l, e[4] = -a * u, e[8] = c, e[1] = d + f * c, e[5] = h - p * c, e[9] = -o * a, e[2] = p - h * c, e[6] = f + d * c, e[10] = r * a;
    } else if (t.order === "YXZ") {
      const h = a * l, d = a * u, f = c * l, p = c * u;
      e[0] = h + p * o, e[4] = f * o - d, e[8] = r * c, e[1] = r * u, e[5] = r * l, e[9] = -o, e[2] = d * o - f, e[6] = p + h * o, e[10] = r * a;
    } else if (t.order === "ZXY") {
      const h = a * l, d = a * u, f = c * l, p = c * u;
      e[0] = h - p * o, e[4] = -r * u, e[8] = f + d * o, e[1] = d + f * o, e[5] = r * l, e[9] = p - h * o, e[2] = -r * c, e[6] = o, e[10] = r * a;
    } else if (t.order === "ZYX") {
      const h = r * l, d = r * u, f = o * l, p = o * u;
      e[0] = a * l, e[4] = f * c - d, e[8] = h * c + p, e[1] = a * u, e[5] = p * c + h, e[9] = d * c - f, e[2] = -c, e[6] = o * a, e[10] = r * a;
    } else if (t.order === "YZX") {
      const h = r * a, d = r * c, f = o * a, p = o * c;
      e[0] = a * l, e[4] = p - h * u, e[8] = f * u + d, e[1] = u, e[5] = r * l, e[9] = -o * l, e[2] = -c * l, e[6] = d * u + f, e[10] = h - p * u;
    } else if (t.order === "XZY") {
      const h = r * a, d = r * c, f = o * a, p = o * c;
      e[0] = a * l, e[4] = -u, e[8] = c * l, e[1] = h * u + p, e[5] = r * l, e[9] = d * u - f, e[2] = f * u - d, e[6] = o * l, e[10] = p * u + h;
    }
    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  },
  makeRotationFromQuaternion: function(t) {
    return this.compose(TF, t, CF);
  },
  lookAt: function(t, e, n) {
    const s = this.elements;
    return Ci.subVectors(t, e), Ci.lengthSq() === 0 && (Ci.z = 1), Ci.normalize(), Yo.crossVectors(n, Ci), Yo.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Ci.x += 1e-4 : Ci.z += 1e-4, Ci.normalize(), Yo.crossVectors(n, Ci)), Yo.normalize(), km.crossVectors(Ci, Yo), s[0] = Yo.x, s[4] = km.x, s[8] = Ci.x, s[1] = Yo.y, s[5] = km.y, s[9] = Ci.y, s[2] = Yo.z, s[6] = km.z, s[10] = Ci.z, this;
  },
  multiply: function(t, e) {
    return e !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t);
  },
  premultiply: function(t) {
    return this.multiplyMatrices(t, this);
  },
  multiplyMatrices: function(t, e) {
    const n = t.elements, s = e.elements, i = this.elements, r = n[0], o = n[4], a = n[8], c = n[12], l = n[1], u = n[5], h = n[9], d = n[13], f = n[2], p = n[6], y = n[10], g = n[14], m = n[3], x = n[7], v = n[11], b = n[15], w = s[0], S = s[4], _ = s[8], E = s[12], I = s[1], k = s[5], M = s[9], L = s[13], O = s[2], $ = s[6], D = s[10], z = s[14], W = s[3], j = s[7], J = s[11], ne = s[15];
    return i[0] = r * w + o * I + a * O + c * W, i[4] = r * S + o * k + a * $ + c * j, i[8] = r * _ + o * M + a * D + c * J, i[12] = r * E + o * L + a * z + c * ne, i[1] = l * w + u * I + h * O + d * W, i[5] = l * S + u * k + h * $ + d * j, i[9] = l * _ + u * M + h * D + d * J, i[13] = l * E + u * L + h * z + d * ne, i[2] = f * w + p * I + y * O + g * W, i[6] = f * S + p * k + y * $ + g * j, i[10] = f * _ + p * M + y * D + g * J, i[14] = f * E + p * L + y * z + g * ne, i[3] = m * w + x * I + v * O + b * W, i[7] = m * S + x * k + v * $ + b * j, i[11] = m * _ + x * M + v * D + b * J, i[15] = m * E + x * L + v * z + b * ne, this;
  },
  multiplyScalar: function(t) {
    const e = this.elements;
    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
  },
  determinant: function() {
    const t = this.elements, e = t[0], n = t[4], s = t[8], i = t[12], r = t[1], o = t[5], a = t[9], c = t[13], l = t[2], u = t[6], h = t[10], d = t[14], f = t[3], p = t[7], y = t[11], g = t[15];
    return f * (+i * a * u - s * c * u - i * o * h + n * c * h + s * o * d - n * a * d) + p * (+e * a * d - e * c * h + i * r * h - s * r * d + s * c * l - i * a * l) + y * (+e * c * u - e * o * d - i * r * u + n * r * d + i * o * l - n * c * l) + g * (-s * o * l - e * a * u + e * o * h + s * r * u - n * r * h + n * a * l);
  },
  transpose: function() {
    const t = this.elements;
    let e;
    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
  },
  setPosition: function(t, e, n) {
    const s = this.elements;
    return t.isVector3 ? (s[12] = t.x, s[13] = t.y, s[14] = t.z) : (s[12] = t, s[13] = e, s[14] = n), this;
  },
  getInverse: function(t, e) {
    e !== void 0 && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
    const n = this.elements, s = t.elements, i = s[0], r = s[1], o = s[2], a = s[3], c = s[4], l = s[5], u = s[6], h = s[7], d = s[8], f = s[9], p = s[10], y = s[11], g = s[12], m = s[13], x = s[14], v = s[15], b = f * x * h - m * p * h + m * u * y - l * x * y - f * u * v + l * p * v, w = g * p * h - d * x * h - g * u * y + c * x * y + d * u * v - c * p * v, S = d * m * h - g * f * h + g * l * y - c * m * y - d * l * v + c * f * v, _ = g * f * u - d * m * u - g * l * p + c * m * p + d * l * x - c * f * x, E = i * b + r * w + o * S + a * _;
    if (E === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const I = 1 / E;
    return n[0] = b * I, n[1] = (m * p * a - f * x * a - m * o * y + r * x * y + f * o * v - r * p * v) * I, n[2] = (l * x * a - m * u * a + m * o * h - r * x * h - l * o * v + r * u * v) * I, n[3] = (f * u * a - l * p * a - f * o * h + r * p * h + l * o * y - r * u * y) * I, n[4] = w * I, n[5] = (d * x * a - g * p * a + g * o * y - i * x * y - d * o * v + i * p * v) * I, n[6] = (g * u * a - c * x * a - g * o * h + i * x * h + c * o * v - i * u * v) * I, n[7] = (c * p * a - d * u * a + d * o * h - i * p * h - c * o * y + i * u * y) * I, n[8] = S * I, n[9] = (g * f * a - d * m * a - g * r * y + i * m * y + d * r * v - i * f * v) * I, n[10] = (c * m * a - g * l * a + g * r * h - i * m * h - c * r * v + i * l * v) * I, n[11] = (d * l * a - c * f * a - d * r * h + i * f * h + c * r * y - i * l * y) * I, n[12] = _ * I, n[13] = (d * m * o - g * f * o + g * r * p - i * m * p - d * r * x + i * f * x) * I, n[14] = (g * l * o - c * m * o - g * r * u + i * m * u + c * r * x - i * l * x) * I, n[15] = (c * f * o - d * l * o + d * r * u - i * f * u - c * r * p + i * l * p) * I, this;
  },
  scale: function(t) {
    const e = this.elements, n = t.x, s = t.y, i = t.z;
    return e[0] *= n, e[4] *= s, e[8] *= i, e[1] *= n, e[5] *= s, e[9] *= i, e[2] *= n, e[6] *= s, e[10] *= i, e[3] *= n, e[7] *= s, e[11] *= i, this;
  },
  getMaxScaleOnAxis: function() {
    const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], s = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, n, s));
  },
  makeTranslation: function(t, e, n) {
    return this.set(
      1,
      0,
      0,
      t,
      0,
      1,
      0,
      e,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationX: function(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      e,
      -n,
      0,
      0,
      n,
      e,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationY: function(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(
      e,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      e,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationZ: function(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(
      e,
      -n,
      0,
      0,
      n,
      e,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationAxis: function(t, e) {
    const n = Math.cos(e), s = Math.sin(e), i = 1 - n, r = t.x, o = t.y, a = t.z, c = i * r, l = i * o;
    return this.set(
      c * r + n,
      c * o - s * a,
      c * a + s * o,
      0,
      c * o + s * a,
      l * o + n,
      l * a - s * r,
      0,
      c * a - s * o,
      l * a + s * r,
      i * a * a + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeScale: function(t, e, n) {
    return this.set(
      t,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeShear: function(t, e, n) {
    return this.set(
      1,
      e,
      n,
      0,
      t,
      1,
      n,
      0,
      t,
      e,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  compose: function(t, e, n) {
    const s = this.elements, i = e._x, r = e._y, o = e._z, a = e._w, c = i + i, l = r + r, u = o + o, h = i * c, d = i * l, f = i * u, p = r * l, y = r * u, g = o * u, m = a * c, x = a * l, v = a * u, b = n.x, w = n.y, S = n.z;
    return s[0] = (1 - (p + g)) * b, s[1] = (d + v) * b, s[2] = (f - x) * b, s[3] = 0, s[4] = (d - v) * w, s[5] = (1 - (h + g)) * w, s[6] = (y + m) * w, s[7] = 0, s[8] = (f + x) * S, s[9] = (y - m) * S, s[10] = (1 - (h + p)) * S, s[11] = 0, s[12] = t.x, s[13] = t.y, s[14] = t.z, s[15] = 1, this;
  },
  decompose: function(t, e, n) {
    const s = this.elements;
    let i = yl.set(s[0], s[1], s[2]).length(), r = yl.set(s[4], s[5], s[6]).length(), o = yl.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (i = -i), t.x = s[12], t.y = s[13], t.z = s[14], cr.copy(this);
    const c = 1 / i, l = 1 / r, u = 1 / o;
    return cr.elements[0] *= c, cr.elements[1] *= c, cr.elements[2] *= c, cr.elements[4] *= l, cr.elements[5] *= l, cr.elements[6] *= l, cr.elements[8] *= u, cr.elements[9] *= u, cr.elements[10] *= u, e.setFromRotationMatrix(cr), n.x = i, n.y = r, n.z = o, this;
  },
  makePerspective: function(t, e, n, s, i, r) {
    r === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    const o = this.elements, a = 2 * i / (e - t), c = 2 * i / (n - s), l = (e + t) / (e - t), u = (n + s) / (n - s), h = -(r + i) / (r - i), d = -2 * r * i / (r - i);
    return o[0] = a, o[4] = 0, o[8] = l, o[12] = 0, o[1] = 0, o[5] = c, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this;
  },
  makeOrthographic: function(t, e, n, s, i, r) {
    const o = this.elements, a = 1 / (e - t), c = 1 / (n - s), l = 1 / (r - i), u = (e + t) * a, h = (n + s) * c, d = (r + i) * l;
    return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * l, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this;
  },
  equals: function(t) {
    const e = this.elements, n = t.elements;
    for (let s = 0; s < 16; s++)
      if (e[s] !== n[s])
        return !1;
    return !0;
  },
  fromArray: function(t, e) {
    e === void 0 && (e = 0);
    for (let n = 0; n < 16; n++)
      this.elements[n] = t[n + e];
    return this;
  },
  toArray: function(t, e) {
    t === void 0 && (t = []), e === void 0 && (e = 0);
    const n = this.elements;
    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t;
  }
});
const rC = new Mt(), oC = new xs();
function Du(t = 0, e = 0, n = 0, s = Du.DefaultOrder) {
  this._x = t, this._y = e, this._z = n, this._order = s;
}
Du.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
Du.DefaultOrder = "XYZ";
Object.defineProperties(Du.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(t) {
      this._x = t, this._onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(t) {
      this._y = t, this._onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(t) {
      this._z = t, this._onChangeCallback();
    }
  },
  order: {
    get: function() {
      return this._order;
    },
    set: function(t) {
      this._order = t, this._onChangeCallback();
    }
  }
});
Object.assign(Du.prototype, {
  isEuler: !0,
  set: function(t, e, n, s) {
    return this._x = t, this._y = e, this._z = n, this._order = s || this._order, this._onChangeCallback(), this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function(t) {
    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
  },
  setFromRotationMatrix: function(t, e, n) {
    const s = Et.clamp, i = t.elements, r = i[0], o = i[4], a = i[8], c = i[1], l = i[5], u = i[9], h = i[2], d = i[6], f = i[10];
    switch (e = e || this._order, e) {
      case "XYZ":
        this._y = Math.asin(s(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(d, l), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-s(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(s(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(c, r));
        break;
      case "ZYX":
        this._y = Math.asin(-s(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(c, r)) : (this._x = 0, this._z = Math.atan2(-o, l));
        break;
      case "YZX":
        this._z = Math.asin(s(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, f));
        break;
      case "XZY":
        this._z = Math.asin(-s(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-u, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
    }
    return this._order = e, n !== !1 && this._onChangeCallback(), this;
  },
  setFromQuaternion: function(t, e, n) {
    return rC.makeRotationFromQuaternion(t), this.setFromRotationMatrix(rC, e, n);
  },
  setFromVector3: function(t, e) {
    return this.set(t.x, t.y, t.z, e || this._order);
  },
  reorder: function(t) {
    return oC.setFromEuler(this), this.setFromQuaternion(oC, t);
  },
  equals: function(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
  },
  fromArray: function(t) {
    return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
  },
  toArray: function(t, e) {
    return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
  },
  toVector3: function(t) {
    return t ? t.set(this._x, this._y, this._z) : new P(this._x, this._y, this._z);
  },
  _onChange: function(t) {
    return this._onChangeCallback = t, this;
  },
  _onChangeCallback: function() {
  }
});
function F1() {
  this.mask = 1;
}
Object.assign(F1.prototype, {
  set: function(t) {
    this.mask = 1 << t | 0;
  },
  enable: function(t) {
    this.mask |= 1 << t | 0;
  },
  enableAll: function() {
    this.mask = -1;
  },
  toggle: function(t) {
    this.mask ^= 1 << t | 0;
  },
  disable: function(t) {
    this.mask &= ~(1 << t | 0);
  },
  disableAll: function() {
    this.mask = 0;
  },
  test: function(t) {
    return (this.mask & t.mask) !== 0;
  }
});
let IF = 0;
const aC = new P(), xl = new xs(), mo = new Mt(), Am = new P(), Kh = new P(), EF = new P(), NF = new xs(), cC = new P(1, 0, 0), lC = new P(0, 1, 0), uC = new P(0, 0, 1), kF = { type: "added" }, AF = { type: "removed" };
function qe() {
  Object.defineProperty(this, "id", { value: IF++ }), this.uuid = Et.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = qe.DefaultUp.clone();
  const t = new P(), e = new Du(), n = new xs(), s = new P(1, 1, 1);
  function i() {
    n.setFromEuler(e, !1);
  }
  function r() {
    e.setFromQuaternion(n, void 0, !1);
  }
  e._onChange(i), n._onChange(r), Object.defineProperties(this, {
    position: {
      configurable: !0,
      enumerable: !0,
      value: t
    },
    rotation: {
      configurable: !0,
      enumerable: !0,
      value: e
    },
    quaternion: {
      configurable: !0,
      enumerable: !0,
      value: n
    },
    scale: {
      configurable: !0,
      enumerable: !0,
      value: s
    },
    modelViewMatrix: {
      value: new Mt()
    },
    normalMatrix: {
      value: new Js()
    }
  }), this.matrix = new Mt(), this.matrixWorld = new Mt(), this.matrixAutoUpdate = qe.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new F1(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {};
}
qe.DefaultUp = new P(0, 1, 0);
qe.DefaultMatrixAutoUpdate = !0;
qe.prototype = Object.assign(Object.create(Po.prototype), {
  constructor: qe,
  isObject3D: !0,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix4: function(t) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(t) {
    return this.quaternion.premultiply(t), this;
  },
  setRotationFromAxisAngle: function(t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  },
  setRotationFromEuler: function(t) {
    this.quaternion.setFromEuler(t, !0);
  },
  setRotationFromMatrix: function(t) {
    this.quaternion.setFromRotationMatrix(t);
  },
  setRotationFromQuaternion: function(t) {
    this.quaternion.copy(t);
  },
  rotateOnAxis: function(t, e) {
    return xl.setFromAxisAngle(t, e), this.quaternion.multiply(xl), this;
  },
  rotateOnWorldAxis: function(t, e) {
    return xl.setFromAxisAngle(t, e), this.quaternion.premultiply(xl), this;
  },
  rotateX: function(t) {
    return this.rotateOnAxis(cC, t);
  },
  rotateY: function(t) {
    return this.rotateOnAxis(lC, t);
  },
  rotateZ: function(t) {
    return this.rotateOnAxis(uC, t);
  },
  translateOnAxis: function(t, e) {
    return aC.copy(t).applyQuaternion(this.quaternion), this.position.add(aC.multiplyScalar(e)), this;
  },
  translateX: function(t) {
    return this.translateOnAxis(cC, t);
  },
  translateY: function(t) {
    return this.translateOnAxis(lC, t);
  },
  translateZ: function(t) {
    return this.translateOnAxis(uC, t);
  },
  localToWorld: function(t) {
    return t.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function(t) {
    return t.applyMatrix4(mo.getInverse(this.matrixWorld));
  },
  lookAt: function(t, e, n) {
    t.isVector3 ? Am.copy(t) : Am.set(t, e, n);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1), Kh.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? mo.lookAt(Kh, Am, this.up) : mo.lookAt(Am, Kh, this.up), this.quaternion.setFromRotationMatrix(mo), s && (mo.extractRotation(s.matrixWorld), xl.setFromRotationMatrix(mo), this.quaternion.premultiply(xl.inverse()));
  },
  add: function(t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++)
        this.add(arguments[e]);
      return this;
    }
    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.parent !== null && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(kF)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
  },
  remove: function(t) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const e = this.children.indexOf(t);
    return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(AF)), this;
  },
  attach: function(t) {
    return this.updateWorldMatrix(!0, !1), mo.getInverse(this.matrixWorld), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), mo.multiply(t.parent.matrixWorld)), t.applyMatrix4(mo), t.updateWorldMatrix(!1, !1), this.add(t), this;
  },
  getObjectById: function(t) {
    return this.getObjectByProperty("id", t);
  },
  getObjectByName: function(t) {
    return this.getObjectByProperty("name", t);
  },
  getObjectByProperty: function(t, e) {
    if (this[t] === e)
      return this;
    for (let n = 0, s = this.children.length; n < s; n++) {
      const r = this.children[n].getObjectByProperty(t, e);
      if (r !== void 0)
        return r;
    }
  },
  getWorldPosition: function(t) {
    return t === void 0 && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new P()), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function(t) {
    return t === void 0 && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new xs()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Kh, t, EF), t;
  },
  getWorldScale: function(t) {
    return t === void 0 && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new P()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Kh, NF, t), t;
  },
  getWorldDirection: function(t) {
    t === void 0 && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new P()), this.updateMatrixWorld(!0);
    const e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function() {
  },
  traverse: function(t) {
    t(this);
    const e = this.children;
    for (let n = 0, s = e.length; n < s; n++)
      e[n].traverse(t);
  },
  traverseVisible: function(t) {
    if (this.visible === !1)
      return;
    t(this);
    const e = this.children;
    for (let n = 0, s = e.length; n < s; n++)
      e[n].traverseVisible(t);
  },
  traverseAncestors: function(t) {
    const e = this.parent;
    e !== null && (t(e), e.traverseAncestors(t));
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  },
  updateMatrixWorld: function(t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
    const e = this.children;
    for (let n = 0, s = e.length; n < s; n++)
      e[n].updateMatrixWorld(t);
  },
  updateWorldMatrix: function(t, e) {
    const n = this.parent;
    if (t === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === !0) {
      const s = this.children;
      for (let i = 0, r = s.length; i < r; i++)
        s[i].updateWorldMatrix(!1, !0);
    }
  },
  toJSON: function(t) {
    const e = t === void 0 || typeof t == "string", n = {};
    e && (t = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {}
    }, n.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON());
    function i(o, a) {
      return o[a.uuid] === void 0 && (o[a.uuid] = a.toJSON(t)), a.uuid;
    }
    if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = i(t.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const a = o.shapes;
        if (Array.isArray(a))
          for (let c = 0, l = a.length; c < l; c++) {
            const u = a[c];
            i(t.shapes, u);
          }
        else
          i(t.shapes, a);
      }
    }
    if (this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let a = 0, c = this.material.length; a < c; a++)
          o.push(i(t.materials, this.material[a]));
        s.material = o;
      } else
        s.material = i(t.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let o = 0; o < this.children.length; o++)
        s.children.push(this.children[o].toJSON(t).object);
    }
    if (e) {
      const o = r(t.geometries), a = r(t.materials), c = r(t.textures), l = r(t.images), u = r(t.shapes);
      o.length > 0 && (n.geometries = o), a.length > 0 && (n.materials = a), c.length > 0 && (n.textures = c), l.length > 0 && (n.images = l), u.length > 0 && (n.shapes = u);
    }
    return n.object = s, n;
    function r(o) {
      const a = [];
      for (const c in o) {
        const l = o[c];
        delete l.metadata, a.push(l);
      }
      return a;
    }
  },
  clone: function(t) {
    return new this.constructor().copy(this, t);
  },
  copy: function(t, e) {
    if (e === void 0 && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
      for (let n = 0; n < t.children.length; n++) {
        const s = t.children[n];
        this.add(s.clone());
      }
    return this;
  }
});
function kd() {
  qe.call(this), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
kd.prototype = Object.assign(Object.create(qe.prototype), {
  constructor: kd,
  isScene: !0,
  copy: function(t, e) {
    return qe.prototype.copy.call(this, t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this;
  },
  toJSON: function(t) {
    const e = qe.prototype.toJSON.call(this, t);
    return this.background !== null && (e.object.background = this.background.toJSON(t)), this.environment !== null && (e.object.environment = this.environment.toJSON(t)), this.fog !== null && (e.object.fog = this.fog.toJSON()), e;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
const go = [
  new P(),
  new P(),
  new P(),
  new P(),
  new P(),
  new P(),
  new P(),
  new P()
], Yh = new P(), zb = new co(), bl = new P(), vl = new P(), wl = new P(), Zo = new P(), Jo = new P(), Ya = new P(), Zh = new P(), Mm = new P(), Rm = new P(), Za = new P();
function co(t, e) {
  this.min = t !== void 0 ? t : new P(1 / 0, 1 / 0, 1 / 0), this.max = e !== void 0 ? e : new P(-1 / 0, -1 / 0, -1 / 0);
}
Object.assign(co.prototype, {
  isBox3: !0,
  set: function(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  },
  setFromArray: function(t) {
    let e = 1 / 0, n = 1 / 0, s = 1 / 0, i = -1 / 0, r = -1 / 0, o = -1 / 0;
    for (let a = 0, c = t.length; a < c; a += 3) {
      const l = t[a], u = t[a + 1], h = t[a + 2];
      l < e && (e = l), u < n && (n = u), h < s && (s = h), l > i && (i = l), u > r && (r = u), h > o && (o = h);
    }
    return this.min.set(e, n, s), this.max.set(i, r, o), this;
  },
  setFromBufferAttribute: function(t) {
    let e = 1 / 0, n = 1 / 0, s = 1 / 0, i = -1 / 0, r = -1 / 0, o = -1 / 0;
    for (let a = 0, c = t.count; a < c; a++) {
      const l = t.getX(a), u = t.getY(a), h = t.getZ(a);
      l < e && (e = l), u < n && (n = u), h < s && (s = h), l > i && (i = l), u > r && (r = u), h > o && (o = h);
    }
    return this.min.set(e, n, s), this.max.set(i, r, o), this;
  },
  setFromPoints: function(t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e++)
      this.expandByPoint(t[e]);
    return this;
  },
  setFromCenterAndSize: function(t, e) {
    const n = Yh.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  },
  setFromObject: function(t) {
    return this.makeEmpty(), this.expandByObject(t);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  },
  makeEmpty: function() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  getCenter: function(t) {
    return t === void 0 && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new P()), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(t) {
    return t === void 0 && (console.warn("THREE.Box3: .getSize() target is now required"), t = new P()), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
  },
  expandByPoint: function(t) {
    return this.min.min(t), this.max.max(t), this;
  },
  expandByVector: function(t) {
    return this.min.sub(t), this.max.add(t), this;
  },
  expandByScalar: function(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  },
  expandByObject: function(t) {
    t.updateWorldMatrix(!1, !1);
    const e = t.geometry;
    e !== void 0 && (e.boundingBox === null && e.computeBoundingBox(), zb.copy(e.boundingBox), zb.applyMatrix4(t.matrixWorld), this.union(zb));
    const n = t.children;
    for (let s = 0, i = n.length; s < i; s++)
      this.expandByObject(n[s]);
    return this;
  },
  containsPoint: function(t) {
    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
  },
  containsBox: function(t) {
    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
  },
  getParameter: function(t, e) {
    return e === void 0 && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new P()), e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y),
      (t.z - this.min.z) / (this.max.z - this.min.z)
    );
  },
  intersectsBox: function(t) {
    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
  },
  intersectsSphere: function(t) {
    return this.clampPoint(t.center, Yh), Yh.distanceToSquared(t.center) <= t.radius * t.radius;
  },
  intersectsPlane: function(t) {
    let e, n;
    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant;
  },
  intersectsTriangle: function(t) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Zh), Mm.subVectors(this.max, Zh), bl.subVectors(t.a, Zh), vl.subVectors(t.b, Zh), wl.subVectors(t.c, Zh), Zo.subVectors(vl, bl), Jo.subVectors(wl, vl), Ya.subVectors(bl, wl);
    let e = [
      0,
      -Zo.z,
      Zo.y,
      0,
      -Jo.z,
      Jo.y,
      0,
      -Ya.z,
      Ya.y,
      Zo.z,
      0,
      -Zo.x,
      Jo.z,
      0,
      -Jo.x,
      Ya.z,
      0,
      -Ya.x,
      -Zo.y,
      Zo.x,
      0,
      -Jo.y,
      Jo.x,
      0,
      -Ya.y,
      Ya.x,
      0
    ];
    return !Vb(e, bl, vl, wl, Mm) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Vb(e, bl, vl, wl, Mm)) ? !1 : (Rm.crossVectors(Zo, Jo), e = [Rm.x, Rm.y, Rm.z], Vb(e, bl, vl, wl, Mm));
  },
  clampPoint: function(t, e) {
    return e === void 0 && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new P()), e.copy(t).clamp(this.min, this.max);
  },
  distanceToPoint: function(t) {
    return Yh.copy(t).clamp(this.min, this.max).sub(t).length();
  },
  getBoundingSphere: function(t) {
    return t === void 0 && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = this.getSize(Yh).length() * 0.5, t;
  },
  intersect: function(t) {
    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
  },
  union: function(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  },
  applyMatrix4: function(t) {
    return this.isEmpty() ? this : (go[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), go[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), go[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), go[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), go[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), go[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), go[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), go[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(go), this);
  },
  translate: function(t) {
    return this.min.add(t), this.max.add(t), this;
  },
  equals: function(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
});
function Vb(t, e, n, s, i) {
  for (let r = 0, o = t.length - 3; r <= o; r += 3) {
    Za.fromArray(t, r);
    const a = i.x * Math.abs(Za.x) + i.y * Math.abs(Za.y) + i.z * Math.abs(Za.z), c = e.dot(Za), l = n.dot(Za), u = s.dot(Za);
    if (Math.max(-Math.max(c, l, u), Math.min(c, l, u)) > a)
      return !1;
  }
  return !0;
}
const MF = new co();
function Bo(t, e) {
  this.center = t !== void 0 ? t : new P(), this.radius = e !== void 0 ? e : -1;
}
Object.assign(Bo.prototype, {
  set: function(t, e) {
    return this.center.copy(t), this.radius = e, this;
  },
  setFromPoints: function(t, e) {
    const n = this.center;
    e !== void 0 ? n.copy(e) : MF.setFromPoints(t).getCenter(n);
    let s = 0;
    for (let i = 0, r = t.length; i < r; i++)
      s = Math.max(s, n.distanceToSquared(t[i]));
    return this.radius = Math.sqrt(s), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.center.copy(t.center), this.radius = t.radius, this;
  },
  isEmpty: function() {
    return this.radius < 0;
  },
  makeEmpty: function() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  },
  containsPoint: function(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function(t) {
    return t.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function(t) {
    const e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  },
  intersectsBox: function(t) {
    return t.intersectsSphere(this);
  },
  intersectsPlane: function(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  },
  clampPoint: function(t, e) {
    const n = this.center.distanceToSquared(t);
    return e === void 0 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new P()), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
  },
  getBoundingBox: function(t) {
    return t === void 0 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new co()), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
  },
  applyMatrix4: function(t) {
    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
  },
  translate: function(t) {
    return this.center.add(t), this;
  },
  equals: function(t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
});
const yo = new P(), Ub = new P(), Dm = new P(), Qo = new P(), Gb = new P(), $m = new P(), Wb = new P();
function $u(t, e) {
  this.origin = t !== void 0 ? t : new P(), this.direction = e !== void 0 ? e : new P(0, 0, -1);
}
Object.assign($u.prototype, {
  set: function(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  },
  at: function(t, e) {
    return e === void 0 && (console.warn("THREE.Ray: .at() target is now required"), e = new P()), e.copy(this.direction).multiplyScalar(t).add(this.origin);
  },
  lookAt: function(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  },
  recast: function(t) {
    return this.origin.copy(this.at(t, yo)), this;
  },
  closestPointToPoint: function(t, e) {
    e === void 0 && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new P()), e.subVectors(t, this.origin);
    const n = e.dot(this.direction);
    return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin);
  },
  distanceToPoint: function(t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  },
  distanceSqToPoint: function(t) {
    const e = yo.subVectors(t, this.origin).dot(this.direction);
    return e < 0 ? this.origin.distanceToSquared(t) : (yo.copy(this.direction).multiplyScalar(e).add(this.origin), yo.distanceToSquared(t));
  },
  distanceSqToSegment: function(t, e, n, s) {
    Ub.copy(t).add(e).multiplyScalar(0.5), Dm.copy(e).sub(t).normalize(), Qo.copy(this.origin).sub(Ub);
    const i = t.distanceTo(e) * 0.5, r = -this.direction.dot(Dm), o = Qo.dot(this.direction), a = -Qo.dot(Dm), c = Qo.lengthSq(), l = Math.abs(1 - r * r);
    let u, h, d, f;
    if (l > 0)
      if (u = r * a - o, h = r * o - a, f = i * l, u >= 0)
        if (h >= -f)
          if (h <= f) {
            const p = 1 / l;
            u *= p, h *= p, d = u * (u + r * h + 2 * o) + h * (r * u + h + 2 * a) + c;
          } else
            h = i, u = Math.max(0, -(r * h + o)), d = -u * u + h * (h + 2 * a) + c;
        else
          h = -i, u = Math.max(0, -(r * h + o)), d = -u * u + h * (h + 2 * a) + c;
      else
        h <= -f ? (u = Math.max(0, -(-r * i + o)), h = u > 0 ? -i : Math.min(Math.max(-i, -a), i), d = -u * u + h * (h + 2 * a) + c) : h <= f ? (u = 0, h = Math.min(Math.max(-i, -a), i), d = h * (h + 2 * a) + c) : (u = Math.max(0, -(r * i + o)), h = u > 0 ? i : Math.min(Math.max(-i, -a), i), d = -u * u + h * (h + 2 * a) + c);
    else
      h = r > 0 ? -i : i, u = Math.max(0, -(r * h + o)), d = -u * u + h * (h + 2 * a) + c;
    return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), s && s.copy(Dm).multiplyScalar(h).add(Ub), d;
  },
  intersectSphere: function(t, e) {
    yo.subVectors(t.center, this.origin);
    const n = yo.dot(this.direction), s = yo.dot(yo) - n * n, i = t.radius * t.radius;
    if (s > i)
      return null;
    const r = Math.sqrt(i - s), o = n - r, a = n + r;
    return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e);
  },
  intersectsSphere: function(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  },
  distanceToPlane: function(t) {
    const e = t.normal.dot(this.direction);
    if (e === 0)
      return t.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(t.normal) + t.constant) / e;
    return n >= 0 ? n : null;
  },
  intersectPlane: function(t, e) {
    const n = this.distanceToPlane(t);
    return n === null ? null : this.at(n, e);
  },
  intersectsPlane: function(t) {
    const e = t.distanceToPoint(this.origin);
    return e === 0 || t.normal.dot(this.direction) * e < 0;
  },
  intersectBox: function(t, e) {
    let n, s, i, r, o, a;
    const c = 1 / this.direction.x, l = 1 / this.direction.y, u = 1 / this.direction.z, h = this.origin;
    return c >= 0 ? (n = (t.min.x - h.x) * c, s = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, s = (t.min.x - h.x) * c), l >= 0 ? (i = (t.min.y - h.y) * l, r = (t.max.y - h.y) * l) : (i = (t.max.y - h.y) * l, r = (t.min.y - h.y) * l), n > r || i > s || ((i > n || n !== n) && (n = i), (r < s || s !== s) && (s = r), u >= 0 ? (o = (t.min.z - h.z) * u, a = (t.max.z - h.z) * u) : (o = (t.max.z - h.z) * u, a = (t.min.z - h.z) * u), n > a || o > s) || ((o > n || n !== n) && (n = o), (a < s || s !== s) && (s = a), s < 0) ? null : this.at(n >= 0 ? n : s, e);
  },
  intersectsBox: function(t) {
    return this.intersectBox(t, yo) !== null;
  },
  intersectTriangle: function(t, e, n, s, i) {
    Gb.subVectors(e, t), $m.subVectors(n, t), Wb.crossVectors(Gb, $m);
    let r = this.direction.dot(Wb), o;
    if (r > 0) {
      if (s)
        return null;
      o = 1;
    } else if (r < 0)
      o = -1, r = -r;
    else
      return null;
    Qo.subVectors(this.origin, t);
    const a = o * this.direction.dot($m.crossVectors(Qo, $m));
    if (a < 0)
      return null;
    const c = o * this.direction.dot(Gb.cross(Qo));
    if (c < 0 || a + c > r)
      return null;
    const l = -o * Qo.dot(Wb);
    return l < 0 ? null : this.at(l / r, i);
  },
  applyMatrix4: function(t) {
    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
  },
  equals: function(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
});
const Hb = new P(), RF = new P(), DF = new Js();
function Fr(t, e) {
  this.normal = t !== void 0 ? t : new P(1, 0, 0), this.constant = e !== void 0 ? e : 0;
}
Object.assign(Fr.prototype, {
  isPlane: !0,
  set: function(t, e) {
    return this.normal.copy(t), this.constant = e, this;
  },
  setComponents: function(t, e, n, s) {
    return this.normal.set(t, e, n), this.constant = s, this;
  },
  setFromNormalAndCoplanarPoint: function(t, e) {
    return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
  },
  setFromCoplanarPoints: function(t, e, n) {
    const s = Hb.subVectors(n, e).cross(RF.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(s, t), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.normal.copy(t.normal), this.constant = t.constant, this;
  },
  normalize: function() {
    const t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), this.constant *= t, this;
  },
  negate: function() {
    return this.constant *= -1, this.normal.negate(), this;
  },
  distanceToPoint: function(t) {
    return this.normal.dot(t) + this.constant;
  },
  distanceToSphere: function(t) {
    return this.distanceToPoint(t.center) - t.radius;
  },
  projectPoint: function(t, e) {
    return e === void 0 && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new P()), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
  },
  intersectLine: function(t, e) {
    e === void 0 && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new P());
    const n = t.delta(Hb), s = this.normal.dot(n);
    if (s === 0)
      return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : void 0;
    const i = -(t.start.dot(this.normal) + this.constant) / s;
    if (!(i < 0 || i > 1))
      return e.copy(n).multiplyScalar(i).add(t.start);
  },
  intersectsLine: function(t) {
    const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end);
    return e < 0 && n > 0 || n < 0 && e > 0;
  },
  intersectsBox: function(t) {
    return t.intersectsPlane(this);
  },
  intersectsSphere: function(t) {
    return t.intersectsPlane(this);
  },
  coplanarPoint: function(t) {
    return t === void 0 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new P()), t.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function(t, e) {
    const n = e || DF.getNormalMatrix(t), s = this.coplanarPoint(Hb).applyMatrix4(t), i = this.normal.applyMatrix3(n).normalize();
    return this.constant = -s.dot(i), this;
  },
  translate: function(t) {
    return this.constant -= t.dot(this.normal), this;
  },
  equals: function(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  }
});
const dr = new P(), vo = new P(), jb = new P(), xo = new P(), Sl = new P(), _l = new P(), hC = new P(), qb = new P(), Xb = new P(), Kb = new P();
function Es(t, e, n) {
  this.a = t !== void 0 ? t : new P(), this.b = e !== void 0 ? e : new P(), this.c = n !== void 0 ? n : new P();
}
Object.assign(Es, {
  getNormal: function(t, e, n, s) {
    s === void 0 && (console.warn("THREE.Triangle: .getNormal() target is now required"), s = new P()), s.subVectors(n, e), dr.subVectors(t, e), s.cross(dr);
    const i = s.lengthSq();
    return i > 0 ? s.multiplyScalar(1 / Math.sqrt(i)) : s.set(0, 0, 0);
  },
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  getBarycoord: function(t, e, n, s, i) {
    dr.subVectors(s, e), vo.subVectors(n, e), jb.subVectors(t, e);
    const r = dr.dot(dr), o = dr.dot(vo), a = dr.dot(jb), c = vo.dot(vo), l = vo.dot(jb), u = r * c - o * o;
    if (i === void 0 && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new P()), u === 0)
      return i.set(-2, -1, -1);
    const h = 1 / u, d = (c * a - o * l) * h, f = (r * l - o * a) * h;
    return i.set(1 - d - f, f, d);
  },
  containsPoint: function(t, e, n, s) {
    return Es.getBarycoord(t, e, n, s, xo), xo.x >= 0 && xo.y >= 0 && xo.x + xo.y <= 1;
  },
  getUV: function(t, e, n, s, i, r, o, a) {
    return this.getBarycoord(t, e, n, s, xo), a.set(0, 0), a.addScaledVector(i, xo.x), a.addScaledVector(r, xo.y), a.addScaledVector(o, xo.z), a;
  },
  isFrontFacing: function(t, e, n, s) {
    return dr.subVectors(n, e), vo.subVectors(t, e), dr.cross(vo).dot(s) < 0;
  }
});
Object.assign(Es.prototype, {
  set: function(t, e, n) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
  },
  setFromPointsAndIndices: function(t, e, n, s) {
    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[s]), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  },
  getArea: function() {
    return dr.subVectors(this.c, this.b), vo.subVectors(this.a, this.b), dr.cross(vo).length() * 0.5;
  },
  getMidpoint: function(t) {
    return t === void 0 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new P()), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  getNormal: function(t) {
    return Es.getNormal(this.a, this.b, this.c, t);
  },
  getPlane: function(t) {
    return t === void 0 && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Fr()), t.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  getBarycoord: function(t, e) {
    return Es.getBarycoord(t, this.a, this.b, this.c, e);
  },
  getUV: function(t, e, n, s, i) {
    return Es.getUV(t, this.a, this.b, this.c, e, n, s, i);
  },
  containsPoint: function(t) {
    return Es.containsPoint(t, this.a, this.b, this.c);
  },
  isFrontFacing: function(t) {
    return Es.isFrontFacing(this.a, this.b, this.c, t);
  },
  intersectsBox: function(t) {
    return t.intersectsTriangle(this);
  },
  closestPointToPoint: function(t, e) {
    e === void 0 && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new P());
    const n = this.a, s = this.b, i = this.c;
    let r, o;
    Sl.subVectors(s, n), _l.subVectors(i, n), qb.subVectors(t, n);
    const a = Sl.dot(qb), c = _l.dot(qb);
    if (a <= 0 && c <= 0)
      return e.copy(n);
    Xb.subVectors(t, s);
    const l = Sl.dot(Xb), u = _l.dot(Xb);
    if (l >= 0 && u <= l)
      return e.copy(s);
    const h = a * u - l * c;
    if (h <= 0 && a >= 0 && l <= 0)
      return r = a / (a - l), e.copy(n).addScaledVector(Sl, r);
    Kb.subVectors(t, i);
    const d = Sl.dot(Kb), f = _l.dot(Kb);
    if (f >= 0 && d <= f)
      return e.copy(i);
    const p = d * c - a * f;
    if (p <= 0 && c >= 0 && f <= 0)
      return o = c / (c - f), e.copy(n).addScaledVector(_l, o);
    const y = l * f - d * u;
    if (y <= 0 && u - l >= 0 && d - f >= 0)
      return hC.subVectors(i, s), o = (u - l) / (u - l + (d - f)), e.copy(s).addScaledVector(hC, o);
    const g = 1 / (y + p + h);
    return r = p * g, o = h * g, e.copy(n).addScaledVector(Sl, r).addScaledVector(_l, o);
  },
  equals: function(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
});
const BE = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, lr = { h: 0, s: 0, l: 0 }, Om = { h: 0, s: 0, l: 0 };
function st(t, e, n) {
  return e === void 0 && n === void 0 ? this.set(t) : this.setRGB(t, e, n);
}
function Yb(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * 6 * (2 / 3 - n) : t;
}
function Zb(t) {
  return t < 0.04045 ? t * 0.0773993808 : Math.pow(t * 0.9478672986 + 0.0521327014, 2.4);
}
function Jb(t) {
  return t < 31308e-7 ? t * 12.92 : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
Object.assign(st.prototype, {
  isColor: !0,
  r: 1,
  g: 1,
  b: 1,
  set: function(t) {
    return t && t.isColor ? this.copy(t) : typeof t == "number" ? this.setHex(t) : typeof t == "string" && this.setStyle(t), this;
  },
  setScalar: function(t) {
    return this.r = t, this.g = t, this.b = t, this;
  },
  setHex: function(t) {
    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, this;
  },
  setRGB: function(t, e, n) {
    return this.r = t, this.g = e, this.b = n, this;
  },
  setHSL: function(t, e, n) {
    if (t = Et.euclideanModulo(t, 1), e = Et.clamp(e, 0, 1), n = Et.clamp(n, 0, 1), e === 0)
      this.r = this.g = this.b = n;
    else {
      const s = n <= 0.5 ? n * (1 + e) : n + e - n * e, i = 2 * n - s;
      this.r = Yb(i, s, t + 1 / 3), this.g = Yb(i, s, t), this.b = Yb(i, s, t - 1 / 3);
    }
    return this;
  },
  setStyle: function(t) {
    function e(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
    }
    let n;
    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
      let s;
      const i = n[1], r = n[2];
      switch (i) {
        case "rgb":
        case "rgba":
          if (s = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r))
            return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, e(s[5]), this;
          if (s = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r))
            return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, e(s[5]), this;
          break;
        case "hsl":
        case "hsla":
          if (s = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) {
            const o = parseFloat(s[1]) / 360, a = parseInt(s[2], 10) / 100, c = parseInt(s[3], 10) / 100;
            return e(s[5]), this.setHSL(o, a, c);
          }
          break;
      }
    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
      const s = n[1], i = s.length;
      if (i === 3)
        return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, this;
      if (i === 6)
        return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, this;
    }
    return t && t.length > 0 ? this.setColorName(t) : this;
  },
  setColorName: function(t) {
    const e = BE[t];
    return e !== void 0 ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this;
  },
  clone: function() {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function(t) {
    return this.r = t.r, this.g = t.g, this.b = t.b, this;
  },
  copyGammaToLinear: function(t, e) {
    return e === void 0 && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
  },
  copyLinearToGamma: function(t, e) {
    e === void 0 && (e = 2);
    const n = e > 0 ? 1 / e : 1;
    return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this;
  },
  convertGammaToLinear: function(t) {
    return this.copyGammaToLinear(this, t), this;
  },
  convertLinearToGamma: function(t) {
    return this.copyLinearToGamma(this, t), this;
  },
  copySRGBToLinear: function(t) {
    return this.r = Zb(t.r), this.g = Zb(t.g), this.b = Zb(t.b), this;
  },
  copyLinearToSRGB: function(t) {
    return this.r = Jb(t.r), this.g = Jb(t.g), this.b = Jb(t.b), this;
  },
  convertSRGBToLinear: function() {
    return this.copySRGBToLinear(this), this;
  },
  convertLinearToSRGB: function() {
    return this.copyLinearToSRGB(this), this;
  },
  getHex: function() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function(t) {
    t === void 0 && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 });
    const e = this.r, n = this.g, s = this.b, i = Math.max(e, n, s), r = Math.min(e, n, s);
    let o, a;
    const c = (r + i) / 2;
    if (r === i)
      o = 0, a = 0;
    else {
      const l = i - r;
      switch (a = c <= 0.5 ? l / (i + r) : l / (2 - i - r), i) {
        case e:
          o = (n - s) / l + (n < s ? 6 : 0);
          break;
        case n:
          o = (s - e) / l + 2;
          break;
        case s:
          o = (e - n) / l + 4;
          break;
      }
      o /= 6;
    }
    return t.h = o, t.s = a, t.l = c, t;
  },
  getStyle: function() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  },
  offsetHSL: function(t, e, n) {
    return this.getHSL(lr), lr.h += t, lr.s += e, lr.l += n, this.setHSL(lr.h, lr.s, lr.l), this;
  },
  add: function(t) {
    return this.r += t.r, this.g += t.g, this.b += t.b, this;
  },
  addColors: function(t, e) {
    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
  },
  addScalar: function(t) {
    return this.r += t, this.g += t, this.b += t, this;
  },
  sub: function(t) {
    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
  },
  multiply: function(t) {
    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
  },
  multiplyScalar: function(t) {
    return this.r *= t, this.g *= t, this.b *= t, this;
  },
  lerp: function(t, e) {
    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
  },
  lerpHSL: function(t, e) {
    this.getHSL(lr), t.getHSL(Om);
    const n = Et.lerp(lr.h, Om.h, e), s = Et.lerp(lr.s, Om.s, e), i = Et.lerp(lr.l, Om.l, e);
    return this.setHSL(n, s, i), this;
  },
  equals: function(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  },
  fromArray: function(t, e) {
    return e === void 0 && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
  },
  toArray: function(t, e) {
    return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
  },
  fromBufferAttribute: function(t, e) {
    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), t.normalized === !0 && (this.r /= 255, this.g /= 255, this.b /= 255), this;
  },
  toJSON: function() {
    return this.getHex();
  }
});
st.NAMES = BE;
function Kg(t, e, n, s, i, r) {
  this.a = t, this.b = e, this.c = n, this.normal = s && s.isVector3 ? s : new P(), this.vertexNormals = Array.isArray(s) ? s : [], this.color = i && i.isColor ? i : new st(), this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = r !== void 0 ? r : 0;
}
Object.assign(Kg.prototype, {
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
    for (let e = 0, n = t.vertexNormals.length; e < n; e++)
      this.vertexNormals[e] = t.vertexNormals[e].clone();
    for (let e = 0, n = t.vertexColors.length; e < n; e++)
      this.vertexColors[e] = t.vertexColors[e].clone();
    return this;
  }
});
let $F = 0;
function yt() {
  Object.defineProperty(this, "id", { value: $F++ }), this.uuid = Et.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = vd, this.side = Rf, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = ME, this.blendDst = RE, this.blendEquation = Ll, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Bv, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = SF, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Pb, this.stencilZFail = Pb, this.stencilZPass = Pb, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0;
}
yt.prototype = Object.assign(Object.create(Po.prototype), {
  constructor: yt,
  isMaterial: !0,
  onBeforeCompile: function() {
  },
  customProgramCacheKey: function() {
    return this.onBeforeCompile.toString();
  },
  setValues: function(t) {
    if (t !== void 0)
      for (const e in t) {
        const n = t[e];
        if (n === void 0) {
          console.warn("THREE.Material: '" + e + "' parameter is undefined.");
          continue;
        }
        if (e === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === AE;
          continue;
        }
        const s = this[e];
        if (s === void 0) {
          console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.");
          continue;
        }
        s && s.isColor ? s.set(n) : s && s.isVector3 && n && n.isVector3 ? s.copy(n) : this[e] = n;
      }
  },
  toJSON: function(t) {
    const e = t === void 0 || typeof t == "string";
    e && (t = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, this.combine !== void 0 && (n.combine = this.combine), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.size !== void 0 && (n.size = this.size), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== vd && (n.blending = this.blending), this.flatShading === !0 && (n.flatShading = this.flatShading), this.side !== Rf && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (n.morphTargets = !0), this.morphNormals === !0 && (n.morphNormals = !0), this.skinning === !0 && (n.skinning = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData);
    function s(i) {
      const r = [];
      for (const o in i) {
        const a = i[o];
        delete a.metadata, r.push(a);
      }
      return r;
    }
    if (e) {
      const i = s(t.textures), r = s(t.images);
      i.length > 0 && (n.textures = i), r.length > 0 && (n.images = r);
    }
    return n;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
    const e = t.clippingPlanes;
    let n = null;
    if (e !== null) {
      const s = e.length;
      n = new Array(s);
      for (let i = 0; i !== s; ++i)
        n[i] = e[i].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
Object.defineProperty(yt.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
function er(t) {
  yt.call(this), this.type = "MeshBasicMaterial", this.color = new st(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = cx, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t);
}
er.prototype = Object.create(yt.prototype);
er.prototype.constructor = er;
er.prototype.isMeshBasicMaterial = !0;
er.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this;
};
const yn = new P(), Lm = new Ce();
function ut(t, e, n) {
  if (Array.isArray(t))
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = n === !0, this.usage = dx, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
}
Object.defineProperty(ut.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
Object.assign(ut.prototype, {
  isBufferAttribute: !0,
  onUploadCallback: function() {
  },
  setUsage: function(t) {
    return this.usage = t, this;
  },
  copy: function(t) {
    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this;
  },
  copyAt: function(t, e, n) {
    t *= this.itemSize, n *= e.itemSize;
    for (let s = 0, i = this.itemSize; s < i; s++)
      this.array[t + s] = e.array[n + s];
    return this;
  },
  copyArray: function(t) {
    return this.array.set(t), this;
  },
  copyColorsArray: function(t) {
    const e = this.array;
    let n = 0;
    for (let s = 0, i = t.length; s < i; s++) {
      let r = t[s];
      r === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", s), r = new st()), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b;
    }
    return this;
  },
  copyVector2sArray: function(t) {
    const e = this.array;
    let n = 0;
    for (let s = 0, i = t.length; s < i; s++) {
      let r = t[s];
      r === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", s), r = new Ce()), e[n++] = r.x, e[n++] = r.y;
    }
    return this;
  },
  copyVector3sArray: function(t) {
    const e = this.array;
    let n = 0;
    for (let s = 0, i = t.length; s < i; s++) {
      let r = t[s];
      r === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", s), r = new P()), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z;
    }
    return this;
  },
  copyVector4sArray: function(t) {
    const e = this.array;
    let n = 0;
    for (let s = 0, i = t.length; s < i; s++) {
      let r = t[s];
      r === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", s), r = new en()), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w;
    }
    return this;
  },
  applyMatrix3: function(t) {
    if (this.itemSize === 2)
      for (let e = 0, n = this.count; e < n; e++)
        Lm.fromBufferAttribute(this, e), Lm.applyMatrix3(t), this.setXY(e, Lm.x, Lm.y);
    else if (this.itemSize === 3)
      for (let e = 0, n = this.count; e < n; e++)
        yn.fromBufferAttribute(this, e), yn.applyMatrix3(t), this.setXYZ(e, yn.x, yn.y, yn.z);
    return this;
  },
  applyMatrix4: function(t) {
    for (let e = 0, n = this.count; e < n; e++)
      yn.x = this.getX(e), yn.y = this.getY(e), yn.z = this.getZ(e), yn.applyMatrix4(t), this.setXYZ(e, yn.x, yn.y, yn.z);
    return this;
  },
  applyNormalMatrix: function(t) {
    for (let e = 0, n = this.count; e < n; e++)
      yn.x = this.getX(e), yn.y = this.getY(e), yn.z = this.getZ(e), yn.applyNormalMatrix(t), this.setXYZ(e, yn.x, yn.y, yn.z);
    return this;
  },
  transformDirection: function(t) {
    for (let e = 0, n = this.count; e < n; e++)
      yn.x = this.getX(e), yn.y = this.getY(e), yn.z = this.getZ(e), yn.transformDirection(t), this.setXYZ(e, yn.x, yn.y, yn.z);
    return this;
  },
  set: function(t, e) {
    return e === void 0 && (e = 0), this.array.set(t, e), this;
  },
  getX: function(t) {
    return this.array[t * this.itemSize];
  },
  setX: function(t, e) {
    return this.array[t * this.itemSize] = e, this;
  },
  getY: function(t) {
    return this.array[t * this.itemSize + 1];
  },
  setY: function(t, e) {
    return this.array[t * this.itemSize + 1] = e, this;
  },
  getZ: function(t) {
    return this.array[t * this.itemSize + 2];
  },
  setZ: function(t, e) {
    return this.array[t * this.itemSize + 2] = e, this;
  },
  getW: function(t) {
    return this.array[t * this.itemSize + 3];
  },
  setW: function(t, e) {
    return this.array[t * this.itemSize + 3] = e, this;
  },
  setXY: function(t, e, n) {
    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this;
  },
  setXYZ: function(t, e, n, s) {
    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = s, this;
  },
  setXYZW: function(t, e, n, s, i) {
    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = s, this.array[t + 3] = i, this;
  },
  onUpload: function(t) {
    return this.onUploadCallback = t, this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function() {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
});
function Uv(t, e, n) {
  ut.call(this, new Int8Array(t), e, n);
}
Uv.prototype = Object.create(ut.prototype);
Uv.prototype.constructor = Uv;
function Gv(t, e, n) {
  ut.call(this, new Uint8Array(t), e, n);
}
Gv.prototype = Object.create(ut.prototype);
Gv.prototype.constructor = Gv;
function Wv(t, e, n) {
  ut.call(this, new Uint8ClampedArray(t), e, n);
}
Wv.prototype = Object.create(ut.prototype);
Wv.prototype.constructor = Wv;
function Hv(t, e, n) {
  ut.call(this, new Int16Array(t), e, n);
}
Hv.prototype = Object.create(ut.prototype);
Hv.prototype.constructor = Hv;
function Ad(t, e, n) {
  ut.call(this, new Uint16Array(t), e, n);
}
Ad.prototype = Object.create(ut.prototype);
Ad.prototype.constructor = Ad;
function jv(t, e, n) {
  ut.call(this, new Int32Array(t), e, n);
}
jv.prototype = Object.create(ut.prototype);
jv.prototype.constructor = jv;
function Md(t, e, n) {
  ut.call(this, new Uint32Array(t), e, n);
}
Md.prototype = Object.create(ut.prototype);
Md.prototype.constructor = Md;
function Ze(t, e, n) {
  ut.call(this, new Float32Array(t), e, n);
}
Ze.prototype = Object.create(ut.prototype);
Ze.prototype.constructor = Ze;
function qv(t, e, n) {
  ut.call(this, new Float64Array(t), e, n);
}
qv.prototype = Object.create(ut.prototype);
qv.prototype.constructor = qv;
function zE() {
  this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1;
}
Object.assign(zE.prototype, {
  computeGroups: function(t) {
    const e = [];
    let n, s, i;
    const r = t.faces;
    for (s = 0; s < r.length; s++) {
      const o = r[s];
      o.materialIndex !== i && (i = o.materialIndex, n !== void 0 && (n.count = s * 3 - n.start, e.push(n)), n = {
        start: s * 3,
        materialIndex: i
      });
    }
    n !== void 0 && (n.count = s * 3 - n.start, e.push(n)), this.groups = e;
  },
  fromGeometry: function(t) {
    const e = t.faces, n = t.vertices, s = t.faceVertexUvs, i = s[0] && s[0].length > 0, r = s[1] && s[1].length > 0, o = t.morphTargets, a = o.length;
    let c;
    if (a > 0) {
      c = [];
      for (let g = 0; g < a; g++)
        c[g] = {
          name: o[g].name,
          data: []
        };
      this.morphTargets.position = c;
    }
    const l = t.morphNormals, u = l.length;
    let h;
    if (u > 0) {
      h = [];
      for (let g = 0; g < u; g++)
        h[g] = {
          name: l[g].name,
          data: []
        };
      this.morphTargets.normal = h;
    }
    const d = t.skinIndices, f = t.skinWeights, p = d.length === n.length, y = f.length === n.length;
    n.length > 0 && e.length === 0 && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    for (let g = 0; g < e.length; g++) {
      const m = e[g];
      this.vertices.push(n[m.a], n[m.b], n[m.c]);
      const x = m.vertexNormals;
      if (x.length === 3)
        this.normals.push(x[0], x[1], x[2]);
      else {
        const b = m.normal;
        this.normals.push(b, b, b);
      }
      const v = m.vertexColors;
      if (v.length === 3)
        this.colors.push(v[0], v[1], v[2]);
      else {
        const b = m.color;
        this.colors.push(b, b, b);
      }
      if (i === !0) {
        const b = s[0][g];
        b !== void 0 ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", g), this.uvs.push(new Ce(), new Ce(), new Ce()));
      }
      if (r === !0) {
        const b = s[1][g];
        b !== void 0 ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", g), this.uvs2.push(new Ce(), new Ce(), new Ce()));
      }
      for (let b = 0; b < a; b++) {
        const w = o[b].vertices;
        c[b].data.push(w[m.a], w[m.b], w[m.c]);
      }
      for (let b = 0; b < u; b++) {
        const w = l[b].vertexNormals[g];
        h[b].data.push(w.a, w.b, w.c);
      }
      p && this.skinIndices.push(d[m.a], d[m.b], d[m.c]), y && this.skinWeights.push(f[m.a], f[m.b], f[m.c]);
    }
    return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), this;
  }
});
function VE(t) {
  if (t.length === 0)
    return -1 / 0;
  let e = t[0];
  for (let n = 1, s = t.length; n < s; ++n)
    t[n] > e && (e = t[n]);
  return e;
}
let OF = 1;
const Dr = new Mt(), Qb = new qe(), Tl = new P(), Ii = new co(), Jh = new co(), fs = new P();
function et() {
  Object.defineProperty(this, "id", { value: OF += 2 }), this.uuid = Et.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
}
et.prototype = Object.assign(Object.create(Po.prototype), {
  constructor: et,
  isBufferGeometry: !0,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(t) {
    Array.isArray(t) ? this.index = new (VE(t) > 65535 ? Md : Ad)(t, 1) : this.index = t;
  },
  getAttribute: function(t) {
    return this.attributes[t];
  },
  setAttribute: function(t, e) {
    return this.attributes[t] = e, this;
  },
  deleteAttribute: function(t) {
    return delete this.attributes[t], this;
  },
  addGroup: function(t, e, n) {
    this.groups.push({
      start: t,
      count: e,
      materialIndex: n !== void 0 ? n : 0
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(t, e) {
    this.drawRange.start = t, this.drawRange.count = e;
  },
  applyMatrix4: function(t) {
    const e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const i = new Js().getNormalMatrix(t);
      n.applyNormalMatrix(i), n.needsUpdate = !0;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(t), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  },
  rotateX: function(t) {
    return Dr.makeRotationX(t), this.applyMatrix4(Dr), this;
  },
  rotateY: function(t) {
    return Dr.makeRotationY(t), this.applyMatrix4(Dr), this;
  },
  rotateZ: function(t) {
    return Dr.makeRotationZ(t), this.applyMatrix4(Dr), this;
  },
  translate: function(t, e, n) {
    return Dr.makeTranslation(t, e, n), this.applyMatrix4(Dr), this;
  },
  scale: function(t, e, n) {
    return Dr.makeScale(t, e, n), this.applyMatrix4(Dr), this;
  },
  lookAt: function(t) {
    return Qb.lookAt(t), Qb.updateMatrix(), this.applyMatrix4(Qb.matrix), this;
  },
  center: function() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Tl).negate(), this.translate(Tl.x, Tl.y, Tl.z), this;
  },
  setFromObject: function(t) {
    const e = t.geometry;
    if (t.isPoints || t.isLine) {
      const n = new Ze(e.vertices.length * 3, 3), s = new Ze(e.colors.length * 3, 3);
      if (this.setAttribute("position", n.copyVector3sArray(e.vertices)), this.setAttribute("color", s.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
        const i = new Ze(e.lineDistances.length, 1);
        this.setAttribute("lineDistance", i.copyArray(e.lineDistances));
      }
      e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone());
    } else
      t.isMesh && e && e.isGeometry && this.fromGeometry(e);
    return this;
  },
  setFromPoints: function(t) {
    const e = [];
    for (let n = 0, s = t.length; n < s; n++) {
      const i = t[n];
      e.push(i.x, i.y, i.z || 0);
    }
    return this.setAttribute("position", new Ze(e, 3)), this;
  },
  updateFromObject: function(t) {
    let e = t.geometry;
    if (t.isMesh) {
      let n = e.__directGeometry;
      if (e.elementsNeedUpdate === !0 && (n = void 0, e.elementsNeedUpdate = !1), n === void 0)
        return this.fromGeometry(e);
      n.verticesNeedUpdate = e.verticesNeedUpdate, n.normalsNeedUpdate = e.normalsNeedUpdate, n.colorsNeedUpdate = e.colorsNeedUpdate, n.uvsNeedUpdate = e.uvsNeedUpdate, n.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = n;
    }
    if (e.verticesNeedUpdate === !0) {
      const n = this.attributes.position;
      n !== void 0 && (n.copyVector3sArray(e.vertices), n.needsUpdate = !0), e.verticesNeedUpdate = !1;
    }
    if (e.normalsNeedUpdate === !0) {
      const n = this.attributes.normal;
      n !== void 0 && (n.copyVector3sArray(e.normals), n.needsUpdate = !0), e.normalsNeedUpdate = !1;
    }
    if (e.colorsNeedUpdate === !0) {
      const n = this.attributes.color;
      n !== void 0 && (n.copyColorsArray(e.colors), n.needsUpdate = !0), e.colorsNeedUpdate = !1;
    }
    if (e.uvsNeedUpdate) {
      const n = this.attributes.uv;
      n !== void 0 && (n.copyVector2sArray(e.uvs), n.needsUpdate = !0), e.uvsNeedUpdate = !1;
    }
    if (e.lineDistancesNeedUpdate) {
      const n = this.attributes.lineDistance;
      n !== void 0 && (n.copyArray(e.lineDistances), n.needsUpdate = !0), e.lineDistancesNeedUpdate = !1;
    }
    return e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this;
  },
  fromGeometry: function(t) {
    return t.__directGeometry = new zE().fromGeometry(t), this.fromDirectGeometry(t.__directGeometry);
  },
  fromDirectGeometry: function(t) {
    const e = new Float32Array(t.vertices.length * 3);
    if (this.setAttribute("position", new ut(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
      const n = new Float32Array(t.normals.length * 3);
      this.setAttribute("normal", new ut(n, 3).copyVector3sArray(t.normals));
    }
    if (t.colors.length > 0) {
      const n = new Float32Array(t.colors.length * 3);
      this.setAttribute("color", new ut(n, 3).copyColorsArray(t.colors));
    }
    if (t.uvs.length > 0) {
      const n = new Float32Array(t.uvs.length * 2);
      this.setAttribute("uv", new ut(n, 2).copyVector2sArray(t.uvs));
    }
    if (t.uvs2.length > 0) {
      const n = new Float32Array(t.uvs2.length * 2);
      this.setAttribute("uv2", new ut(n, 2).copyVector2sArray(t.uvs2));
    }
    this.groups = t.groups;
    for (const n in t.morphTargets) {
      const s = [], i = t.morphTargets[n];
      for (let r = 0, o = i.length; r < o; r++) {
        const a = i[r], c = new Ze(a.data.length * 3, 3);
        c.name = a.name, s.push(c.copyVector3sArray(a.data));
      }
      this.morphAttributes[n] = s;
    }
    if (t.skinIndices.length > 0) {
      const n = new Ze(t.skinIndices.length * 4, 4);
      this.setAttribute("skinIndex", n.copyVector4sArray(t.skinIndices));
    }
    if (t.skinWeights.length > 0) {
      const n = new Ze(t.skinWeights.length * 4, 4);
      this.setAttribute("skinWeight", n.copyVector4sArray(t.skinWeights));
    }
    return t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), this;
  },
  computeBoundingBox: function() {
    this.boundingBox === null && (this.boundingBox = new co());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(t), e)
        for (let n = 0, s = e.length; n < s; n++) {
          const i = e[n];
          Ii.setFromBufferAttribute(i), this.morphTargetsRelative ? (fs.addVectors(this.boundingBox.min, Ii.min), this.boundingBox.expandByPoint(fs), fs.addVectors(this.boundingBox.max, Ii.max), this.boundingBox.expandByPoint(fs)) : (this.boundingBox.expandByPoint(Ii.min), this.boundingBox.expandByPoint(Ii.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  },
  computeBoundingSphere: function() {
    this.boundingSphere === null && (this.boundingSphere = new Bo());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t) {
      const n = this.boundingSphere.center;
      if (Ii.setFromBufferAttribute(t), e)
        for (let i = 0, r = e.length; i < r; i++) {
          const o = e[i];
          Jh.setFromBufferAttribute(o), this.morphTargetsRelative ? (fs.addVectors(Ii.min, Jh.min), Ii.expandByPoint(fs), fs.addVectors(Ii.max, Jh.max), Ii.expandByPoint(fs)) : (Ii.expandByPoint(Jh.min), Ii.expandByPoint(Jh.max));
        }
      Ii.getCenter(n);
      let s = 0;
      for (let i = 0, r = t.count; i < r; i++)
        fs.fromBufferAttribute(t, i), s = Math.max(s, n.distanceToSquared(fs));
      if (e)
        for (let i = 0, r = e.length; i < r; i++) {
          const o = e[i], a = this.morphTargetsRelative;
          for (let c = 0, l = o.count; c < l; c++)
            fs.fromBufferAttribute(o, c), a && (Tl.fromBufferAttribute(t, c), fs.add(Tl)), s = Math.max(s, n.distanceToSquared(fs));
        }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeFaceNormals: function() {
  },
  computeVertexNormals: function() {
    const t = this.index, e = this.getAttribute("position");
    if (e !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new ut(new Float32Array(e.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let h = 0, d = n.count; h < d; h++)
          n.setXYZ(h, 0, 0, 0);
      const s = new P(), i = new P(), r = new P(), o = new P(), a = new P(), c = new P(), l = new P(), u = new P();
      if (t)
        for (let h = 0, d = t.count; h < d; h += 3) {
          const f = t.getX(h + 0), p = t.getX(h + 1), y = t.getX(h + 2);
          s.fromBufferAttribute(e, f), i.fromBufferAttribute(e, p), r.fromBufferAttribute(e, y), l.subVectors(r, i), u.subVectors(s, i), l.cross(u), o.fromBufferAttribute(n, f), a.fromBufferAttribute(n, p), c.fromBufferAttribute(n, y), o.add(l), a.add(l), c.add(l), n.setXYZ(f, o.x, o.y, o.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(y, c.x, c.y, c.z);
        }
      else
        for (let h = 0, d = e.count; h < d; h += 3)
          s.fromBufferAttribute(e, h + 0), i.fromBufferAttribute(e, h + 1), r.fromBufferAttribute(e, h + 2), l.subVectors(r, i), u.subVectors(s, i), l.cross(u), n.setXYZ(h + 0, l.x, l.y, l.z), n.setXYZ(h + 1, l.x, l.y, l.z), n.setXYZ(h + 2, l.x, l.y, l.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  },
  merge: function(t, e) {
    if (!(t && t.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
      return;
    }
    e === void 0 && (e = 0, console.warn(
      "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
    ));
    const n = this.attributes;
    for (const s in n) {
      if (t.attributes[s] === void 0)
        continue;
      const r = n[s].array, o = t.attributes[s], a = o.array, c = o.itemSize * e, l = Math.min(a.length, r.length - c);
      for (let u = 0, h = c; u < l; u++, h++)
        r[h] = a[u];
    }
    return this;
  },
  normalizeNormals: function() {
    const t = this.attributes.normal;
    for (let e = 0, n = t.count; e < n; e++)
      fs.fromBufferAttribute(t, e), fs.normalize(), t.setXYZ(e, fs.x, fs.y, fs.z);
  },
  toNonIndexed: function() {
    function t(o, a) {
      const c = o.array, l = o.itemSize, u = o.normalized, h = new c.constructor(a.length * l);
      let d = 0, f = 0;
      for (let p = 0, y = a.length; p < y; p++) {
        d = a[p] * l;
        for (let g = 0; g < l; g++)
          h[f++] = c[d++];
      }
      return new ut(h, l, u);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
    const e = new et(), n = this.index.array, s = this.attributes;
    for (const o in s) {
      const a = s[o], c = t(a, n);
      e.setAttribute(o, c);
    }
    const i = this.morphAttributes;
    for (const o in i) {
      const a = [], c = i[o];
      for (let l = 0, u = c.length; l < u; l++) {
        const h = c[l], d = t(h, n);
        a.push(d);
      }
      e.morphAttributes[o] = a;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const r = this.groups;
    for (let o = 0, a = r.length; o < a; o++) {
      const c = r[o];
      e.addGroup(c.start, c.count, c.materialIndex);
    }
    return e;
  },
  toJSON: function() {
    const t = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
      const a = this.parameters;
      for (const c in a)
        a[c] !== void 0 && (t[c] = a[c]);
      return t;
    }
    t.data = { attributes: {} };
    const e = this.index;
    e !== null && (t.data.index = {
      type: e.array.constructor.name,
      array: Array.prototype.slice.call(e.array)
    });
    const n = this.attributes;
    for (const a in n) {
      const c = n[a], l = c.toJSON(t.data);
      c.name !== "" && (l.name = c.name), t.data.attributes[a] = l;
    }
    const s = {};
    let i = !1;
    for (const a in this.morphAttributes) {
      const c = this.morphAttributes[a], l = [];
      for (let u = 0, h = c.length; u < h; u++) {
        const d = c[u], f = d.toJSON(t.data);
        d.name !== "" && (f.name = d.name), l.push(f);
      }
      l.length > 0 && (s[a] = l, i = !0);
    }
    i && (t.data.morphAttributes = s, t.data.morphTargetsRelative = this.morphTargetsRelative);
    const r = this.groups;
    r.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(r)));
    const o = this.boundingSphere;
    return o !== null && (t.data.boundingSphere = {
      center: o.center.toArray(),
      radius: o.radius
    }), t;
  },
  clone: function() {
    return new et().copy(this);
  },
  copy: function(t) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const e = {};
    this.name = t.name;
    const n = t.index;
    n !== null && this.setIndex(n.clone(e));
    const s = t.attributes;
    for (const c in s) {
      const l = s[c];
      this.setAttribute(c, l.clone(e));
    }
    const i = t.morphAttributes;
    for (const c in i) {
      const l = [], u = i[c];
      for (let h = 0, d = u.length; h < d; h++)
        l.push(u[h].clone(e));
      this.morphAttributes[c] = l;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const r = t.groups;
    for (let c = 0, l = r.length; c < l; c++) {
      const u = r[c];
      this.addGroup(u.start, u.count, u.materialIndex);
    }
    const o = t.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const a = t.boundingSphere;
    return a !== null && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
const dC = new Mt(), Ja = new $u(), ev = new Bo(), ea = new P(), ta = new P(), na = new P(), tv = new P(), nv = new P(), sv = new P(), Fm = new P(), Pm = new P(), Bm = new P(), Vl = new Ce(), Ul = new Ce(), Gl = new Ce(), Sd = new P(), zm = new P();
function cn(t, e) {
  qe.call(this), this.type = "Mesh", this.geometry = t !== void 0 ? t : new et(), this.material = e !== void 0 ? e : new er(), this.updateMorphTargets();
}
cn.prototype = Object.assign(Object.create(qe.prototype), {
  constructor: cn,
  isMesh: !0,
  copy: function(t) {
    return qe.prototype.copy.call(this, t), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this;
  },
  updateMorphTargets: function() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes, n = Object.keys(e);
      if (n.length > 0) {
        const s = e[n[0]];
        if (s !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let i = 0, r = s.length; i < r; i++) {
            const o = s[i].name || String(i);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i;
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  raycast: function(t, e) {
    const n = this.geometry, s = this.material, i = this.matrixWorld;
    if (s === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(), ev.copy(n.boundingSphere), ev.applyMatrix4(i), t.ray.intersectsSphere(ev) === !1) || (dC.getInverse(i), Ja.copy(t.ray).applyMatrix4(dC), n.boundingBox !== null && Ja.intersectsBox(n.boundingBox) === !1))
      return;
    let r;
    if (n.isBufferGeometry) {
      const o = n.index, a = n.attributes.position, c = n.morphAttributes.position, l = n.morphTargetsRelative, u = n.attributes.uv, h = n.attributes.uv2, d = n.groups, f = n.drawRange;
      if (o !== null)
        if (Array.isArray(s))
          for (let p = 0, y = d.length; p < y; p++) {
            const g = d[p], m = s[g.materialIndex], x = Math.max(g.start, f.start), v = Math.min(g.start + g.count, f.start + f.count);
            for (let b = x, w = v; b < w; b += 3) {
              const S = o.getX(b), _ = o.getX(b + 1), E = o.getX(b + 2);
              r = Vm(this, m, t, Ja, a, c, l, u, h, S, _, E), r && (r.faceIndex = Math.floor(b / 3), r.face.materialIndex = g.materialIndex, e.push(r));
            }
          }
        else {
          const p = Math.max(0, f.start), y = Math.min(o.count, f.start + f.count);
          for (let g = p, m = y; g < m; g += 3) {
            const x = o.getX(g), v = o.getX(g + 1), b = o.getX(g + 2);
            r = Vm(this, s, t, Ja, a, c, l, u, h, x, v, b), r && (r.faceIndex = Math.floor(g / 3), e.push(r));
          }
        }
      else if (a !== void 0)
        if (Array.isArray(s))
          for (let p = 0, y = d.length; p < y; p++) {
            const g = d[p], m = s[g.materialIndex], x = Math.max(g.start, f.start), v = Math.min(g.start + g.count, f.start + f.count);
            for (let b = x, w = v; b < w; b += 3) {
              const S = b, _ = b + 1, E = b + 2;
              r = Vm(this, m, t, Ja, a, c, l, u, h, S, _, E), r && (r.faceIndex = Math.floor(b / 3), r.face.materialIndex = g.materialIndex, e.push(r));
            }
          }
        else {
          const p = Math.max(0, f.start), y = Math.min(a.count, f.start + f.count);
          for (let g = p, m = y; g < m; g += 3) {
            const x = g, v = g + 1, b = g + 2;
            r = Vm(this, s, t, Ja, a, c, l, u, h, x, v, b), r && (r.faceIndex = Math.floor(g / 3), e.push(r));
          }
        }
    } else if (n.isGeometry) {
      const o = Array.isArray(s), a = n.vertices, c = n.faces;
      let l;
      const u = n.faceVertexUvs[0];
      u.length > 0 && (l = u);
      for (let h = 0, d = c.length; h < d; h++) {
        const f = c[h], p = o ? s[f.materialIndex] : s;
        if (p === void 0)
          continue;
        const y = a[f.a], g = a[f.b], m = a[f.c];
        if (r = UE(this, p, t, Ja, y, g, m, Sd), r) {
          if (l && l[h]) {
            const x = l[h];
            Vl.copy(x[0]), Ul.copy(x[1]), Gl.copy(x[2]), r.uv = Es.getUV(Sd, y, g, m, Vl, Ul, Gl, new Ce());
          }
          r.face = f, r.faceIndex = h, e.push(r);
        }
      }
    }
  }
});
function UE(t, e, n, s, i, r, o, a) {
  let c;
  if (e.side === is ? c = s.intersectTriangle(o, r, i, !0, a) : c = s.intersectTriangle(i, r, o, e.side !== ax, a), c === null)
    return null;
  zm.copy(a), zm.applyMatrix4(t.matrixWorld);
  const l = n.ray.origin.distanceTo(zm);
  return l < n.near || l > n.far ? null : {
    distance: l,
    point: zm.clone(),
    object: t
  };
}
function Vm(t, e, n, s, i, r, o, a, c, l, u, h) {
  ea.fromBufferAttribute(i, l), ta.fromBufferAttribute(i, u), na.fromBufferAttribute(i, h);
  const d = t.morphTargetInfluences;
  if (e.morphTargets && r && d) {
    Fm.set(0, 0, 0), Pm.set(0, 0, 0), Bm.set(0, 0, 0);
    for (let p = 0, y = r.length; p < y; p++) {
      const g = d[p], m = r[p];
      g !== 0 && (tv.fromBufferAttribute(m, l), nv.fromBufferAttribute(m, u), sv.fromBufferAttribute(m, h), o ? (Fm.addScaledVector(tv, g), Pm.addScaledVector(nv, g), Bm.addScaledVector(sv, g)) : (Fm.addScaledVector(tv.sub(ea), g), Pm.addScaledVector(nv.sub(ta), g), Bm.addScaledVector(sv.sub(na), g)));
    }
    ea.add(Fm), ta.add(Pm), na.add(Bm);
  }
  t.isSkinnedMesh && (t.boneTransform(l, ea), t.boneTransform(u, ta), t.boneTransform(h, na));
  const f = UE(t, e, n, s, ea, ta, na, Sd);
  if (f) {
    a && (Vl.fromBufferAttribute(a, l), Ul.fromBufferAttribute(a, u), Gl.fromBufferAttribute(a, h), f.uv = Es.getUV(Sd, ea, ta, na, Vl, Ul, Gl, new Ce())), c && (Vl.fromBufferAttribute(c, l), Ul.fromBufferAttribute(c, u), Gl.fromBufferAttribute(c, h), f.uv2 = Es.getUV(Sd, ea, ta, na, Vl, Ul, Gl, new Ce()));
    const p = new Kg(l, u, h);
    Es.getNormal(ea, ta, na, p.normal), f.face = p;
  }
  return f;
}
let LF = 0;
const $r = new Mt(), iv = new qe(), Um = new P();
function xt() {
  Object.defineProperty(this, "id", { value: LF += 2 }), this.uuid = Et.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1;
}
xt.prototype = Object.assign(Object.create(Po.prototype), {
  constructor: xt,
  isGeometry: !0,
  applyMatrix4: function(t) {
    const e = new Js().getNormalMatrix(t);
    for (let n = 0, s = this.vertices.length; n < s; n++)
      this.vertices[n].applyMatrix4(t);
    for (let n = 0, s = this.faces.length; n < s; n++) {
      const i = this.faces[n];
      i.normal.applyMatrix3(e).normalize();
      for (let r = 0, o = i.vertexNormals.length; r < o; r++)
        i.vertexNormals[r].applyMatrix3(e).normalize();
    }
    return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this;
  },
  rotateX: function(t) {
    return $r.makeRotationX(t), this.applyMatrix4($r), this;
  },
  rotateY: function(t) {
    return $r.makeRotationY(t), this.applyMatrix4($r), this;
  },
  rotateZ: function(t) {
    return $r.makeRotationZ(t), this.applyMatrix4($r), this;
  },
  translate: function(t, e, n) {
    return $r.makeTranslation(t, e, n), this.applyMatrix4($r), this;
  },
  scale: function(t, e, n) {
    return $r.makeScale(t, e, n), this.applyMatrix4($r), this;
  },
  lookAt: function(t) {
    return iv.lookAt(t), iv.updateMatrix(), this.applyMatrix4(iv.matrix), this;
  },
  fromBufferGeometry: function(t) {
    const e = this, n = t.index !== null ? t.index : void 0, s = t.attributes;
    if (s.position === void 0)
      return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
    const i = s.position, r = s.normal, o = s.color, a = s.uv, c = s.uv2;
    c !== void 0 && (this.faceVertexUvs[1] = []);
    for (let h = 0; h < i.count; h++)
      e.vertices.push(new P().fromBufferAttribute(i, h)), o !== void 0 && e.colors.push(new st().fromBufferAttribute(o, h));
    function l(h, d, f, p) {
      const y = o === void 0 ? [] : [
        e.colors[h].clone(),
        e.colors[d].clone(),
        e.colors[f].clone()
      ], g = r === void 0 ? [] : [
        new P().fromBufferAttribute(r, h),
        new P().fromBufferAttribute(r, d),
        new P().fromBufferAttribute(r, f)
      ], m = new Kg(h, d, f, g, y, p);
      e.faces.push(m), a !== void 0 && e.faceVertexUvs[0].push([
        new Ce().fromBufferAttribute(a, h),
        new Ce().fromBufferAttribute(a, d),
        new Ce().fromBufferAttribute(a, f)
      ]), c !== void 0 && e.faceVertexUvs[1].push([
        new Ce().fromBufferAttribute(c, h),
        new Ce().fromBufferAttribute(c, d),
        new Ce().fromBufferAttribute(c, f)
      ]);
    }
    const u = t.groups;
    if (u.length > 0)
      for (let h = 0; h < u.length; h++) {
        const d = u[h], f = d.start, p = d.count;
        for (let y = f, g = f + p; y < g; y += 3)
          n !== void 0 ? l(n.getX(y), n.getX(y + 1), n.getX(y + 2), d.materialIndex) : l(y, y + 1, y + 2, d.materialIndex);
      }
    else if (n !== void 0)
      for (let h = 0; h < n.count; h += 3)
        l(n.getX(h), n.getX(h + 1), n.getX(h + 2));
    else
      for (let h = 0; h < i.count; h += 3)
        l(h, h + 1, h + 2);
    return this.computeFaceNormals(), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
  },
  center: function() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Um).negate(), this.translate(Um.x, Um.y, Um.z), this;
  },
  normalize: function() {
    this.computeBoundingSphere();
    const t = this.boundingSphere.center, e = this.boundingSphere.radius, n = e === 0 ? 1 : 1 / e, s = new Mt();
    return s.set(
      n,
      0,
      0,
      -n * t.x,
      0,
      n,
      0,
      -n * t.y,
      0,
      0,
      n,
      -n * t.z,
      0,
      0,
      0,
      1
    ), this.applyMatrix4(s), this;
  },
  computeFaceNormals: function() {
    const t = new P(), e = new P();
    for (let n = 0, s = this.faces.length; n < s; n++) {
      const i = this.faces[n], r = this.vertices[i.a], o = this.vertices[i.b], a = this.vertices[i.c];
      t.subVectors(a, o), e.subVectors(r, o), t.cross(e), t.normalize(), i.normal.copy(t);
    }
  },
  computeVertexNormals: function(t) {
    t === void 0 && (t = !0);
    const e = new Array(this.vertices.length);
    for (let n = 0, s = this.vertices.length; n < s; n++)
      e[n] = new P();
    if (t) {
      const n = new P(), s = new P();
      for (let i = 0, r = this.faces.length; i < r; i++) {
        const o = this.faces[i], a = this.vertices[o.a], c = this.vertices[o.b], l = this.vertices[o.c];
        n.subVectors(l, c), s.subVectors(a, c), n.cross(s), e[o.a].add(n), e[o.b].add(n), e[o.c].add(n);
      }
    } else {
      this.computeFaceNormals();
      for (let n = 0, s = this.faces.length; n < s; n++) {
        const i = this.faces[n];
        e[i.a].add(i.normal), e[i.b].add(i.normal), e[i.c].add(i.normal);
      }
    }
    for (let n = 0, s = this.vertices.length; n < s; n++)
      e[n].normalize();
    for (let n = 0, s = this.faces.length; n < s; n++) {
      const i = this.faces[n], r = i.vertexNormals;
      r.length === 3 ? (r[0].copy(e[i.a]), r[1].copy(e[i.b]), r[2].copy(e[i.c])) : (r[0] = e[i.a].clone(), r[1] = e[i.b].clone(), r[2] = e[i.c].clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeFlatVertexNormals: function() {
    this.computeFaceNormals();
    for (let t = 0, e = this.faces.length; t < e; t++) {
      const n = this.faces[t], s = n.vertexNormals;
      s.length === 3 ? (s[0].copy(n.normal), s[1].copy(n.normal), s[2].copy(n.normal)) : (s[0] = n.normal.clone(), s[1] = n.normal.clone(), s[2] = n.normal.clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeMorphNormals: function() {
    for (let e = 0, n = this.faces.length; e < n; e++) {
      const s = this.faces[e];
      s.__originalFaceNormal ? s.__originalFaceNormal.copy(s.normal) : s.__originalFaceNormal = s.normal.clone(), s.__originalVertexNormals || (s.__originalVertexNormals = []);
      for (let i = 0, r = s.vertexNormals.length; i < r; i++)
        s.__originalVertexNormals[i] ? s.__originalVertexNormals[i].copy(s.vertexNormals[i]) : s.__originalVertexNormals[i] = s.vertexNormals[i].clone();
    }
    const t = new xt();
    t.faces = this.faces;
    for (let e = 0, n = this.morphTargets.length; e < n; e++) {
      if (!this.morphNormals[e]) {
        this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
        const i = this.morphNormals[e].faceNormals, r = this.morphNormals[e].vertexNormals;
        for (let o = 0, a = this.faces.length; o < a; o++) {
          const c = new P(), l = { a: new P(), b: new P(), c: new P() };
          i.push(c), r.push(l);
        }
      }
      const s = this.morphNormals[e];
      t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals();
      for (let i = 0, r = this.faces.length; i < r; i++) {
        const o = this.faces[i], a = s.faceNormals[i], c = s.vertexNormals[i];
        a.copy(o.normal), c.a.copy(o.vertexNormals[0]), c.b.copy(o.vertexNormals[1]), c.c.copy(o.vertexNormals[2]);
      }
    }
    for (let e = 0, n = this.faces.length; e < n; e++) {
      const s = this.faces[e];
      s.normal = s.__originalFaceNormal, s.vertexNormals = s.__originalVertexNormals;
    }
  },
  computeBoundingBox: function() {
    this.boundingBox === null && (this.boundingBox = new co()), this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function() {
    this.boundingSphere === null && (this.boundingSphere = new Bo()), this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function(t, e, n) {
    if (!(t && t.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
      return;
    }
    let s, i = this.vertices.length, r = this.vertices, o = t.vertices, a = this.faces, c = t.faces, l = this.colors, u = t.colors;
    n === void 0 && (n = 0), e !== void 0 && (s = new Js().getNormalMatrix(e));
    for (let h = 0, d = o.length; h < d; h++) {
      const p = o[h].clone();
      e !== void 0 && p.applyMatrix4(e), r.push(p);
    }
    for (let h = 0, d = u.length; h < d; h++)
      l.push(u[h].clone());
    for (let h = 0, d = c.length; h < d; h++) {
      let f = c[h], p, y, g, m = f.vertexNormals, x = f.vertexColors;
      p = new Kg(f.a + i, f.b + i, f.c + i), p.normal.copy(f.normal), s !== void 0 && p.normal.applyMatrix3(s).normalize();
      for (let v = 0, b = m.length; v < b; v++)
        y = m[v].clone(), s !== void 0 && y.applyMatrix3(s).normalize(), p.vertexNormals.push(y);
      p.color.copy(f.color);
      for (let v = 0, b = x.length; v < b; v++)
        g = x[v], p.vertexColors.push(g.clone());
      p.materialIndex = f.materialIndex + n, a.push(p);
    }
    for (let h = 0, d = t.faceVertexUvs.length; h < d; h++) {
      const f = t.faceVertexUvs[h];
      this.faceVertexUvs[h] === void 0 && (this.faceVertexUvs[h] = []);
      for (let p = 0, y = f.length; p < y; p++) {
        const g = f[p], m = [];
        for (let x = 0, v = g.length; x < v; x++)
          m.push(g[x].clone());
        this.faceVertexUvs[h].push(m);
      }
    }
  },
  mergeMesh: function(t) {
    if (!(t && t.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t);
      return;
    }
    t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix);
  },
  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */
  mergeVertices: function() {
    const t = {}, e = [], n = [], i = Math.pow(10, 4);
    for (let a = 0, c = this.vertices.length; a < c; a++) {
      const l = this.vertices[a], u = Math.round(l.x * i) + "_" + Math.round(l.y * i) + "_" + Math.round(l.z * i);
      t[u] === void 0 ? (t[u] = a, e.push(this.vertices[a]), n[a] = e.length - 1) : n[a] = n[t[u]];
    }
    const r = [];
    for (let a = 0, c = this.faces.length; a < c; a++) {
      const l = this.faces[a];
      l.a = n[l.a], l.b = n[l.b], l.c = n[l.c];
      const u = [l.a, l.b, l.c];
      for (let h = 0; h < 3; h++)
        if (u[h] === u[(h + 1) % 3]) {
          r.push(a);
          break;
        }
    }
    for (let a = r.length - 1; a >= 0; a--) {
      const c = r[a];
      this.faces.splice(c, 1);
      for (let l = 0, u = this.faceVertexUvs.length; l < u; l++)
        this.faceVertexUvs[l].splice(c, 1);
    }
    const o = this.vertices.length - e.length;
    return this.vertices = e, o;
  },
  setFromPoints: function(t) {
    this.vertices = [];
    for (let e = 0, n = t.length; e < n; e++) {
      const s = t[e];
      this.vertices.push(new P(s.x, s.y, s.z || 0));
    }
    return this;
  },
  sortFacesByMaterialIndex: function() {
    const t = this.faces, e = t.length;
    for (let a = 0; a < e; a++)
      t[a]._id = a;
    function n(a, c) {
      return a.materialIndex - c.materialIndex;
    }
    t.sort(n);
    const s = this.faceVertexUvs[0], i = this.faceVertexUvs[1];
    let r, o;
    s && s.length === e && (r = []), i && i.length === e && (o = []);
    for (let a = 0; a < e; a++) {
      const c = t[a]._id;
      r && r.push(s[c]), o && o.push(i[c]);
    }
    r && (this.faceVertexUvs[0] = r), o && (this.faceVertexUvs[1] = o);
  },
  toJSON: function() {
    const t = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON"
      }
    };
    if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), this.parameters !== void 0) {
      const f = this.parameters;
      for (const p in f)
        f[p] !== void 0 && (t[p] = f[p]);
      return t;
    }
    const e = [];
    for (let f = 0; f < this.vertices.length; f++) {
      const p = this.vertices[f];
      e.push(p.x, p.y, p.z);
    }
    const n = [], s = [], i = {}, r = [], o = {}, a = [], c = {};
    for (let f = 0; f < this.faces.length; f++) {
      const p = this.faces[f], y = !0, g = !1, m = this.faceVertexUvs[0][f] !== void 0, x = p.normal.length() > 0, v = p.vertexNormals.length > 0, b = p.color.r !== 1 || p.color.g !== 1 || p.color.b !== 1, w = p.vertexColors.length > 0;
      let S = 0;
      if (S = l(S, 0, 0), S = l(S, 1, y), S = l(S, 2, g), S = l(S, 3, m), S = l(S, 4, x), S = l(S, 5, v), S = l(S, 6, b), S = l(S, 7, w), n.push(S), n.push(p.a, p.b, p.c), n.push(p.materialIndex), m) {
        const _ = this.faceVertexUvs[0][f];
        n.push(
          d(_[0]),
          d(_[1]),
          d(_[2])
        );
      }
      if (x && n.push(u(p.normal)), v) {
        const _ = p.vertexNormals;
        n.push(
          u(_[0]),
          u(_[1]),
          u(_[2])
        );
      }
      if (b && n.push(h(p.color)), w) {
        const _ = p.vertexColors;
        n.push(
          h(_[0]),
          h(_[1]),
          h(_[2])
        );
      }
    }
    function l(f, p, y) {
      return y ? f | 1 << p : f & ~(1 << p);
    }
    function u(f) {
      const p = f.x.toString() + f.y.toString() + f.z.toString();
      return i[p] !== void 0 || (i[p] = s.length / 3, s.push(f.x, f.y, f.z)), i[p];
    }
    function h(f) {
      const p = f.r.toString() + f.g.toString() + f.b.toString();
      return o[p] !== void 0 || (o[p] = r.length, r.push(f.getHex())), o[p];
    }
    function d(f) {
      const p = f.x.toString() + f.y.toString();
      return c[p] !== void 0 || (c[p] = a.length / 2, a.push(f.x, f.y)), c[p];
    }
    return t.data = {}, t.data.vertices = e, t.data.normals = s, r.length > 0 && (t.data.colors = r), a.length > 0 && (t.data.uvs = [a]), t.data.faces = n, t;
  },
  clone: function() {
    return new xt().copy(this);
  },
  copy: function(t) {
    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
    const e = t.vertices;
    for (let h = 0, d = e.length; h < d; h++)
      this.vertices.push(e[h].clone());
    const n = t.colors;
    for (let h = 0, d = n.length; h < d; h++)
      this.colors.push(n[h].clone());
    const s = t.faces;
    for (let h = 0, d = s.length; h < d; h++)
      this.faces.push(s[h].clone());
    for (let h = 0, d = t.faceVertexUvs.length; h < d; h++) {
      const f = t.faceVertexUvs[h];
      this.faceVertexUvs[h] === void 0 && (this.faceVertexUvs[h] = []);
      for (let p = 0, y = f.length; p < y; p++) {
        const g = f[p], m = [];
        for (let x = 0, v = g.length; x < v; x++) {
          const b = g[x];
          m.push(b.clone());
        }
        this.faceVertexUvs[h].push(m);
      }
    }
    const i = t.morphTargets;
    for (let h = 0, d = i.length; h < d; h++) {
      const f = {};
      if (f.name = i[h].name, i[h].vertices !== void 0) {
        f.vertices = [];
        for (let p = 0, y = i[h].vertices.length; p < y; p++)
          f.vertices.push(i[h].vertices[p].clone());
      }
      if (i[h].normals !== void 0) {
        f.normals = [];
        for (let p = 0, y = i[h].normals.length; p < y; p++)
          f.normals.push(i[h].normals[p].clone());
      }
      this.morphTargets.push(f);
    }
    const r = t.morphNormals;
    for (let h = 0, d = r.length; h < d; h++) {
      const f = {};
      if (r[h].vertexNormals !== void 0) {
        f.vertexNormals = [];
        for (let p = 0, y = r[h].vertexNormals.length; p < y; p++) {
          const g = r[h].vertexNormals[p], m = {};
          m.a = g.a.clone(), m.b = g.b.clone(), m.c = g.c.clone(), f.vertexNormals.push(m);
        }
      }
      if (r[h].faceNormals !== void 0) {
        f.faceNormals = [];
        for (let p = 0, y = r[h].faceNormals.length; p < y; p++)
          f.faceNormals.push(r[h].faceNormals[p].clone());
      }
      this.morphNormals.push(f);
    }
    const o = t.skinWeights;
    for (let h = 0, d = o.length; h < d; h++)
      this.skinWeights.push(o[h].clone());
    const a = t.skinIndices;
    for (let h = 0, d = a.length; h < d; h++)
      this.skinIndices.push(a[h].clone());
    const c = t.lineDistances;
    for (let h = 0, d = c.length; h < d; h++)
      this.lineDistances.push(c[h]);
    const l = t.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const u = t.boundingSphere;
    return u !== null && (this.boundingSphere = u.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
class FF extends xt {
  constructor(e, n, s, i, r, o) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: n,
      depth: s,
      widthSegments: i,
      heightSegments: r,
      depthSegments: o
    }, this.fromBufferGeometry(new fx(e, n, s, i, r, o)), this.mergeVertices();
  }
}
class fx extends et {
  constructor(e = 1, n = 1, s = 1, i = 1, r = 1, o = 1) {
    super(), this.type = "BoxBufferGeometry", this.parameters = {
      width: e,
      height: n,
      depth: s,
      widthSegments: i,
      heightSegments: r,
      depthSegments: o
    };
    const a = this;
    i = Math.floor(i), r = Math.floor(r), o = Math.floor(o);
    const c = [], l = [], u = [], h = [];
    let d = 0, f = 0;
    p("z", "y", "x", -1, -1, s, n, e, o, r, 0), p("z", "y", "x", 1, -1, s, n, -e, o, r, 1), p("x", "z", "y", 1, 1, e, s, n, i, o, 2), p("x", "z", "y", 1, -1, e, s, -n, i, o, 3), p("x", "y", "z", 1, -1, e, n, s, i, r, 4), p("x", "y", "z", -1, -1, e, n, -s, i, r, 5), this.setIndex(c), this.setAttribute("position", new Ze(l, 3)), this.setAttribute("normal", new Ze(u, 3)), this.setAttribute("uv", new Ze(h, 2));
    function p(y, g, m, x, v, b, w, S, _, E, I) {
      const k = b / _, M = w / E, L = b / 2, O = w / 2, $ = S / 2, D = _ + 1, z = E + 1;
      let W = 0, j = 0;
      const J = new P();
      for (let ne = 0; ne < z; ne++) {
        const re = ne * M - O;
        for (let fe = 0; fe < D; fe++) {
          const ae = fe * k - L;
          J[y] = ae * x, J[g] = re * v, J[m] = $, l.push(J.x, J.y, J.z), J[y] = 0, J[g] = 0, J[m] = S > 0 ? 1 : -1, u.push(J.x, J.y, J.z), h.push(fe / _), h.push(1 - ne / E), W += 1;
        }
      }
      for (let ne = 0; ne < E; ne++)
        for (let re = 0; re < _; re++) {
          const fe = d + re + D * ne, ae = d + re + D * (ne + 1), ve = d + (re + 1) + D * (ne + 1), me = d + (re + 1) + D * ne;
          c.push(fe, ae, me), c.push(ae, ve, me), j += 6;
        }
      a.addGroup(f, j, I), f += j, d += W;
    }
  }
}
function eu(t) {
  const e = {};
  for (const n in t) {
    e[n] = {};
    for (const s in t[n]) {
      const i = t[n][s];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? e[n][s] = i.clone() : Array.isArray(i) ? e[n][s] = i.slice() : e[n][s] = i;
    }
  }
  return e;
}
function $s(t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const s = eu(t[n]);
    for (const i in s)
      e[i] = s[i];
  }
  return e;
}
const PF = { clone: eu, merge: $s };
var BF = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, zF = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
function yi(t) {
  yt.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = BF, this.fragmentShader = zF, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
    derivatives: !1,
    // set to use derivatives
    fragDepth: !1,
    // set to use fragment depth values
    drawBuffers: !1,
    // set to use draw buffers
    shaderTextureLOD: !1
    // set to use shader texture LOD
  }, this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, t !== void 0 && (t.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t));
}
yi.prototype = Object.create(yt.prototype);
yi.prototype.constructor = yi;
yi.prototype.isShaderMaterial = !0;
yi.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = eu(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this;
};
yi.prototype.toJSON = function(t) {
  const e = yt.prototype.toJSON.call(this, t);
  e.uniforms = {};
  for (const s in this.uniforms) {
    const r = this.uniforms[s].value;
    r && r.isTexture ? e.uniforms[s] = {
      type: "t",
      value: r.toJSON(t).uuid
    } : r && r.isColor ? e.uniforms[s] = {
      type: "c",
      value: r.getHex()
    } : r && r.isVector2 ? e.uniforms[s] = {
      type: "v2",
      value: r.toArray()
    } : r && r.isVector3 ? e.uniforms[s] = {
      type: "v3",
      value: r.toArray()
    } : r && r.isVector4 ? e.uniforms[s] = {
      type: "v4",
      value: r.toArray()
    } : r && r.isMatrix3 ? e.uniforms[s] = {
      type: "m3",
      value: r.toArray()
    } : r && r.isMatrix4 ? e.uniforms[s] = {
      type: "m4",
      value: r.toArray()
    } : e.uniforms[s] = {
      value: r
    };
  }
  Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
  const n = {};
  for (const s in this.extensions)
    this.extensions[s] === !0 && (n[s] = !0);
  return Object.keys(n).length > 0 && (e.extensions = n), e;
};
function Eo() {
  qe.call(this), this.type = "Camera", this.matrixWorldInverse = new Mt(), this.projectionMatrix = new Mt(), this.projectionMatrixInverse = new Mt();
}
Eo.prototype = Object.assign(Object.create(qe.prototype), {
  constructor: Eo,
  isCamera: !0,
  copy: function(t, e) {
    return qe.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
  },
  getWorldDirection: function(t) {
    t === void 0 && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new P()), this.updateMatrixWorld(!0);
    const e = this.matrixWorld.elements;
    return t.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function(t) {
    qe.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  updateWorldMatrix: function(t, e) {
    qe.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function Yn(t, e, n, s) {
  Eo.call(this), this.type = "PerspectiveCamera", this.fov = t !== void 0 ? t : 50, this.zoom = 1, this.near = n !== void 0 ? n : 0.1, this.far = s !== void 0 ? s : 2e3, this.focus = 10, this.aspect = e !== void 0 ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
}
Yn.prototype = Object.assign(Object.create(Eo.prototype), {
  constructor: Yn,
  isPerspectiveCamera: !0,
  copy: function(t, e) {
    return Eo.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
  },
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength: function(t) {
    const e = 0.5 * this.getFilmHeight() / t;
    this.fov = Et.RAD2DEG * 2 * Math.atan(e), this.updateProjectionMatrix();
  },
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength: function() {
    const t = Math.tan(Et.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / t;
  },
  getEffectiveFOV: function() {
    return Et.RAD2DEG * 2 * Math.atan(
      Math.tan(Et.DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset: function(t, e, n, s, i, r) {
    this.aspect = t / e, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = s, this.view.width = i, this.view.height = r, this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    let t = this.near, e = t * Math.tan(Et.DEG2RAD * 0.5 * this.fov) / this.zoom, n = 2 * e, s = this.aspect * n, i = -0.5 * s, r = this.view;
    if (this.view !== null && this.view.enabled) {
      const a = r.fullWidth, c = r.fullHeight;
      i += r.offsetX * s / a, e -= r.offsetY * n / c, s *= r.width / a, n *= r.height / c;
    }
    const o = this.filmOffset;
    o !== 0 && (i += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + s, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function(t) {
    const e = qe.prototype.toJSON.call(this, t);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
});
const Cl = 90, Il = 1;
function Rd(t, e, n) {
  if (qe.call(this), this.type = "CubeCamera", n.isWebGLCubeRenderTarget !== !0) {
    console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
    return;
  }
  this.renderTarget = n;
  const s = new Yn(Cl, Il, t, e);
  s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new P(1, 0, 0)), this.add(s);
  const i = new Yn(Cl, Il, t, e);
  i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new P(-1, 0, 0)), this.add(i);
  const r = new Yn(Cl, Il, t, e);
  r.layers = this.layers, r.up.set(0, 0, 1), r.lookAt(new P(0, 1, 0)), this.add(r);
  const o = new Yn(Cl, Il, t, e);
  o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new P(0, -1, 0)), this.add(o);
  const a = new Yn(Cl, Il, t, e);
  a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new P(0, 0, 1)), this.add(a);
  const c = new Yn(Cl, Il, t, e);
  c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new P(0, 0, -1)), this.add(c), this.update = function(l, u) {
    this.parent === null && this.updateMatrixWorld();
    const h = l.xr.enabled, d = l.getRenderTarget();
    l.xr.enabled = !1;
    const f = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, l.setRenderTarget(n, 0), l.render(u, s), l.setRenderTarget(n, 1), l.render(u, i), l.setRenderTarget(n, 2), l.render(u, r), l.setRenderTarget(n, 3), l.render(u, o), l.setRenderTarget(n, 4), l.render(u, a), n.texture.generateMipmaps = f, l.setRenderTarget(n, 5), l.render(u, c), l.setRenderTarget(d), l.xr.enabled = h;
  }, this.clear = function(l, u, h, d) {
    const f = l.getRenderTarget();
    for (let p = 0; p < 6; p++)
      l.setRenderTarget(n, p), l.clear(u, h, d);
    l.setRenderTarget(f);
  };
}
Rd.prototype = Object.create(qe.prototype);
Rd.prototype.constructor = Rd;
function Dd(t, e, n) {
  Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), Ji.call(this, t, t, e);
}
Dd.prototype = Object.create(Ji.prototype);
Dd.prototype.constructor = Dd;
Dd.prototype.isWebGLCubeRenderTarget = !0;
Dd.prototype.fromEquirectangularTexture = function(t, e) {
  this.texture.type = e.type, this.texture.format = Zi, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
  const n = new kd(), s = {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: (
      /* glsl */
      `

			varying vec3 vWorldDirection;

			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

			}

			void main() {

				vWorldDirection = transformDirection( position, modelMatrix );

				#include <begin_vertex>
				#include <project_vertex>

			}
		`
    ),
    fragmentShader: (
      /* glsl */
      `

			uniform sampler2D tEquirect;

			varying vec3 vWorldDirection;

			#include <common>

			void main() {

				vec3 direction = normalize( vWorldDirection );

				vec2 sampleUV = equirectUv( direction );

				gl_FragColor = texture2D( tEquirect, sampleUV );

			}
		`
    )
  }, i = new yi({
    name: "CubemapFromEquirect",
    uniforms: eu(s.uniforms),
    vertexShader: s.vertexShader,
    fragmentShader: s.fragmentShader,
    side: is,
    blending: ha
  });
  i.uniforms.tEquirect.value = e;
  const r = new cn(new fx(5, 5, 5), i);
  return n.add(r), new Rd(1, 10, this).update(t, n), r.geometry.dispose(), r.material.dispose(), this;
};
function tu(t, e, n, s, i, r, o, a, c, l, u, h) {
  dn.call(this, null, r, o, a, c, l, s, i, u, h), this.image = { data: t || null, width: e || 1, height: n || 1 }, this.magFilter = c !== void 0 ? c : ps, this.minFilter = l !== void 0 ? l : ps, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0;
}
tu.prototype = Object.create(dn.prototype);
tu.prototype.constructor = tu;
tu.prototype.isDataTexture = !0;
const El = new Bo(), Gm = new P();
function Of(t, e, n, s, i, r) {
  this.planes = [
    t !== void 0 ? t : new Fr(),
    e !== void 0 ? e : new Fr(),
    n !== void 0 ? n : new Fr(),
    s !== void 0 ? s : new Fr(),
    i !== void 0 ? i : new Fr(),
    r !== void 0 ? r : new Fr()
  ];
}
Object.assign(Of.prototype, {
  set: function(t, e, n, s, i, r) {
    const o = this.planes;
    return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(s), o[4].copy(i), o[5].copy(r), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++)
      e[n].copy(t.planes[n]);
    return this;
  },
  setFromProjectionMatrix: function(t) {
    const e = this.planes, n = t.elements, s = n[0], i = n[1], r = n[2], o = n[3], a = n[4], c = n[5], l = n[6], u = n[7], h = n[8], d = n[9], f = n[10], p = n[11], y = n[12], g = n[13], m = n[14], x = n[15];
    return e[0].setComponents(o - s, u - a, p - h, x - y).normalize(), e[1].setComponents(o + s, u + a, p + h, x + y).normalize(), e[2].setComponents(o + i, u + c, p + d, x + g).normalize(), e[3].setComponents(o - i, u - c, p - d, x - g).normalize(), e[4].setComponents(o - r, u - l, p - f, x - m).normalize(), e[5].setComponents(o + r, u + l, p + f, x + m).normalize(), this;
  },
  intersectsObject: function(t) {
    const e = t.geometry;
    return e.boundingSphere === null && e.computeBoundingSphere(), El.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(El);
  },
  intersectsSprite: function(t) {
    return El.center.set(0, 0, 0), El.radius = 0.7071067811865476, El.applyMatrix4(t.matrixWorld), this.intersectsSphere(El);
  },
  intersectsSphere: function(t) {
    const e = this.planes, n = t.center, s = -t.radius;
    for (let i = 0; i < 6; i++)
      if (e[i].distanceToPoint(n) < s)
        return !1;
    return !0;
  },
  intersectsBox: function(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) {
      const s = e[n];
      if (Gm.x = s.normal.x > 0 ? t.max.x : t.min.x, Gm.y = s.normal.y > 0 ? t.max.y : t.min.y, Gm.z = s.normal.z > 0 ? t.max.z : t.min.z, s.distanceToPoint(Gm) < 0)
        return !1;
    }
    return !0;
  },
  containsPoint: function(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++)
      if (e[n].distanceToPoint(t) < 0)
        return !1;
    return !0;
  }
});
const Ye = {
  common: {
    diffuse: { value: new st(15658734) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Js() },
    uv2Transform: { value: new Js() },
    alphaMap: { value: null }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new Ce(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new st(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } }
  },
  points: {
    diffuse: { value: new st(15658734) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new Js() }
  },
  sprite: {
    diffuse: { value: new st(15658734) },
    opacity: { value: 1 },
    center: { value: new Ce(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new Js() }
  }
};
function GE() {
  let t = null, e = !1, n = null, s = null;
  function i(r, o) {
    n(r, o), s = t.requestAnimationFrame(i);
  }
  return {
    start: function() {
      e !== !0 && n !== null && (s = t.requestAnimationFrame(i), e = !0);
    },
    stop: function() {
      t.cancelAnimationFrame(s), e = !1;
    },
    setAnimationLoop: function(r) {
      n = r;
    },
    setContext: function(r) {
      t = r;
    }
  };
}
function VF(t, e) {
  const n = e.isWebGL2, s = /* @__PURE__ */ new WeakMap();
  function i(l, u) {
    const h = l.array, d = l.usage, f = t.createBuffer();
    t.bindBuffer(u, f), t.bufferData(u, h, d), l.onUploadCallback();
    let p = 5126;
    return h instanceof Float32Array ? p = 5126 : h instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : h instanceof Uint16Array ? p = 5123 : h instanceof Int16Array ? p = 5122 : h instanceof Uint32Array ? p = 5125 : h instanceof Int32Array ? p = 5124 : h instanceof Int8Array ? p = 5120 : h instanceof Uint8Array && (p = 5121), {
      buffer: f,
      type: p,
      bytesPerElement: h.BYTES_PER_ELEMENT,
      version: l.version
    };
  }
  function r(l, u, h) {
    const d = u.array, f = u.updateRange;
    t.bindBuffer(h, l), f.count === -1 ? t.bufferSubData(h, 0, d) : (n ? t.bufferSubData(
      h,
      f.offset * d.BYTES_PER_ELEMENT,
      d,
      f.offset,
      f.count
    ) : t.bufferSubData(
      h,
      f.offset * d.BYTES_PER_ELEMENT,
      d.subarray(f.offset, f.offset + f.count)
    ), f.count = -1);
  }
  function o(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), s.get(l);
  }
  function a(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const u = s.get(l);
    u && (t.deleteBuffer(u.buffer), s.delete(l));
  }
  function c(l, u) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const h = s.get(l);
    h === void 0 ? s.set(l, i(l, u)) : h.version < l.version && (r(h.buffer, l, u), h.version = l.version);
  }
  return {
    get: o,
    remove: a,
    update: c
  };
}
function Yg(t, e, n, s) {
  xt.call(this), this.type = "PlaneGeometry", this.parameters = {
    width: t,
    height: e,
    widthSegments: n,
    heightSegments: s
  }, this.fromBufferGeometry(new nu(t, e, n, s)), this.mergeVertices();
}
Yg.prototype = Object.create(xt.prototype);
Yg.prototype.constructor = Yg;
function nu(t, e, n, s) {
  et.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
    width: t,
    height: e,
    widthSegments: n,
    heightSegments: s
  }, t = t || 1, e = e || 1;
  const i = t / 2, r = e / 2, o = Math.floor(n) || 1, a = Math.floor(s) || 1, c = o + 1, l = a + 1, u = t / o, h = e / a, d = [], f = [], p = [], y = [];
  for (let g = 0; g < l; g++) {
    const m = g * h - r;
    for (let x = 0; x < c; x++) {
      const v = x * u - i;
      f.push(v, -m, 0), p.push(0, 0, 1), y.push(x / o), y.push(1 - g / a);
    }
  }
  for (let g = 0; g < a; g++)
    for (let m = 0; m < o; m++) {
      const x = m + c * g, v = m + c * (g + 1), b = m + 1 + c * (g + 1), w = m + 1 + c * g;
      d.push(x, v, w), d.push(v, b, w);
    }
  this.setIndex(d), this.setAttribute("position", new Ze(f, 3)), this.setAttribute("normal", new Ze(p, 3)), this.setAttribute("uv", new Ze(y, 2));
}
nu.prototype = Object.create(et.prototype);
nu.prototype.constructor = nu;
var UF = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, GF = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, WF = `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`, HF = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`, jF = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, qF = "vec3 transformed = vec3( position );", XF = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, KF = `vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha  = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`, YF = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, ZF = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, JF = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, QF = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, e3 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, t3 = `#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`, n3 = `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`, s3 = `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`, i3 = `#ifdef USE_COLOR
	vColor.xyz = color.xyz;
#endif`, r3 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, o3 = `#ifdef ENVMAP_TYPE_CUBE_UV
#define cubeUV_maxMipLevel 8.0
#define cubeUV_minMipLevel 4.0
#define cubeUV_maxTileSize 256.0
#define cubeUV_minTileSize 16.0
float getFace(vec3 direction) {
    vec3 absDirection = abs(direction);
    float face = -1.0;
    if (absDirection.x > absDirection.z) {
      if (absDirection.x > absDirection.y)
        face = direction.x > 0.0 ? 0.0 : 3.0;
      else
        face = direction.y > 0.0 ? 1.0 : 4.0;
    } else {
      if (absDirection.z > absDirection.y)
        face = direction.z > 0.0 ? 2.0 : 5.0;
      else
        face = direction.y > 0.0 ? 1.0 : 4.0;
    }
    return face;
}
vec2 getUV(vec3 direction, float face) {
    vec2 uv;
    if (face == 0.0) {
      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {
      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {
      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {
      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {
      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {
      uv = vec2(direction.x, direction.y) / abs(direction.z);    }
    return 0.5 * (uv + 1.0);
}
vec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
  float face = getFace(direction);
  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
  mipInt = max(mipInt, cubeUV_minMipLevel);
  float faceSize = exp2(mipInt);
  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
  vec2 uv = getUV(direction, face) * (faceSize - 1.0);
  vec2 f = fract(uv);
  uv += 0.5 - f;
  if (face > 2.0) {
    uv.y += faceSize;
    face -= 3.0;
  }
  uv.x += face * faceSize;
  if(mipInt < cubeUV_maxMipLevel){
    uv.y += 2.0 * cubeUV_maxTileSize;
  }
  uv.y += filterInt * 2.0 * cubeUV_minTileSize;
  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
  uv *= texelSize;
  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.x += texelSize;
  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.y += texelSize;
  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.x -= texelSize;
  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  vec3 tm = mix(tl, tr, f.x);
  vec3 bm = mix(bl, br, f.x);
  return mix(tm, bm, f.y);
}
#define r0 1.0
#define v0 0.339
#define m0 -2.0
#define r1 0.8
#define v1 0.276
#define m1 -1.0
#define r4 0.4
#define v4 0.046
#define m4 2.0
#define r5 0.305
#define v5 0.016
#define m5 3.0
#define r6 0.21
#define v6 0.0038
#define m6 4.0
float roughnessToMip(float roughness) {
  float mip = 0.0;
  if (roughness >= r1) {
    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
  } else if (roughness >= r4) {
    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
  } else if (roughness >= r5) {
    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
  } else if (roughness >= r6) {
    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
  } else {
    mip = -2.0 * log2(1.16 * roughness);  }
  return mip;
}
vec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {
  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);
  float mipF = fract(mip);
  float mipInt = floor(mip);
  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);
  if (mipF == 0.0) {
    return vec4(color0, 1.0);
  } else {
    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);
    return vec4(mix(color0, color1, mipF), 1.0);
  }
}
#endif`, a3 = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, c3 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, l3 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, u3 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, h3 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, d3 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", f3 = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`, p3 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		}  else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#elif defined( ENVMAP_TYPE_EQUIREC )
		reflectVec = normalize( reflectVec );
		vec2 sampleUV = equirectUv( reflectVec );
		vec4 envColor = texture2D( envMap, sampleUV );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, m3 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, g3 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, y3 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, x3 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, b3 = `#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`, v3 = `#ifdef USE_FOG
	varying float fogDepth;
#endif`, w3 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, S3 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, _3 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`, T3 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`, C3 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, I3 = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`, E3 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`, N3 = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
		  vec3 reflectVec = reflect( -viewDir, normal );
		  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
		  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#elif defined( ENVMAP_TYPE_EQUIREC )
			vec2 sampleUV = equirectUv( reflectVec );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`, k3 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, A3 = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`, M3 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, R3 = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`, D3 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`, $3 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, O3 = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, L3 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`, F3 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, P3 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, B3 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, z3 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, V3 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, U3 = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`, G3 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, W3 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, H3 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, j3 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, q3 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, X3 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`, K3 = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`, Y3 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`, Z3 = `#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, J3 = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif`, Q3 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif`, eP = `#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, tP = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );
	#endif
#endif`, nP = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, sP = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, iP = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, rP = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, oP = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, aP = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, cP = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, lP = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, uP = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, hP = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, dP = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, fP = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, pP = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, mP = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`, gP = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, yP = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, xP = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, bP = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, vP = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, wP = `#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, SP = `#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`, _P = `#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`, TP = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, CP = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, IP = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, EP = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, NP = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, kP = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, AP = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`, MP = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, RP = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, DP = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, $P = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, OP = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, LP = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, FP = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, PP = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, BP = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, zP = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, VP = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, UP = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, GP = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, WP = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, HP = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, jP = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, qP = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, XP = `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, KP = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, YP = `#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, ZP = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, JP = `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, QP = `#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, eB = `#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, tB = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`, nB = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, sB = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, iB = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, rB = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, oB = `#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, aB = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, cB = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;
const Vt = {
  alphamap_fragment: UF,
  alphamap_pars_fragment: GF,
  alphatest_fragment: WF,
  aomap_fragment: HF,
  aomap_pars_fragment: jF,
  begin_vertex: qF,
  beginnormal_vertex: XF,
  bsdfs: KF,
  bumpmap_pars_fragment: YF,
  clipping_planes_fragment: ZF,
  clipping_planes_pars_fragment: JF,
  clipping_planes_pars_vertex: QF,
  clipping_planes_vertex: e3,
  color_fragment: t3,
  color_pars_fragment: n3,
  color_pars_vertex: s3,
  color_vertex: i3,
  common: r3,
  cube_uv_reflection_fragment: o3,
  defaultnormal_vertex: a3,
  displacementmap_pars_vertex: c3,
  displacementmap_vertex: l3,
  emissivemap_fragment: u3,
  emissivemap_pars_fragment: h3,
  encodings_fragment: d3,
  encodings_pars_fragment: f3,
  envmap_fragment: p3,
  envmap_common_pars_fragment: m3,
  envmap_pars_fragment: g3,
  envmap_pars_vertex: y3,
  envmap_physical_pars_fragment: N3,
  envmap_vertex: x3,
  fog_vertex: b3,
  fog_pars_vertex: v3,
  fog_fragment: w3,
  fog_pars_fragment: S3,
  gradientmap_pars_fragment: _3,
  lightmap_fragment: T3,
  lightmap_pars_fragment: C3,
  lights_lambert_vertex: I3,
  lights_pars_begin: E3,
  lights_toon_fragment: k3,
  lights_toon_pars_fragment: A3,
  lights_phong_fragment: M3,
  lights_phong_pars_fragment: R3,
  lights_physical_fragment: D3,
  lights_physical_pars_fragment: $3,
  lights_fragment_begin: O3,
  lights_fragment_maps: L3,
  lights_fragment_end: F3,
  logdepthbuf_fragment: P3,
  logdepthbuf_pars_fragment: B3,
  logdepthbuf_pars_vertex: z3,
  logdepthbuf_vertex: V3,
  map_fragment: U3,
  map_pars_fragment: G3,
  map_particle_fragment: W3,
  map_particle_pars_fragment: H3,
  metalnessmap_fragment: j3,
  metalnessmap_pars_fragment: q3,
  morphnormal_vertex: X3,
  morphtarget_pars_vertex: K3,
  morphtarget_vertex: Y3,
  normal_fragment_begin: Z3,
  normal_fragment_maps: J3,
  normalmap_pars_fragment: Q3,
  clearcoat_normal_fragment_begin: eP,
  clearcoat_normal_fragment_maps: tP,
  clearcoat_pars_fragment: nP,
  packing: sP,
  premultiplied_alpha_fragment: iP,
  project_vertex: rP,
  dithering_fragment: oP,
  dithering_pars_fragment: aP,
  roughnessmap_fragment: cP,
  roughnessmap_pars_fragment: lP,
  shadowmap_pars_fragment: uP,
  shadowmap_pars_vertex: hP,
  shadowmap_vertex: dP,
  shadowmask_pars_fragment: fP,
  skinbase_vertex: pP,
  skinning_pars_vertex: mP,
  skinning_vertex: gP,
  skinnormal_vertex: yP,
  specularmap_fragment: xP,
  specularmap_pars_fragment: bP,
  tonemapping_fragment: vP,
  tonemapping_pars_fragment: wP,
  transmissionmap_fragment: SP,
  transmissionmap_pars_fragment: _P,
  uv_pars_fragment: TP,
  uv_pars_vertex: CP,
  uv_vertex: IP,
  uv2_pars_fragment: EP,
  uv2_pars_vertex: NP,
  uv2_vertex: kP,
  worldpos_vertex: AP,
  background_frag: MP,
  background_vert: RP,
  cube_frag: DP,
  cube_vert: $P,
  depth_frag: OP,
  depth_vert: LP,
  distanceRGBA_frag: FP,
  distanceRGBA_vert: PP,
  equirect_frag: BP,
  equirect_vert: zP,
  linedashed_frag: VP,
  linedashed_vert: UP,
  meshbasic_frag: GP,
  meshbasic_vert: WP,
  meshlambert_frag: HP,
  meshlambert_vert: jP,
  meshmatcap_frag: qP,
  meshmatcap_vert: XP,
  meshtoon_frag: KP,
  meshtoon_vert: YP,
  meshphong_frag: ZP,
  meshphong_vert: JP,
  meshphysical_frag: QP,
  meshphysical_vert: eB,
  normal_frag: tB,
  normal_vert: nB,
  points_frag: sB,
  points_vert: iB,
  shadow_frag: rB,
  shadow_vert: oB,
  sprite_frag: aB,
  sprite_vert: cB
}, Pr = {
  basic: {
    uniforms: $s([
      Ye.common,
      Ye.specularmap,
      Ye.envmap,
      Ye.aomap,
      Ye.lightmap,
      Ye.fog
    ]),
    vertexShader: Vt.meshbasic_vert,
    fragmentShader: Vt.meshbasic_frag
  },
  lambert: {
    uniforms: $s([
      Ye.common,
      Ye.specularmap,
      Ye.envmap,
      Ye.aomap,
      Ye.lightmap,
      Ye.emissivemap,
      Ye.fog,
      Ye.lights,
      {
        emissive: { value: new st(0) }
      }
    ]),
    vertexShader: Vt.meshlambert_vert,
    fragmentShader: Vt.meshlambert_frag
  },
  phong: {
    uniforms: $s([
      Ye.common,
      Ye.specularmap,
      Ye.envmap,
      Ye.aomap,
      Ye.lightmap,
      Ye.emissivemap,
      Ye.bumpmap,
      Ye.normalmap,
      Ye.displacementmap,
      Ye.fog,
      Ye.lights,
      {
        emissive: { value: new st(0) },
        specular: { value: new st(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Vt.meshphong_vert,
    fragmentShader: Vt.meshphong_frag
  },
  standard: {
    uniforms: $s([
      Ye.common,
      Ye.envmap,
      Ye.aomap,
      Ye.lightmap,
      Ye.emissivemap,
      Ye.bumpmap,
      Ye.normalmap,
      Ye.displacementmap,
      Ye.roughnessmap,
      Ye.metalnessmap,
      Ye.fog,
      Ye.lights,
      {
        emissive: { value: new st(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: Vt.meshphysical_vert,
    fragmentShader: Vt.meshphysical_frag
  },
  toon: {
    uniforms: $s([
      Ye.common,
      Ye.aomap,
      Ye.lightmap,
      Ye.emissivemap,
      Ye.bumpmap,
      Ye.normalmap,
      Ye.displacementmap,
      Ye.gradientmap,
      Ye.fog,
      Ye.lights,
      {
        emissive: { value: new st(0) }
      }
    ]),
    vertexShader: Vt.meshtoon_vert,
    fragmentShader: Vt.meshtoon_frag
  },
  matcap: {
    uniforms: $s([
      Ye.common,
      Ye.bumpmap,
      Ye.normalmap,
      Ye.displacementmap,
      Ye.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Vt.meshmatcap_vert,
    fragmentShader: Vt.meshmatcap_frag
  },
  points: {
    uniforms: $s([
      Ye.points,
      Ye.fog
    ]),
    vertexShader: Vt.points_vert,
    fragmentShader: Vt.points_frag
  },
  dashed: {
    uniforms: $s([
      Ye.common,
      Ye.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Vt.linedashed_vert,
    fragmentShader: Vt.linedashed_frag
  },
  depth: {
    uniforms: $s([
      Ye.common,
      Ye.displacementmap
    ]),
    vertexShader: Vt.depth_vert,
    fragmentShader: Vt.depth_frag
  },
  normal: {
    uniforms: $s([
      Ye.common,
      Ye.bumpmap,
      Ye.normalmap,
      Ye.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Vt.normal_vert,
    fragmentShader: Vt.normal_frag
  },
  sprite: {
    uniforms: $s([
      Ye.sprite,
      Ye.fog
    ]),
    vertexShader: Vt.sprite_vert,
    fragmentShader: Vt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Js() },
      t2D: { value: null }
    },
    vertexShader: Vt.background_vert,
    fragmentShader: Vt.background_frag
  },
  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: $s([
      Ye.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Vt.cube_vert,
    fragmentShader: Vt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Vt.equirect_vert,
    fragmentShader: Vt.equirect_frag
  },
  distanceRGBA: {
    uniforms: $s([
      Ye.common,
      Ye.displacementmap,
      {
        referencePosition: { value: new P() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Vt.distanceRGBA_vert,
    fragmentShader: Vt.distanceRGBA_frag
  },
  shadow: {
    uniforms: $s([
      Ye.lights,
      Ye.fog,
      {
        color: { value: new st(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Vt.shadow_vert,
    fragmentShader: Vt.shadow_frag
  }
};
Pr.physical = {
  uniforms: $s([
    Pr.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new Ce(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: new st(0) },
      transmission: { value: 0 },
      transmissionMap: { value: null }
    }
  ]),
  vertexShader: Vt.meshphysical_vert,
  fragmentShader: Vt.meshphysical_frag
};
function lB(t, e, n, s) {
  const i = new st(0);
  let r = 0, o, a, c = null, l = 0, u = null;
  function h(f, p, y, g) {
    let m = p.isScene === !0 ? p.background : null;
    const x = t.xr, v = x.getSession && x.getSession();
    if (v && v.environmentBlendMode === "additive" && (m = null), m === null ? d(i, r) : m && m.isColor && (d(m, 1), g = !0), (t.autoClear || g) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), m && (m.isCubeTexture || m.isWebGLCubeRenderTarget || m.mapping === Df)) {
      a === void 0 && (a = new cn(
        new fx(1, 1, 1),
        new yi({
          name: "BackgroundCubeMaterial",
          uniforms: eu(Pr.cube.uniforms),
          vertexShader: Pr.cube.vertexShader,
          fragmentShader: Pr.cube.fragmentShader,
          side: is,
          depthTest: !1,
          depthWrite: !1,
          fog: !1
        })
      ), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function(w, S, _) {
        this.matrixWorld.copyPosition(_.matrixWorld);
      }, Object.defineProperty(a.material, "envMap", {
        get: function() {
          return this.uniforms.envMap.value;
        }
      }), n.update(a));
      const b = m.isWebGLCubeRenderTarget ? m.texture : m;
      a.material.uniforms.envMap.value = b, a.material.uniforms.flipEnvMap.value = b.isCubeTexture ? -1 : 1, (c !== m || l !== b.version || u !== t.toneMapping) && (a.material.needsUpdate = !0, c = m, l = b.version, u = t.toneMapping), f.unshift(a, a.geometry, a.material, 0, 0, null);
    } else
      m && m.isTexture && (o === void 0 && (o = new cn(
        new nu(2, 2),
        new yi({
          name: "BackgroundMaterial",
          uniforms: eu(Pr.background.uniforms),
          vertexShader: Pr.background.vertexShader,
          fragmentShader: Pr.background.fragmentShader,
          side: Rf,
          depthTest: !1,
          depthWrite: !1,
          fog: !1
        })
      ), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
        get: function() {
          return this.uniforms.t2D.value;
        }
      }), n.update(o)), o.material.uniforms.t2D.value = m, m.matrixAutoUpdate === !0 && m.updateMatrix(), o.material.uniforms.uvTransform.value.copy(m.matrix), (c !== m || l !== m.version || u !== t.toneMapping) && (o.material.needsUpdate = !0, c = m, l = m.version, u = t.toneMapping), f.unshift(o, o.geometry, o.material, 0, 0, null));
  }
  function d(f, p) {
    e.buffers.color.setClear(f.r, f.g, f.b, p, s);
  }
  return {
    getClearColor: function() {
      return i;
    },
    setClearColor: function(f, p) {
      i.set(f), r = p !== void 0 ? p : 1, d(i, r);
    },
    getClearAlpha: function() {
      return r;
    },
    setClearAlpha: function(f) {
      r = f, d(i, r);
    },
    render: h
  };
}
function uB(t, e, n, s) {
  const i = t.getParameter(34921), r = s.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = s.isWebGL2 || r !== null, a = {}, c = y(null);
  let l = c;
  function u(O, $, D, z, W) {
    let j = !1;
    if (o) {
      const J = p(z, D, $);
      l !== J && (l = J, d(l.object)), j = g(z), j && m(z);
    } else {
      const J = $.wireframe === !0;
      (l.geometry !== z.id || l.program !== D.id || l.wireframe !== J) && (l.geometry = z.id, l.program = D.id, l.wireframe = J, j = !0);
    }
    O.isInstancedMesh === !0 && (j = !0), W !== null && n.update(W, 34963), j && (_(O, $, D, z), W !== null && t.bindBuffer(34963, n.get(W).buffer));
  }
  function h() {
    return s.isWebGL2 ? t.createVertexArray() : r.createVertexArrayOES();
  }
  function d(O) {
    return s.isWebGL2 ? t.bindVertexArray(O) : r.bindVertexArrayOES(O);
  }
  function f(O) {
    return s.isWebGL2 ? t.deleteVertexArray(O) : r.deleteVertexArrayOES(O);
  }
  function p(O, $, D) {
    const z = D.wireframe === !0;
    let W = a[O.id];
    W === void 0 && (W = {}, a[O.id] = W);
    let j = W[$.id];
    j === void 0 && (j = {}, W[$.id] = j);
    let J = j[z];
    return J === void 0 && (J = y(h()), j[z] = J), J;
  }
  function y(O) {
    const $ = [], D = [], z = [];
    for (let W = 0; W < i; W++)
      $[W] = 0, D[W] = 0, z[W] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: $,
      enabledAttributes: D,
      attributeDivisors: z,
      object: O,
      attributes: {}
    };
  }
  function g(O) {
    const $ = l.attributes, D = O.attributes;
    if (Object.keys($).length !== Object.keys(D).length)
      return !0;
    for (const z in D) {
      const W = $[z], j = D[z];
      if (W.attribute !== j || W.data !== j.data)
        return !0;
    }
    return !1;
  }
  function m(O) {
    const $ = {}, D = O.attributes;
    for (const z in D) {
      const W = D[z], j = {};
      j.attribute = W, W.data && (j.data = W.data), $[z] = j;
    }
    l.attributes = $;
  }
  function x() {
    const O = l.newAttributes;
    for (let $ = 0, D = O.length; $ < D; $++)
      O[$] = 0;
  }
  function v(O) {
    b(O, 0);
  }
  function b(O, $) {
    const D = l.newAttributes, z = l.enabledAttributes, W = l.attributeDivisors;
    D[O] = 1, z[O] === 0 && (t.enableVertexAttribArray(O), z[O] = 1), W[O] !== $ && ((s.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[s.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](O, $), W[O] = $);
  }
  function w() {
    const O = l.newAttributes, $ = l.enabledAttributes;
    for (let D = 0, z = $.length; D < z; D++)
      $[D] !== O[D] && (t.disableVertexAttribArray(D), $[D] = 0);
  }
  function S(O, $, D, z, W, j) {
    s.isWebGL2 === !0 && (D === 5124 || D === 5125) ? t.vertexAttribIPointer(O, $, D, W, j) : t.vertexAttribPointer(O, $, D, z, W, j);
  }
  function _(O, $, D, z) {
    if (s.isWebGL2 === !1 && (O.isInstancedMesh || z.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    x();
    const W = z.attributes, j = D.getAttributes(), J = $.defaultAttributeValues;
    for (const ne in j) {
      const re = j[ne];
      if (re >= 0) {
        const fe = W[ne];
        if (fe !== void 0) {
          const ae = fe.normalized, ve = fe.itemSize, me = n.get(fe);
          if (me === void 0)
            continue;
          const te = me.buffer, $e = me.type, _e = me.bytesPerElement;
          if (fe.isInterleavedBufferAttribute) {
            const ke = fe.data, Re = ke.stride, ce = fe.offset;
            ke && ke.isInstancedInterleavedBuffer ? (b(re, ke.meshPerAttribute), z._maxInstanceCount === void 0 && (z._maxInstanceCount = ke.meshPerAttribute * ke.count)) : v(re), t.bindBuffer(34962, te), S(re, ve, $e, ae, Re * _e, ce * _e);
          } else
            fe.isInstancedBufferAttribute ? (b(re, fe.meshPerAttribute), z._maxInstanceCount === void 0 && (z._maxInstanceCount = fe.meshPerAttribute * fe.count)) : v(re), t.bindBuffer(34962, te), S(re, ve, $e, ae, 0, 0);
        } else if (ne === "instanceMatrix") {
          const ae = n.get(O.instanceMatrix);
          if (ae === void 0)
            continue;
          const ve = ae.buffer, me = ae.type;
          b(re + 0, 1), b(re + 1, 1), b(re + 2, 1), b(re + 3, 1), t.bindBuffer(34962, ve), t.vertexAttribPointer(re + 0, 4, me, !1, 64, 0), t.vertexAttribPointer(re + 1, 4, me, !1, 64, 16), t.vertexAttribPointer(re + 2, 4, me, !1, 64, 32), t.vertexAttribPointer(re + 3, 4, me, !1, 64, 48);
        } else if (J !== void 0) {
          const ae = J[ne];
          if (ae !== void 0)
            switch (ae.length) {
              case 2:
                t.vertexAttrib2fv(re, ae);
                break;
              case 3:
                t.vertexAttrib3fv(re, ae);
                break;
              case 4:
                t.vertexAttrib4fv(re, ae);
                break;
              default:
                t.vertexAttrib1fv(re, ae);
            }
        }
      }
    }
    w();
  }
  function E() {
    M();
    for (const O in a) {
      const $ = a[O];
      for (const D in $) {
        const z = $[D];
        for (const W in z)
          f(z[W].object), delete z[W];
        delete $[D];
      }
      delete a[O];
    }
  }
  function I(O) {
    if (a[O.id] === void 0)
      return;
    const $ = a[O.id];
    for (const D in $) {
      const z = $[D];
      for (const W in z)
        f(z[W].object), delete z[W];
      delete $[D];
    }
    delete a[O.id];
  }
  function k(O) {
    for (const $ in a) {
      const D = a[$];
      if (D[O.id] === void 0)
        continue;
      const z = D[O.id];
      for (const W in z)
        f(z[W].object), delete z[W];
      delete D[O.id];
    }
  }
  function M() {
    L(), l !== c && (l = c, d(l.object));
  }
  function L() {
    c.geometry = null, c.program = null, c.wireframe = !1;
  }
  return {
    setup: u,
    reset: M,
    resetDefaultState: L,
    dispose: E,
    releaseStatesOfGeometry: I,
    releaseStatesOfProgram: k,
    initAttributes: x,
    enableAttribute: v,
    disableUnusedAttributes: w
  };
}
function hB(t, e, n, s) {
  const i = s.isWebGL2;
  let r;
  function o(l) {
    r = l;
  }
  function a(l, u) {
    t.drawArrays(r, l, u), n.update(u, r, 1);
  }
  function c(l, u, h) {
    if (h === 0)
      return;
    let d, f;
    if (i)
      d = t, f = "drawArraysInstanced";
    else if (d = e.get("ANGLE_instanced_arrays"), f = "drawArraysInstancedANGLE", d === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    d[f](r, l, u, h), n.update(u, r, h);
  }
  this.setMode = o, this.render = a, this.renderInstances = c;
}
function dB(t, e, n) {
  let s;
  function i() {
    if (s !== void 0)
      return s;
    const S = e.get("EXT_texture_filter_anisotropic");
    return S !== null ? s = t.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : s = 0, s;
  }
  function r(S) {
    if (S === "highp") {
      if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      S = "mediump";
    }
    return S === "mediump" && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const o = typeof WebGL2RenderingContext < "u" && t instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && t instanceof WebGL2ComputeRenderingContext;
  let a = n.precision !== void 0 ? n.precision : "highp";
  const c = r(a);
  c !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", c, "instead."), a = c);
  const l = n.logarithmicDepthBuffer === !0, u = t.getParameter(34930), h = t.getParameter(35660), d = t.getParameter(3379), f = t.getParameter(34076), p = t.getParameter(34921), y = t.getParameter(36347), g = t.getParameter(36348), m = t.getParameter(36349), x = h > 0, v = o || !!e.get("OES_texture_float"), b = x && v, w = o ? t.getParameter(36183) : 0;
  return {
    isWebGL2: o,
    getMaxAnisotropy: i,
    getMaxPrecision: r,
    precision: a,
    logarithmicDepthBuffer: l,
    maxTextures: u,
    maxVertexTextures: h,
    maxTextureSize: d,
    maxCubemapSize: f,
    maxAttributes: p,
    maxVertexUniforms: y,
    maxVaryings: g,
    maxFragmentUniforms: m,
    vertexTextures: x,
    floatFragmentTextures: v,
    floatVertexTextures: b,
    maxSamples: w
  };
}
function fB() {
  const t = this;
  let e = null, n = 0, s = !1, i = !1;
  const r = new Fr(), o = new Js(), a = { value: null, needsUpdate: !1 };
  this.uniform = a, this.numPlanes = 0, this.numIntersection = 0, this.init = function(u, h, d) {
    const f = u.length !== 0 || h || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || s;
    return s = h, e = l(u, d, 0), n = u.length, f;
  }, this.beginShadows = function() {
    i = !0, l(null);
  }, this.endShadows = function() {
    i = !1, c();
  }, this.setState = function(u, h, d, f, p, y) {
    if (!s || u === null || u.length === 0 || i && !d)
      i ? l(null) : c();
    else {
      const g = i ? 0 : n, m = g * 4;
      let x = p.clippingState || null;
      a.value = x, x = l(u, f, m, y);
      for (let v = 0; v !== m; ++v)
        x[v] = e[v];
      p.clippingState = x, this.numIntersection = h ? this.numPlanes : 0, this.numPlanes += g;
    }
  };
  function c() {
    a.value !== e && (a.value = e, a.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0;
  }
  function l(u, h, d, f) {
    let p = u !== null ? u.length : 0, y = null;
    if (p !== 0) {
      if (y = a.value, f !== !0 || y === null) {
        const g = d + p * 4, m = h.matrixWorldInverse;
        o.getNormalMatrix(m), (y === null || y.length < g) && (y = new Float32Array(g));
        for (let x = 0, v = d; x !== p; ++x, v += 4)
          r.copy(u[x]).applyMatrix4(m, o), r.normal.toArray(y, v), y[v + 3] = r.constant;
      }
      a.value = y, a.needsUpdate = !0;
    }
    return t.numPlanes = p, t.numIntersection = 0, y;
  }
}
function pB(t) {
  const e = {};
  return {
    has: function(n) {
      if (e[n] !== void 0)
        return e[n];
      let s;
      switch (n) {
        case "WEBGL_depth_texture":
          s = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          s = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          s = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          s = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          s = t.getExtension(n);
      }
      return e[n] = s, !!s;
    },
    get: function(n) {
      return this.has(n) || console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n];
    }
  };
}
function mB(t, e, n, s) {
  const i = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  function o(h) {
    const d = h.target, f = i.get(d);
    f.index !== null && e.remove(f.index);
    for (const y in f.attributes)
      e.remove(f.attributes[y]);
    d.removeEventListener("dispose", o), i.delete(d);
    const p = r.get(f);
    p && (e.remove(p), r.delete(f)), s.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, n.memory.geometries--;
  }
  function a(h, d) {
    let f = i.get(d);
    return f || (d.addEventListener("dispose", o), d.isBufferGeometry ? f = d : d.isGeometry && (d._bufferGeometry === void 0 && (d._bufferGeometry = new et().setFromObject(h)), f = d._bufferGeometry), i.set(d, f), n.memory.geometries++, f);
  }
  function c(h) {
    const d = h.attributes;
    for (const p in d)
      e.update(d[p], 34962);
    const f = h.morphAttributes;
    for (const p in f) {
      const y = f[p];
      for (let g = 0, m = y.length; g < m; g++)
        e.update(y[g], 34962);
    }
  }
  function l(h) {
    const d = [], f = h.index, p = h.attributes.position;
    let y = 0;
    if (f !== null) {
      const x = f.array;
      y = f.version;
      for (let v = 0, b = x.length; v < b; v += 3) {
        const w = x[v + 0], S = x[v + 1], _ = x[v + 2];
        d.push(w, S, S, _, _, w);
      }
    } else {
      const x = p.array;
      y = p.version;
      for (let v = 0, b = x.length / 3 - 1; v < b; v += 3) {
        const w = v + 0, S = v + 1, _ = v + 2;
        d.push(w, S, S, _, _, w);
      }
    }
    const g = new (VE(d) > 65535 ? Md : Ad)(d, 1);
    g.version = y;
    const m = r.get(h);
    m && e.remove(m), r.set(h, g);
  }
  function u(h) {
    const d = r.get(h);
    if (d) {
      const f = h.index;
      f !== null && d.version < f.version && l(h);
    } else
      l(h);
    return r.get(h);
  }
  return {
    get: a,
    update: c,
    getWireframeAttribute: u
  };
}
function gB(t, e, n, s) {
  const i = s.isWebGL2;
  let r;
  function o(d) {
    r = d;
  }
  let a, c;
  function l(d) {
    a = d.type, c = d.bytesPerElement;
  }
  function u(d, f) {
    t.drawElements(r, f, a, d * c), n.update(f, r, 1);
  }
  function h(d, f, p) {
    if (p === 0)
      return;
    let y, g;
    if (i)
      y = t, g = "drawElementsInstanced";
    else if (y = e.get("ANGLE_instanced_arrays"), g = "drawElementsInstancedANGLE", y === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    y[g](r, f, a, d * c, p), n.update(f, r, p);
  }
  this.setMode = o, this.setIndex = l, this.render = u, this.renderInstances = h;
}
function yB(t) {
  const e = {
    geometries: 0,
    textures: 0
  }, n = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function s(r, o, a) {
    switch (n.calls++, o) {
      case 4:
        n.triangles += a * (r / 3);
        break;
      case 1:
        n.lines += a * (r / 2);
        break;
      case 3:
        n.lines += a * (r - 1);
        break;
      case 2:
        n.lines += a * r;
        break;
      case 0:
        n.points += a * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    n.frame++, n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0;
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: i,
    update: s
  };
}
function xB(t, e) {
  return t[0] - e[0];
}
function bB(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}
function vB(t) {
  const e = {}, n = new Float32Array(8), s = [];
  for (let r = 0; r < 8; r++)
    s[r] = [r, 0];
  function i(r, o, a, c) {
    const l = r.morphTargetInfluences, u = l === void 0 ? 0 : l.length;
    let h = e[o.id];
    if (h === void 0) {
      h = [];
      for (let g = 0; g < u; g++)
        h[g] = [g, 0];
      e[o.id] = h;
    }
    for (let g = 0; g < u; g++) {
      const m = h[g];
      m[0] = g, m[1] = l[g];
    }
    h.sort(bB);
    for (let g = 0; g < 8; g++)
      g < u && h[g][1] ? (s[g][0] = h[g][0], s[g][1] = h[g][1]) : (s[g][0] = Number.MAX_SAFE_INTEGER, s[g][1] = 0);
    s.sort(xB);
    const d = a.morphTargets && o.morphAttributes.position, f = a.morphNormals && o.morphAttributes.normal;
    let p = 0;
    for (let g = 0; g < 8; g++) {
      const m = s[g], x = m[0], v = m[1];
      x !== Number.MAX_SAFE_INTEGER && v ? (d && o.getAttribute("morphTarget" + g) !== d[x] && o.setAttribute("morphTarget" + g, d[x]), f && o.getAttribute("morphNormal" + g) !== f[x] && o.setAttribute("morphNormal" + g, f[x]), n[g] = v, p += v) : (d && o.getAttribute("morphTarget" + g) !== void 0 && o.deleteAttribute("morphTarget" + g), f && o.getAttribute("morphNormal" + g) !== void 0 && o.deleteAttribute("morphNormal" + g), n[g] = 0);
    }
    const y = o.morphTargetsRelative ? 1 : 1 - p;
    c.getUniforms().setValue(t, "morphTargetBaseInfluence", y), c.getUniforms().setValue(t, "morphTargetInfluences", n);
  }
  return {
    update: i
  };
}
function wB(t, e, n, s) {
  let i = /* @__PURE__ */ new WeakMap();
  function r(a) {
    const c = s.render.frame, l = a.geometry, u = e.get(a, l);
    return i.get(u) !== c && (l.isGeometry && u.updateFromObject(a), e.update(u), i.set(u, c)), a.isInstancedMesh && n.update(a.instanceMatrix, 34962), u;
  }
  function o() {
    i = /* @__PURE__ */ new WeakMap();
  }
  return {
    update: r,
    dispose: o
  };
}
function xa(t, e, n, s, i, r, o, a, c, l) {
  t = t !== void 0 ? t : [], e = e !== void 0 ? e : M1, o = o !== void 0 ? o : xc, dn.call(this, t, e, n, s, i, r, o, a, c, l), this.flipY = !1;
}
xa.prototype = Object.create(dn.prototype);
xa.prototype.constructor = xa;
xa.prototype.isCubeTexture = !0;
Object.defineProperty(xa.prototype, "images", {
  get: function() {
    return this.image;
  },
  set: function(t) {
    this.image = t;
  }
});
function $d(t, e, n, s) {
  dn.call(this, null), this.image = { data: t || null, width: e || 1, height: n || 1, depth: s || 1 }, this.magFilter = ps, this.minFilter = ps, this.wrapR = hi, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0;
}
$d.prototype = Object.create(dn.prototype);
$d.prototype.constructor = $d;
$d.prototype.isDataTexture2DArray = !0;
function Od(t, e, n, s) {
  dn.call(this, null), this.image = { data: t || null, width: e || 1, height: n || 1, depth: s || 1 }, this.magFilter = ps, this.minFilter = ps, this.wrapR = hi, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0;
}
Od.prototype = Object.create(dn.prototype);
Od.prototype.constructor = Od;
Od.prototype.isDataTexture3D = !0;
const WE = new dn(), SB = new $d(), _B = new Od(), HE = new xa(), fC = [], pC = [], mC = new Float32Array(16), gC = new Float32Array(9), yC = new Float32Array(4);
function Ou(t, e, n) {
  const s = t[0];
  if (s <= 0 || s > 0)
    return t;
  let i = e * n, r = fC[i];
  if (r === void 0 && (r = new Float32Array(i), fC[i] = r), e !== 0) {
    s.toArray(r, 0);
    for (let o = 1, a = 0; o !== e; ++o)
      a += n, t[o].toArray(r, a);
  }
  return r;
}
function tr(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0, s = t.length; n < s; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function Di(t, e) {
  for (let n = 0, s = e.length; n < s; n++)
    t[n] = e[n];
}
function jE(t, e) {
  let n = pC[e];
  n === void 0 && (n = new Int32Array(e), pC[e] = n);
  for (let s = 0; s !== e; ++s)
    n[s] = t.allocateTextureUnit();
  return n;
}
function TB(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e);
}
function CB(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (tr(n, e))
      return;
    t.uniform2fv(this.addr, e), Di(n, e);
  }
}
function IB(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
  else {
    if (tr(n, e))
      return;
    t.uniform3fv(this.addr, e), Di(n, e);
  }
}
function EB(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (tr(n, e))
      return;
    t.uniform4fv(this.addr, e), Di(n, e);
  }
}
function NB(t, e) {
  const n = this.cache, s = e.elements;
  if (s === void 0) {
    if (tr(n, e))
      return;
    t.uniformMatrix2fv(this.addr, !1, e), Di(n, e);
  } else {
    if (tr(n, s))
      return;
    yC.set(s), t.uniformMatrix2fv(this.addr, !1, yC), Di(n, s);
  }
}
function kB(t, e) {
  const n = this.cache, s = e.elements;
  if (s === void 0) {
    if (tr(n, e))
      return;
    t.uniformMatrix3fv(this.addr, !1, e), Di(n, e);
  } else {
    if (tr(n, s))
      return;
    gC.set(s), t.uniformMatrix3fv(this.addr, !1, gC), Di(n, s);
  }
}
function AB(t, e) {
  const n = this.cache, s = e.elements;
  if (s === void 0) {
    if (tr(n, e))
      return;
    t.uniformMatrix4fv(this.addr, !1, e), Di(n, e);
  } else {
    if (tr(n, s))
      return;
    mC.set(s), t.uniformMatrix4fv(this.addr, !1, mC), Di(n, s);
  }
}
function MB(t, e, n) {
  const s = this.cache, i = n.allocateTextureUnit();
  s[0] !== i && (t.uniform1i(this.addr, i), s[0] = i), n.safeSetTexture2D(e || WE, i);
}
function RB(t, e, n) {
  const s = this.cache, i = n.allocateTextureUnit();
  s[0] !== i && (t.uniform1i(this.addr, i), s[0] = i), n.setTexture2DArray(e || SB, i);
}
function DB(t, e, n) {
  const s = this.cache, i = n.allocateTextureUnit();
  s[0] !== i && (t.uniform1i(this.addr, i), s[0] = i), n.setTexture3D(e || _B, i);
}
function $B(t, e, n) {
  const s = this.cache, i = n.allocateTextureUnit();
  s[0] !== i && (t.uniform1i(this.addr, i), s[0] = i), n.safeSetTextureCube(e || HE, i);
}
function OB(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e);
}
function LB(t, e) {
  const n = this.cache;
  tr(n, e) || (t.uniform2iv(this.addr, e), Di(n, e));
}
function FB(t, e) {
  const n = this.cache;
  tr(n, e) || (t.uniform3iv(this.addr, e), Di(n, e));
}
function PB(t, e) {
  const n = this.cache;
  tr(n, e) || (t.uniform4iv(this.addr, e), Di(n, e));
}
function BB(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e);
}
function zB(t) {
  switch (t) {
    case 5126:
      return TB;
    case 35664:
      return CB;
    case 35665:
      return IB;
    case 35666:
      return EB;
    case 35674:
      return NB;
    case 35675:
      return kB;
    case 35676:
      return AB;
    case 5124:
    case 35670:
      return OB;
    case 35667:
    case 35671:
      return LB;
    case 35668:
    case 35672:
      return FB;
    case 35669:
    case 35673:
      return PB;
    case 5125:
      return BB;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return MB;
    case 35679:
    case 36299:
    case 36307:
      return DB;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return $B;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return RB;
  }
}
function VB(t, e) {
  t.uniform1fv(this.addr, e);
}
function UB(t, e) {
  t.uniform1iv(this.addr, e);
}
function GB(t, e) {
  t.uniform2iv(this.addr, e);
}
function WB(t, e) {
  t.uniform3iv(this.addr, e);
}
function HB(t, e) {
  t.uniform4iv(this.addr, e);
}
function jB(t, e) {
  const n = Ou(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}
function qB(t, e) {
  const n = Ou(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}
function XB(t, e) {
  const n = Ou(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}
function KB(t, e) {
  const n = Ou(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}
function YB(t, e) {
  const n = Ou(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}
function ZB(t, e) {
  const n = Ou(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}
function JB(t, e, n) {
  const s = e.length, i = jE(n, s);
  t.uniform1iv(this.addr, i);
  for (let r = 0; r !== s; ++r)
    n.safeSetTexture2D(e[r] || WE, i[r]);
}
function QB(t, e, n) {
  const s = e.length, i = jE(n, s);
  t.uniform1iv(this.addr, i);
  for (let r = 0; r !== s; ++r)
    n.safeSetTextureCube(e[r] || HE, i[r]);
}
function ez(t) {
  switch (t) {
    case 5126:
      return VB;
    case 35664:
      return jB;
    case 35665:
      return qB;
    case 35666:
      return XB;
    case 35674:
      return KB;
    case 35675:
      return YB;
    case 35676:
      return ZB;
    case 5124:
    case 35670:
      return UB;
    case 35667:
    case 35671:
      return GB;
    case 35668:
    case 35672:
      return WB;
    case 35669:
    case 35673:
      return HB;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return JB;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return QB;
  }
}
function tz(t, e, n) {
  this.id = t, this.addr = n, this.cache = [], this.setValue = zB(e.type);
}
function qE(t, e, n) {
  this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = ez(e.type);
}
qE.prototype.updateCache = function(t) {
  let e = this.cache;
  t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Di(e, t);
};
function XE(t) {
  this.id = t, this.seq = [], this.map = {};
}
XE.prototype.setValue = function(t, e, n) {
  const s = this.seq;
  for (let i = 0, r = s.length; i !== r; ++i) {
    const o = s[i];
    o.setValue(t, e[o.id], n);
  }
};
const rv = /([\w\d_]+)(\])?(\[|\.)?/g;
function xC(t, e) {
  t.seq.push(e), t.map[e.id] = e;
}
function nz(t, e, n) {
  const s = t.name, i = s.length;
  for (rv.lastIndex = 0; ; ) {
    const r = rv.exec(s), o = rv.lastIndex;
    let a = r[1], c = r[2] === "]", l = r[3];
    if (c && (a = a | 0), l === void 0 || l === "[" && o + 2 === i) {
      xC(n, l === void 0 ? new tz(a, t, e) : new qE(a, t, e));
      break;
    } else {
      let h = n.map[a];
      h === void 0 && (h = new XE(a), xC(n, h)), n = h;
    }
  }
}
function da(t, e) {
  this.seq = [], this.map = {};
  const n = t.getProgramParameter(e, 35718);
  for (let s = 0; s < n; ++s) {
    const i = t.getActiveUniform(e, s), r = t.getUniformLocation(e, i.name);
    nz(i, r, this);
  }
}
da.prototype.setValue = function(t, e, n, s) {
  const i = this.map[e];
  i !== void 0 && i.setValue(t, n, s);
};
da.prototype.setOptional = function(t, e, n) {
  const s = e[n];
  s !== void 0 && this.setValue(t, n, s);
};
da.upload = function(t, e, n, s) {
  for (let i = 0, r = e.length; i !== r; ++i) {
    const o = e[i], a = n[o.id];
    a.needsUpdate !== !1 && o.setValue(t, a.value, s);
  }
};
da.seqWithValue = function(t, e) {
  const n = [];
  for (let s = 0, i = t.length; s !== i; ++s) {
    const r = t[s];
    r.id in e && n.push(r);
  }
  return n;
};
function bC(t, e, n) {
  const s = t.createShader(e);
  return t.shaderSource(s, n), t.compileShader(s), s;
}
let sz = 0;
function iz(t) {
  const e = t.split(`
`);
  for (let n = 0; n < e.length; n++)
    e[n] = n + 1 + ": " + e[n];
  return e.join(`
`);
}
function KE(t) {
  switch (t) {
    case gi:
      return ["Linear", "( value )"];
    case hx:
      return ["sRGB", "( value )"];
    case L1:
      return ["RGBE", "( value )"];
    case LE:
      return ["RGBM", "( value, 7.0 )"];
    case FE:
      return ["RGBM", "( value, 16.0 )"];
    case PE:
      return ["RGBD", "( value, 256.0 )"];
    case O1:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case xF:
      return ["LogLuv", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"];
  }
}
function vC(t, e, n) {
  const s = t.getShaderParameter(e, 35713), i = t.getShaderInfoLog(e).trim();
  if (s && i === "")
    return "";
  const r = t.getShaderSource(e);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + `
` + i + iz(r);
}
function Qh(t, e) {
  const n = KE(e);
  return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }";
}
function rz(t, e) {
  const n = KE(e);
  return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
}
function oz(t, e) {
  let n;
  switch (e) {
    case yL:
      n = "Linear";
      break;
    case xL:
      n = "Reinhard";
      break;
    case bL:
      n = "OptimizedCineon";
      break;
    case vL:
      n = "ACESFilmic";
      break;
    case wL:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";
  }
  return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
}
function az(t) {
  return [
    t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || t.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(hd).join(`
`);
}
function cz(t) {
  const e = [];
  for (const n in t) {
    const s = t[n];
    s !== !1 && e.push("#define " + n + " " + s);
  }
  return e.join(`
`);
}
function lz(t, e) {
  const n = {}, s = t.getProgramParameter(e, 35721);
  for (let i = 0; i < s; i++) {
    const o = t.getActiveAttrib(e, i).name;
    n[o] = t.getAttribLocation(e, o);
  }
  return n;
}
function hd(t) {
  return t !== "";
}
function wC(t, e) {
  return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function SC(t, e) {
  return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const uz = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Xv(t) {
  return t.replace(uz, hz);
}
function hz(t, e) {
  const n = Vt[e];
  if (n === void 0)
    throw new Error("Can not resolve #include <" + e + ">");
  return Xv(n);
}
const dz = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, fz = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
function _C(t) {
  return t.replace(fz, YE).replace(dz, pz);
}
function pz(t, e, n, s) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), YE(t, e, n, s);
}
function YE(t, e, n, s) {
  let i = "";
  for (let r = parseInt(e); r < parseInt(n); r++)
    i += s.replace(/\[ i \]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
  return i;
}
function TC(t) {
  let e = "precision " + t.precision + ` float;
precision ` + t.precision + " int;";
  return t.precision === "highp" ? e += `
#define HIGH_PRECISION` : t.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : t.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function mz(t) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return t.shadowMapType === kE ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === KO ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === ud && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function gz(t) {
  let e = "ENVMAP_TYPE_CUBE";
  if (t.envMap)
    switch (t.envMapMode) {
      case M1:
      case R1:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Df:
      case lx:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
      case DE:
      case D1:
        e = "ENVMAP_TYPE_EQUIREC";
        break;
    }
  return e;
}
function yz(t) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (t.envMap)
    switch (t.envMapMode) {
      case R1:
      case D1:
      case lx:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function xz(t) {
  let e = "ENVMAP_BLENDING_NONE";
  if (t.envMap)
    switch (t.combine) {
      case cx:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case mL:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case gL:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function bz(t, e, n, s) {
  const i = t.getContext(), r = n.defines;
  let o = n.vertexShader, a = n.fragmentShader;
  const c = mz(n), l = gz(n), u = yz(n), h = xz(n), d = t.gammaFactor > 0 ? t.gammaFactor : 1, f = n.isWebGL2 ? "" : az(n), p = cz(r), y = i.createProgram();
  let g, m;
  n.isRawShaderMaterial ? (g = [
    p
  ].filter(hd).join(`
`), g.length > 0 && (g += `
`), m = [
    f,
    p
  ].filter(hd).join(`
`), m.length > 0 && (m += `
`)) : (g = [
    TC(n),
    "#define SHADER_NAME " + n.shaderName,
    p,
    n.instancing ? "#define USE_INSTANCING" : "",
    n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    "#define GAMMA_FACTOR " + d,
    "#define MAX_BONES " + n.maxBones,
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.map ? "#define USE_MAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + u : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.vertexTangents ? "#define USE_TANGENT" : "",
    n.vertexColors ? "#define USE_COLOR" : "",
    n.vertexUvs ? "#define USE_UV" : "",
    n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.skinning ? "#define USE_SKINNING" : "",
    n.useVertexTexture ? "#define BONE_TEXTURE" : "",
    n.morphTargets ? "#define USE_MORPHTARGETS" : "",
    n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    " attribute mat4 instanceMatrix;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#ifdef USE_COLOR",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_MORPHTARGETS",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(hd).join(`
`), m = [
    f,
    TC(n),
    "#define SHADER_NAME " + n.shaderName,
    p,
    n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "",
    // add '.0' if integer
    "#define GAMMA_FACTOR " + d,
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.map ? "#define USE_MAP" : "",
    n.matcap ? "#define USE_MATCAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + l : "",
    n.envMap ? "#define " + u : "",
    n.envMap ? "#define " + h : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.sheen ? "#define USE_SHEEN" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.vertexTangents ? "#define USE_TANGENT" : "",
    n.vertexColors ? "#define USE_COLOR" : "",
    n.vertexUvs ? "#define USE_UV" : "",
    n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    n.gradientMap ? "#define USE_GRADIENTMAP" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    n.toneMapping !== jl ? "#define TONE_MAPPING" : "",
    n.toneMapping !== jl ? Vt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    n.toneMapping !== jl ? oz("toneMapping", n.toneMapping) : "",
    n.dithering ? "#define DITHERING" : "",
    Vt.encodings_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    n.map ? Qh("mapTexelToLinear", n.mapEncoding) : "",
    n.matcap ? Qh("matcapTexelToLinear", n.matcapEncoding) : "",
    n.envMap ? Qh("envMapTexelToLinear", n.envMapEncoding) : "",
    n.emissiveMap ? Qh("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "",
    n.lightMap ? Qh("lightMapTexelToLinear", n.lightMapEncoding) : "",
    rz("linearToOutputTexel", n.outputEncoding),
    n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
    `
`
  ].filter(hd).join(`
`)), o = Xv(o), o = wC(o, n), o = SC(o, n), a = Xv(a), a = wC(a, n), a = SC(a, n), o = _C(o), a = _C(a), n.isWebGL2 && !n.isRawShaderMaterial && (g = [
    `#version 300 es
`,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + g, m = [
    `#version 300 es
`,
    "#define varying in",
    "out highp vec4 pc_fragColor;",
    "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + m);
  const x = g + o, v = m + a, b = bC(i, 35633, x), w = bC(i, 35632, v);
  if (i.attachShader(y, b), i.attachShader(y, w), n.index0AttributeName !== void 0 ? i.bindAttribLocation(y, 0, n.index0AttributeName) : n.morphTargets === !0 && i.bindAttribLocation(y, 0, "position"), i.linkProgram(y), t.debug.checkShaderErrors) {
    const E = i.getProgramInfoLog(y).trim(), I = i.getShaderInfoLog(b).trim(), k = i.getShaderInfoLog(w).trim();
    let M = !0, L = !0;
    if (i.getProgramParameter(y, 35714) === !1) {
      M = !1;
      const O = vC(i, b, "vertex"), $ = vC(i, w, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", i.getError(), "35715", i.getProgramParameter(y, 35715), "gl.getProgramInfoLog", E, O, $);
    } else
      E !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", E) : (I === "" || k === "") && (L = !1);
    L && (this.diagnostics = {
      runnable: M,
      programLog: E,
      vertexShader: {
        log: I,
        prefix: g
      },
      fragmentShader: {
        log: k,
        prefix: m
      }
    });
  }
  i.deleteShader(b), i.deleteShader(w);
  let S;
  this.getUniforms = function() {
    return S === void 0 && (S = new da(i, y)), S;
  };
  let _;
  return this.getAttributes = function() {
    return _ === void 0 && (_ = lz(i, y)), _;
  }, this.destroy = function() {
    s.releaseStatesOfProgram(this), i.deleteProgram(y), this.program = void 0;
  }, this.name = n.shaderName, this.id = sz++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = b, this.fragmentShader = w, this;
}
function vz(t, e, n, s) {
  const i = [], r = n.isWebGL2, o = n.logarithmicDepthBuffer, a = n.floatVertexTextures, c = n.maxVertexUniforms, l = n.vertexTextures;
  let u = n.precision;
  const h = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  }, d = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen",
    "transmissionMap"
  ];
  function f(b) {
    const S = b.skeleton.bones;
    if (a)
      return 1024;
    {
      const E = Math.floor((c - 20) / 4), I = Math.min(E, S.length);
      return I < S.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + S.length + " bones. This GPU supports " + I + "."), 0) : I;
    }
  }
  function p(b) {
    let w;
    return b ? b.isTexture ? w = b.encoding : b.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), w = b.texture.encoding) : w = gi, w;
  }
  function y(b, w, S, _, E, I, k) {
    const M = _.fog, L = b.isMeshStandardMaterial ? _.environment : null, O = b.envMap || L, $ = h[b.type], D = k.isSkinnedMesh ? f(k) : 0;
    b.precision !== null && (u = n.getMaxPrecision(b.precision), u !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", u, "instead."));
    let z, W;
    if ($) {
      const ne = Pr[$];
      z = ne.vertexShader, W = ne.fragmentShader;
    } else
      z = b.vertexShader, W = b.fragmentShader;
    const j = t.getRenderTarget();
    return {
      isWebGL2: r,
      shaderID: $,
      shaderName: b.type,
      vertexShader: z,
      fragmentShader: W,
      defines: b.defines,
      isRawShaderMaterial: b.isRawShaderMaterial,
      isShaderMaterial: b.isShaderMaterial,
      precision: u,
      instancing: k.isInstancedMesh === !0,
      supportsVertexTextures: l,
      outputEncoding: j !== null ? p(j.texture) : t.outputEncoding,
      map: !!b.map,
      mapEncoding: p(b.map),
      matcap: !!b.matcap,
      matcapEncoding: p(b.matcap),
      envMap: !!O,
      envMapMode: O && O.mapping,
      envMapEncoding: p(O),
      envMapCubeUV: !!O && (O.mapping === Df || O.mapping === lx),
      lightMap: !!b.lightMap,
      lightMapEncoding: p(b.lightMap),
      aoMap: !!b.aoMap,
      emissiveMap: !!b.emissiveMap,
      emissiveMapEncoding: p(b.emissiveMap),
      bumpMap: !!b.bumpMap,
      normalMap: !!b.normalMap,
      objectSpaceNormalMap: b.normalMapType === wF,
      tangentSpaceNormalMap: b.normalMapType === Ru,
      clearcoatMap: !!b.clearcoatMap,
      clearcoatRoughnessMap: !!b.clearcoatRoughnessMap,
      clearcoatNormalMap: !!b.clearcoatNormalMap,
      displacementMap: !!b.displacementMap,
      roughnessMap: !!b.roughnessMap,
      metalnessMap: !!b.metalnessMap,
      specularMap: !!b.specularMap,
      alphaMap: !!b.alphaMap,
      gradientMap: !!b.gradientMap,
      sheen: !!b.sheen,
      transmissionMap: !!b.transmissionMap,
      combine: b.combine,
      vertexTangents: b.normalMap && b.vertexTangents,
      vertexColors: b.vertexColors,
      vertexUvs: !!b.map || !!b.bumpMap || !!b.normalMap || !!b.specularMap || !!b.alphaMap || !!b.emissiveMap || !!b.roughnessMap || !!b.metalnessMap || !!b.clearcoatMap || !!b.clearcoatRoughnessMap || !!b.clearcoatNormalMap || !!b.displacementMap || !!b.transmissionMap,
      uvsVertexOnly: !(b.map || b.bumpMap || b.normalMap || b.specularMap || b.alphaMap || b.emissiveMap || b.roughnessMap || b.metalnessMap || b.clearcoatNormalMap || b.transmissionMap) && !!b.displacementMap,
      fog: !!M,
      useFog: b.fog,
      fogExp2: M && M.isFogExp2,
      flatShading: b.flatShading,
      sizeAttenuation: b.sizeAttenuation,
      logarithmicDepthBuffer: o,
      skinning: b.skinning && D > 0,
      maxBones: D,
      useVertexTexture: a,
      morphTargets: b.morphTargets,
      morphNormals: b.morphNormals,
      maxMorphTargets: t.maxMorphTargets,
      maxMorphNormals: t.maxMorphNormals,
      numDirLights: w.directional.length,
      numPointLights: w.point.length,
      numSpotLights: w.spot.length,
      numRectAreaLights: w.rectArea.length,
      numHemiLights: w.hemi.length,
      numDirLightShadows: w.directionalShadowMap.length,
      numPointLightShadows: w.pointShadowMap.length,
      numSpotLightShadows: w.spotShadowMap.length,
      numClippingPlanes: E,
      numClipIntersection: I,
      dithering: b.dithering,
      shadowMapEnabled: t.shadowMap.enabled && S.length > 0,
      shadowMapType: t.shadowMap.type,
      toneMapping: b.toneMapped ? t.toneMapping : jl,
      physicallyCorrectLights: t.physicallyCorrectLights,
      premultipliedAlpha: b.premultipliedAlpha,
      alphaTest: b.alphaTest,
      doubleSided: b.side === ax,
      flipSided: b.side === is,
      depthPacking: b.depthPacking !== void 0 ? b.depthPacking : !1,
      index0AttributeName: b.index0AttributeName,
      extensionDerivatives: b.extensions && b.extensions.derivatives,
      extensionFragDepth: b.extensions && b.extensions.fragDepth,
      extensionDrawBuffers: b.extensions && b.extensions.drawBuffers,
      extensionShaderTextureLOD: b.extensions && b.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: r || e.get("EXT_frag_depth") !== null,
      rendererExtensionDrawBuffers: r || e.get("WEBGL_draw_buffers") !== null,
      rendererExtensionShaderTextureLod: r || e.get("EXT_shader_texture_lod") !== null,
      customProgramCacheKey: b.customProgramCacheKey()
    };
  }
  function g(b) {
    const w = [];
    if (b.shaderID ? w.push(b.shaderID) : (w.push(b.fragmentShader), w.push(b.vertexShader)), b.defines !== void 0)
      for (const S in b.defines)
        w.push(S), w.push(b.defines[S]);
    if (b.isRawShaderMaterial === void 0) {
      for (let S = 0; S < d.length; S++)
        w.push(b[d[S]]);
      w.push(t.outputEncoding), w.push(t.gammaFactor);
    }
    return w.push(b.customProgramCacheKey), w.join();
  }
  function m(b) {
    const w = h[b.type];
    let S;
    if (w) {
      const _ = Pr[w];
      S = PF.clone(_.uniforms);
    } else
      S = b.uniforms;
    return S;
  }
  function x(b, w) {
    let S;
    for (let _ = 0, E = i.length; _ < E; _++) {
      const I = i[_];
      if (I.cacheKey === w) {
        S = I, ++S.usedTimes;
        break;
      }
    }
    return S === void 0 && (S = new bz(t, w, b, s), i.push(S)), S;
  }
  function v(b) {
    if (--b.usedTimes === 0) {
      const w = i.indexOf(b);
      i[w] = i[i.length - 1], i.pop(), b.destroy();
    }
  }
  return {
    getParameters: y,
    getProgramCacheKey: g,
    getUniforms: m,
    acquireProgram: x,
    releaseProgram: v,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: i
  };
}
function wz() {
  let t = /* @__PURE__ */ new WeakMap();
  function e(r) {
    let o = t.get(r);
    return o === void 0 && (o = {}, t.set(r, o)), o;
  }
  function n(r) {
    t.delete(r);
  }
  function s(r, o, a) {
    t.get(r)[o] = a;
  }
  function i() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: n,
    update: s,
    dispose: i
  };
}
function Sz(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
}
function _z(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
}
function CC(t) {
  const e = [];
  let n = 0;
  const s = [], i = [], r = { id: -1 };
  function o() {
    n = 0, s.length = 0, i.length = 0;
  }
  function a(d, f, p, y, g, m) {
    let x = e[n];
    const v = t.get(p);
    return x === void 0 ? (x = {
      id: d.id,
      object: d,
      geometry: f,
      material: p,
      program: v.program || r,
      groupOrder: y,
      renderOrder: d.renderOrder,
      z: g,
      group: m
    }, e[n] = x) : (x.id = d.id, x.object = d, x.geometry = f, x.material = p, x.program = v.program || r, x.groupOrder = y, x.renderOrder = d.renderOrder, x.z = g, x.group = m), n++, x;
  }
  function c(d, f, p, y, g, m) {
    const x = a(d, f, p, y, g, m);
    (p.transparent === !0 ? i : s).push(x);
  }
  function l(d, f, p, y, g, m) {
    const x = a(d, f, p, y, g, m);
    (p.transparent === !0 ? i : s).unshift(x);
  }
  function u(d, f) {
    s.length > 1 && s.sort(d || Sz), i.length > 1 && i.sort(f || _z);
  }
  function h() {
    for (let d = n, f = e.length; d < f; d++) {
      const p = e[d];
      if (p.id === null)
        break;
      p.id = null, p.object = null, p.geometry = null, p.material = null, p.program = null, p.group = null;
    }
  }
  return {
    opaque: s,
    transparent: i,
    init: o,
    push: c,
    unshift: l,
    finish: h,
    sort: u
  };
}
function Tz(t) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(r) {
    const o = r.target;
    o.removeEventListener("dispose", n), e.delete(o);
  }
  function s(r, o) {
    const a = e.get(r);
    let c;
    return a === void 0 ? (c = new CC(t), e.set(r, /* @__PURE__ */ new WeakMap()), e.get(r).set(o, c), r.addEventListener("dispose", n)) : (c = a.get(o), c === void 0 && (c = new CC(t), a.set(o, c))), c;
  }
  function i() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: s,
    dispose: i
  };
}
function Cz() {
  const t = {};
  return {
    get: function(e) {
      if (t[e.id] !== void 0)
        return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            direction: new P(),
            color: new st()
          };
          break;
        case "SpotLight":
          n = {
            position: new P(),
            direction: new P(),
            color: new st(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          n = {
            position: new P(),
            color: new st(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          n = {
            direction: new P(),
            skyColor: new st(),
            groundColor: new st()
          };
          break;
        case "RectAreaLight":
          n = {
            color: new st(),
            position: new P(),
            halfWidth: new P(),
            halfHeight: new P()
          };
          break;
      }
      return t[e.id] = n, n;
    }
  };
}
function Iz() {
  const t = {};
  return {
    get: function(e) {
      if (t[e.id] !== void 0)
        return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ce()
          };
          break;
        case "SpotLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ce()
          };
          break;
        case "PointLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ce(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return t[e.id] = n, n;
    }
  };
}
let Ez = 0;
function Nz(t, e) {
  return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
}
function kz() {
  const t = new Cz(), e = Iz(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let a = 0; a < 9; a++)
    n.probe.push(new P());
  const s = new P(), i = new Mt(), r = new Mt();
  function o(a, c, l) {
    let u = 0, h = 0, d = 0;
    for (let _ = 0; _ < 9; _++)
      n.probe[_].set(0, 0, 0);
    let f = 0, p = 0, y = 0, g = 0, m = 0, x = 0, v = 0, b = 0;
    const w = l.matrixWorldInverse;
    a.sort(Nz);
    for (let _ = 0, E = a.length; _ < E; _++) {
      const I = a[_], k = I.color, M = I.intensity, L = I.distance, O = I.shadow && I.shadow.map ? I.shadow.map.texture : null;
      if (I.isAmbientLight)
        u += k.r * M, h += k.g * M, d += k.b * M;
      else if (I.isLightProbe)
        for (let $ = 0; $ < 9; $++)
          n.probe[$].addScaledVector(I.sh.coefficients[$], M);
      else if (I.isDirectionalLight) {
        const $ = t.get(I);
        if ($.color.copy(I.color).multiplyScalar(I.intensity), $.direction.setFromMatrixPosition(I.matrixWorld), s.setFromMatrixPosition(I.target.matrixWorld), $.direction.sub(s), $.direction.transformDirection(w), I.castShadow) {
          const D = I.shadow, z = e.get(I);
          z.shadowBias = D.bias, z.shadowNormalBias = D.normalBias, z.shadowRadius = D.radius, z.shadowMapSize = D.mapSize, n.directionalShadow[f] = z, n.directionalShadowMap[f] = O, n.directionalShadowMatrix[f] = I.shadow.matrix, x++;
        }
        n.directional[f] = $, f++;
      } else if (I.isSpotLight) {
        const $ = t.get(I);
        if ($.position.setFromMatrixPosition(I.matrixWorld), $.position.applyMatrix4(w), $.color.copy(k).multiplyScalar(M), $.distance = L, $.direction.setFromMatrixPosition(I.matrixWorld), s.setFromMatrixPosition(I.target.matrixWorld), $.direction.sub(s), $.direction.transformDirection(w), $.coneCos = Math.cos(I.angle), $.penumbraCos = Math.cos(I.angle * (1 - I.penumbra)), $.decay = I.decay, I.castShadow) {
          const D = I.shadow, z = e.get(I);
          z.shadowBias = D.bias, z.shadowNormalBias = D.normalBias, z.shadowRadius = D.radius, z.shadowMapSize = D.mapSize, n.spotShadow[y] = z, n.spotShadowMap[y] = O, n.spotShadowMatrix[y] = I.shadow.matrix, b++;
        }
        n.spot[y] = $, y++;
      } else if (I.isRectAreaLight) {
        const $ = t.get(I);
        $.color.copy(k).multiplyScalar(M), $.position.setFromMatrixPosition(I.matrixWorld), $.position.applyMatrix4(w), r.identity(), i.copy(I.matrixWorld), i.premultiply(w), r.extractRotation(i), $.halfWidth.set(I.width * 0.5, 0, 0), $.halfHeight.set(0, I.height * 0.5, 0), $.halfWidth.applyMatrix4(r), $.halfHeight.applyMatrix4(r), n.rectArea[g] = $, g++;
      } else if (I.isPointLight) {
        const $ = t.get(I);
        if ($.position.setFromMatrixPosition(I.matrixWorld), $.position.applyMatrix4(w), $.color.copy(I.color).multiplyScalar(I.intensity), $.distance = I.distance, $.decay = I.decay, I.castShadow) {
          const D = I.shadow, z = e.get(I);
          z.shadowBias = D.bias, z.shadowNormalBias = D.normalBias, z.shadowRadius = D.radius, z.shadowMapSize = D.mapSize, z.shadowCameraNear = D.camera.near, z.shadowCameraFar = D.camera.far, n.pointShadow[p] = z, n.pointShadowMap[p] = O, n.pointShadowMatrix[p] = I.shadow.matrix, v++;
        }
        n.point[p] = $, p++;
      } else if (I.isHemisphereLight) {
        const $ = t.get(I);
        $.direction.setFromMatrixPosition(I.matrixWorld), $.direction.transformDirection(w), $.direction.normalize(), $.skyColor.copy(I.color).multiplyScalar(M), $.groundColor.copy(I.groundColor).multiplyScalar(M), n.hemi[m] = $, m++;
      }
    }
    n.ambient[0] = u, n.ambient[1] = h, n.ambient[2] = d;
    const S = n.hash;
    (S.directionalLength !== f || S.pointLength !== p || S.spotLength !== y || S.rectAreaLength !== g || S.hemiLength !== m || S.numDirectionalShadows !== x || S.numPointShadows !== v || S.numSpotShadows !== b) && (n.directional.length = f, n.spot.length = y, n.rectArea.length = g, n.point.length = p, n.hemi.length = m, n.directionalShadow.length = x, n.directionalShadowMap.length = x, n.pointShadow.length = v, n.pointShadowMap.length = v, n.spotShadow.length = b, n.spotShadowMap.length = b, n.directionalShadowMatrix.length = x, n.pointShadowMatrix.length = v, n.spotShadowMatrix.length = b, S.directionalLength = f, S.pointLength = p, S.spotLength = y, S.rectAreaLength = g, S.hemiLength = m, S.numDirectionalShadows = x, S.numPointShadows = v, S.numSpotShadows = b, n.version = Ez++);
  }
  return {
    setup: o,
    state: n
  };
}
function IC() {
  const t = new kz(), e = [], n = [];
  function s() {
    e.length = 0, n.length = 0;
  }
  function i(c) {
    e.push(c);
  }
  function r(c) {
    n.push(c);
  }
  function o(c) {
    t.setup(e, n, c);
  }
  return {
    init: s,
    state: {
      lightsArray: e,
      shadowsArray: n,
      lights: t
    },
    setupLights: o,
    pushLight: i,
    pushShadow: r
  };
}
function Az() {
  let t = /* @__PURE__ */ new WeakMap();
  function e(i) {
    const r = i.target;
    r.removeEventListener("dispose", e), t.delete(r);
  }
  function n(i, r) {
    let o;
    return t.has(i) === !1 ? (o = new IC(), t.set(i, /* @__PURE__ */ new WeakMap()), t.get(i).set(r, o), i.addEventListener("dispose", e)) : t.get(i).has(r) === !1 ? (o = new IC(), t.get(i).set(r, o)) : o = t.get(i).get(r), o;
  }
  function s() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: s
  };
}
function kc(t) {
  yt.call(this), this.type = "MeshDepthMaterial", this.depthPacking = bF, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t);
}
kc.prototype = Object.create(yt.prototype);
kc.prototype.constructor = kc;
kc.prototype.isMeshDepthMaterial = !0;
kc.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
};
function Ac(t) {
  yt.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new P(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t);
}
Ac.prototype = Object.create(yt.prototype);
Ac.prototype.constructor = Ac;
Ac.prototype.isMeshDistanceMaterial = !0;
Ac.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
};
var Mz = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
  float mean = 0.0;
  float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );
  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
    #ifdef HORIZONAL_PASS
      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
      mean += distribution.x;
      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
    #else
      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );
      mean += depth;
      squared_mean += depth * depth;
    #endif
  }
  mean = mean * HALF_SAMPLE_RATE;
  squared_mean = squared_mean * HALF_SAMPLE_RATE;
  float std_dev = sqrt( squared_mean - mean * mean );
  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`, Rz = `void main() {
	gl_Position = vec4( position, 1.0 );
}`;
function ZE(t, e, n) {
  let s = new Of();
  const i = new Ce(), r = new Ce(), o = new en(), a = [], c = [], l = {}, u = { 0: is, 1: Rf, 2: ax }, h = new yi({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Ce() },
      radius: { value: 4 }
    },
    vertexShader: Rz,
    fragmentShader: Mz
  }), d = h.clone();
  d.defines.HORIZONAL_PASS = 1;
  const f = new et();
  f.setAttribute(
    "position",
    new ut(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const p = new cn(f, h), y = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = kE, this.render = function(w, S, _) {
    if (y.enabled === !1 || y.autoUpdate === !1 && y.needsUpdate === !1 || w.length === 0)
      return;
    const E = t.getRenderTarget(), I = t.getActiveCubeFace(), k = t.getActiveMipmapLevel(), M = t.state;
    M.setBlending(ha), M.buffers.color.setClear(1, 1, 1, 1), M.buffers.depth.setTest(!0), M.setScissorTest(!1);
    for (let L = 0, O = w.length; L < O; L++) {
      const $ = w[L], D = $.shadow;
      if (D.autoUpdate === !1 && D.needsUpdate === !1)
        continue;
      if (D === void 0) {
        console.warn("THREE.WebGLShadowMap:", $, "has no shadow.");
        continue;
      }
      i.copy(D.mapSize);
      const z = D.getFrameExtents();
      if (i.multiply(z), r.copy(D.mapSize), (i.x > n || i.y > n) && (i.x > n && (r.x = Math.floor(n / z.x), i.x = r.x * z.x, D.mapSize.x = r.x), i.y > n && (r.y = Math.floor(n / z.y), i.y = r.y * z.y, D.mapSize.y = r.y)), D.map === null && !D.isPointLightShadow && this.type === ud) {
        const j = { minFilter: Vs, magFilter: Vs, format: Zi, stencilBuffer: !1 };
        D.map = new Ji(i.x, i.y, j), D.map.texture.name = $.name + ".shadowMap", D.mapPass = new Ji(i.x, i.y, j), D.camera.updateProjectionMatrix();
      }
      if (D.map === null) {
        const j = { minFilter: ps, magFilter: ps, format: Zi, stencilBuffer: !1 };
        D.map = new Ji(i.x, i.y, j), D.map.texture.name = $.name + ".shadowMap", D.camera.updateProjectionMatrix();
      }
      t.setRenderTarget(D.map), t.clear();
      const W = D.getViewportCount();
      for (let j = 0; j < W; j++) {
        const J = D.getViewport(j);
        o.set(
          r.x * J.x,
          r.y * J.y,
          r.x * J.z,
          r.y * J.w
        ), M.viewport(o), D.updateMatrices($, j), s = D.getFrustum(), b(S, _, D.camera, $, this.type);
      }
      !D.isPointLightShadow && this.type === ud && g(D, _), D.needsUpdate = !1;
    }
    y.needsUpdate = !1, t.setRenderTarget(E, I, k);
  };
  function g(w, S) {
    const _ = e.update(p);
    h.uniforms.shadow_pass.value = w.map.texture, h.uniforms.resolution.value = w.mapSize, h.uniforms.radius.value = w.radius, t.setRenderTarget(w.mapPass), t.clear(), t.renderBufferDirect(S, null, _, h, p, null), d.uniforms.shadow_pass.value = w.mapPass.texture, d.uniforms.resolution.value = w.mapSize, d.uniforms.radius.value = w.radius, t.setRenderTarget(w.map), t.clear(), t.renderBufferDirect(S, null, _, d, p, null);
  }
  function m(w, S, _) {
    const E = w << 0 | S << 1 | _ << 2;
    let I = a[E];
    return I === void 0 && (I = new kc({
      depthPacking: vF,
      morphTargets: w,
      skinning: S
    }), a[E] = I), I;
  }
  function x(w, S, _) {
    const E = w << 0 | S << 1 | _ << 2;
    let I = c[E];
    return I === void 0 && (I = new Ac({
      morphTargets: w,
      skinning: S
    }), c[E] = I), I;
  }
  function v(w, S, _, E, I, k, M) {
    let L = null, O = m, $ = w.customDepthMaterial;
    if (E.isPointLight === !0 && (O = x, $ = w.customDistanceMaterial), $ === void 0) {
      let D = !1;
      _.morphTargets === !0 && (D = S.morphAttributes && S.morphAttributes.position && S.morphAttributes.position.length > 0);
      let z = !1;
      w.isSkinnedMesh === !0 && (_.skinning === !0 ? z = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", w));
      const W = w.isInstancedMesh === !0;
      L = O(D, z, W);
    } else
      L = $;
    if (t.localClippingEnabled && _.clipShadows === !0 && _.clippingPlanes.length !== 0) {
      const D = L.uuid, z = _.uuid;
      let W = l[D];
      W === void 0 && (W = {}, l[D] = W);
      let j = W[z];
      j === void 0 && (j = L.clone(), W[z] = j), L = j;
    }
    return L.visible = _.visible, L.wireframe = _.wireframe, M === ud ? L.side = _.shadowSide !== null ? _.shadowSide : _.side : L.side = _.shadowSide !== null ? _.shadowSide : u[_.side], L.clipShadows = _.clipShadows, L.clippingPlanes = _.clippingPlanes, L.clipIntersection = _.clipIntersection, L.wireframeLinewidth = _.wireframeLinewidth, L.linewidth = _.linewidth, E.isPointLight === !0 && L.isMeshDistanceMaterial === !0 && (L.referencePosition.setFromMatrixPosition(E.matrixWorld), L.nearDistance = I, L.farDistance = k), L;
  }
  function b(w, S, _, E, I) {
    if (w.visible === !1)
      return;
    if (w.layers.test(S.layers) && (w.isMesh || w.isLine || w.isPoints) && (w.castShadow || w.receiveShadow && I === ud) && (!w.frustumCulled || s.intersectsObject(w))) {
      w.modelViewMatrix.multiplyMatrices(_.matrixWorldInverse, w.matrixWorld);
      const L = e.update(w), O = w.material;
      if (Array.isArray(O)) {
        const $ = L.groups;
        for (let D = 0, z = $.length; D < z; D++) {
          const W = $[D], j = O[W.materialIndex];
          if (j && j.visible) {
            const J = v(w, L, j, E, _.near, _.far, I);
            t.renderBufferDirect(_, null, L, J, w, W);
          }
        }
      } else if (O.visible) {
        const $ = v(w, L, O, E, _.near, _.far, I);
        t.renderBufferDirect(_, null, L, $, w, null);
      }
    }
    const M = w.children;
    for (let L = 0, O = M.length; L < O; L++)
      b(M[L], S, _, E, I);
  }
}
function Dz(t, e, n) {
  const s = n.isWebGL2;
  function i() {
    let ee = !1;
    const De = new en();
    let Fe = null;
    const tt = new en(0, 0, 0, 0);
    return {
      setMask: function(X) {
        Fe !== X && !ee && (t.colorMask(X, X, X, X), Fe = X);
      },
      setLocked: function(X) {
        ee = X;
      },
      setClear: function(X, pe, Oe, Ie, Be) {
        Be === !0 && (X *= Ie, pe *= Ie, Oe *= Ie), De.set(X, pe, Oe, Ie), tt.equals(De) === !1 && (t.clearColor(X, pe, Oe, Ie), tt.copy(De));
      },
      reset: function() {
        ee = !1, Fe = null, tt.set(-1, 0, 0, 0);
      }
    };
  }
  function r() {
    let ee = !1, De = null, Fe = null, tt = null;
    return {
      setTest: function(X) {
        X ? ne(2929) : re(2929);
      },
      setMask: function(X) {
        De !== X && !ee && (t.depthMask(X), De = X);
      },
      setFunc: function(X) {
        if (Fe !== X) {
          if (X)
            switch (X) {
              case cL:
                t.depthFunc(512);
                break;
              case lL:
                t.depthFunc(519);
                break;
              case uL:
                t.depthFunc(513);
                break;
              case Bv:
                t.depthFunc(515);
                break;
              case hL:
                t.depthFunc(514);
                break;
              case dL:
                t.depthFunc(518);
                break;
              case fL:
                t.depthFunc(516);
                break;
              case pL:
                t.depthFunc(517);
                break;
              default:
                t.depthFunc(515);
            }
          else
            t.depthFunc(515);
          Fe = X;
        }
      },
      setLocked: function(X) {
        ee = X;
      },
      setClear: function(X) {
        tt !== X && (t.clearDepth(X), tt = X);
      },
      reset: function() {
        ee = !1, De = null, Fe = null, tt = null;
      }
    };
  }
  function o() {
    let ee = !1, De = null, Fe = null, tt = null, X = null, pe = null, Oe = null, Ie = null, Be = null;
    return {
      setTest: function(Ue) {
        ee || (Ue ? ne(2960) : re(2960));
      },
      setMask: function(Ue) {
        De !== Ue && !ee && (t.stencilMask(Ue), De = Ue);
      },
      setFunc: function(Ue, Ke, wt) {
        (Fe !== Ue || tt !== Ke || X !== wt) && (t.stencilFunc(Ue, Ke, wt), Fe = Ue, tt = Ke, X = wt);
      },
      setOp: function(Ue, Ke, wt) {
        (pe !== Ue || Oe !== Ke || Ie !== wt) && (t.stencilOp(Ue, Ke, wt), pe = Ue, Oe = Ke, Ie = wt);
      },
      setLocked: function(Ue) {
        ee = Ue;
      },
      setClear: function(Ue) {
        Be !== Ue && (t.clearStencil(Ue), Be = Ue);
      },
      reset: function() {
        ee = !1, De = null, Fe = null, tt = null, X = null, pe = null, Oe = null, Ie = null, Be = null;
      }
    };
  }
  const a = new i(), c = new r(), l = new o();
  let u = {}, h = null, d = null, f = null, p = null, y = null, g = null, m = null, x = null, v = null, b = !1, w = null, S = null, _ = null, E = null, I = null;
  const k = t.getParameter(35661);
  let M = !1, L = 0;
  const O = t.getParameter(7938);
  O.indexOf("WebGL") !== -1 ? (L = parseFloat(/^WebGL\ ([0-9])/.exec(O)[1]), M = L >= 1) : O.indexOf("OpenGL ES") !== -1 && (L = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(O)[1]), M = L >= 2);
  let $ = null, D = {};
  const z = new en(), W = new en();
  function j(ee, De, Fe) {
    const tt = new Uint8Array(4), X = t.createTexture();
    t.bindTexture(ee, X), t.texParameteri(ee, 10241, 9728), t.texParameteri(ee, 10240, 9728);
    for (let pe = 0; pe < Fe; pe++)
      t.texImage2D(De + pe, 0, 6408, 1, 1, 0, 6408, 5121, tt);
    return X;
  }
  const J = {};
  J[3553] = j(3553, 3553, 1), J[34067] = j(34067, 34069, 6), a.setClear(0, 0, 0, 1), c.setClear(1), l.setClear(0), ne(2929), c.setFunc(Bv), $e(!1), _e(VT), ne(2884), me(ha);
  function ne(ee) {
    u[ee] !== !0 && (t.enable(ee), u[ee] = !0);
  }
  function re(ee) {
    u[ee] !== !1 && (t.disable(ee), u[ee] = !1);
  }
  function fe(ee) {
    return h !== ee ? (t.useProgram(ee), h = ee, !0) : !1;
  }
  const ae = {
    [Ll]: 32774,
    [ZO]: 32778,
    [JO]: 32779
  };
  if (s)
    ae[HT] = 32775, ae[jT] = 32776;
  else {
    const ee = e.get("EXT_blend_minmax");
    ee !== null && (ae[HT] = ee.MIN_EXT, ae[jT] = ee.MAX_EXT);
  }
  const ve = {
    [QO]: 0,
    [eL]: 1,
    [tL]: 768,
    [ME]: 770,
    [aL]: 776,
    [rL]: 774,
    [sL]: 772,
    [nL]: 769,
    [RE]: 771,
    [oL]: 775,
    [iL]: 773
  };
  function me(ee, De, Fe, tt, X, pe, Oe, Ie) {
    if (ee === ha) {
      d && (re(3042), d = !1);
      return;
    }
    if (d || (ne(3042), d = !0), ee !== YO) {
      if (ee !== f || Ie !== b) {
        if ((p !== Ll || m !== Ll) && (t.blendEquation(32774), p = Ll, m = Ll), Ie)
          switch (ee) {
            case vd:
              t.blendFuncSeparate(1, 771, 1, 771);
              break;
            case UT:
              t.blendFunc(1, 1);
              break;
            case GT:
              t.blendFuncSeparate(0, 0, 769, 771);
              break;
            case WT:
              t.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ee);
              break;
          }
        else
          switch (ee) {
            case vd:
              t.blendFuncSeparate(770, 771, 1, 771);
              break;
            case UT:
              t.blendFunc(770, 1);
              break;
            case GT:
              t.blendFunc(0, 769);
              break;
            case WT:
              t.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ee);
              break;
          }
        y = null, g = null, x = null, v = null, f = ee, b = Ie;
      }
      return;
    }
    X = X || De, pe = pe || Fe, Oe = Oe || tt, (De !== p || X !== m) && (t.blendEquationSeparate(ae[De], ae[X]), p = De, m = X), (Fe !== y || tt !== g || pe !== x || Oe !== v) && (t.blendFuncSeparate(ve[Fe], ve[tt], ve[pe], ve[Oe]), y = Fe, g = tt, x = pe, v = Oe), f = ee, b = null;
  }
  function te(ee, De) {
    ee.side === ax ? re(2884) : ne(2884);
    let Fe = ee.side === is;
    De && (Fe = !Fe), $e(Fe), ee.blending === vd && ee.transparent === !1 ? me(ha) : me(ee.blending, ee.blendEquation, ee.blendSrc, ee.blendDst, ee.blendEquationAlpha, ee.blendSrcAlpha, ee.blendDstAlpha, ee.premultipliedAlpha), c.setFunc(ee.depthFunc), c.setTest(ee.depthTest), c.setMask(ee.depthWrite), a.setMask(ee.colorWrite);
    const tt = ee.stencilWrite;
    l.setTest(tt), tt && (l.setMask(ee.stencilWriteMask), l.setFunc(ee.stencilFunc, ee.stencilRef, ee.stencilFuncMask), l.setOp(ee.stencilFail, ee.stencilZFail, ee.stencilZPass)), Re(ee.polygonOffset, ee.polygonOffsetFactor, ee.polygonOffsetUnits);
  }
  function $e(ee) {
    w !== ee && (ee ? t.frontFace(2304) : t.frontFace(2305), w = ee);
  }
  function _e(ee) {
    ee !== qO ? (ne(2884), ee !== S && (ee === VT ? t.cullFace(1029) : ee === XO ? t.cullFace(1028) : t.cullFace(1032))) : re(2884), S = ee;
  }
  function ke(ee) {
    ee !== _ && (M && t.lineWidth(ee), _ = ee);
  }
  function Re(ee, De, Fe) {
    ee ? (ne(32823), (E !== De || I !== Fe) && (t.polygonOffset(De, Fe), E = De, I = Fe)) : re(32823);
  }
  function ce(ee) {
    ee ? ne(3089) : re(3089);
  }
  function xe(ee) {
    ee === void 0 && (ee = 33984 + k - 1), $ !== ee && (t.activeTexture(ee), $ = ee);
  }
  function we(ee, De) {
    $ === null && xe();
    let Fe = D[$];
    Fe === void 0 && (Fe = { type: void 0, texture: void 0 }, D[$] = Fe), (Fe.type !== ee || Fe.texture !== De) && (t.bindTexture(ee, De || J[ee]), Fe.type = ee, Fe.texture = De);
  }
  function Pe() {
    const ee = D[$];
    ee !== void 0 && ee.type !== void 0 && (t.bindTexture(ee.type, null), ee.type = void 0, ee.texture = void 0);
  }
  function Me() {
    try {
      t.compressedTexImage2D.apply(t, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Ge() {
    try {
      t.texImage2D.apply(t, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function F() {
    try {
      t.texImage3D.apply(t, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function V(ee) {
    z.equals(ee) === !1 && (t.scissor(ee.x, ee.y, ee.z, ee.w), z.copy(ee));
  }
  function Ae(ee) {
    W.equals(ee) === !1 && (t.viewport(ee.x, ee.y, ee.z, ee.w), W.copy(ee));
  }
  function ge() {
    u = {}, $ = null, D = {}, h = null, f = null, w = null, S = null, a.reset(), c.reset(), l.reset();
  }
  return {
    buffers: {
      color: a,
      depth: c,
      stencil: l
    },
    enable: ne,
    disable: re,
    useProgram: fe,
    setBlending: me,
    setMaterial: te,
    setFlipSided: $e,
    setCullFace: _e,
    setLineWidth: ke,
    setPolygonOffset: Re,
    setScissorTest: ce,
    activeTexture: xe,
    bindTexture: we,
    unbindTexture: Pe,
    compressedTexImage2D: Me,
    texImage2D: Ge,
    texImage3D: F,
    scissor: V,
    viewport: Ae,
    reset: ge
  };
}
function $z(t, e, n, s, i, r, o) {
  const a = i.isWebGL2, c = i.maxTextures, l = i.maxCubemapSize, u = i.maxTextureSize, h = i.maxSamples, d = /* @__PURE__ */ new WeakMap();
  let f, p = !1;
  try {
    p = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function y(F, V) {
    return p ? new OffscreenCanvas(F, V) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function g(F, V, Ae, ge) {
    let ee = 1;
    if ((F.width > ge || F.height > ge) && (ee = ge / Math.max(F.width, F.height)), ee < 1 || V === !0)
      if (typeof HTMLImageElement < "u" && F instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && F instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && F instanceof ImageBitmap) {
        const De = V ? Et.floorPowerOfTwo : Math.floor, Fe = De(ee * F.width), tt = De(ee * F.height);
        f === void 0 && (f = y(Fe, tt));
        const X = Ae ? y(Fe, tt) : f;
        return X.width = Fe, X.height = tt, X.getContext("2d").drawImage(F, 0, 0, Fe, tt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + F.width + "x" + F.height + ") to (" + Fe + "x" + tt + ")."), X;
      } else
        return "data" in F && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + F.width + "x" + F.height + ")."), F;
    return F;
  }
  function m(F) {
    return Et.isPowerOfTwo(F.width) && Et.isPowerOfTwo(F.height);
  }
  function x(F) {
    return a ? !1 : F.wrapS !== hi || F.wrapT !== hi || F.minFilter !== ps && F.minFilter !== Vs;
  }
  function v(F, V) {
    return F.generateMipmaps && V && F.minFilter !== ps && F.minFilter !== Vs;
  }
  function b(F, V, Ae, ge) {
    t.generateMipmap(F);
    const ee = s.get(V);
    ee.__maxMipLevel = Math.log(Math.max(Ae, ge)) * Math.LOG2E;
  }
  function w(F, V, Ae) {
    if (a === !1)
      return V;
    if (F !== null) {
      if (t[F] !== void 0)
        return t[F];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + F + "'");
    }
    let ge = V;
    return V === 6403 && (Ae === 5126 && (ge = 33326), Ae === 5131 && (ge = 33325), Ae === 5121 && (ge = 33321)), V === 6407 && (Ae === 5126 && (ge = 34837), Ae === 5131 && (ge = 34843), Ae === 5121 && (ge = 32849)), V === 6408 && (Ae === 5126 && (ge = 34836), Ae === 5131 && (ge = 34842), Ae === 5121 && (ge = 32856)), (ge === 33325 || ge === 33326 || ge === 34842 || ge === 34836) && e.get("EXT_color_buffer_float"), ge;
  }
  function S(F) {
    return F === ps || F === zv || F === Vv ? 9728 : 9729;
  }
  function _(F) {
    const V = F.target;
    V.removeEventListener("dispose", _), I(V), V.isVideoTexture && d.delete(V), o.memory.textures--;
  }
  function E(F) {
    const V = F.target;
    V.removeEventListener("dispose", E), k(V), o.memory.textures--;
  }
  function I(F) {
    const V = s.get(F);
    V.__webglInit !== void 0 && (t.deleteTexture(V.__webglTexture), s.remove(F));
  }
  function k(F) {
    const V = s.get(F), Ae = s.get(F.texture);
    if (F) {
      if (Ae.__webglTexture !== void 0 && t.deleteTexture(Ae.__webglTexture), F.depthTexture && F.depthTexture.dispose(), F.isWebGLCubeRenderTarget)
        for (let ge = 0; ge < 6; ge++)
          t.deleteFramebuffer(V.__webglFramebuffer[ge]), V.__webglDepthbuffer && t.deleteRenderbuffer(V.__webglDepthbuffer[ge]);
      else
        t.deleteFramebuffer(V.__webglFramebuffer), V.__webglDepthbuffer && t.deleteRenderbuffer(V.__webglDepthbuffer), V.__webglMultisampledFramebuffer && t.deleteFramebuffer(V.__webglMultisampledFramebuffer), V.__webglColorRenderbuffer && t.deleteRenderbuffer(V.__webglColorRenderbuffer), V.__webglDepthRenderbuffer && t.deleteRenderbuffer(V.__webglDepthRenderbuffer);
      s.remove(F.texture), s.remove(F);
    }
  }
  let M = 0;
  function L() {
    M = 0;
  }
  function O() {
    const F = M;
    return F >= c && console.warn("THREE.WebGLTextures: Trying to use " + F + " texture units while this GPU supports only " + c), M += 1, F;
  }
  function $(F, V) {
    const Ae = s.get(F);
    if (F.isVideoTexture && xe(F), F.version > 0 && Ae.__version !== F.version) {
      const ge = F.image;
      if (ge === void 0)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      else if (ge.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        ae(Ae, F, V);
        return;
      }
    }
    n.activeTexture(33984 + V), n.bindTexture(3553, Ae.__webglTexture);
  }
  function D(F, V) {
    const Ae = s.get(F);
    if (F.version > 0 && Ae.__version !== F.version) {
      ae(Ae, F, V);
      return;
    }
    n.activeTexture(33984 + V), n.bindTexture(35866, Ae.__webglTexture);
  }
  function z(F, V) {
    const Ae = s.get(F);
    if (F.version > 0 && Ae.__version !== F.version) {
      ae(Ae, F, V);
      return;
    }
    n.activeTexture(33984 + V), n.bindTexture(32879, Ae.__webglTexture);
  }
  function W(F, V) {
    if (F.image.length !== 6)
      return;
    const Ae = s.get(F);
    if (F.version > 0 && Ae.__version !== F.version) {
      fe(Ae, F), n.activeTexture(33984 + V), n.bindTexture(34067, Ae.__webglTexture), t.pixelStorei(37440, F.flipY);
      const ge = F && (F.isCompressedTexture || F.image[0].isCompressedTexture), ee = F.image[0] && F.image[0].isDataTexture, De = [];
      for (let Be = 0; Be < 6; Be++)
        !ge && !ee ? De[Be] = g(F.image[Be], !1, !0, l) : De[Be] = ee ? F.image[Be].image : F.image[Be];
      const Fe = De[0], tt = m(Fe) || a, X = r.convert(F.format), pe = r.convert(F.type), Oe = w(F.internalFormat, X, pe);
      re(34067, F, tt);
      let Ie;
      if (ge) {
        for (let Be = 0; Be < 6; Be++) {
          Ie = De[Be].mipmaps;
          for (let Ue = 0; Ue < Ie.length; Ue++) {
            const Ke = Ie[Ue];
            F.format !== Zi && F.format !== xc ? X !== null ? n.compressedTexImage2D(34069 + Be, Ue, Oe, Ke.width, Ke.height, 0, Ke.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + Be, Ue, Oe, Ke.width, Ke.height, 0, X, pe, Ke.data);
          }
        }
        Ae.__maxMipLevel = Ie.length - 1;
      } else {
        Ie = F.mipmaps;
        for (let Be = 0; Be < 6; Be++)
          if (ee) {
            n.texImage2D(34069 + Be, 0, Oe, De[Be].width, De[Be].height, 0, X, pe, De[Be].data);
            for (let Ue = 0; Ue < Ie.length; Ue++) {
              const wt = Ie[Ue].image[Be].image;
              n.texImage2D(34069 + Be, Ue + 1, Oe, wt.width, wt.height, 0, X, pe, wt.data);
            }
          } else {
            n.texImage2D(34069 + Be, 0, Oe, X, pe, De[Be]);
            for (let Ue = 0; Ue < Ie.length; Ue++) {
              const Ke = Ie[Ue];
              n.texImage2D(34069 + Be, Ue + 1, Oe, X, pe, Ke.image[Be]);
            }
          }
        Ae.__maxMipLevel = Ie.length;
      }
      v(F, tt) && b(34067, F, Fe.width, Fe.height), Ae.__version = F.version, F.onUpdate && F.onUpdate(F);
    } else
      n.activeTexture(33984 + V), n.bindTexture(34067, Ae.__webglTexture);
  }
  function j(F, V) {
    n.activeTexture(33984 + V), n.bindTexture(34067, s.get(F).__webglTexture);
  }
  const J = {
    [Gg]: 10497,
    [hi]: 33071,
    [Wg]: 33648
  }, ne = {
    [ps]: 9728,
    [zv]: 9984,
    [Vv]: 9986,
    [Vs]: 9729,
    [$E]: 9985,
    [ux]: 9987
  };
  function re(F, V, Ae) {
    Ae ? (t.texParameteri(F, 10242, J[V.wrapS]), t.texParameteri(F, 10243, J[V.wrapT]), (F === 32879 || F === 35866) && t.texParameteri(F, 32882, J[V.wrapR]), t.texParameteri(F, 10240, ne[V.magFilter]), t.texParameteri(F, 10241, ne[V.minFilter])) : (t.texParameteri(F, 10242, 33071), t.texParameteri(F, 10243, 33071), (F === 32879 || F === 35866) && t.texParameteri(F, 32882, 33071), (V.wrapS !== hi || V.wrapT !== hi) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(F, 10240, S(V.magFilter)), t.texParameteri(F, 10241, S(V.minFilter)), V.minFilter !== ps && V.minFilter !== Vs && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
    const ge = e.get("EXT_texture_filter_anisotropic");
    if (ge) {
      if (V.type === ra && e.get("OES_texture_float_linear") === null || V.type === jg && (a || e.get("OES_texture_half_float_linear")) === null)
        return;
      (V.anisotropy > 1 || s.get(V).__currentAnisotropy) && (t.texParameterf(F, ge.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(V.anisotropy, i.getMaxAnisotropy())), s.get(V).__currentAnisotropy = V.anisotropy);
    }
  }
  function fe(F, V) {
    F.__webglInit === void 0 && (F.__webglInit = !0, V.addEventListener("dispose", _), F.__webglTexture = t.createTexture(), o.memory.textures++);
  }
  function ae(F, V, Ae) {
    let ge = 3553;
    V.isDataTexture2DArray && (ge = 35866), V.isDataTexture3D && (ge = 32879), fe(F, V), n.activeTexture(33984 + Ae), n.bindTexture(ge, F.__webglTexture), t.pixelStorei(37440, V.flipY), t.pixelStorei(37441, V.premultiplyAlpha), t.pixelStorei(3317, V.unpackAlignment);
    const ee = x(V) && m(V.image) === !1, De = g(V.image, ee, !1, u), Fe = m(De) || a, tt = r.convert(V.format);
    let X = r.convert(V.type), pe = w(V.internalFormat, tt, X);
    re(ge, V, Fe);
    let Oe;
    const Ie = V.mipmaps;
    if (V.isDepthTexture)
      pe = 6402, a ? V.type === ra ? pe = 36012 : V.type === Fg ? pe = 33190 : V.type === wd ? pe = 35056 : pe = 33189 : V.type === ra && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), V.format === ql && pe === 6402 && V.type !== Hg && V.type !== Fg && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), V.type = Hg, X = r.convert(V.type)), V.format === Ed && pe === 6402 && (pe = 34041, V.type !== wd && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), V.type = wd, X = r.convert(V.type))), n.texImage2D(3553, 0, pe, De.width, De.height, 0, tt, X, null);
    else if (V.isDataTexture)
      if (Ie.length > 0 && Fe) {
        for (let Be = 0, Ue = Ie.length; Be < Ue; Be++)
          Oe = Ie[Be], n.texImage2D(3553, Be, pe, Oe.width, Oe.height, 0, tt, X, Oe.data);
        V.generateMipmaps = !1, F.__maxMipLevel = Ie.length - 1;
      } else
        n.texImage2D(3553, 0, pe, De.width, De.height, 0, tt, X, De.data), F.__maxMipLevel = 0;
    else if (V.isCompressedTexture) {
      for (let Be = 0, Ue = Ie.length; Be < Ue; Be++)
        Oe = Ie[Be], V.format !== Zi && V.format !== xc ? tt !== null ? n.compressedTexImage2D(3553, Be, pe, Oe.width, Oe.height, 0, Oe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, Be, pe, Oe.width, Oe.height, 0, tt, X, Oe.data);
      F.__maxMipLevel = Ie.length - 1;
    } else if (V.isDataTexture2DArray)
      n.texImage3D(35866, 0, pe, De.width, De.height, De.depth, 0, tt, X, De.data), F.__maxMipLevel = 0;
    else if (V.isDataTexture3D)
      n.texImage3D(32879, 0, pe, De.width, De.height, De.depth, 0, tt, X, De.data), F.__maxMipLevel = 0;
    else if (Ie.length > 0 && Fe) {
      for (let Be = 0, Ue = Ie.length; Be < Ue; Be++)
        Oe = Ie[Be], n.texImage2D(3553, Be, pe, tt, X, Oe);
      V.generateMipmaps = !1, F.__maxMipLevel = Ie.length - 1;
    } else
      n.texImage2D(3553, 0, pe, tt, X, De), F.__maxMipLevel = 0;
    v(V, Fe) && b(ge, V, De.width, De.height), F.__version = V.version, V.onUpdate && V.onUpdate(V);
  }
  function ve(F, V, Ae, ge) {
    const ee = r.convert(V.texture.format), De = r.convert(V.texture.type), Fe = w(V.texture.internalFormat, ee, De);
    n.texImage2D(ge, 0, Fe, V.width, V.height, 0, ee, De, null), t.bindFramebuffer(36160, F), t.framebufferTexture2D(36160, Ae, ge, s.get(V.texture).__webglTexture, 0), t.bindFramebuffer(36160, null);
  }
  function me(F, V, Ae) {
    if (t.bindRenderbuffer(36161, F), V.depthBuffer && !V.stencilBuffer) {
      let ge = 33189;
      if (Ae) {
        const ee = V.depthTexture;
        ee && ee.isDepthTexture && (ee.type === ra ? ge = 36012 : ee.type === Fg && (ge = 33190));
        const De = ce(V);
        t.renderbufferStorageMultisample(36161, De, ge, V.width, V.height);
      } else
        t.renderbufferStorage(36161, ge, V.width, V.height);
      t.framebufferRenderbuffer(36160, 36096, 36161, F);
    } else if (V.depthBuffer && V.stencilBuffer) {
      if (Ae) {
        const ge = ce(V);
        t.renderbufferStorageMultisample(36161, ge, 35056, V.width, V.height);
      } else
        t.renderbufferStorage(36161, 34041, V.width, V.height);
      t.framebufferRenderbuffer(36160, 33306, 36161, F);
    } else {
      const ge = r.convert(V.texture.format), ee = r.convert(V.texture.type), De = w(V.texture.internalFormat, ge, ee);
      if (Ae) {
        const Fe = ce(V);
        t.renderbufferStorageMultisample(36161, Fe, De, V.width, V.height);
      } else
        t.renderbufferStorage(36161, De, V.width, V.height);
    }
    t.bindRenderbuffer(36161, null);
  }
  function te(F, V) {
    if (V && V.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(36160, F), !(V.depthTexture && V.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!s.get(V.depthTexture).__webglTexture || V.depthTexture.image.width !== V.width || V.depthTexture.image.height !== V.height) && (V.depthTexture.image.width = V.width, V.depthTexture.image.height = V.height, V.depthTexture.needsUpdate = !0), $(V.depthTexture, 0);
    const ge = s.get(V.depthTexture).__webglTexture;
    if (V.depthTexture.format === ql)
      t.framebufferTexture2D(36160, 36096, 3553, ge, 0);
    else if (V.depthTexture.format === Ed)
      t.framebufferTexture2D(36160, 33306, 3553, ge, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function $e(F) {
    const V = s.get(F), Ae = F.isWebGLCubeRenderTarget === !0;
    if (F.depthTexture) {
      if (Ae)
        throw new Error("target.depthTexture not supported in Cube render targets");
      te(V.__webglFramebuffer, F);
    } else if (Ae) {
      V.__webglDepthbuffer = [];
      for (let ge = 0; ge < 6; ge++)
        t.bindFramebuffer(36160, V.__webglFramebuffer[ge]), V.__webglDepthbuffer[ge] = t.createRenderbuffer(), me(V.__webglDepthbuffer[ge], F, !1);
    } else
      t.bindFramebuffer(36160, V.__webglFramebuffer), V.__webglDepthbuffer = t.createRenderbuffer(), me(V.__webglDepthbuffer, F, !1);
    t.bindFramebuffer(36160, null);
  }
  function _e(F) {
    const V = s.get(F), Ae = s.get(F.texture);
    F.addEventListener("dispose", E), Ae.__webglTexture = t.createTexture(), o.memory.textures++;
    const ge = F.isWebGLCubeRenderTarget === !0, ee = F.isWebGLMultisampleRenderTarget === !0, De = m(F) || a;
    if (a && F.texture.format === xc && (F.texture.type === ra || F.texture.type === jg) && (F.texture.format = Zi, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), ge) {
      V.__webglFramebuffer = [];
      for (let Fe = 0; Fe < 6; Fe++)
        V.__webglFramebuffer[Fe] = t.createFramebuffer();
    } else if (V.__webglFramebuffer = t.createFramebuffer(), ee)
      if (a) {
        V.__webglMultisampledFramebuffer = t.createFramebuffer(), V.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, V.__webglColorRenderbuffer);
        const Fe = r.convert(F.texture.format), tt = r.convert(F.texture.type), X = w(F.texture.internalFormat, Fe, tt), pe = ce(F);
        t.renderbufferStorageMultisample(36161, pe, X, F.width, F.height), t.bindFramebuffer(36160, V.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, V.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), F.depthBuffer && (V.__webglDepthRenderbuffer = t.createRenderbuffer(), me(V.__webglDepthRenderbuffer, F, !0)), t.bindFramebuffer(36160, null);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    if (ge) {
      n.bindTexture(34067, Ae.__webglTexture), re(34067, F.texture, De);
      for (let Fe = 0; Fe < 6; Fe++)
        ve(V.__webglFramebuffer[Fe], F, 36064, 34069 + Fe);
      v(F.texture, De) && b(34067, F.texture, F.width, F.height), n.bindTexture(34067, null);
    } else
      n.bindTexture(3553, Ae.__webglTexture), re(3553, F.texture, De), ve(V.__webglFramebuffer, F, 36064, 3553), v(F.texture, De) && b(3553, F.texture, F.width, F.height), n.bindTexture(3553, null);
    F.depthBuffer && $e(F);
  }
  function ke(F) {
    const V = F.texture, Ae = m(F) || a;
    if (v(V, Ae)) {
      const ge = F.isWebGLCubeRenderTarget ? 34067 : 3553, ee = s.get(V).__webglTexture;
      n.bindTexture(ge, ee), b(ge, V, F.width, F.height), n.bindTexture(ge, null);
    }
  }
  function Re(F) {
    if (F.isWebGLMultisampleRenderTarget)
      if (a) {
        const V = s.get(F);
        t.bindFramebuffer(36008, V.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, V.__webglFramebuffer);
        const Ae = F.width, ge = F.height;
        let ee = 16384;
        F.depthBuffer && (ee |= 256), F.stencilBuffer && (ee |= 1024), t.blitFramebuffer(0, 0, Ae, ge, 0, 0, Ae, ge, ee, 9728), t.bindFramebuffer(36160, V.__webglMultisampledFramebuffer);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
  }
  function ce(F) {
    return a && F.isWebGLMultisampleRenderTarget ? Math.min(h, F.samples) : 0;
  }
  function xe(F) {
    const V = o.render.frame;
    d.get(F) !== V && (d.set(F, V), F.update());
  }
  let we = !1, Pe = !1;
  function Me(F, V) {
    F && F.isWebGLRenderTarget && (we === !1 && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), we = !0), F = F.texture), $(F, V);
  }
  function Ge(F, V) {
    F && F.isWebGLCubeRenderTarget && (Pe === !1 && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), Pe = !0), F = F.texture), F && F.isCubeTexture || Array.isArray(F.image) && F.image.length === 6 ? W(F, V) : j(F, V);
  }
  this.allocateTextureUnit = O, this.resetTextureUnits = L, this.setTexture2D = $, this.setTexture2DArray = D, this.setTexture3D = z, this.setTextureCube = W, this.setTextureCubeDynamic = j, this.setupRenderTarget = _e, this.updateRenderTargetMipmap = ke, this.updateMultisampleRenderTarget = Re, this.safeSetTexture2D = Me, this.safeSetTextureCube = Ge;
}
function Oz(t, e, n) {
  const s = n.isWebGL2;
  function i(r) {
    let o;
    if (r === $f)
      return 5121;
    if (r === CL)
      return 32819;
    if (r === IL)
      return 32820;
    if (r === EL)
      return 33635;
    if (r === SL)
      return 5120;
    if (r === _L)
      return 5122;
    if (r === Hg)
      return 5123;
    if (r === TL)
      return 5124;
    if (r === Fg)
      return 5125;
    if (r === ra)
      return 5126;
    if (r === jg)
      return s ? 5131 : (o = e.get("OES_texture_half_float"), o !== null ? o.HALF_FLOAT_OES : null);
    if (r === NL)
      return 6406;
    if (r === xc)
      return 6407;
    if (r === Zi)
      return 6408;
    if (r === kL)
      return 6409;
    if (r === AL)
      return 6410;
    if (r === ql)
      return 6402;
    if (r === Ed)
      return 34041;
    if (r === RL)
      return 6403;
    if (r === DL)
      return 36244;
    if (r === $L)
      return 33319;
    if (r === OL)
      return 33320;
    if (r === LL)
      return 36248;
    if (r === FL)
      return 36249;
    if (r === qT || r === XT || r === KT || r === YT)
      if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) {
        if (r === qT)
          return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === XT)
          return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === KT)
          return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === YT)
          return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (r === ZT || r === JT || r === QT || r === eC)
      if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
        if (r === ZT)
          return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === JT)
          return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === QT)
          return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === eC)
          return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (r === PL)
      return o = e.get("WEBGL_compressed_texture_etc1"), o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null;
    if ((r === tC || r === nC) && (o = e.get("WEBGL_compressed_texture_etc"), o !== null)) {
      if (r === tC)
        return o.COMPRESSED_RGB8_ETC2;
      if (r === nC)
        return o.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (r === BL || r === zL || r === VL || r === UL || r === GL || r === WL || r === HL || r === jL || r === qL || r === XL || r === KL || r === YL || r === ZL || r === JL || r === eF || r === tF || r === nF || r === sF || r === iF || r === rF || r === oF || r === aF || r === cF || r === lF || r === uF || r === hF || r === dF || r === fF)
      return o = e.get("WEBGL_compressed_texture_astc"), o !== null ? r : null;
    if (r === QL)
      return o = e.get("EXT_texture_compression_bptc"), o !== null ? r : null;
    if (r === wd)
      return s ? 34042 : (o = e.get("WEBGL_depth_texture"), o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null);
  }
  return { convert: i };
}
function Kv(t) {
  Yn.call(this), this.cameras = t || [];
}
Kv.prototype = Object.assign(Object.create(Yn.prototype), {
  constructor: Kv,
  isArrayCamera: !0
});
function oa() {
  qe.call(this), this.type = "Group";
}
oa.prototype = Object.assign(Object.create(qe.prototype), {
  constructor: oa,
  isGroup: !0
});
function _d() {
  this._targetRay = null, this._grip = null, this._hand = null;
}
Object.assign(_d.prototype, {
  constructor: _d,
  getHandSpace: function() {
    if (this._hand === null && (this._hand = new oa(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = { pinching: !1 }, window.XRHand))
      for (let t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) {
        let e = new oa();
        e.matrixAutoUpdate = !1, e.visible = !1, this._hand.joints.push(e), this._hand.add(e);
      }
    return this._hand;
  },
  getTargetRaySpace: function() {
    return this._targetRay === null && (this._targetRay = new oa(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay;
  },
  getGripSpace: function() {
    return this._grip === null && (this._grip = new oa(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip;
  },
  dispatchEvent: function(t) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
  },
  disconnect: function(t) {
    return this.dispatchEvent({ type: "disconnected", data: t }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  },
  update: function(t, e, n) {
    let s = null, i = null, r = null;
    const o = this._targetRay, a = this._grip, c = this._hand;
    if (t)
      if (t.hand) {
        r = !0;
        for (let l = 0; l <= window.XRHand.LITTLE_PHALANX_TIP; l++)
          if (t.hand[l]) {
            let u = e.getJointPose(t.hand[l], n);
            const h = c.joints[l];
            u !== null && (h.matrix.fromArray(u.transform.matrix), h.matrix.decompose(h.position, h.rotation, h.scale), h.jointRadius = u.radius), h.visible = u !== null;
            const d = c.joints[window.XRHand.INDEX_PHALANX_TIP], f = c.joints[window.XRHand.THUMB_PHALANX_TIP], p = d.position.distanceTo(f.position), y = 0.02, g = 5e-3;
            c.inputState.pinching && p > y + g ? (c.inputState.pinching = !1, this.dispatchEvent({
              type: "pinchend",
              handedness: t.handedness,
              target: this
            })) : !c.inputState.pinching && p <= y - g && (c.inputState.pinching = !0, this.dispatchEvent({
              type: "pinchstart",
              handedness: t.handedness,
              target: this
            }));
          }
      } else
        o !== null && (s = e.getPose(t.targetRaySpace, n), s !== null && (o.matrix.fromArray(s.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale))), a !== null && t.gripSpace && (i = e.getPose(t.gripSpace, n), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale)));
    return o !== null && (o.visible = s !== null), a !== null && (a.visible = i !== null), c !== null && (c.visible = r !== null), this;
  }
});
function JE(t, e) {
  const n = this;
  let s = null, i = 1, r = null, o = "local-floor", a = null;
  const c = [], l = /* @__PURE__ */ new Map(), u = new Yn();
  u.layers.enable(1), u.viewport = new en();
  const h = new Yn();
  h.layers.enable(2), h.viewport = new en();
  const d = [u, h], f = new Kv();
  f.layers.enable(1), f.layers.enable(2);
  let p = null, y = null;
  this.enabled = !1, this.isPresenting = !1, this.getController = function(M) {
    let L = c[M];
    return L === void 0 && (L = new _d(), c[M] = L), L.getTargetRaySpace();
  }, this.getControllerGrip = function(M) {
    let L = c[M];
    return L === void 0 && (L = new _d(), c[M] = L), L.getGripSpace();
  }, this.getHand = function(M) {
    let L = c[M];
    return L === void 0 && (L = new _d(), c[M] = L), L.getHandSpace();
  };
  function g(M) {
    const L = l.get(M.inputSource);
    L && L.dispatchEvent({ type: M.type });
  }
  function m() {
    l.forEach(function(M, L) {
      M.disconnect(L);
    }), l.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), k.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" });
  }
  function x(M) {
    r = M, k.setContext(s), k.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
  }
  this.setFramebufferScaleFactor = function(M) {
    i = M, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
  }, this.setReferenceSpaceType = function(M) {
    o = M, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
  }, this.getReferenceSpace = function() {
    return r;
  }, this.getSession = function() {
    return s;
  }, this.setSession = function(M) {
    if (s = M, s !== null) {
      s.addEventListener("select", g), s.addEventListener("selectstart", g), s.addEventListener("selectend", g), s.addEventListener("squeeze", g), s.addEventListener("squeezestart", g), s.addEventListener("squeezeend", g), s.addEventListener("end", m);
      const L = e.getContextAttributes();
      L.xrCompatible !== !0 && e.makeXRCompatible();
      const O = {
        antialias: L.antialias,
        alpha: L.alpha,
        depth: L.depth,
        stencil: L.stencil,
        framebufferScaleFactor: i
      }, $ = new XRWebGLLayer(s, e, O);
      s.updateRenderState({ baseLayer: $ }), s.requestReferenceSpace(o).then(x), s.addEventListener("inputsourceschange", v);
    }
  };
  function v(M) {
    const L = s.inputSources;
    for (let O = 0; O < c.length; O++)
      l.set(L[O], c[O]);
    for (let O = 0; O < M.removed.length; O++) {
      const $ = M.removed[O], D = l.get($);
      D && (D.dispatchEvent({ type: "disconnected", data: $ }), l.delete($));
    }
    for (let O = 0; O < M.added.length; O++) {
      const $ = M.added[O], D = l.get($);
      D && D.dispatchEvent({ type: "connected", data: $ });
    }
  }
  const b = new P(), w = new P();
  function S(M, L, O) {
    b.setFromMatrixPosition(L.matrixWorld), w.setFromMatrixPosition(O.matrixWorld);
    const $ = b.distanceTo(w), D = L.projectionMatrix.elements, z = O.projectionMatrix.elements, W = D[14] / (D[10] - 1), j = D[14] / (D[10] + 1), J = (D[9] + 1) / D[5], ne = (D[9] - 1) / D[5], re = (D[8] - 1) / D[0], fe = (z[8] + 1) / z[0], ae = W * re, ve = W * fe, me = $ / (-re + fe), te = me * -re;
    L.matrixWorld.decompose(M.position, M.quaternion, M.scale), M.translateX(te), M.translateZ(me), M.matrixWorld.compose(M.position, M.quaternion, M.scale), M.matrixWorldInverse.getInverse(M.matrixWorld);
    const $e = W + me, _e = j + me, ke = ae - te, Re = ve + ($ - te), ce = J * j / _e * $e, xe = ne * j / _e * $e;
    M.projectionMatrix.makePerspective(ke, Re, ce, xe, $e, _e);
  }
  function _(M, L) {
    L === null ? M.matrixWorld.copy(M.matrix) : M.matrixWorld.multiplyMatrices(L.matrixWorld, M.matrix), M.matrixWorldInverse.getInverse(M.matrixWorld);
  }
  this.getCamera = function(M) {
    f.near = h.near = u.near = M.near, f.far = h.far = u.far = M.far, (p !== f.near || y !== f.far) && (s.updateRenderState({
      depthNear: f.near,
      depthFar: f.far
    }), p = f.near, y = f.far);
    const L = M.parent, O = f.cameras;
    _(f, L);
    for (let D = 0; D < O.length; D++)
      _(O[D], L);
    M.matrixWorld.copy(f.matrixWorld);
    const $ = M.children;
    for (let D = 0, z = $.length; D < z; D++)
      $[D].updateMatrixWorld(!0);
    return O.length === 2 ? S(f, u, h) : f.projectionMatrix.copy(u.projectionMatrix), f;
  };
  let E = null;
  function I(M, L) {
    if (a = L.getViewerPose(r), a !== null) {
      const $ = a.views, D = s.renderState.baseLayer;
      t.setFramebuffer(D.framebuffer);
      let z = !1;
      $.length !== f.cameras.length && (f.cameras.length = 0, z = !0);
      for (let W = 0; W < $.length; W++) {
        const j = $[W], J = D.getViewport(j), ne = d[W];
        ne.matrix.fromArray(j.transform.matrix), ne.projectionMatrix.fromArray(j.projectionMatrix), ne.viewport.set(J.x, J.y, J.width, J.height), W === 0 && f.matrix.copy(ne.matrix), z === !0 && f.cameras.push(ne);
      }
    }
    const O = s.inputSources;
    for (let $ = 0; $ < c.length; $++) {
      const D = c[$], z = O[$];
      D.update(z, L, r);
    }
    E && E(M, L);
  }
  const k = new GE();
  k.setAnimationLoop(I), this.setAnimationLoop = function(M) {
    E = M;
  }, this.dispose = function() {
  };
}
Object.assign(JE.prototype, Po.prototype);
function Lz(t) {
  function e(m, x) {
    m.fogColor.value.copy(x.color), x.isFog ? (m.fogNear.value = x.near, m.fogFar.value = x.far) : x.isFogExp2 && (m.fogDensity.value = x.density);
  }
  function n(m, x, v, b, w) {
    x.isMeshBasicMaterial ? s(m, x) : x.isMeshLambertMaterial ? (s(m, x), c(m, x)) : x.isMeshToonMaterial ? (s(m, x), u(m, x)) : x.isMeshPhongMaterial ? (s(m, x), l(m, x)) : x.isMeshStandardMaterial ? (s(m, x, v), x.isMeshPhysicalMaterial ? d(m, x, v) : h(m, x, v)) : x.isMeshMatcapMaterial ? (s(m, x), f(m, x)) : x.isMeshDepthMaterial ? (s(m, x), p(m, x)) : x.isMeshDistanceMaterial ? (s(m, x), y(m, x)) : x.isMeshNormalMaterial ? (s(m, x), g(m, x)) : x.isLineBasicMaterial ? (i(m, x), x.isLineDashedMaterial && r(m, x)) : x.isPointsMaterial ? o(m, x, b, w) : x.isSpriteMaterial ? a(m, x) : x.isShadowMaterial ? (m.color.value.copy(x.color), m.opacity.value = x.opacity) : x.isShaderMaterial && (x.uniformsNeedUpdate = !1);
  }
  function s(m, x, v) {
    m.opacity.value = x.opacity, x.color && m.diffuse.value.copy(x.color), x.emissive && m.emissive.value.copy(x.emissive).multiplyScalar(x.emissiveIntensity), x.map && (m.map.value = x.map), x.alphaMap && (m.alphaMap.value = x.alphaMap), x.specularMap && (m.specularMap.value = x.specularMap);
    const b = x.envMap || v;
    if (b) {
      m.envMap.value = b, m.flipEnvMap.value = b.isCubeTexture ? -1 : 1, m.reflectivity.value = x.reflectivity, m.refractionRatio.value = x.refractionRatio;
      var w = t.get(b).__maxMipLevel;
      w !== void 0 && (m.maxMipLevel.value = w);
    }
    x.lightMap && (m.lightMap.value = x.lightMap, m.lightMapIntensity.value = x.lightMapIntensity), x.aoMap && (m.aoMap.value = x.aoMap, m.aoMapIntensity.value = x.aoMapIntensity);
    let S;
    x.map ? S = x.map : x.specularMap ? S = x.specularMap : x.displacementMap ? S = x.displacementMap : x.normalMap ? S = x.normalMap : x.bumpMap ? S = x.bumpMap : x.roughnessMap ? S = x.roughnessMap : x.metalnessMap ? S = x.metalnessMap : x.alphaMap ? S = x.alphaMap : x.emissiveMap && (S = x.emissiveMap), S !== void 0 && (S.isWebGLRenderTarget && (S = S.texture), S.matrixAutoUpdate === !0 && S.updateMatrix(), m.uvTransform.value.copy(S.matrix));
    let _;
    x.aoMap ? _ = x.aoMap : x.lightMap && (_ = x.lightMap), _ !== void 0 && (_.isWebGLRenderTarget && (_ = _.texture), _.matrixAutoUpdate === !0 && _.updateMatrix(), m.uv2Transform.value.copy(_.matrix));
  }
  function i(m, x) {
    m.diffuse.value.copy(x.color), m.opacity.value = x.opacity;
  }
  function r(m, x) {
    m.dashSize.value = x.dashSize, m.totalSize.value = x.dashSize + x.gapSize, m.scale.value = x.scale;
  }
  function o(m, x, v, b) {
    m.diffuse.value.copy(x.color), m.opacity.value = x.opacity, m.size.value = x.size * v, m.scale.value = b * 0.5, x.map && (m.map.value = x.map), x.alphaMap && (m.alphaMap.value = x.alphaMap);
    let w;
    x.map ? w = x.map : x.alphaMap && (w = x.alphaMap), w !== void 0 && (w.matrixAutoUpdate === !0 && w.updateMatrix(), m.uvTransform.value.copy(w.matrix));
  }
  function a(m, x) {
    m.diffuse.value.copy(x.color), m.opacity.value = x.opacity, m.rotation.value = x.rotation, x.map && (m.map.value = x.map), x.alphaMap && (m.alphaMap.value = x.alphaMap);
    let v;
    x.map ? v = x.map : x.alphaMap && (v = x.alphaMap), v !== void 0 && (v.matrixAutoUpdate === !0 && v.updateMatrix(), m.uvTransform.value.copy(v.matrix));
  }
  function c(m, x) {
    x.emissiveMap && (m.emissiveMap.value = x.emissiveMap);
  }
  function l(m, x) {
    m.specular.value.copy(x.specular), m.shininess.value = Math.max(x.shininess, 1e-4), x.emissiveMap && (m.emissiveMap.value = x.emissiveMap), x.bumpMap && (m.bumpMap.value = x.bumpMap, m.bumpScale.value = x.bumpScale, x.side === is && (m.bumpScale.value *= -1)), x.normalMap && (m.normalMap.value = x.normalMap, m.normalScale.value.copy(x.normalScale), x.side === is && m.normalScale.value.negate()), x.displacementMap && (m.displacementMap.value = x.displacementMap, m.displacementScale.value = x.displacementScale, m.displacementBias.value = x.displacementBias);
  }
  function u(m, x) {
    x.gradientMap && (m.gradientMap.value = x.gradientMap), x.emissiveMap && (m.emissiveMap.value = x.emissiveMap), x.bumpMap && (m.bumpMap.value = x.bumpMap, m.bumpScale.value = x.bumpScale, x.side === is && (m.bumpScale.value *= -1)), x.normalMap && (m.normalMap.value = x.normalMap, m.normalScale.value.copy(x.normalScale), x.side === is && m.normalScale.value.negate()), x.displacementMap && (m.displacementMap.value = x.displacementMap, m.displacementScale.value = x.displacementScale, m.displacementBias.value = x.displacementBias);
  }
  function h(m, x, v) {
    m.roughness.value = x.roughness, m.metalness.value = x.metalness, x.roughnessMap && (m.roughnessMap.value = x.roughnessMap), x.metalnessMap && (m.metalnessMap.value = x.metalnessMap), x.emissiveMap && (m.emissiveMap.value = x.emissiveMap), x.bumpMap && (m.bumpMap.value = x.bumpMap, m.bumpScale.value = x.bumpScale, x.side === is && (m.bumpScale.value *= -1)), x.normalMap && (m.normalMap.value = x.normalMap, m.normalScale.value.copy(x.normalScale), x.side === is && m.normalScale.value.negate()), x.displacementMap && (m.displacementMap.value = x.displacementMap, m.displacementScale.value = x.displacementScale, m.displacementBias.value = x.displacementBias), (x.envMap || v) && (m.envMapIntensity.value = x.envMapIntensity);
  }
  function d(m, x, v) {
    h(m, x, v), m.reflectivity.value = x.reflectivity, m.clearcoat.value = x.clearcoat, m.clearcoatRoughness.value = x.clearcoatRoughness, x.sheen && m.sheen.value.copy(x.sheen), x.clearcoatMap && (m.clearcoatMap.value = x.clearcoatMap), x.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = x.clearcoatRoughnessMap), x.clearcoatNormalMap && (m.clearcoatNormalScale.value.copy(x.clearcoatNormalScale), m.clearcoatNormalMap.value = x.clearcoatNormalMap, x.side === is && m.clearcoatNormalScale.value.negate()), m.transmission.value = x.transmission, x.transmissionMap && (m.transmissionMap.value = x.transmissionMap);
  }
  function f(m, x) {
    x.matcap && (m.matcap.value = x.matcap), x.bumpMap && (m.bumpMap.value = x.bumpMap, m.bumpScale.value = x.bumpScale, x.side === is && (m.bumpScale.value *= -1)), x.normalMap && (m.normalMap.value = x.normalMap, m.normalScale.value.copy(x.normalScale), x.side === is && m.normalScale.value.negate()), x.displacementMap && (m.displacementMap.value = x.displacementMap, m.displacementScale.value = x.displacementScale, m.displacementBias.value = x.displacementBias);
  }
  function p(m, x) {
    x.displacementMap && (m.displacementMap.value = x.displacementMap, m.displacementScale.value = x.displacementScale, m.displacementBias.value = x.displacementBias);
  }
  function y(m, x) {
    x.displacementMap && (m.displacementMap.value = x.displacementMap, m.displacementScale.value = x.displacementScale, m.displacementBias.value = x.displacementBias), m.referencePosition.value.copy(x.referencePosition), m.nearDistance.value = x.nearDistance, m.farDistance.value = x.farDistance;
  }
  function g(m, x) {
    x.bumpMap && (m.bumpMap.value = x.bumpMap, m.bumpScale.value = x.bumpScale, x.side === is && (m.bumpScale.value *= -1)), x.normalMap && (m.normalMap.value = x.normalMap, m.normalScale.value.copy(x.normalScale), x.side === is && m.normalScale.value.negate()), x.displacementMap && (m.displacementMap.value = x.displacementMap, m.displacementScale.value = x.displacementScale, m.displacementBias.value = x.displacementBias);
  }
  return {
    refreshFogUniforms: e,
    refreshMaterialUniforms: n
  };
}
function Lf(t) {
  t = t || {};
  const e = t.canvas !== void 0 ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), n = t.context !== void 0 ? t.context : null, s = t.alpha !== void 0 ? t.alpha : !1, i = t.depth !== void 0 ? t.depth : !0, r = t.stencil !== void 0 ? t.stencil : !0, o = t.antialias !== void 0 ? t.antialias : !1, a = t.premultipliedAlpha !== void 0 ? t.premultipliedAlpha : !0, c = t.preserveDrawingBuffer !== void 0 ? t.preserveDrawingBuffer : !1, l = t.powerPreference !== void 0 ? t.powerPreference : "default", u = t.failIfMajorPerformanceCaveat !== void 0 ? t.failIfMajorPerformanceCaveat : !1;
  let h = null, d = null;
  this.domElement = e, this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = gi, this.physicallyCorrectLights = !1, this.toneMapping = jl, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
  const f = this;
  let p = !1, y = null, g = 0, m = 0, x = null, v = null, b = -1, w = null, S = null;
  const _ = new en(), E = new en();
  let I = null, k = e.width, M = e.height, L = 1, O = null, $ = null;
  const D = new en(0, 0, k, M), z = new en(0, 0, k, M);
  let W = !1;
  const j = new Of(), J = new fB();
  let ne = !1, re = !1;
  const fe = new Mt(), ae = new P(), ve = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
  function me() {
    return x === null ? L : 1;
  }
  let te = n;
  function $e(U, ye) {
    for (let he = 0; he < U.length; he++) {
      const Te = U[he], Xe = e.getContext(Te, ye);
      if (Xe !== null)
        return Xe;
    }
    return null;
  }
  try {
    const U = {
      alpha: s,
      depth: i,
      stencil: r,
      antialias: o,
      premultipliedAlpha: a,
      preserveDrawingBuffer: c,
      powerPreference: l,
      failIfMajorPerformanceCaveat: u
    };
    if (e.addEventListener("webglcontextlost", Ue, !1), e.addEventListener("webglcontextrestored", Ke, !1), te === null) {
      const ye = ["webgl2", "webgl", "experimental-webgl"];
      if (f.isWebGL1Renderer === !0 && ye.shift(), te = $e(ye, U), te === null)
        throw $e(ye) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    te.getShaderPrecisionFormat === void 0 && (te.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (U) {
    throw console.error("THREE.WebGLRenderer: " + U.message), U;
  }
  let _e, ke, Re, ce, xe, we, Pe, Me, Ge, F, V, Ae, ge, ee, De, Fe, tt, X, pe;
  function Oe() {
    _e = new pB(te), ke = new dB(te, _e, t), ke.isWebGL2 === !1 && (_e.get("WEBGL_depth_texture"), _e.get("OES_texture_float"), _e.get("OES_texture_half_float"), _e.get("OES_texture_half_float_linear"), _e.get("OES_standard_derivatives"), _e.get("OES_element_index_uint"), _e.get("OES_vertex_array_object"), _e.get("ANGLE_instanced_arrays")), _e.get("OES_texture_float_linear"), X = new Oz(te, _e, ke), Re = new Dz(te, _e, ke), Re.scissor(E.copy(z).multiplyScalar(L).floor()), Re.viewport(_.copy(D).multiplyScalar(L).floor()), ce = new yB(), xe = new wz(), we = new $z(te, _e, Re, xe, ke, X, ce), Pe = new VF(te, ke), pe = new uB(te, _e, Pe, ke), Me = new mB(te, Pe, ce, pe), Ge = new wB(te, Me, Pe, ce), De = new vB(te), F = new vz(f, _e, ke, pe), V = new Lz(xe), Ae = new Tz(xe), ge = new Az(), ee = new lB(f, Re, Ge, a), Fe = new hB(te, _e, ce, ke), tt = new gB(te, _e, ce, ke), ce.programs = F.programs, f.capabilities = ke, f.extensions = _e, f.properties = xe, f.renderLists = Ae, f.state = Re, f.info = ce;
  }
  Oe();
  const Ie = new JE(f, te);
  this.xr = Ie;
  const Be = new ZE(f, Ge, ke.maxTextureSize);
  this.shadowMap = Be, this.getContext = function() {
    return te;
  }, this.getContextAttributes = function() {
    return te.getContextAttributes();
  }, this.forceContextLoss = function() {
    const U = _e.get("WEBGL_lose_context");
    U && U.loseContext();
  }, this.forceContextRestore = function() {
    const U = _e.get("WEBGL_lose_context");
    U && U.restoreContext();
  }, this.getPixelRatio = function() {
    return L;
  }, this.setPixelRatio = function(U) {
    U !== void 0 && (L = U, this.setSize(k, M, !1));
  }, this.getSize = function(U) {
    return U === void 0 && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), U = new Ce()), U.set(k, M);
  }, this.setSize = function(U, ye, he) {
    if (Ie.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    k = U, M = ye, e.width = Math.floor(U * L), e.height = Math.floor(ye * L), he !== !1 && (e.style.width = U + "px", e.style.height = ye + "px"), this.setViewport(0, 0, U, ye);
  }, this.getDrawingBufferSize = function(U) {
    return U === void 0 && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), U = new Ce()), U.set(k * L, M * L).floor();
  }, this.setDrawingBufferSize = function(U, ye, he) {
    k = U, M = ye, L = he, e.width = Math.floor(U * he), e.height = Math.floor(ye * he), this.setViewport(0, 0, U, ye);
  }, this.getCurrentViewport = function(U) {
    return U === void 0 && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), U = new en()), U.copy(_);
  }, this.getViewport = function(U) {
    return U.copy(D);
  }, this.setViewport = function(U, ye, he, Te) {
    U.isVector4 ? D.set(U.x, U.y, U.z, U.w) : D.set(U, ye, he, Te), Re.viewport(_.copy(D).multiplyScalar(L).floor());
  }, this.getScissor = function(U) {
    return U.copy(z);
  }, this.setScissor = function(U, ye, he, Te) {
    U.isVector4 ? z.set(U.x, U.y, U.z, U.w) : z.set(U, ye, he, Te), Re.scissor(E.copy(z).multiplyScalar(L).floor());
  }, this.getScissorTest = function() {
    return W;
  }, this.setScissorTest = function(U) {
    Re.setScissorTest(W = U);
  }, this.setOpaqueSort = function(U) {
    O = U;
  }, this.setTransparentSort = function(U) {
    $ = U;
  }, this.getClearColor = function() {
    return ee.getClearColor();
  }, this.setClearColor = function() {
    ee.setClearColor.apply(ee, arguments);
  }, this.getClearAlpha = function() {
    return ee.getClearAlpha();
  }, this.setClearAlpha = function() {
    ee.setClearAlpha.apply(ee, arguments);
  }, this.clear = function(U, ye, he) {
    let Te = 0;
    (U === void 0 || U) && (Te |= 16384), (ye === void 0 || ye) && (Te |= 256), (he === void 0 || he) && (Te |= 1024), te.clear(Te);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.dispose = function() {
    e.removeEventListener("webglcontextlost", Ue, !1), e.removeEventListener("webglcontextrestored", Ke, !1), Ae.dispose(), ge.dispose(), xe.dispose(), Ge.dispose(), pe.dispose(), Ie.dispose(), zi.stop();
  };
  function Ue(U) {
    U.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), p = !0;
  }
  function Ke() {
    console.log("THREE.WebGLRenderer: Context Restored."), p = !1, Oe();
  }
  function wt(U) {
    const ye = U.target;
    ye.removeEventListener("dispose", wt), Yt(ye);
  }
  function Yt(U) {
    St(U), xe.remove(U);
  }
  function St(U) {
    const ye = xe.get(U).program;
    ye !== void 0 && F.releaseProgram(ye);
  }
  function Mr(U, ye) {
    U.render(function(he) {
      f.renderBufferImmediate(he, ye);
    });
  }
  this.renderBufferImmediate = function(U, ye) {
    pe.initAttributes();
    const he = xe.get(U);
    U.hasPositions && !he.position && (he.position = te.createBuffer()), U.hasNormals && !he.normal && (he.normal = te.createBuffer()), U.hasUvs && !he.uv && (he.uv = te.createBuffer()), U.hasColors && !he.color && (he.color = te.createBuffer());
    const Te = ye.getAttributes();
    U.hasPositions && (te.bindBuffer(34962, he.position), te.bufferData(34962, U.positionArray, 35048), pe.enableAttribute(Te.position), te.vertexAttribPointer(Te.position, 3, 5126, !1, 0, 0)), U.hasNormals && (te.bindBuffer(34962, he.normal), te.bufferData(34962, U.normalArray, 35048), pe.enableAttribute(Te.normal), te.vertexAttribPointer(Te.normal, 3, 5126, !1, 0, 0)), U.hasUvs && (te.bindBuffer(34962, he.uv), te.bufferData(34962, U.uvArray, 35048), pe.enableAttribute(Te.uv), te.vertexAttribPointer(Te.uv, 2, 5126, !1, 0, 0)), U.hasColors && (te.bindBuffer(34962, he.color), te.bufferData(34962, U.colorArray, 35048), pe.enableAttribute(Te.color), te.vertexAttribPointer(Te.color, 3, 5126, !1, 0, 0)), pe.disableUnusedAttributes(), te.drawArrays(4, 0, U.count), U.count = 0;
  }, this.renderBufferDirect = function(U, ye, he, Te, Xe, Dt) {
    ye === null && (ye = ve);
    const _t = Xe.isMesh && Xe.matrixWorld.determinant() < 0, lt = Xo(U, ye, Te, Xe);
    Re.setMaterial(Te, _t);
    let Tn = he.index;
    const pn = he.attributes.position;
    if (Tn === null) {
      if (pn === void 0 || pn.count === 0)
        return;
    } else if (Tn.count === 0)
      return;
    let ln = 1;
    Te.wireframe === !0 && (Tn = Me.getWireframeAttribute(he), ln = 2), (Te.morphTargets || Te.morphNormals) && De.update(Xe, he, Te, lt), pe.setup(Xe, Te, lt, he, Tn);
    let Mn, vt = Fe;
    Tn !== null && (Mn = Pe.get(Tn), vt = tt, vt.setIndex(Mn));
    const Cn = Tn !== null ? Tn.count : pn.count, On = he.drawRange.start * ln, Qt = he.drawRange.count * ln, pl = Dt !== null ? Dt.start * ln : 0, Ms = Dt !== null ? Dt.count * ln : 1 / 0, Rr = Math.max(On, pl), Xh = Math.min(Cn, On + Qt, pl + Ms) - 1, qa = Math.max(0, Xh - Rr + 1);
    if (qa !== 0) {
      if (Xe.isMesh)
        Te.wireframe === !0 ? (Re.setLineWidth(Te.wireframeLinewidth * me()), vt.setMode(1)) : vt.setMode(4);
      else if (Xe.isLine) {
        let Ko = Te.linewidth;
        Ko === void 0 && (Ko = 1), Re.setLineWidth(Ko * me()), Xe.isLineSegments ? vt.setMode(1) : Xe.isLineLoop ? vt.setMode(2) : vt.setMode(3);
      } else
        Xe.isPoints ? vt.setMode(0) : Xe.isSprite && vt.setMode(4);
      if (Xe.isInstancedMesh)
        vt.renderInstances(Rr, qa, Xe.count);
      else if (he.isInstancedBufferGeometry) {
        const Ko = Math.min(he.instanceCount, he._maxInstanceCount);
        vt.renderInstances(Rr, qa, Ko);
      } else
        vt.render(Rr, qa);
    }
  }, this.compile = function(U, ye) {
    d = ge.get(U, ye), d.init(), U.traverse(function(Te) {
      Te.isLight && (d.pushLight(Te), Te.castShadow && d.pushShadow(Te));
    }), d.setupLights(ye);
    const he = /* @__PURE__ */ new WeakMap();
    U.traverse(function(Te) {
      let Xe = Te.material;
      if (Xe)
        if (Array.isArray(Xe))
          for (let Dt = 0; Dt < Xe.length; Dt++) {
            let _t = Xe[Dt];
            he.has(_t) === !1 && (on(_t, U, Te), he.set(_t));
          }
        else
          he.has(Xe) === !1 && (on(Xe, U, Te), he.set(Xe));
    });
  };
  let fo = null;
  function ar(U) {
    Ie.isPresenting || fo && fo(U);
  }
  const zi = new GE();
  zi.setAnimationLoop(ar), typeof window < "u" && zi.setContext(window), this.setAnimationLoop = function(U) {
    fo = U, Ie.setAnimationLoop(U), U === null ? zi.stop() : zi.start();
  }, this.render = function(U, ye) {
    let he, Te;
    if (arguments[2] !== void 0 && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), he = arguments[2]), arguments[3] !== void 0 && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), Te = arguments[3]), ye !== void 0 && ye.isCamera !== !0) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (p === !0)
      return;
    pe.resetDefaultState(), b = -1, w = null, U.autoUpdate === !0 && U.updateMatrixWorld(), ye.parent === null && ye.updateMatrixWorld(), Ie.enabled === !0 && Ie.isPresenting === !0 && (ye = Ie.getCamera(ye)), U.isScene === !0 && U.onBeforeRender(f, U, ye, he || x), d = ge.get(U, ye), d.init(), fe.multiplyMatrices(ye.projectionMatrix, ye.matrixWorldInverse), j.setFromProjectionMatrix(fe), re = this.localClippingEnabled, ne = J.init(this.clippingPlanes, re, ye), h = Ae.get(U, ye), h.init(), fl(U, ye, 0, f.sortObjects), h.finish(), f.sortObjects === !0 && h.sort(O, $), ne === !0 && J.beginShadows();
    const Xe = d.state.shadowsArray;
    Be.render(Xe, U, ye), d.setupLights(ye), ne === !0 && J.endShadows(), this.info.autoReset === !0 && this.info.reset(), he !== void 0 && this.setRenderTarget(he), ee.render(h, U, ye, Te);
    const Dt = h.opaque, _t = h.transparent;
    Dt.length > 0 && ja(Dt, U, ye), _t.length > 0 && ja(_t, U, ye), U.isScene === !0 && U.onAfterRender(f, U, ye), x !== null && (we.updateRenderTargetMipmap(x), we.updateMultisampleRenderTarget(x)), Re.buffers.depth.setTest(!0), Re.buffers.depth.setMask(!0), Re.buffers.color.setMask(!0), Re.setPolygonOffset(!1), h = null, d = null;
  };
  function fl(U, ye, he, Te) {
    if (U.visible === !1)
      return;
    if (U.layers.test(ye.layers)) {
      if (U.isGroup)
        he = U.renderOrder;
      else if (U.isLOD)
        U.autoUpdate === !0 && U.update(ye);
      else if (U.isLight)
        d.pushLight(U), U.castShadow && d.pushShadow(U);
      else if (U.isSprite) {
        if (!U.frustumCulled || j.intersectsSprite(U)) {
          Te && ae.setFromMatrixPosition(U.matrixWorld).applyMatrix4(fe);
          const _t = Ge.update(U), lt = U.material;
          lt.visible && h.push(U, _t, lt, he, ae.z, null);
        }
      } else if (U.isImmediateRenderObject)
        Te && ae.setFromMatrixPosition(U.matrixWorld).applyMatrix4(fe), h.push(U, null, U.material, he, ae.z, null);
      else if ((U.isMesh || U.isLine || U.isPoints) && (U.isSkinnedMesh && U.skeleton.frame !== ce.render.frame && (U.skeleton.update(), U.skeleton.frame = ce.render.frame), !U.frustumCulled || j.intersectsObject(U))) {
        Te && ae.setFromMatrixPosition(U.matrixWorld).applyMatrix4(fe);
        const _t = Ge.update(U), lt = U.material;
        if (Array.isArray(lt)) {
          const Tn = _t.groups;
          for (let pn = 0, ln = Tn.length; pn < ln; pn++) {
            const Mn = Tn[pn], vt = lt[Mn.materialIndex];
            vt && vt.visible && h.push(U, _t, vt, he, ae.z, Mn);
          }
        } else
          lt.visible && h.push(U, _t, lt, he, ae.z, null);
      }
    }
    const Dt = U.children;
    for (let _t = 0, lt = Dt.length; _t < lt; _t++)
      fl(Dt[_t], ye, he, Te);
  }
  function ja(U, ye, he) {
    const Te = ye.isScene === !0 ? ye.overrideMaterial : null;
    for (let Xe = 0, Dt = U.length; Xe < Dt; Xe++) {
      const _t = U[Xe], lt = _t.object, Tn = _t.geometry, pn = Te === null ? _t.material : Te, ln = _t.group;
      if (he.isArrayCamera) {
        S = he;
        const Mn = he.cameras;
        for (let vt = 0, Cn = Mn.length; vt < Cn; vt++) {
          const On = Mn[vt];
          lt.layers.test(On.layers) && (Re.viewport(_.copy(On.viewport)), d.setupLights(On), po(lt, ye, On, Tn, pn, ln));
        }
      } else
        S = null, po(lt, ye, he, Tn, pn, ln);
    }
  }
  function po(U, ye, he, Te, Xe, Dt) {
    if (U.onBeforeRender(f, ye, he, Te, Xe, Dt), d = ge.get(ye, S || he), U.modelViewMatrix.multiplyMatrices(he.matrixWorldInverse, U.matrixWorld), U.normalMatrix.getNormalMatrix(U.modelViewMatrix), U.isImmediateRenderObject) {
      const _t = Xo(he, ye, Xe, U);
      Re.setMaterial(Xe), pe.reset(), Mr(U, _t);
    } else
      f.renderBufferDirect(he, ye, Te, Xe, U, Dt);
    U.onAfterRender(f, ye, he, Te, Xe, Dt), d = ge.get(ye, S || he);
  }
  function on(U, ye, he) {
    ye.isScene !== !0 && (ye = ve);
    const Te = xe.get(U), Xe = d.state.lights, Dt = d.state.shadowsArray, _t = Xe.state.version, lt = F.getParameters(U, Xe.state, Dt, ye, J.numPlanes, J.numIntersection, he), Tn = F.getProgramCacheKey(lt);
    let pn = Te.program, ln = !0;
    if (pn === void 0)
      U.addEventListener("dispose", wt);
    else if (pn.cacheKey !== Tn)
      St(U);
    else if (Te.lightsStateVersion !== _t)
      Te.lightsStateVersion = _t, ln = !1;
    else {
      if (lt.shaderID !== void 0)
        return;
      ln = !1;
    }
    ln && (lt.uniforms = F.getUniforms(U, lt), U.onBeforeCompile(lt, f), pn = F.acquireProgram(lt, Tn), Te.program = pn, Te.uniforms = lt.uniforms, Te.outputEncoding = lt.outputEncoding);
    const Mn = pn.getAttributes();
    if (U.morphTargets) {
      U.numSupportedMorphTargets = 0;
      for (let Qt = 0; Qt < f.maxMorphTargets; Qt++)
        Mn["morphTarget" + Qt] >= 0 && U.numSupportedMorphTargets++;
    }
    if (U.morphNormals) {
      U.numSupportedMorphNormals = 0;
      for (let Qt = 0; Qt < f.maxMorphNormals; Qt++)
        Mn["morphNormal" + Qt] >= 0 && U.numSupportedMorphNormals++;
    }
    const vt = Te.uniforms;
    (!U.isShaderMaterial && !U.isRawShaderMaterial || U.clipping === !0) && (Te.numClippingPlanes = J.numPlanes, Te.numIntersection = J.numIntersection, vt.clippingPlanes = J.uniform), Te.environment = U.isMeshStandardMaterial ? ye.environment : null, Te.fog = ye.fog, Te.needsLights = qh(U), Te.lightsStateVersion = _t, Te.needsLights && (vt.ambientLightColor.value = Xe.state.ambient, vt.lightProbe.value = Xe.state.probe, vt.directionalLights.value = Xe.state.directional, vt.directionalLightShadows.value = Xe.state.directionalShadow, vt.spotLights.value = Xe.state.spot, vt.spotLightShadows.value = Xe.state.spotShadow, vt.rectAreaLights.value = Xe.state.rectArea, vt.pointLights.value = Xe.state.point, vt.pointLightShadows.value = Xe.state.pointShadow, vt.hemisphereLights.value = Xe.state.hemi, vt.directionalShadowMap.value = Xe.state.directionalShadowMap, vt.directionalShadowMatrix.value = Xe.state.directionalShadowMatrix, vt.spotShadowMap.value = Xe.state.spotShadowMap, vt.spotShadowMatrix.value = Xe.state.spotShadowMatrix, vt.pointShadowMap.value = Xe.state.pointShadowMap, vt.pointShadowMatrix.value = Xe.state.pointShadowMatrix);
    const Cn = Te.program.getUniforms(), On = da.seqWithValue(Cn.seq, vt);
    Te.uniformsList = On;
  }
  function Xo(U, ye, he, Te) {
    ye.isScene !== !0 && (ye = ve), we.resetTextureUnits();
    const Xe = ye.fog, Dt = he.isMeshStandardMaterial ? ye.environment : null, _t = x === null ? f.outputEncoding : x.texture.encoding, lt = xe.get(he), Tn = d.state.lights;
    if (ne === !0 && (re === !0 || U !== w)) {
      const Qt = U === w && he.id === b;
      J.setState(
        he.clippingPlanes,
        he.clipIntersection,
        he.clipShadows,
        U,
        lt,
        Qt
      );
    }
    he.version === lt.__version ? (lt.program === void 0 || he.fog && lt.fog !== Xe || lt.environment !== Dt || lt.needsLights && lt.lightsStateVersion !== Tn.state.version || lt.numClippingPlanes !== void 0 && (lt.numClippingPlanes !== J.numPlanes || lt.numIntersection !== J.numIntersection) || lt.outputEncoding !== _t) && on(he, ye, Te) : (on(he, ye, Te), lt.__version = he.version);
    let pn = !1, ln = !1, Mn = !1;
    const vt = lt.program, Cn = vt.getUniforms(), On = lt.uniforms;
    if (Re.useProgram(vt.program) && (pn = !0, ln = !0, Mn = !0), he.id !== b && (b = he.id, ln = !0), pn || w !== U) {
      if (Cn.setValue(te, "projectionMatrix", U.projectionMatrix), ke.logarithmicDepthBuffer && Cn.setValue(
        te,
        "logDepthBufFC",
        2 / (Math.log(U.far + 1) / Math.LN2)
      ), w !== U && (w = U, ln = !0, Mn = !0), he.isShaderMaterial || he.isMeshPhongMaterial || he.isMeshToonMaterial || he.isMeshStandardMaterial || he.envMap) {
        const Qt = Cn.map.cameraPosition;
        Qt !== void 0 && Qt.setValue(
          te,
          ae.setFromMatrixPosition(U.matrixWorld)
        );
      }
      (he.isMeshPhongMaterial || he.isMeshToonMaterial || he.isMeshLambertMaterial || he.isMeshBasicMaterial || he.isMeshStandardMaterial || he.isShaderMaterial) && Cn.setValue(te, "isOrthographic", U.isOrthographicCamera === !0), (he.isMeshPhongMaterial || he.isMeshToonMaterial || he.isMeshLambertMaterial || he.isMeshBasicMaterial || he.isMeshStandardMaterial || he.isShaderMaterial || he.isShadowMaterial || he.skinning) && Cn.setValue(te, "viewMatrix", U.matrixWorldInverse);
    }
    if (he.skinning) {
      Cn.setOptional(te, Te, "bindMatrix"), Cn.setOptional(te, Te, "bindMatrixInverse");
      const Qt = Te.skeleton;
      if (Qt) {
        const pl = Qt.bones;
        if (ke.floatVertexTextures) {
          if (Qt.boneTexture === void 0) {
            let Ms = Math.sqrt(pl.length * 4);
            Ms = Et.ceilPowerOfTwo(Ms), Ms = Math.max(Ms, 4);
            const Rr = new Float32Array(Ms * Ms * 4);
            Rr.set(Qt.boneMatrices);
            const Xh = new tu(Rr, Ms, Ms, Zi, ra);
            Qt.boneMatrices = Rr, Qt.boneTexture = Xh, Qt.boneTextureSize = Ms;
          }
          Cn.setValue(te, "boneTexture", Qt.boneTexture, we), Cn.setValue(te, "boneTextureSize", Qt.boneTextureSize);
        } else
          Cn.setOptional(te, Qt, "boneMatrices");
      }
    }
    return (ln || lt.receiveShadow !== Te.receiveShadow) && (lt.receiveShadow = Te.receiveShadow, Cn.setValue(te, "receiveShadow", Te.receiveShadow)), ln && (Cn.setValue(te, "toneMappingExposure", f.toneMappingExposure), lt.needsLights && $b(On, Mn), Xe && he.fog && V.refreshFogUniforms(On, Xe), V.refreshMaterialUniforms(On, he, Dt, L, M), On.ltc_1 !== void 0 && (On.ltc_1.value = Ye.LTC_1), On.ltc_2 !== void 0 && (On.ltc_2.value = Ye.LTC_2), da.upload(te, lt.uniformsList, On, we)), he.isShaderMaterial && he.uniformsNeedUpdate === !0 && (da.upload(te, lt.uniformsList, On, we), he.uniformsNeedUpdate = !1), he.isSpriteMaterial && Cn.setValue(te, "center", Te.center), Cn.setValue(te, "modelViewMatrix", Te.modelViewMatrix), Cn.setValue(te, "normalMatrix", Te.normalMatrix), Cn.setValue(te, "modelMatrix", Te.matrixWorld), vt;
  }
  function $b(U, ye) {
    U.ambientLightColor.needsUpdate = ye, U.lightProbe.needsUpdate = ye, U.directionalLights.needsUpdate = ye, U.directionalLightShadows.needsUpdate = ye, U.pointLights.needsUpdate = ye, U.pointLightShadows.needsUpdate = ye, U.spotLights.needsUpdate = ye, U.spotLightShadows.needsUpdate = ye, U.rectAreaLights.needsUpdate = ye, U.hemisphereLights.needsUpdate = ye;
  }
  function qh(U) {
    return U.isMeshLambertMaterial || U.isMeshToonMaterial || U.isMeshPhongMaterial || U.isMeshStandardMaterial || U.isShadowMaterial || U.isShaderMaterial && U.lights === !0;
  }
  this.setFramebuffer = function(U) {
    y !== U && x === null && te.bindFramebuffer(36160, U), y = U;
  }, this.getActiveCubeFace = function() {
    return g;
  }, this.getActiveMipmapLevel = function() {
    return m;
  }, this.getRenderTarget = function() {
    return x;
  }, this.setRenderTarget = function(U, ye, he) {
    x = U, g = ye, m = he, U && xe.get(U).__webglFramebuffer === void 0 && we.setupRenderTarget(U);
    let Te = y, Xe = !1;
    if (U) {
      const Dt = xe.get(U).__webglFramebuffer;
      U.isWebGLCubeRenderTarget ? (Te = Dt[ye || 0], Xe = !0) : U.isWebGLMultisampleRenderTarget ? Te = xe.get(U).__webglMultisampledFramebuffer : Te = Dt, _.copy(U.viewport), E.copy(U.scissor), I = U.scissorTest;
    } else
      _.copy(D).multiplyScalar(L).floor(), E.copy(z).multiplyScalar(L).floor(), I = W;
    if (v !== Te && (te.bindFramebuffer(36160, Te), v = Te), Re.viewport(_), Re.scissor(E), Re.setScissorTest(I), Xe) {
      const Dt = xe.get(U.texture);
      te.framebufferTexture2D(36160, 36064, 34069 + (ye || 0), Dt.__webglTexture, he || 0);
    }
  }, this.readRenderTargetPixels = function(U, ye, he, Te, Xe, Dt, _t) {
    if (!(U && U.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let lt = xe.get(U).__webglFramebuffer;
    if (U.isWebGLCubeRenderTarget && _t !== void 0 && (lt = lt[_t]), lt) {
      let Tn = !1;
      lt !== v && (te.bindFramebuffer(36160, lt), Tn = !0);
      try {
        const pn = U.texture, ln = pn.format, Mn = pn.type;
        if (ln !== Zi && X.convert(ln) !== te.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        if (Mn !== $f && X.convert(Mn) !== te.getParameter(35738) && // IE11, Edge and Chrome Mac < 52 (#9513)
        !(Mn === ra && (ke.isWebGL2 || _e.get("OES_texture_float") || _e.get("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
        !(Mn === jg && (ke.isWebGL2 ? _e.get("EXT_color_buffer_float") : _e.get("EXT_color_buffer_half_float")))) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        te.checkFramebufferStatus(36160) === 36053 ? ye >= 0 && ye <= U.width - Te && he >= 0 && he <= U.height - Xe && te.readPixels(ye, he, Te, Xe, X.convert(ln), X.convert(Mn), Dt) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
      } finally {
        Tn && te.bindFramebuffer(36160, v);
      }
    }
  }, this.copyFramebufferToTexture = function(U, ye, he) {
    he === void 0 && (he = 0);
    const Te = Math.pow(2, -he), Xe = Math.floor(ye.image.width * Te), Dt = Math.floor(ye.image.height * Te), _t = X.convert(ye.format);
    we.setTexture2D(ye, 0), te.copyTexImage2D(3553, he, _t, U.x, U.y, Xe, Dt, 0), Re.unbindTexture();
  }, this.copyTextureToTexture = function(U, ye, he, Te) {
    Te === void 0 && (Te = 0);
    const Xe = ye.image.width, Dt = ye.image.height, _t = X.convert(he.format), lt = X.convert(he.type);
    we.setTexture2D(he, 0), te.pixelStorei(37440, he.flipY), te.pixelStorei(37441, he.premultiplyAlpha), te.pixelStorei(3317, he.unpackAlignment), ye.isDataTexture ? te.texSubImage2D(3553, Te, U.x, U.y, Xe, Dt, _t, lt, ye.image.data) : ye.isCompressedTexture ? te.compressedTexSubImage2D(3553, Te, U.x, U.y, ye.mipmaps[0].width, ye.mipmaps[0].height, _t, ye.mipmaps[0].data) : te.texSubImage2D(3553, Te, U.x, U.y, _t, lt, ye.image), Te === 0 && he.generateMipmaps && te.generateMipmap(3553), Re.unbindTexture();
  }, this.initTexture = function(U) {
    we.setTexture2D(U, 0), Re.unbindTexture();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
function EC(t) {
  Lf.call(this, t);
}
EC.prototype = Object.assign(Object.create(Lf.prototype), {
  constructor: EC,
  isWebGL1Renderer: !0
});
function Yv(t, e) {
  this.name = "", this.color = new st(t), this.density = e !== void 0 ? e : 25e-5;
}
Object.assign(Yv.prototype, {
  isFogExp2: !0,
  clone: function() {
    return new Yv(this.color, this.density);
  },
  toJSON: function() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
});
function Zv(t, e, n) {
  this.name = "", this.color = new st(t), this.near = e !== void 0 ? e : 1, this.far = n !== void 0 ? n : 1e3;
}
Object.assign(Zv.prototype, {
  isFog: !0,
  clone: function() {
    return new Zv(this.color, this.near, this.far);
  },
  toJSON: function() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
});
function Hi(t, e) {
  this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.usage = dx, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Et.generateUUID();
}
Object.defineProperty(Hi.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
Object.assign(Hi.prototype, {
  isInterleavedBuffer: !0,
  onUploadCallback: function() {
  },
  setUsage: function(t) {
    return this.usage = t, this;
  },
  copy: function(t) {
    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
  },
  copyAt: function(t, e, n) {
    t *= this.stride, n *= e.stride;
    for (let s = 0, i = this.stride; s < i; s++)
      this.array[t + s] = e.array[n + s];
    return this;
  },
  set: function(t, e) {
    return e === void 0 && (e = 0), this.array.set(t, e), this;
  },
  clone: function(t) {
    t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Et.generateUUID()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), n = new Hi(e, this.stride);
    return n.setUsage(this.usage), n;
  },
  onUpload: function(t) {
    return this.onUploadCallback = t, this;
  },
  toJSON: function(t) {
    return t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Et.generateUUID()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
});
const Qa = new P();
function Mc(t, e, n, s) {
  this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = s === !0;
}
Object.defineProperties(Mc.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  },
  needsUpdate: {
    set: function(t) {
      this.data.needsUpdate = t;
    }
  }
});
Object.assign(Mc.prototype, {
  isInterleavedBufferAttribute: !0,
  applyMatrix4: function(t) {
    for (let e = 0, n = this.data.count; e < n; e++)
      Qa.x = this.getX(e), Qa.y = this.getY(e), Qa.z = this.getZ(e), Qa.applyMatrix4(t), this.setXYZ(e, Qa.x, Qa.y, Qa.z);
    return this;
  },
  setX: function(t, e) {
    return this.data.array[t * this.data.stride + this.offset] = e, this;
  },
  setY: function(t, e) {
    return this.data.array[t * this.data.stride + this.offset + 1] = e, this;
  },
  setZ: function(t, e) {
    return this.data.array[t * this.data.stride + this.offset + 2] = e, this;
  },
  setW: function(t, e) {
    return this.data.array[t * this.data.stride + this.offset + 3] = e, this;
  },
  getX: function(t) {
    return this.data.array[t * this.data.stride + this.offset];
  },
  getY: function(t) {
    return this.data.array[t * this.data.stride + this.offset + 1];
  },
  getZ: function(t) {
    return this.data.array[t * this.data.stride + this.offset + 2];
  },
  getW: function(t) {
    return this.data.array[t * this.data.stride + this.offset + 3];
  },
  setXY: function(t, e, n) {
    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this;
  },
  setXYZ: function(t, e, n, s) {
    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = s, this;
  },
  setXYZW: function(t, e, n, s, i) {
    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = s, this.data.array[t + 3] = i, this;
  },
  clone: function(t) {
    if (t === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let i = 0; i < this.itemSize; i++)
          e.push(this.data.array[s + i]);
      }
      return new ut(new this.array.constructor(e), this.itemSize, this.normalized);
    } else
      return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Mc(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  },
  toJSON: function(t) {
    if (t === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let i = 0; i < this.itemSize; i++)
          e.push(this.data.array[s + i]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: e,
        normalized: this.normalized
      };
    } else
      return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
});
function Rc(t) {
  yt.call(this), this.type = "SpriteMaterial", this.color = new st(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t);
}
Rc.prototype = Object.create(yt.prototype);
Rc.prototype.constructor = Rc;
Rc.prototype.isSpriteMaterial = !0;
Rc.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this;
};
let Nl;
const ed = new P(), kl = new P(), Al = new P(), Ml = new Ce(), td = new Ce(), QE = new Mt(), Wm = new P(), nd = new P(), Hm = new P(), NC = new Ce(), ov = new Ce(), kC = new Ce();
function Jv(t) {
  if (qe.call(this), this.type = "Sprite", Nl === void 0) {
    Nl = new et();
    const e = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0,
      0.5,
      -0.5,
      0,
      1,
      0,
      0.5,
      0.5,
      0,
      1,
      1,
      -0.5,
      0.5,
      0,
      0,
      1
    ]), n = new Hi(e, 5);
    Nl.setIndex([0, 1, 2, 0, 2, 3]), Nl.setAttribute("position", new Mc(n, 3, 0, !1)), Nl.setAttribute("uv", new Mc(n, 2, 3, !1));
  }
  this.geometry = Nl, this.material = t !== void 0 ? t : new Rc(), this.center = new Ce(0.5, 0.5);
}
Jv.prototype = Object.assign(Object.create(qe.prototype), {
  constructor: Jv,
  isSprite: !0,
  raycast: function(t, e) {
    t.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), kl.setFromMatrixScale(this.matrixWorld), QE.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Al.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && kl.multiplyScalar(-Al.z);
    const n = this.material.rotation;
    let s, i;
    n !== 0 && (i = Math.cos(n), s = Math.sin(n));
    const r = this.center;
    jm(Wm.set(-0.5, -0.5, 0), Al, r, kl, s, i), jm(nd.set(0.5, -0.5, 0), Al, r, kl, s, i), jm(Hm.set(0.5, 0.5, 0), Al, r, kl, s, i), NC.set(0, 0), ov.set(1, 0), kC.set(1, 1);
    let o = t.ray.intersectTriangle(Wm, nd, Hm, !1, ed);
    if (o === null && (jm(nd.set(-0.5, 0.5, 0), Al, r, kl, s, i), ov.set(0, 1), o = t.ray.intersectTriangle(Wm, Hm, nd, !1, ed), o === null))
      return;
    const a = t.ray.origin.distanceTo(ed);
    a < t.near || a > t.far || e.push({
      distance: a,
      point: ed.clone(),
      uv: Es.getUV(ed, Wm, nd, Hm, NC, ov, kC, new Ce()),
      face: null,
      object: this
    });
  },
  copy: function(t) {
    return qe.prototype.copy.call(this, t), t.center !== void 0 && this.center.copy(t.center), this.material = t.material, this;
  }
});
function jm(t, e, n, s, i, r) {
  Ml.subVectors(t, n).addScalar(0.5).multiply(s), i !== void 0 ? (td.x = r * Ml.x - i * Ml.y, td.y = i * Ml.x + r * Ml.y) : td.copy(Ml), t.copy(e), t.x += td.x, t.y += td.y, t.applyMatrix4(QE);
}
const qm = new P(), AC = new P();
function Zg() {
  qe.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
    levels: {
      enumerable: !0,
      value: []
    }
  }), this.autoUpdate = !0;
}
Zg.prototype = Object.assign(Object.create(qe.prototype), {
  constructor: Zg,
  isLOD: !0,
  copy: function(t) {
    qe.prototype.copy.call(this, t, !1);
    const e = t.levels;
    for (let n = 0, s = e.length; n < s; n++) {
      const i = e[n];
      this.addLevel(i.object.clone(), i.distance);
    }
    return this.autoUpdate = t.autoUpdate, this;
  },
  addLevel: function(t, e) {
    e === void 0 && (e = 0), e = Math.abs(e);
    const n = this.levels;
    let s;
    for (s = 0; s < n.length && !(e < n[s].distance); s++)
      ;
    return n.splice(s, 0, { distance: e, object: t }), this.add(t), this;
  },
  getCurrentLevel: function() {
    return this._currentLevel;
  },
  getObjectForDistance: function(t) {
    const e = this.levels;
    if (e.length > 0) {
      let n, s;
      for (n = 1, s = e.length; n < s && !(t < e[n].distance); n++)
        ;
      return e[n - 1].object;
    }
    return null;
  },
  raycast: function(t, e) {
    if (this.levels.length > 0) {
      qm.setFromMatrixPosition(this.matrixWorld);
      const s = t.ray.origin.distanceTo(qm);
      this.getObjectForDistance(s).raycast(t, e);
    }
  },
  update: function(t) {
    const e = this.levels;
    if (e.length > 1) {
      qm.setFromMatrixPosition(t.matrixWorld), AC.setFromMatrixPosition(this.matrixWorld);
      const n = qm.distanceTo(AC) / t.zoom;
      e[0].object.visible = !0;
      let s, i;
      for (s = 1, i = e.length; s < i && n >= e[s].distance; s++)
        e[s - 1].object.visible = !1, e[s].object.visible = !0;
      for (this._currentLevel = s - 1; s < i; s++)
        e[s].object.visible = !1;
    }
  },
  toJSON: function(t) {
    const e = qe.prototype.toJSON.call(this, t);
    this.autoUpdate === !1 && (e.object.autoUpdate = !1), e.object.levels = [];
    const n = this.levels;
    for (let s = 0, i = n.length; s < i; s++) {
      const r = n[s];
      e.object.levels.push({
        object: r.object.uuid,
        distance: r.distance
      });
    }
    return e;
  }
});
function Qv(t, e) {
  t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), cn.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Mt(), this.bindMatrixInverse = new Mt();
}
Qv.prototype = Object.assign(Object.create(cn.prototype), {
  constructor: Qv,
  isSkinnedMesh: !0,
  copy: function(t) {
    return cn.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this;
  },
  bind: function(t, e) {
    this.skeleton = t, e === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e);
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    const t = new en(), e = this.geometry.attributes.skinWeight;
    for (let n = 0, s = e.count; n < s; n++) {
      t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
      const i = 1 / t.manhattanLength();
      i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w);
    }
  },
  updateMatrixWorld: function(t) {
    cn.prototype.updateMatrixWorld.call(this, t), this.bindMode === "attached" ? this.bindMatrixInverse.getInverse(this.matrixWorld) : this.bindMode === "detached" ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  },
  boneTransform: function() {
    const t = new P(), e = new en(), n = new en(), s = new P(), i = new Mt();
    return function(r, o) {
      const a = this.skeleton, c = this.geometry;
      e.fromBufferAttribute(c.attributes.skinIndex, r), n.fromBufferAttribute(c.attributes.skinWeight, r), t.fromBufferAttribute(c.attributes.position, r).applyMatrix4(this.bindMatrix), o.set(0, 0, 0);
      for (let l = 0; l < 4; l++) {
        const u = n.getComponent(l);
        if (u !== 0) {
          const h = e.getComponent(l);
          i.multiplyMatrices(a.bones[h].matrixWorld, a.boneInverses[h]), o.addScaledVector(s.copy(t).applyMatrix4(i), u);
        }
      }
      return o.applyMatrix4(this.bindMatrixInverse);
    };
  }()
});
const MC = new Mt(), Fz = new Mt();
function ew(t, e) {
  if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(this.bones.length * 16), this.frame = -1, e === void 0)
    this.calculateInverses();
  else if (this.bones.length === e.length)
    this.boneInverses = e.slice(0);
  else {
    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
    for (let n = 0, s = this.bones.length; n < s; n++)
      this.boneInverses.push(new Mt());
  }
}
Object.assign(ew.prototype, {
  calculateInverses: function() {
    this.boneInverses = [];
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = new Mt();
      this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n);
    }
  },
  pose: function() {
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t];
      n && n.matrixWorld.getInverse(this.boneInverses[t]);
    }
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t];
      n && (n.parent && n.parent.isBone ? (n.matrix.getInverse(n.parent.matrixWorld), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  },
  update: function() {
    const t = this.bones, e = this.boneInverses, n = this.boneMatrices, s = this.boneTexture;
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i] ? t[i].matrixWorld : Fz;
      MC.multiplyMatrices(o, e[i]), MC.toArray(n, i * 16);
    }
    s !== void 0 && (s.needsUpdate = !0);
  },
  clone: function() {
    return new ew(this.bones, this.boneInverses);
  },
  getBoneByName: function(t) {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const s = this.bones[e];
      if (s.name === t)
        return s;
    }
  },
  dispose: function() {
    this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0);
  }
});
function RC() {
  qe.call(this), this.type = "Bone";
}
RC.prototype = Object.assign(Object.create(qe.prototype), {
  constructor: RC,
  isBone: !0
});
const DC = new Mt(), $C = new Mt(), Xm = [], sd = new cn();
function tw(t, e, n) {
  cn.call(this, t, e), this.instanceMatrix = new ut(new Float32Array(n * 16), 16), this.count = n, this.frustumCulled = !1;
}
tw.prototype = Object.assign(Object.create(cn.prototype), {
  constructor: tw,
  isInstancedMesh: !0,
  copy: function(t) {
    return cn.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this;
  },
  getMatrixAt: function(t, e) {
    e.fromArray(this.instanceMatrix.array, t * 16);
  },
  raycast: function(t, e) {
    const n = this.matrixWorld, s = this.count;
    if (sd.geometry = this.geometry, sd.material = this.material, sd.material !== void 0)
      for (let i = 0; i < s; i++) {
        this.getMatrixAt(i, DC), $C.multiplyMatrices(n, DC), sd.matrixWorld = $C, sd.raycast(t, Xm);
        for (let r = 0, o = Xm.length; r < o; r++) {
          const a = Xm[r];
          a.instanceId = i, a.object = this, e.push(a);
        }
        Xm.length = 0;
      }
  },
  setMatrixAt: function(t, e) {
    e.toArray(this.instanceMatrix.array, t * 16);
  },
  updateMorphTargets: function() {
  }
});
function Bn(t) {
  yt.call(this), this.type = "LineBasicMaterial", this.color = new st(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t);
}
Bn.prototype = Object.create(yt.prototype);
Bn.prototype.constructor = Bn;
Bn.prototype.isLineBasicMaterial = !0;
Bn.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this;
};
const OC = new P(), LC = new P(), FC = new Mt(), Km = new $u(), Ym = new Bo();
function nr(t, e, n) {
  n === 1 && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), qe.call(this), this.type = "Line", this.geometry = t !== void 0 ? t : new et(), this.material = e !== void 0 ? e : new Bn(), this.updateMorphTargets();
}
nr.prototype = Object.assign(Object.create(qe.prototype), {
  constructor: nr,
  isLine: !0,
  copy: function(t) {
    return qe.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this;
  },
  computeLineDistances: function() {
    const t = this.geometry;
    if (t.isBufferGeometry)
      if (t.index === null) {
        const e = t.attributes.position, n = [0];
        for (let s = 1, i = e.count; s < i; s++)
          OC.fromBufferAttribute(e, s - 1), LC.fromBufferAttribute(e, s), n[s] = n[s - 1], n[s] += OC.distanceTo(LC);
        t.setAttribute("lineDistance", new Ze(n, 1));
      } else
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else if (t.isGeometry) {
      const e = t.vertices, n = t.lineDistances;
      n[0] = 0;
      for (let s = 1, i = e.length; s < i; s++)
        n[s] = n[s - 1], n[s] += e[s - 1].distanceTo(e[s]);
    }
    return this;
  },
  raycast: function(t, e) {
    const n = this.geometry, s = this.matrixWorld, i = t.params.Line.threshold;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Ym.copy(n.boundingSphere), Ym.applyMatrix4(s), Ym.radius += i, t.ray.intersectsSphere(Ym) === !1)
      return;
    FC.getInverse(s), Km.copy(t.ray).applyMatrix4(FC);
    const r = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = r * r, a = new P(), c = new P(), l = new P(), u = new P(), h = this && this.isLineSegments ? 2 : 1;
    if (n.isBufferGeometry) {
      const d = n.index, p = n.attributes.position.array;
      if (d !== null) {
        const y = d.array;
        for (let g = 0, m = y.length - 1; g < m; g += h) {
          const x = y[g], v = y[g + 1];
          if (a.fromArray(p, x * 3), c.fromArray(p, v * 3), Km.distanceSqToSegment(a, c, u, l) > o)
            continue;
          u.applyMatrix4(this.matrixWorld);
          const w = t.ray.origin.distanceTo(u);
          w < t.near || w > t.far || e.push({
            distance: w,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: l.clone().applyMatrix4(this.matrixWorld),
            index: g,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else
        for (let y = 0, g = p.length / 3 - 1; y < g; y += h) {
          if (a.fromArray(p, 3 * y), c.fromArray(p, 3 * y + 3), Km.distanceSqToSegment(a, c, u, l) > o)
            continue;
          u.applyMatrix4(this.matrixWorld);
          const x = t.ray.origin.distanceTo(u);
          x < t.near || x > t.far || e.push({
            distance: x,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: l.clone().applyMatrix4(this.matrixWorld),
            index: y,
            face: null,
            faceIndex: null,
            object: this
          });
        }
    } else if (n.isGeometry) {
      const d = n.vertices, f = d.length;
      for (let p = 0; p < f - 1; p += h) {
        if (Km.distanceSqToSegment(d[p], d[p + 1], u, l) > o)
          continue;
        u.applyMatrix4(this.matrixWorld);
        const g = t.ray.origin.distanceTo(u);
        g < t.near || g > t.far || e.push({
          distance: g,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: l.clone().applyMatrix4(this.matrixWorld),
          index: p,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  },
  updateMorphTargets: function() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes, n = Object.keys(e);
      if (n.length > 0) {
        const s = e[n[0]];
        if (s !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let i = 0, r = s.length; i < r; i++) {
            const o = s[i].name || String(i);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i;
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
});
const Zm = new P(), Jm = new P();
function ns(t, e) {
  nr.call(this, t, e), this.type = "LineSegments";
}
ns.prototype = Object.assign(Object.create(nr.prototype), {
  constructor: ns,
  isLineSegments: !0,
  computeLineDistances: function() {
    const t = this.geometry;
    if (t.isBufferGeometry)
      if (t.index === null) {
        const e = t.attributes.position, n = [];
        for (let s = 0, i = e.count; s < i; s += 2)
          Zm.fromBufferAttribute(e, s), Jm.fromBufferAttribute(e, s + 1), n[s] = s === 0 ? 0 : n[s - 1], n[s + 1] = n[s] + Zm.distanceTo(Jm);
        t.setAttribute("lineDistance", new Ze(n, 1));
      } else
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else if (t.isGeometry) {
      const e = t.vertices, n = t.lineDistances;
      for (let s = 0, i = e.length; s < i; s += 2)
        Zm.copy(e[s]), Jm.copy(e[s + 1]), n[s] = s === 0 ? 0 : n[s - 1], n[s + 1] = n[s] + Zm.distanceTo(Jm);
    }
    return this;
  }
});
function nw(t, e) {
  nr.call(this, t, e), this.type = "LineLoop";
}
nw.prototype = Object.assign(Object.create(nr.prototype), {
  constructor: nw,
  isLineLoop: !0
});
function ba(t) {
  yt.call(this), this.type = "PointsMaterial", this.color = new st(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t);
}
ba.prototype = Object.create(yt.prototype);
ba.prototype.constructor = ba;
ba.prototype.isPointsMaterial = !0;
ba.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this;
};
const PC = new Mt(), sw = new $u(), Qm = new Bo(), eg = new P();
function Jg(t, e) {
  qe.call(this), this.type = "Points", this.geometry = t !== void 0 ? t : new et(), this.material = e !== void 0 ? e : new ba(), this.updateMorphTargets();
}
Jg.prototype = Object.assign(Object.create(qe.prototype), {
  constructor: Jg,
  isPoints: !0,
  copy: function(t) {
    return qe.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this;
  },
  raycast: function(t, e) {
    const n = this.geometry, s = this.matrixWorld, i = t.params.Points.threshold;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Qm.copy(n.boundingSphere), Qm.applyMatrix4(s), Qm.radius += i, t.ray.intersectsSphere(Qm) === !1)
      return;
    PC.getInverse(s), sw.copy(t.ray).applyMatrix4(PC);
    const r = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = r * r;
    if (n.isBufferGeometry) {
      const a = n.index, l = n.attributes.position.array;
      if (a !== null) {
        const u = a.array;
        for (let h = 0, d = u.length; h < d; h++) {
          const f = u[h];
          eg.fromArray(l, f * 3), av(eg, f, o, s, t, e, this);
        }
      } else
        for (let u = 0, h = l.length / 3; u < h; u++)
          eg.fromArray(l, u * 3), av(eg, u, o, s, t, e, this);
    } else {
      const a = n.vertices;
      for (let c = 0, l = a.length; c < l; c++)
        av(a[c], c, o, s, t, e, this);
    }
  },
  updateMorphTargets: function() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes, n = Object.keys(e);
      if (n.length > 0) {
        const s = e[n[0]];
        if (s !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let i = 0, r = s.length; i < r; i++) {
            const o = s[i].name || String(i);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i;
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
});
function av(t, e, n, s, i, r, o) {
  const a = sw.distanceSqToPoint(t);
  if (a < n) {
    const c = new P();
    sw.closestPointToPoint(t, c), c.applyMatrix4(s);
    const l = i.ray.origin.distanceTo(c);
    if (l < i.near || l > i.far)
      return;
    r.push({
      distance: l,
      distanceToRay: Math.sqrt(a),
      point: c,
      index: e,
      face: null,
      object: o
    });
  }
}
function BC(t, e, n, s, i, r, o, a, c) {
  dn.call(this, t, e, n, s, i, r, o, a, c), this.format = o !== void 0 ? o : xc, this.minFilter = r !== void 0 ? r : Vs, this.magFilter = i !== void 0 ? i : Vs, this.generateMipmaps = !1;
  const l = this;
  function u() {
    l.needsUpdate = !0, t.requestVideoFrameCallback(u);
  }
  "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(u);
}
BC.prototype = Object.assign(Object.create(dn.prototype), {
  constructor: BC,
  isVideoTexture: !0,
  update: function() {
    const t = this.image;
    "requestVideoFrameCallback" in t === !1 && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
});
function Ld(t, e, n, s, i, r, o, a, c, l, u, h) {
  dn.call(this, null, r, o, a, c, l, s, i, u, h), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1;
}
Ld.prototype = Object.create(dn.prototype);
Ld.prototype.constructor = Ld;
Ld.prototype.isCompressedTexture = !0;
function Fd(t, e, n, s, i, r, o, a, c) {
  dn.call(this, t, e, n, s, i, r, o, a, c), this.needsUpdate = !0;
}
Fd.prototype = Object.create(dn.prototype);
Fd.prototype.constructor = Fd;
Fd.prototype.isCanvasTexture = !0;
function Qg(t, e, n, s, i, r, o, a, c, l) {
  if (l = l !== void 0 ? l : ql, l !== ql && l !== Ed)
    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
  n === void 0 && l === ql && (n = Hg), n === void 0 && l === Ed && (n = wd), dn.call(this, null, s, i, r, o, a, l, n, c), this.image = { width: t, height: e }, this.magFilter = o !== void 0 ? o : ps, this.minFilter = a !== void 0 ? a : ps, this.flipY = !1, this.generateMipmaps = !1;
}
Qg.prototype = Object.create(dn.prototype);
Qg.prototype.constructor = Qg;
Qg.prototype.isDepthTexture = !0;
function ey(t) {
  et.call(this), this.type = "WireframeGeometry";
  const e = [], n = [0, 0], s = {}, i = ["a", "b", "c"];
  if (t && t.isGeometry) {
    const r = t.faces;
    for (let o = 0, a = r.length; o < a; o++) {
      const c = r[o];
      for (let l = 0; l < 3; l++) {
        const u = c[i[l]], h = c[i[(l + 1) % 3]];
        n[0] = Math.min(u, h), n[1] = Math.max(u, h);
        const d = n[0] + "," + n[1];
        s[d] === void 0 && (s[d] = { index1: n[0], index2: n[1] });
      }
    }
    for (const o in s) {
      const a = s[o];
      let c = t.vertices[a.index1];
      e.push(c.x, c.y, c.z), c = t.vertices[a.index2], e.push(c.x, c.y, c.z);
    }
  } else if (t && t.isBufferGeometry) {
    let r = new P();
    if (t.index !== null) {
      const o = t.attributes.position, a = t.index;
      let c = t.groups;
      c.length === 0 && (c = [{ start: 0, count: a.count, materialIndex: 0 }]);
      for (let l = 0, u = c.length; l < u; ++l) {
        const h = c[l], d = h.start, f = h.count;
        for (let p = d, y = d + f; p < y; p += 3)
          for (let g = 0; g < 3; g++) {
            const m = a.getX(p + g), x = a.getX(p + (g + 1) % 3);
            n[0] = Math.min(m, x), n[1] = Math.max(m, x);
            const v = n[0] + "," + n[1];
            s[v] === void 0 && (s[v] = { index1: n[0], index2: n[1] });
          }
      }
      for (const l in s) {
        const u = s[l];
        r.fromBufferAttribute(o, u.index1), e.push(r.x, r.y, r.z), r.fromBufferAttribute(o, u.index2), e.push(r.x, r.y, r.z);
      }
    } else {
      const o = t.attributes.position;
      for (let a = 0, c = o.count / 3; a < c; a++)
        for (let l = 0; l < 3; l++) {
          const u = 3 * a + l;
          r.fromBufferAttribute(o, u), e.push(r.x, r.y, r.z);
          const h = 3 * a + (l + 1) % 3;
          r.fromBufferAttribute(o, h), e.push(r.x, r.y, r.z);
        }
    }
  }
  this.setAttribute("position", new Ze(e, 3));
}
ey.prototype = Object.create(et.prototype);
ey.prototype.constructor = ey;
function ty(t, e, n) {
  xt.call(this), this.type = "ParametricGeometry", this.parameters = {
    func: t,
    slices: e,
    stacks: n
  }, this.fromBufferGeometry(new Pd(t, e, n)), this.mergeVertices();
}
ty.prototype = Object.create(xt.prototype);
ty.prototype.constructor = ty;
function Pd(t, e, n) {
  et.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
    func: t,
    slices: e,
    stacks: n
  };
  const s = [], i = [], r = [], o = [], a = 1e-5, c = new P(), l = new P(), u = new P(), h = new P(), d = new P();
  t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  const f = e + 1;
  for (let p = 0; p <= n; p++) {
    const y = p / n;
    for (let g = 0; g <= e; g++) {
      const m = g / e;
      t(m, y, l), i.push(l.x, l.y, l.z), m - a >= 0 ? (t(m - a, y, u), h.subVectors(l, u)) : (t(m + a, y, u), h.subVectors(u, l)), y - a >= 0 ? (t(m, y - a, u), d.subVectors(l, u)) : (t(m, y + a, u), d.subVectors(u, l)), c.crossVectors(h, d).normalize(), r.push(c.x, c.y, c.z), o.push(m, y);
    }
  }
  for (let p = 0; p < n; p++)
    for (let y = 0; y < e; y++) {
      const g = p * f + y, m = p * f + y + 1, x = (p + 1) * f + y + 1, v = (p + 1) * f + y;
      s.push(g, m, v), s.push(m, x, v);
    }
  this.setIndex(s), this.setAttribute("position", new Ze(i, 3)), this.setAttribute("normal", new Ze(r, 3)), this.setAttribute("uv", new Ze(o, 2));
}
Pd.prototype = Object.create(et.prototype);
Pd.prototype.constructor = Pd;
function ny(t, e, n, s) {
  xt.call(this), this.type = "PolyhedronGeometry", this.parameters = {
    vertices: t,
    indices: e,
    radius: n,
    detail: s
  }, this.fromBufferGeometry(new $i(t, e, n, s)), this.mergeVertices();
}
ny.prototype = Object.create(xt.prototype);
ny.prototype.constructor = ny;
function $i(t, e, n, s) {
  et.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
    vertices: t,
    indices: e,
    radius: n,
    detail: s
  }, n = n || 1, s = s || 0;
  const i = [], r = [];
  o(s), c(n), l(), this.setAttribute("position", new Ze(i, 3)), this.setAttribute("normal", new Ze(i.slice(), 3)), this.setAttribute("uv", new Ze(r, 2)), s === 0 ? this.computeVertexNormals() : this.normalizeNormals();
  function o(m) {
    const x = new P(), v = new P(), b = new P();
    for (let w = 0; w < e.length; w += 3)
      d(e[w + 0], x), d(e[w + 1], v), d(e[w + 2], b), a(x, v, b, m);
  }
  function a(m, x, v, b) {
    const w = Math.pow(2, b), S = [];
    for (let _ = 0; _ <= w; _++) {
      S[_] = [];
      const E = m.clone().lerp(v, _ / w), I = x.clone().lerp(v, _ / w), k = w - _;
      for (let M = 0; M <= k; M++)
        M === 0 && _ === w ? S[_][M] = E : S[_][M] = E.clone().lerp(I, M / k);
    }
    for (let _ = 0; _ < w; _++)
      for (let E = 0; E < 2 * (w - _) - 1; E++) {
        const I = Math.floor(E / 2);
        E % 2 === 0 ? (h(S[_][I + 1]), h(S[_ + 1][I]), h(S[_][I])) : (h(S[_][I + 1]), h(S[_ + 1][I + 1]), h(S[_ + 1][I]));
      }
  }
  function c(m) {
    const x = new P();
    for (let v = 0; v < i.length; v += 3)
      x.x = i[v + 0], x.y = i[v + 1], x.z = i[v + 2], x.normalize().multiplyScalar(m), i[v + 0] = x.x, i[v + 1] = x.y, i[v + 2] = x.z;
  }
  function l() {
    const m = new P();
    for (let x = 0; x < i.length; x += 3) {
      m.x = i[x + 0], m.y = i[x + 1], m.z = i[x + 2];
      const v = y(m) / 2 / Math.PI + 0.5, b = g(m) / Math.PI + 0.5;
      r.push(v, 1 - b);
    }
    f(), u();
  }
  function u() {
    for (let m = 0; m < r.length; m += 6) {
      const x = r[m + 0], v = r[m + 2], b = r[m + 4], w = Math.max(x, v, b), S = Math.min(x, v, b);
      w > 0.9 && S < 0.1 && (x < 0.2 && (r[m + 0] += 1), v < 0.2 && (r[m + 2] += 1), b < 0.2 && (r[m + 4] += 1));
    }
  }
  function h(m) {
    i.push(m.x, m.y, m.z);
  }
  function d(m, x) {
    const v = m * 3;
    x.x = t[v + 0], x.y = t[v + 1], x.z = t[v + 2];
  }
  function f() {
    const m = new P(), x = new P(), v = new P(), b = new P(), w = new Ce(), S = new Ce(), _ = new Ce();
    for (let E = 0, I = 0; E < i.length; E += 9, I += 6) {
      m.set(i[E + 0], i[E + 1], i[E + 2]), x.set(i[E + 3], i[E + 4], i[E + 5]), v.set(i[E + 6], i[E + 7], i[E + 8]), w.set(r[I + 0], r[I + 1]), S.set(r[I + 2], r[I + 3]), _.set(r[I + 4], r[I + 5]), b.copy(m).add(x).add(v).divideScalar(3);
      const k = y(b);
      p(w, I + 0, m, k), p(S, I + 2, x, k), p(_, I + 4, v, k);
    }
  }
  function p(m, x, v, b) {
    b < 0 && m.x === 1 && (r[x] = m.x - 1), v.x === 0 && v.z === 0 && (r[x] = b / 2 / Math.PI + 0.5);
  }
  function y(m) {
    return Math.atan2(m.z, -m.x);
  }
  function g(m) {
    return Math.atan2(-m.y, Math.sqrt(m.x * m.x + m.z * m.z));
  }
}
$i.prototype = Object.create(et.prototype);
$i.prototype.constructor = $i;
function sy(t, e) {
  xt.call(this), this.type = "TetrahedronGeometry", this.parameters = {
    radius: t,
    detail: e
  }, this.fromBufferGeometry(new Bd(t, e)), this.mergeVertices();
}
sy.prototype = Object.create(xt.prototype);
sy.prototype.constructor = sy;
function Bd(t, e) {
  const n = [
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    -1,
    -1
  ], s = [
    2,
    1,
    0,
    0,
    3,
    2,
    1,
    3,
    0,
    2,
    3,
    1
  ];
  $i.call(this, n, s, t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
    radius: t,
    detail: e
  };
}
Bd.prototype = Object.create($i.prototype);
Bd.prototype.constructor = Bd;
function iy(t, e) {
  xt.call(this), this.type = "OctahedronGeometry", this.parameters = {
    radius: t,
    detail: e
  }, this.fromBufferGeometry(new su(t, e)), this.mergeVertices();
}
iy.prototype = Object.create(xt.prototype);
iy.prototype.constructor = iy;
function su(t, e) {
  const n = [
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1
  ], s = [
    0,
    2,
    4,
    0,
    4,
    3,
    0,
    3,
    5,
    0,
    5,
    2,
    1,
    2,
    5,
    1,
    5,
    3,
    1,
    3,
    4,
    1,
    4,
    2
  ];
  $i.call(this, n, s, t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
    radius: t,
    detail: e
  };
}
su.prototype = Object.create($i.prototype);
su.prototype.constructor = su;
function ry(t, e) {
  xt.call(this), this.type = "IcosahedronGeometry", this.parameters = {
    radius: t,
    detail: e
  }, this.fromBufferGeometry(new zd(t, e)), this.mergeVertices();
}
ry.prototype = Object.create(xt.prototype);
ry.prototype.constructor = ry;
function zd(t, e) {
  const n = (1 + Math.sqrt(5)) / 2, s = [
    -1,
    n,
    0,
    1,
    n,
    0,
    -1,
    -n,
    0,
    1,
    -n,
    0,
    0,
    -1,
    n,
    0,
    1,
    n,
    0,
    -1,
    -n,
    0,
    1,
    -n,
    n,
    0,
    -1,
    n,
    0,
    1,
    -n,
    0,
    -1,
    -n,
    0,
    1
  ], i = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    0,
    10,
    11,
    1,
    5,
    9,
    5,
    11,
    4,
    11,
    10,
    2,
    10,
    7,
    6,
    7,
    1,
    8,
    3,
    9,
    4,
    3,
    4,
    2,
    3,
    2,
    6,
    3,
    6,
    8,
    3,
    8,
    9,
    4,
    9,
    5,
    2,
    4,
    11,
    6,
    2,
    10,
    8,
    6,
    7,
    9,
    8,
    1
  ];
  $i.call(this, s, i, t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
    radius: t,
    detail: e
  };
}
zd.prototype = Object.create($i.prototype);
zd.prototype.constructor = zd;
function oy(t, e) {
  xt.call(this), this.type = "DodecahedronGeometry", this.parameters = {
    radius: t,
    detail: e
  }, this.fromBufferGeometry(new Vd(t, e)), this.mergeVertices();
}
oy.prototype = Object.create(xt.prototype);
oy.prototype.constructor = oy;
function Vd(t, e) {
  const n = (1 + Math.sqrt(5)) / 2, s = 1 / n, i = [
    // (1, 1, 1)
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    1,
    1,
    // (0, 1/, )
    0,
    -s,
    -n,
    0,
    -s,
    n,
    0,
    s,
    -n,
    0,
    s,
    n,
    // (1/, , 0)
    -s,
    -n,
    0,
    -s,
    n,
    0,
    s,
    -n,
    0,
    s,
    n,
    0,
    // (, 0, 1/)
    -n,
    0,
    -s,
    n,
    0,
    -s,
    -n,
    0,
    s,
    n,
    0,
    s
  ], r = [
    3,
    11,
    7,
    3,
    7,
    15,
    3,
    15,
    13,
    7,
    19,
    17,
    7,
    17,
    6,
    7,
    6,
    15,
    17,
    4,
    8,
    17,
    8,
    10,
    17,
    10,
    6,
    8,
    0,
    16,
    8,
    16,
    2,
    8,
    2,
    10,
    0,
    12,
    1,
    0,
    1,
    18,
    0,
    18,
    16,
    6,
    10,
    2,
    6,
    2,
    13,
    6,
    13,
    15,
    2,
    16,
    18,
    2,
    18,
    3,
    2,
    3,
    13,
    18,
    1,
    9,
    18,
    9,
    11,
    18,
    11,
    3,
    4,
    14,
    12,
    4,
    12,
    0,
    4,
    0,
    8,
    11,
    9,
    5,
    11,
    5,
    19,
    11,
    19,
    7,
    19,
    5,
    14,
    19,
    14,
    4,
    19,
    4,
    17,
    1,
    12,
    14,
    1,
    14,
    5,
    1,
    5,
    9
  ];
  $i.call(this, i, r, t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
    radius: t,
    detail: e
  };
}
Vd.prototype = Object.create($i.prototype);
Vd.prototype.constructor = Vd;
function ay(t, e, n, s, i, r) {
  xt.call(this), this.type = "TubeGeometry", this.parameters = {
    path: t,
    tubularSegments: e,
    radius: n,
    radialSegments: s,
    closed: i
  }, r !== void 0 && console.warn("THREE.TubeGeometry: taper has been removed.");
  const o = new iu(t, e, n, s, i);
  this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this.fromBufferGeometry(o), this.mergeVertices();
}
ay.prototype = Object.create(xt.prototype);
ay.prototype.constructor = ay;
function iu(t, e, n, s, i) {
  et.call(this), this.type = "TubeBufferGeometry", this.parameters = {
    path: t,
    tubularSegments: e,
    radius: n,
    radialSegments: s,
    closed: i
  }, e = e || 64, n = n || 1, s = s || 8, i = i || !1;
  const r = t.computeFrenetFrames(e, i);
  this.tangents = r.tangents, this.normals = r.normals, this.binormals = r.binormals;
  const o = new P(), a = new P(), c = new Ce();
  let l = new P();
  const u = [], h = [], d = [], f = [];
  p(), this.setIndex(f), this.setAttribute("position", new Ze(u, 3)), this.setAttribute("normal", new Ze(h, 3)), this.setAttribute("uv", new Ze(d, 2));
  function p() {
    for (let x = 0; x < e; x++)
      y(x);
    y(i === !1 ? e : 0), m(), g();
  }
  function y(x) {
    l = t.getPointAt(x / e, l);
    const v = r.normals[x], b = r.binormals[x];
    for (let w = 0; w <= s; w++) {
      const S = w / s * Math.PI * 2, _ = Math.sin(S), E = -Math.cos(S);
      a.x = E * v.x + _ * b.x, a.y = E * v.y + _ * b.y, a.z = E * v.z + _ * b.z, a.normalize(), h.push(a.x, a.y, a.z), o.x = l.x + n * a.x, o.y = l.y + n * a.y, o.z = l.z + n * a.z, u.push(o.x, o.y, o.z);
    }
  }
  function g() {
    for (let x = 1; x <= e; x++)
      for (let v = 1; v <= s; v++) {
        const b = (s + 1) * (x - 1) + (v - 1), w = (s + 1) * x + (v - 1), S = (s + 1) * x + v, _ = (s + 1) * (x - 1) + v;
        f.push(b, w, _), f.push(w, S, _);
      }
  }
  function m() {
    for (let x = 0; x <= e; x++)
      for (let v = 0; v <= s; v++)
        c.x = x / e, c.y = v / s, d.push(c.x, c.y);
  }
}
iu.prototype = Object.create(et.prototype);
iu.prototype.constructor = iu;
iu.prototype.toJSON = function() {
  const t = et.prototype.toJSON.call(this);
  return t.path = this.parameters.path.toJSON(), t;
};
function cy(t, e, n, s, i, r, o) {
  xt.call(this), this.type = "TorusKnotGeometry", this.parameters = {
    radius: t,
    tube: e,
    tubularSegments: n,
    radialSegments: s,
    p: i,
    q: r
  }, o !== void 0 && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Ud(t, e, n, s, i, r)), this.mergeVertices();
}
cy.prototype = Object.create(xt.prototype);
cy.prototype.constructor = cy;
function Ud(t, e, n, s, i, r) {
  et.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
    radius: t,
    tube: e,
    tubularSegments: n,
    radialSegments: s,
    p: i,
    q: r
  }, t = t || 1, e = e || 0.4, n = Math.floor(n) || 64, s = Math.floor(s) || 8, i = i || 2, r = r || 3;
  const o = [], a = [], c = [], l = [], u = new P(), h = new P(), d = new P(), f = new P(), p = new P(), y = new P(), g = new P();
  for (let x = 0; x <= n; ++x) {
    const v = x / n * i * Math.PI * 2;
    m(v, i, r, t, d), m(v + 0.01, i, r, t, f), y.subVectors(f, d), g.addVectors(f, d), p.crossVectors(y, g), g.crossVectors(p, y), p.normalize(), g.normalize();
    for (let b = 0; b <= s; ++b) {
      const w = b / s * Math.PI * 2, S = -e * Math.cos(w), _ = e * Math.sin(w);
      u.x = d.x + (S * g.x + _ * p.x), u.y = d.y + (S * g.y + _ * p.y), u.z = d.z + (S * g.z + _ * p.z), a.push(u.x, u.y, u.z), h.subVectors(u, d).normalize(), c.push(h.x, h.y, h.z), l.push(x / n), l.push(b / s);
    }
  }
  for (let x = 1; x <= n; x++)
    for (let v = 1; v <= s; v++) {
      const b = (s + 1) * (x - 1) + (v - 1), w = (s + 1) * x + (v - 1), S = (s + 1) * x + v, _ = (s + 1) * (x - 1) + v;
      o.push(b, w, _), o.push(w, S, _);
    }
  this.setIndex(o), this.setAttribute("position", new Ze(a, 3)), this.setAttribute("normal", new Ze(c, 3)), this.setAttribute("uv", new Ze(l, 2));
  function m(x, v, b, w, S) {
    const _ = Math.cos(x), E = Math.sin(x), I = b / v * x, k = Math.cos(I);
    S.x = w * (2 + k) * 0.5 * _, S.y = w * (2 + k) * E * 0.5, S.z = w * Math.sin(I) * 0.5;
  }
}
Ud.prototype = Object.create(et.prototype);
Ud.prototype.constructor = Ud;
function ly(t, e, n, s, i) {
  xt.call(this), this.type = "TorusGeometry", this.parameters = {
    radius: t,
    tube: e,
    radialSegments: n,
    tubularSegments: s,
    arc: i
  }, this.fromBufferGeometry(new Gd(t, e, n, s, i)), this.mergeVertices();
}
ly.prototype = Object.create(xt.prototype);
ly.prototype.constructor = ly;
function Gd(t, e, n, s, i) {
  et.call(this), this.type = "TorusBufferGeometry", this.parameters = {
    radius: t,
    tube: e,
    radialSegments: n,
    tubularSegments: s,
    arc: i
  }, t = t || 1, e = e || 0.4, n = Math.floor(n) || 8, s = Math.floor(s) || 6, i = i || Math.PI * 2;
  const r = [], o = [], a = [], c = [], l = new P(), u = new P(), h = new P();
  for (let d = 0; d <= n; d++)
    for (let f = 0; f <= s; f++) {
      const p = f / s * i, y = d / n * Math.PI * 2;
      u.x = (t + e * Math.cos(y)) * Math.cos(p), u.y = (t + e * Math.cos(y)) * Math.sin(p), u.z = e * Math.sin(y), o.push(u.x, u.y, u.z), l.x = t * Math.cos(p), l.y = t * Math.sin(p), h.subVectors(u, l).normalize(), a.push(h.x, h.y, h.z), c.push(f / s), c.push(d / n);
    }
  for (let d = 1; d <= n; d++)
    for (let f = 1; f <= s; f++) {
      const p = (s + 1) * d + f - 1, y = (s + 1) * (d - 1) + f - 1, g = (s + 1) * (d - 1) + f, m = (s + 1) * d + f;
      r.push(p, y, m), r.push(y, g, m);
    }
  this.setIndex(r), this.setAttribute("position", new Ze(o, 3)), this.setAttribute("normal", new Ze(a, 3)), this.setAttribute("uv", new Ze(c, 2));
}
Gd.prototype = Object.create(et.prototype);
Gd.prototype.constructor = Gd;
const Pz = {
  triangulate: function(t, e, n) {
    n = n || 2;
    let s = e && e.length, i = s ? e[0] * n : t.length, r = eN(t, 0, i, n, !0), o = [];
    if (!r || r.next === r.prev)
      return o;
    let a, c, l, u, h, d, f;
    if (s && (r = Gz(t, e, r, n)), t.length > 80 * n) {
      a = l = t[0], c = u = t[1];
      for (let p = n; p < i; p += n)
        h = t[p], d = t[p + 1], h < a && (a = h), d < c && (c = d), h > l && (l = h), d > u && (u = d);
      f = Math.max(l - a, u - c), f = f !== 0 ? 1 / f : 0;
    }
    return Wd(r, o, n, a, c, f), o;
  }
};
function eN(t, e, n, s, i) {
  let r, o;
  if (i === eV(t, e, n, s) > 0)
    for (r = e; r < n; r += s)
      o = zC(r, t[r], t[r + 1], o);
  else
    for (r = n - s; r >= e; r -= s)
      o = zC(r, t[r], t[r + 1], o);
  return o && px(o, o.next) && (jd(o), o = o.next), o;
}
function va(t, e) {
  if (!t)
    return t;
  e || (e = t);
  let n = t, s;
  do
    if (s = !1, !n.steiner && (px(n, n.next) || Dn(n.prev, n, n.next) === 0)) {
      if (jd(n), n = e = n.prev, n === n.next)
        break;
      s = !0;
    } else
      n = n.next;
  while (s || n !== e);
  return e;
}
function Wd(t, e, n, s, i, r, o) {
  if (!t)
    return;
  !o && r && Xz(t, s, i, r);
  let a = t, c, l;
  for (; t.prev !== t.next; ) {
    if (c = t.prev, l = t.next, r ? zz(t, s, i, r) : Bz(t)) {
      e.push(c.i / n), e.push(t.i / n), e.push(l.i / n), jd(t), t = l.next, a = l.next;
      continue;
    }
    if (t = l, t === a) {
      o ? o === 1 ? (t = Vz(va(t), e, n), Wd(t, e, n, s, i, r, 2)) : o === 2 && Uz(t, e, n, s, i, r) : Wd(va(t), e, n, s, i, r, 1);
      break;
    }
  }
}
function Bz(t) {
  let e = t.prev, n = t, s = t.next;
  if (Dn(e, n, s) >= 0)
    return !1;
  let i = t.next.next;
  for (; i !== t.prev; ) {
    if (Wl(e.x, e.y, n.x, n.y, s.x, s.y, i.x, i.y) && Dn(i.prev, i, i.next) >= 0)
      return !1;
    i = i.next;
  }
  return !0;
}
function zz(t, e, n, s) {
  let i = t.prev, r = t, o = t.next;
  if (Dn(i, r, o) >= 0)
    return !1;
  let a = i.x < r.x ? i.x < o.x ? i.x : o.x : r.x < o.x ? r.x : o.x, c = i.y < r.y ? i.y < o.y ? i.y : o.y : r.y < o.y ? r.y : o.y, l = i.x > r.x ? i.x > o.x ? i.x : o.x : r.x > o.x ? r.x : o.x, u = i.y > r.y ? i.y > o.y ? i.y : o.y : r.y > o.y ? r.y : o.y, h = iw(a, c, e, n, s), d = iw(l, u, e, n, s), f = t.prevZ, p = t.nextZ;
  for (; f && f.z >= h && p && p.z <= d; ) {
    if (f !== t.prev && f !== t.next && Wl(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) && Dn(f.prev, f, f.next) >= 0 || (f = f.prevZ, p !== t.prev && p !== t.next && Wl(i.x, i.y, r.x, r.y, o.x, o.y, p.x, p.y) && Dn(p.prev, p, p.next) >= 0))
      return !1;
    p = p.nextZ;
  }
  for (; f && f.z >= h; ) {
    if (f !== t.prev && f !== t.next && Wl(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) && Dn(f.prev, f, f.next) >= 0)
      return !1;
    f = f.prevZ;
  }
  for (; p && p.z <= d; ) {
    if (p !== t.prev && p !== t.next && Wl(i.x, i.y, r.x, r.y, o.x, o.y, p.x, p.y) && Dn(p.prev, p, p.next) >= 0)
      return !1;
    p = p.nextZ;
  }
  return !0;
}
function Vz(t, e, n) {
  let s = t;
  do {
    let i = s.prev, r = s.next.next;
    !px(i, r) && tN(i, s, s.next, r) && Hd(i, r) && Hd(r, i) && (e.push(i.i / n), e.push(s.i / n), e.push(r.i / n), jd(s), jd(s.next), s = t = r), s = s.next;
  } while (s !== t);
  return va(s);
}
function Uz(t, e, n, s, i, r) {
  let o = t;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && Zz(o, a)) {
        let c = nN(o, a);
        o = va(o, o.next), c = va(c, c.next), Wd(o, e, n, s, i, r), Wd(c, e, n, s, i, r);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== t);
}
function Gz(t, e, n, s) {
  let i = [], r, o, a, c, l;
  for (r = 0, o = e.length; r < o; r++)
    a = e[r] * s, c = r < o - 1 ? e[r + 1] * s : t.length, l = eN(t, a, c, s, !1), l === l.next && (l.steiner = !0), i.push(Yz(l));
  for (i.sort(Wz), r = 0; r < i.length; r++)
    Hz(i[r], n), n = va(n, n.next);
  return n;
}
function Wz(t, e) {
  return t.x - e.x;
}
function Hz(t, e) {
  if (e = jz(t, e), e) {
    const n = nN(e, t);
    va(e, e.next), va(n, n.next);
  }
}
function jz(t, e) {
  let n = e, s = t.x, i = t.y, r = -1 / 0, o;
  do {
    if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
      let d = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (d <= s && d > r) {
        if (r = d, d === s) {
          if (i === n.y)
            return n;
          if (i === n.next.y)
            return n.next;
        }
        o = n.x < n.next.x ? n : n.next;
      }
    }
    n = n.next;
  } while (n !== e);
  if (!o)
    return null;
  if (s === r)
    return o;
  let a = o, c = o.x, l = o.y, u = 1 / 0, h;
  n = o;
  do
    s >= n.x && n.x >= c && s !== n.x && Wl(i < l ? s : r, i, c, l, i < l ? r : s, i, n.x, n.y) && (h = Math.abs(i - n.y) / (s - n.x), Hd(n, t) && (h < u || h === u && (n.x > o.x || n.x === o.x && qz(o, n))) && (o = n, u = h)), n = n.next;
  while (n !== a);
  return o;
}
function qz(t, e) {
  return Dn(t.prev, t, e.prev) < 0 && Dn(e.next, t, t.next) < 0;
}
function Xz(t, e, n, s) {
  let i = t;
  do
    i.z === null && (i.z = iw(i.x, i.y, e, n, s)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== t);
  i.prevZ.nextZ = null, i.prevZ = null, Kz(i);
}
function Kz(t) {
  let e, n, s, i, r, o, a, c, l = 1;
  do {
    for (n = t, t = null, r = null, o = 0; n; ) {
      for (o++, s = n, a = 0, e = 0; e < l && (a++, s = s.nextZ, !!s); e++)
        ;
      for (c = l; a > 0 || c > 0 && s; )
        a !== 0 && (c === 0 || !s || n.z <= s.z) ? (i = n, n = n.nextZ, a--) : (i = s, s = s.nextZ, c--), r ? r.nextZ = i : t = i, i.prevZ = r, r = i;
      n = s;
    }
    r.nextZ = null, l *= 2;
  } while (o > 1);
  return t;
}
function iw(t, e, n, s, i) {
  return t = 32767 * (t - n) * i, e = 32767 * (e - s) * i, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t | e << 1;
}
function Yz(t) {
  let e = t, n = t;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== t);
  return n;
}
function Wl(t, e, n, s, i, r, o, a) {
  return (i - o) * (e - a) - (t - o) * (r - a) >= 0 && (t - o) * (s - a) - (n - o) * (e - a) >= 0 && (n - o) * (r - a) - (i - o) * (s - a) >= 0;
}
function Zz(t, e) {
  return t.next.i !== e.i && t.prev.i !== e.i && !Jz(t, e) && // dones't intersect other edges
  (Hd(t, e) && Hd(e, t) && Qz(t, e) && // locally visible
  (Dn(t.prev, t, e.prev) || Dn(t, e.prev, e)) || // does not create opposite-facing sectors
  px(t, e) && Dn(t.prev, t, t.next) > 0 && Dn(e.prev, e, e.next) > 0);
}
function Dn(t, e, n) {
  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
}
function px(t, e) {
  return t.x === e.x && t.y === e.y;
}
function tN(t, e, n, s) {
  const i = ng(Dn(t, e, n)), r = ng(Dn(t, e, s)), o = ng(Dn(n, s, t)), a = ng(Dn(n, s, e));
  return !!(i !== r && o !== a || i === 0 && tg(t, n, e) || r === 0 && tg(t, s, e) || o === 0 && tg(n, t, s) || a === 0 && tg(n, e, s));
}
function tg(t, e, n) {
  return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y);
}
function ng(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function Jz(t, e) {
  let n = t;
  do {
    if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && tN(n, n.next, t, e))
      return !0;
    n = n.next;
  } while (n !== t);
  return !1;
}
function Hd(t, e) {
  return Dn(t.prev, t, t.next) < 0 ? Dn(t, e, t.next) >= 0 && Dn(t, t.prev, e) >= 0 : Dn(t, e, t.prev) < 0 || Dn(t, t.next, e) < 0;
}
function Qz(t, e) {
  let n = t, s = !1, i = (t.x + e.x) / 2, r = (t.y + e.y) / 2;
  do
    n.y > r != n.next.y > r && n.next.y !== n.y && i < (n.next.x - n.x) * (r - n.y) / (n.next.y - n.y) + n.x && (s = !s), n = n.next;
  while (n !== t);
  return s;
}
function nN(t, e) {
  let n = new rw(t.i, t.x, t.y), s = new rw(e.i, e.x, e.y), i = t.next, r = e.prev;
  return t.next = e, e.prev = t, n.next = i, i.prev = n, s.next = n, n.prev = s, r.next = s, s.prev = r, s;
}
function zC(t, e, n, s) {
  const i = new rw(t, e, n);
  return s ? (i.next = s.next, i.prev = s, s.next.prev = i, s.next = i) : (i.prev = i, i.next = i), i;
}
function jd(t) {
  t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function rw(t, e, n) {
  this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function eV(t, e, n, s) {
  let i = 0;
  for (let r = e, o = n - s; r < n; r += s)
    i += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r;
  return i;
}
const fa = {
  // calculate area of the contour polygon
  area: function(t) {
    const e = t.length;
    let n = 0;
    for (let s = e - 1, i = 0; i < e; s = i++)
      n += t[s].x * t[i].y - t[i].x * t[s].y;
    return n * 0.5;
  },
  isClockWise: function(t) {
    return fa.area(t) < 0;
  },
  triangulateShape: function(t, e) {
    const n = [], s = [], i = [];
    VC(t), UC(n, t);
    let r = t.length;
    e.forEach(VC);
    for (let a = 0; a < e.length; a++)
      s.push(r), r += e[a].length, UC(n, e[a]);
    const o = Pz.triangulate(n, s);
    for (let a = 0; a < o.length; a += 3)
      i.push(o.slice(a, a + 3));
    return i;
  }
};
function VC(t) {
  const e = t.length;
  e > 2 && t[e - 1].equals(t[0]) && t.pop();
}
function UC(t, e) {
  for (let n = 0; n < e.length; n++)
    t.push(e[n].x), t.push(e[n].y);
}
function ru(t, e) {
  xt.call(this), this.type = "ExtrudeGeometry", this.parameters = {
    shapes: t,
    options: e
  }, this.fromBufferGeometry(new No(t, e)), this.mergeVertices();
}
ru.prototype = Object.create(xt.prototype);
ru.prototype.constructor = ru;
ru.prototype.toJSON = function() {
  const t = xt.prototype.toJSON.call(this), e = this.parameters.shapes, n = this.parameters.options;
  return sN(e, n, t);
};
function No(t, e) {
  et.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
    shapes: t,
    options: e
  }, t = Array.isArray(t) ? t : [t];
  const n = this, s = [], i = [];
  for (let o = 0, a = t.length; o < a; o++) {
    const c = t[o];
    r(c);
  }
  this.setAttribute("position", new Ze(s, 3)), this.setAttribute("uv", new Ze(i, 2)), this.computeVertexNormals();
  function r(o) {
    const a = [], c = e.curveSegments !== void 0 ? e.curveSegments : 12, l = e.steps !== void 0 ? e.steps : 1;
    let u = e.depth !== void 0 ? e.depth : 100, h = e.bevelEnabled !== void 0 ? e.bevelEnabled : !0, d = e.bevelThickness !== void 0 ? e.bevelThickness : 6, f = e.bevelSize !== void 0 ? e.bevelSize : d - 2, p = e.bevelOffset !== void 0 ? e.bevelOffset : 0, y = e.bevelSegments !== void 0 ? e.bevelSegments : 3;
    const g = e.extrudePath, m = e.UVGenerator !== void 0 ? e.UVGenerator : tV;
    e.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), u = e.amount);
    let x, v = !1, b, w, S, _;
    g && (x = g.getSpacedPoints(l), v = !0, h = !1, b = g.computeFrenetFrames(l, !1), w = new P(), S = new P(), _ = new P()), h || (y = 0, d = 0, f = 0, p = 0);
    const E = o.extractPoints(c);
    let I = E.shape;
    const k = E.holes;
    if (!fa.isClockWise(I)) {
      I = I.reverse();
      for (let ce = 0, xe = k.length; ce < xe; ce++) {
        const we = k[ce];
        fa.isClockWise(we) && (k[ce] = we.reverse());
      }
    }
    const L = fa.triangulateShape(I, k), O = I;
    for (let ce = 0, xe = k.length; ce < xe; ce++) {
      const we = k[ce];
      I = I.concat(we);
    }
    function $(ce, xe, we) {
      return xe || console.error("THREE.ExtrudeGeometry: vec does not exist"), xe.clone().multiplyScalar(we).add(ce);
    }
    const D = I.length, z = L.length;
    function W(ce, xe, we) {
      let Pe, Me, Ge;
      const F = ce.x - xe.x, V = ce.y - xe.y, Ae = we.x - ce.x, ge = we.y - ce.y, ee = F * F + V * V, De = F * ge - V * Ae;
      if (Math.abs(De) > Number.EPSILON) {
        const Fe = Math.sqrt(ee), tt = Math.sqrt(Ae * Ae + ge * ge), X = xe.x - V / Fe, pe = xe.y + F / Fe, Oe = we.x - ge / tt, Ie = we.y + Ae / tt, Be = ((Oe - X) * ge - (Ie - pe) * Ae) / (F * ge - V * Ae);
        Pe = X + F * Be - ce.x, Me = pe + V * Be - ce.y;
        const Ue = Pe * Pe + Me * Me;
        if (Ue <= 2)
          return new Ce(Pe, Me);
        Ge = Math.sqrt(Ue / 2);
      } else {
        let Fe = !1;
        F > Number.EPSILON ? Ae > Number.EPSILON && (Fe = !0) : F < -Number.EPSILON ? Ae < -Number.EPSILON && (Fe = !0) : Math.sign(V) === Math.sign(ge) && (Fe = !0), Fe ? (Pe = -V, Me = F, Ge = Math.sqrt(ee)) : (Pe = F, Me = V, Ge = Math.sqrt(ee / 2));
      }
      return new Ce(Pe / Ge, Me / Ge);
    }
    const j = [];
    for (let ce = 0, xe = O.length, we = xe - 1, Pe = ce + 1; ce < xe; ce++, we++, Pe++)
      we === xe && (we = 0), Pe === xe && (Pe = 0), j[ce] = W(O[ce], O[we], O[Pe]);
    const J = [];
    let ne, re = j.concat();
    for (let ce = 0, xe = k.length; ce < xe; ce++) {
      const we = k[ce];
      ne = [];
      for (let Pe = 0, Me = we.length, Ge = Me - 1, F = Pe + 1; Pe < Me; Pe++, Ge++, F++)
        Ge === Me && (Ge = 0), F === Me && (F = 0), ne[Pe] = W(we[Pe], we[Ge], we[F]);
      J.push(ne), re = re.concat(ne);
    }
    for (let ce = 0; ce < y; ce++) {
      const xe = ce / y, we = d * Math.cos(xe * Math.PI / 2), Pe = f * Math.sin(xe * Math.PI / 2) + p;
      for (let Me = 0, Ge = O.length; Me < Ge; Me++) {
        const F = $(O[Me], j[Me], Pe);
        te(F.x, F.y, -we);
      }
      for (let Me = 0, Ge = k.length; Me < Ge; Me++) {
        const F = k[Me];
        ne = J[Me];
        for (let V = 0, Ae = F.length; V < Ae; V++) {
          const ge = $(F[V], ne[V], Pe);
          te(ge.x, ge.y, -we);
        }
      }
    }
    const fe = f + p;
    for (let ce = 0; ce < D; ce++) {
      const xe = h ? $(I[ce], re[ce], fe) : I[ce];
      v ? (S.copy(b.normals[0]).multiplyScalar(xe.x), w.copy(b.binormals[0]).multiplyScalar(xe.y), _.copy(x[0]).add(S).add(w), te(_.x, _.y, _.z)) : te(xe.x, xe.y, 0);
    }
    for (let ce = 1; ce <= l; ce++)
      for (let xe = 0; xe < D; xe++) {
        const we = h ? $(I[xe], re[xe], fe) : I[xe];
        v ? (S.copy(b.normals[ce]).multiplyScalar(we.x), w.copy(b.binormals[ce]).multiplyScalar(we.y), _.copy(x[ce]).add(S).add(w), te(_.x, _.y, _.z)) : te(we.x, we.y, u / l * ce);
      }
    for (let ce = y - 1; ce >= 0; ce--) {
      const xe = ce / y, we = d * Math.cos(xe * Math.PI / 2), Pe = f * Math.sin(xe * Math.PI / 2) + p;
      for (let Me = 0, Ge = O.length; Me < Ge; Me++) {
        const F = $(O[Me], j[Me], Pe);
        te(F.x, F.y, u + we);
      }
      for (let Me = 0, Ge = k.length; Me < Ge; Me++) {
        const F = k[Me];
        ne = J[Me];
        for (let V = 0, Ae = F.length; V < Ae; V++) {
          const ge = $(F[V], ne[V], Pe);
          v ? te(ge.x, ge.y + x[l - 1].y, x[l - 1].x + we) : te(ge.x, ge.y, u + we);
        }
      }
    }
    ae(), ve();
    function ae() {
      const ce = s.length / 3;
      if (h) {
        let xe = 0, we = D * xe;
        for (let Pe = 0; Pe < z; Pe++) {
          const Me = L[Pe];
          $e(Me[2] + we, Me[1] + we, Me[0] + we);
        }
        xe = l + y * 2, we = D * xe;
        for (let Pe = 0; Pe < z; Pe++) {
          const Me = L[Pe];
          $e(Me[0] + we, Me[1] + we, Me[2] + we);
        }
      } else {
        for (let xe = 0; xe < z; xe++) {
          const we = L[xe];
          $e(we[2], we[1], we[0]);
        }
        for (let xe = 0; xe < z; xe++) {
          const we = L[xe];
          $e(we[0] + D * l, we[1] + D * l, we[2] + D * l);
        }
      }
      n.addGroup(ce, s.length / 3 - ce, 0);
    }
    function ve() {
      const ce = s.length / 3;
      let xe = 0;
      me(O, xe), xe += O.length;
      for (let we = 0, Pe = k.length; we < Pe; we++) {
        const Me = k[we];
        me(Me, xe), xe += Me.length;
      }
      n.addGroup(ce, s.length / 3 - ce, 1);
    }
    function me(ce, xe) {
      let we = ce.length;
      for (; --we >= 0; ) {
        const Pe = we;
        let Me = we - 1;
        Me < 0 && (Me = ce.length - 1);
        for (let Ge = 0, F = l + y * 2; Ge < F; Ge++) {
          const V = D * Ge, Ae = D * (Ge + 1), ge = xe + Pe + V, ee = xe + Me + V, De = xe + Me + Ae, Fe = xe + Pe + Ae;
          _e(ge, ee, De, Fe);
        }
      }
    }
    function te(ce, xe, we) {
      a.push(ce), a.push(xe), a.push(we);
    }
    function $e(ce, xe, we) {
      ke(ce), ke(xe), ke(we);
      const Pe = s.length / 3, Me = m.generateTopUV(n, s, Pe - 3, Pe - 2, Pe - 1);
      Re(Me[0]), Re(Me[1]), Re(Me[2]);
    }
    function _e(ce, xe, we, Pe) {
      ke(ce), ke(xe), ke(Pe), ke(xe), ke(we), ke(Pe);
      const Me = s.length / 3, Ge = m.generateSideWallUV(n, s, Me - 6, Me - 3, Me - 2, Me - 1);
      Re(Ge[0]), Re(Ge[1]), Re(Ge[3]), Re(Ge[1]), Re(Ge[2]), Re(Ge[3]);
    }
    function ke(ce) {
      s.push(a[ce * 3 + 0]), s.push(a[ce * 3 + 1]), s.push(a[ce * 3 + 2]);
    }
    function Re(ce) {
      i.push(ce.x), i.push(ce.y);
    }
  }
}
No.prototype = Object.create(et.prototype);
No.prototype.constructor = No;
No.prototype.toJSON = function() {
  const t = et.prototype.toJSON.call(this), e = this.parameters.shapes, n = this.parameters.options;
  return sN(e, n, t);
};
const tV = {
  generateTopUV: function(t, e, n, s, i) {
    const r = e[n * 3], o = e[n * 3 + 1], a = e[s * 3], c = e[s * 3 + 1], l = e[i * 3], u = e[i * 3 + 1];
    return [
      new Ce(r, o),
      new Ce(a, c),
      new Ce(l, u)
    ];
  },
  generateSideWallUV: function(t, e, n, s, i, r) {
    const o = e[n * 3], a = e[n * 3 + 1], c = e[n * 3 + 2], l = e[s * 3], u = e[s * 3 + 1], h = e[s * 3 + 2], d = e[i * 3], f = e[i * 3 + 1], p = e[i * 3 + 2], y = e[r * 3], g = e[r * 3 + 1], m = e[r * 3 + 2];
    return Math.abs(a - u) < 0.01 ? [
      new Ce(o, 1 - c),
      new Ce(l, 1 - h),
      new Ce(d, 1 - p),
      new Ce(y, 1 - m)
    ] : [
      new Ce(a, 1 - c),
      new Ce(u, 1 - h),
      new Ce(f, 1 - p),
      new Ce(g, 1 - m)
    ];
  }
};
function sN(t, e, n) {
  if (n.shapes = [], Array.isArray(t))
    for (let s = 0, i = t.length; s < i; s++) {
      const r = t[s];
      n.shapes.push(r.uuid);
    }
  else
    n.shapes.push(t.uuid);
  return e.extrudePath !== void 0 && (n.options.extrudePath = e.extrudePath.toJSON()), n;
}
function uy(t, e) {
  xt.call(this), this.type = "TextGeometry", this.parameters = {
    text: t,
    parameters: e
  }, this.fromBufferGeometry(new qd(t, e)), this.mergeVertices();
}
uy.prototype = Object.create(xt.prototype);
uy.prototype.constructor = uy;
function qd(t, e) {
  e = e || {};
  const n = e.font;
  if (!(n && n.isFont))
    return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new xt();
  const s = n.generateShapes(t, e.size);
  e.depth = e.height !== void 0 ? e.height : 50, e.bevelThickness === void 0 && (e.bevelThickness = 10), e.bevelSize === void 0 && (e.bevelSize = 8), e.bevelEnabled === void 0 && (e.bevelEnabled = !1), No.call(this, s, e), this.type = "TextBufferGeometry";
}
qd.prototype = Object.create(No.prototype);
qd.prototype.constructor = qd;
function Xd(t, e, n, s, i, r, o) {
  xt.call(this), this.type = "SphereGeometry", this.parameters = {
    radius: t,
    widthSegments: e,
    heightSegments: n,
    phiStart: s,
    phiLength: i,
    thetaStart: r,
    thetaLength: o
  }, this.fromBufferGeometry(new ou(t, e, n, s, i, r, o)), this.mergeVertices();
}
Xd.prototype = Object.create(xt.prototype);
Xd.prototype.constructor = Xd;
function ou(t, e, n, s, i, r, o) {
  et.call(this), this.type = "SphereBufferGeometry", this.parameters = {
    radius: t,
    widthSegments: e,
    heightSegments: n,
    phiStart: s,
    phiLength: i,
    thetaStart: r,
    thetaLength: o
  }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), s = s !== void 0 ? s : 0, i = i !== void 0 ? i : Math.PI * 2, r = r !== void 0 ? r : 0, o = o !== void 0 ? o : Math.PI;
  const a = Math.min(r + o, Math.PI);
  let c = 0;
  const l = [], u = new P(), h = new P(), d = [], f = [], p = [], y = [];
  for (let g = 0; g <= n; g++) {
    const m = [], x = g / n;
    let v = 0;
    g == 0 && r == 0 ? v = 0.5 / e : g == n && a == Math.PI && (v = -0.5 / e);
    for (let b = 0; b <= e; b++) {
      const w = b / e;
      u.x = -t * Math.cos(s + w * i) * Math.sin(r + x * o), u.y = t * Math.cos(r + x * o), u.z = t * Math.sin(s + w * i) * Math.sin(r + x * o), f.push(u.x, u.y, u.z), h.copy(u).normalize(), p.push(h.x, h.y, h.z), y.push(w + v, 1 - x), m.push(c++);
    }
    l.push(m);
  }
  for (let g = 0; g < n; g++)
    for (let m = 0; m < e; m++) {
      const x = l[g][m + 1], v = l[g][m], b = l[g + 1][m], w = l[g + 1][m + 1];
      (g !== 0 || r > 0) && d.push(x, v, w), (g !== n - 1 || a < Math.PI) && d.push(v, b, w);
    }
  this.setIndex(d), this.setAttribute("position", new Ze(f, 3)), this.setAttribute("normal", new Ze(p, 3)), this.setAttribute("uv", new Ze(y, 2));
}
ou.prototype = Object.create(et.prototype);
ou.prototype.constructor = ou;
function hy(t, e, n, s, i, r) {
  xt.call(this), this.type = "RingGeometry", this.parameters = {
    innerRadius: t,
    outerRadius: e,
    thetaSegments: n,
    phiSegments: s,
    thetaStart: i,
    thetaLength: r
  }, this.fromBufferGeometry(new Kd(t, e, n, s, i, r)), this.mergeVertices();
}
hy.prototype = Object.create(xt.prototype);
hy.prototype.constructor = hy;
function Kd(t, e, n, s, i, r) {
  et.call(this), this.type = "RingBufferGeometry", this.parameters = {
    innerRadius: t,
    outerRadius: e,
    thetaSegments: n,
    phiSegments: s,
    thetaStart: i,
    thetaLength: r
  }, t = t || 0.5, e = e || 1, i = i !== void 0 ? i : 0, r = r !== void 0 ? r : Math.PI * 2, n = n !== void 0 ? Math.max(3, n) : 8, s = s !== void 0 ? Math.max(1, s) : 1;
  const o = [], a = [], c = [], l = [];
  let u = t;
  const h = (e - t) / s, d = new P(), f = new Ce();
  for (let p = 0; p <= s; p++) {
    for (let y = 0; y <= n; y++) {
      const g = i + y / n * r;
      d.x = u * Math.cos(g), d.y = u * Math.sin(g), a.push(d.x, d.y, d.z), c.push(0, 0, 1), f.x = (d.x / e + 1) / 2, f.y = (d.y / e + 1) / 2, l.push(f.x, f.y);
    }
    u += h;
  }
  for (let p = 0; p < s; p++) {
    const y = p * (n + 1);
    for (let g = 0; g < n; g++) {
      const m = g + y, x = m, v = m + n + 1, b = m + n + 2, w = m + 1;
      o.push(x, v, w), o.push(v, b, w);
    }
  }
  this.setIndex(o), this.setAttribute("position", new Ze(a, 3)), this.setAttribute("normal", new Ze(c, 3)), this.setAttribute("uv", new Ze(l, 2));
}
Kd.prototype = Object.create(et.prototype);
Kd.prototype.constructor = Kd;
function dy(t, e, n, s) {
  xt.call(this), this.type = "LatheGeometry", this.parameters = {
    points: t,
    segments: e,
    phiStart: n,
    phiLength: s
  }, this.fromBufferGeometry(new Yd(t, e, n, s)), this.mergeVertices();
}
dy.prototype = Object.create(xt.prototype);
dy.prototype.constructor = dy;
function Yd(t, e, n, s) {
  et.call(this), this.type = "LatheBufferGeometry", this.parameters = {
    points: t,
    segments: e,
    phiStart: n,
    phiLength: s
  }, e = Math.floor(e) || 12, n = n || 0, s = s || Math.PI * 2, s = Et.clamp(s, 0, Math.PI * 2);
  const i = [], r = [], o = [], a = 1 / e, c = new P(), l = new Ce();
  for (let u = 0; u <= e; u++) {
    const h = n + u * a * s, d = Math.sin(h), f = Math.cos(h);
    for (let p = 0; p <= t.length - 1; p++)
      c.x = t[p].x * d, c.y = t[p].y, c.z = t[p].x * f, r.push(c.x, c.y, c.z), l.x = u / e, l.y = p / (t.length - 1), o.push(l.x, l.y);
  }
  for (let u = 0; u < e; u++)
    for (let h = 0; h < t.length - 1; h++) {
      const d = h + u * t.length, f = d, p = d + t.length, y = d + t.length + 1, g = d + 1;
      i.push(f, p, g), i.push(p, y, g);
    }
  if (this.setIndex(i), this.setAttribute("position", new Ze(r, 3)), this.setAttribute("uv", new Ze(o, 2)), this.computeVertexNormals(), s === Math.PI * 2) {
    const u = this.attributes.normal.array, h = new P(), d = new P(), f = new P(), p = e * t.length * 3;
    for (let y = 0, g = 0; y < t.length; y++, g += 3)
      h.x = u[g + 0], h.y = u[g + 1], h.z = u[g + 2], d.x = u[p + g + 0], d.y = u[p + g + 1], d.z = u[p + g + 2], f.addVectors(h, d).normalize(), u[g + 0] = u[p + g + 0] = f.x, u[g + 1] = u[p + g + 1] = f.y, u[g + 2] = u[p + g + 2] = f.z;
  }
}
Yd.prototype = Object.create(et.prototype);
Yd.prototype.constructor = Yd;
function au(t, e) {
  xt.call(this), this.type = "ShapeGeometry", typeof e == "object" && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
    shapes: t,
    curveSegments: e
  }, this.fromBufferGeometry(new cu(t, e)), this.mergeVertices();
}
au.prototype = Object.create(xt.prototype);
au.prototype.constructor = au;
au.prototype.toJSON = function() {
  const t = xt.prototype.toJSON.call(this), e = this.parameters.shapes;
  return iN(e, t);
};
function cu(t, e) {
  et.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
    shapes: t,
    curveSegments: e
  }, e = e || 12;
  const n = [], s = [], i = [], r = [];
  let o = 0, a = 0;
  if (Array.isArray(t) === !1)
    c(t);
  else
    for (let l = 0; l < t.length; l++)
      c(t[l]), this.addGroup(o, a, l), o += a, a = 0;
  this.setIndex(n), this.setAttribute("position", new Ze(s, 3)), this.setAttribute("normal", new Ze(i, 3)), this.setAttribute("uv", new Ze(r, 2));
  function c(l) {
    const u = s.length / 3, h = l.extractPoints(e);
    let d = h.shape;
    const f = h.holes;
    fa.isClockWise(d) === !1 && (d = d.reverse());
    for (let y = 0, g = f.length; y < g; y++) {
      const m = f[y];
      fa.isClockWise(m) === !0 && (f[y] = m.reverse());
    }
    const p = fa.triangulateShape(d, f);
    for (let y = 0, g = f.length; y < g; y++) {
      const m = f[y];
      d = d.concat(m);
    }
    for (let y = 0, g = d.length; y < g; y++) {
      const m = d[y];
      s.push(m.x, m.y, 0), i.push(0, 0, 1), r.push(m.x, m.y);
    }
    for (let y = 0, g = p.length; y < g; y++) {
      const m = p[y], x = m[0] + u, v = m[1] + u, b = m[2] + u;
      n.push(x, v, b), a += 3;
    }
  }
}
cu.prototype = Object.create(et.prototype);
cu.prototype.constructor = cu;
cu.prototype.toJSON = function() {
  const t = et.prototype.toJSON.call(this), e = this.parameters.shapes;
  return iN(e, t);
};
function iN(t, e) {
  if (e.shapes = [], Array.isArray(t))
    for (let n = 0, s = t.length; n < s; n++) {
      const i = t[n];
      e.shapes.push(i.uuid);
    }
  else
    e.shapes.push(t.uuid);
  return e;
}
function fy(t, e) {
  et.call(this), this.type = "EdgesGeometry", this.parameters = {
    thresholdAngle: e
  }, e = e !== void 0 ? e : 1;
  const n = [], s = Math.cos(Et.DEG2RAD * e), i = [0, 0], r = {};
  let o, a, c;
  const l = ["a", "b", "c"];
  let u;
  t.isBufferGeometry ? (u = new xt(), u.fromBufferGeometry(t)) : u = t.clone(), u.mergeVertices(), u.computeFaceNormals();
  const h = u.vertices, d = u.faces;
  for (let f = 0, p = d.length; f < p; f++) {
    const y = d[f];
    for (let g = 0; g < 3; g++)
      o = y[l[g]], a = y[l[(g + 1) % 3]], i[0] = Math.min(o, a), i[1] = Math.max(o, a), c = i[0] + "," + i[1], r[c] === void 0 ? r[c] = { index1: i[0], index2: i[1], face1: f, face2: void 0 } : r[c].face2 = f;
  }
  for (c in r) {
    const f = r[c];
    if (f.face2 === void 0 || d[f.face1].normal.dot(d[f.face2].normal) <= s) {
      let p = h[f.index1];
      n.push(p.x, p.y, p.z), p = h[f.index2], n.push(p.x, p.y, p.z);
    }
  }
  this.setAttribute("position", new Ze(n, 3));
}
fy.prototype = Object.create(et.prototype);
fy.prototype.constructor = fy;
function lu(t, e, n, s, i, r, o, a) {
  xt.call(this), this.type = "CylinderGeometry", this.parameters = {
    radiusTop: t,
    radiusBottom: e,
    height: n,
    radialSegments: s,
    heightSegments: i,
    openEnded: r,
    thetaStart: o,
    thetaLength: a
  }, this.fromBufferGeometry(new wa(t, e, n, s, i, r, o, a)), this.mergeVertices();
}
lu.prototype = Object.create(xt.prototype);
lu.prototype.constructor = lu;
function wa(t, e, n, s, i, r, o, a) {
  et.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
    radiusTop: t,
    radiusBottom: e,
    height: n,
    radialSegments: s,
    heightSegments: i,
    openEnded: r,
    thetaStart: o,
    thetaLength: a
  };
  const c = this;
  t = t !== void 0 ? t : 1, e = e !== void 0 ? e : 1, n = n || 1, s = Math.floor(s) || 8, i = Math.floor(i) || 1, r = r !== void 0 ? r : !1, o = o !== void 0 ? o : 0, a = a !== void 0 ? a : Math.PI * 2;
  const l = [], u = [], h = [], d = [];
  let f = 0;
  const p = [], y = n / 2;
  let g = 0;
  m(), r === !1 && (t > 0 && x(!0), e > 0 && x(!1)), this.setIndex(l), this.setAttribute("position", new Ze(u, 3)), this.setAttribute("normal", new Ze(h, 3)), this.setAttribute("uv", new Ze(d, 2));
  function m() {
    const v = new P(), b = new P();
    let w = 0;
    const S = (e - t) / n;
    for (let _ = 0; _ <= i; _++) {
      const E = [], I = _ / i, k = I * (e - t) + t;
      for (let M = 0; M <= s; M++) {
        const L = M / s, O = L * a + o, $ = Math.sin(O), D = Math.cos(O);
        b.x = k * $, b.y = -I * n + y, b.z = k * D, u.push(b.x, b.y, b.z), v.set($, S, D).normalize(), h.push(v.x, v.y, v.z), d.push(L, 1 - I), E.push(f++);
      }
      p.push(E);
    }
    for (let _ = 0; _ < s; _++)
      for (let E = 0; E < i; E++) {
        const I = p[E][_], k = p[E + 1][_], M = p[E + 1][_ + 1], L = p[E][_ + 1];
        l.push(I, k, L), l.push(k, M, L), w += 6;
      }
    c.addGroup(g, w, 0), g += w;
  }
  function x(v) {
    let b, w;
    const S = new Ce(), _ = new P();
    let E = 0;
    const I = v === !0 ? t : e, k = v === !0 ? 1 : -1;
    b = f;
    for (let M = 1; M <= s; M++)
      u.push(0, y * k, 0), h.push(0, k, 0), d.push(0.5, 0.5), f++;
    w = f;
    for (let M = 0; M <= s; M++) {
      const O = M / s * a + o, $ = Math.cos(O), D = Math.sin(O);
      _.x = I * D, _.y = y * k, _.z = I * $, u.push(_.x, _.y, _.z), h.push(0, k, 0), S.x = $ * 0.5 + 0.5, S.y = D * 0.5 * k + 0.5, d.push(S.x, S.y), f++;
    }
    for (let M = 0; M < s; M++) {
      const L = b + M, O = w + M;
      v === !0 ? l.push(O, O + 1, L) : l.push(O + 1, O, L), E += 3;
    }
    c.addGroup(g, E, v === !0 ? 1 : 2), g += E;
  }
}
wa.prototype = Object.create(et.prototype);
wa.prototype.constructor = wa;
function py(t, e, n, s, i, r, o) {
  lu.call(this, 0, t, e, n, s, i, r, o), this.type = "ConeGeometry", this.parameters = {
    radius: t,
    height: e,
    radialSegments: n,
    heightSegments: s,
    openEnded: i,
    thetaStart: r,
    thetaLength: o
  };
}
py.prototype = Object.create(lu.prototype);
py.prototype.constructor = py;
function my(t, e, n, s, i, r, o) {
  wa.call(this, 0, t, e, n, s, i, r, o), this.type = "ConeBufferGeometry", this.parameters = {
    radius: t,
    height: e,
    radialSegments: n,
    heightSegments: s,
    openEnded: i,
    thetaStart: r,
    thetaLength: o
  };
}
my.prototype = Object.create(wa.prototype);
my.prototype.constructor = my;
function gy(t, e, n, s) {
  xt.call(this), this.type = "CircleGeometry", this.parameters = {
    radius: t,
    segments: e,
    thetaStart: n,
    thetaLength: s
  }, this.fromBufferGeometry(new Zd(t, e, n, s)), this.mergeVertices();
}
gy.prototype = Object.create(xt.prototype);
gy.prototype.constructor = gy;
function Zd(t, e, n, s) {
  et.call(this), this.type = "CircleBufferGeometry", this.parameters = {
    radius: t,
    segments: e,
    thetaStart: n,
    thetaLength: s
  }, t = t || 1, e = e !== void 0 ? Math.max(3, e) : 8, n = n !== void 0 ? n : 0, s = s !== void 0 ? s : Math.PI * 2;
  const i = [], r = [], o = [], a = [], c = new P(), l = new Ce();
  r.push(0, 0, 0), o.push(0, 0, 1), a.push(0.5, 0.5);
  for (let u = 0, h = 3; u <= e; u++, h += 3) {
    const d = n + u / e * s;
    c.x = t * Math.cos(d), c.y = t * Math.sin(d), r.push(c.x, c.y, c.z), o.push(0, 0, 1), l.x = (r[h] / t + 1) / 2, l.y = (r[h + 1] / t + 1) / 2, a.push(l.x, l.y);
  }
  for (let u = 1; u <= e; u++)
    i.push(u, u + 1, 0);
  this.setIndex(i), this.setAttribute("position", new Ze(r, 3)), this.setAttribute("normal", new Ze(o, 3)), this.setAttribute("uv", new Ze(a, 2));
}
Zd.prototype = Object.create(et.prototype);
Zd.prototype.constructor = Zd;
var Ys = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WireframeGeometry: ey,
  ParametricGeometry: ty,
  ParametricBufferGeometry: Pd,
  TetrahedronGeometry: sy,
  TetrahedronBufferGeometry: Bd,
  OctahedronGeometry: iy,
  OctahedronBufferGeometry: su,
  IcosahedronGeometry: ry,
  IcosahedronBufferGeometry: zd,
  DodecahedronGeometry: oy,
  DodecahedronBufferGeometry: Vd,
  PolyhedronGeometry: ny,
  PolyhedronBufferGeometry: $i,
  TubeGeometry: ay,
  TubeBufferGeometry: iu,
  TorusKnotGeometry: cy,
  TorusKnotBufferGeometry: Ud,
  TorusGeometry: ly,
  TorusBufferGeometry: Gd,
  TextGeometry: uy,
  TextBufferGeometry: qd,
  SphereGeometry: Xd,
  SphereBufferGeometry: ou,
  RingGeometry: hy,
  RingBufferGeometry: Kd,
  PlaneGeometry: Yg,
  PlaneBufferGeometry: nu,
  LatheGeometry: dy,
  LatheBufferGeometry: Yd,
  ShapeGeometry: au,
  ShapeBufferGeometry: cu,
  ExtrudeGeometry: ru,
  ExtrudeBufferGeometry: No,
  EdgesGeometry: fy,
  ConeGeometry: py,
  ConeBufferGeometry: my,
  CylinderGeometry: lu,
  CylinderBufferGeometry: wa,
  CircleGeometry: gy,
  CircleBufferGeometry: Zd,
  BoxGeometry: FF,
  BoxBufferGeometry: fx
});
function uu(t) {
  yt.call(this), this.type = "ShadowMaterial", this.color = new st(0), this.transparent = !0, this.setValues(t);
}
uu.prototype = Object.create(yt.prototype);
uu.prototype.constructor = uu;
uu.prototype.isShadowMaterial = !0;
uu.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.color.copy(t.color), this;
};
function Sa(t) {
  yi.call(this, t), this.type = "RawShaderMaterial";
}
Sa.prototype = Object.create(yi.prototype);
Sa.prototype.constructor = Sa;
Sa.prototype.isRawShaderMaterial = !0;
function wr(t) {
  yt.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new st(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new st(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ru, this.normalScale = new Ce(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t);
}
wr.prototype = Object.create(yt.prototype);
wr.prototype.constructor = wr;
wr.prototype.isMeshStandardMaterial = !0;
wr.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this;
};
function Dc(t) {
  wr.call(this), this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ce(1, 1), this.clearcoatNormalMap = null, this.reflectivity = 0.5, this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t);
}
Dc.prototype = Object.create(wr.prototype);
Dc.prototype.constructor = Dc;
Dc.prototype.isMeshPhysicalMaterial = !0;
Dc.prototype.copy = function(t) {
  return wr.prototype.copy.call(this, t), this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new st()).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this;
};
function $c(t) {
  yt.call(this), this.type = "MeshPhongMaterial", this.color = new st(16777215), this.specular = new st(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new st(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ru, this.normalScale = new Ce(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = cx, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
$c.prototype = Object.create(yt.prototype);
$c.prototype.constructor = $c;
$c.prototype.isMeshPhongMaterial = !0;
$c.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function hu(t) {
  yt.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new st(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new st(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ru, this.normalScale = new Ce(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
hu.prototype = Object.create(yt.prototype);
hu.prototype.constructor = hu;
hu.prototype.isMeshToonMaterial = !0;
hu.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function du(t) {
  yt.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ru, this.normalScale = new Ce(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
du.prototype = Object.create(yt.prototype);
du.prototype.constructor = du;
du.prototype.isMeshNormalMaterial = !0;
du.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function fu(t) {
  yt.call(this), this.type = "MeshLambertMaterial", this.color = new st(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new st(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = cx, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
fu.prototype = Object.create(yt.prototype);
fu.prototype.constructor = fu;
fu.prototype.isMeshLambertMaterial = !0;
fu.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function pu(t) {
  yt.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new st(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ru, this.normalScale = new Ce(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
pu.prototype = Object.create(yt.prototype);
pu.prototype.constructor = pu;
pu.prototype.isMeshMatcapMaterial = !0;
pu.prototype.copy = function(t) {
  return yt.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function mu(t) {
  Bn.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
}
mu.prototype = Object.create(Bn.prototype);
mu.prototype.constructor = mu;
mu.prototype.isLineDashedMaterial = !0;
mu.prototype.copy = function(t) {
  return Bn.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
};
var nV = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ShadowMaterial: uu,
  SpriteMaterial: Rc,
  RawShaderMaterial: Sa,
  ShaderMaterial: yi,
  PointsMaterial: ba,
  MeshPhysicalMaterial: Dc,
  MeshStandardMaterial: wr,
  MeshPhongMaterial: $c,
  MeshToonMaterial: hu,
  MeshNormalMaterial: du,
  MeshLambertMaterial: fu,
  MeshDepthMaterial: kc,
  MeshDistanceMaterial: Ac,
  MeshBasicMaterial: er,
  MeshMatcapMaterial: pu,
  LineDashedMaterial: mu,
  LineBasicMaterial: Bn,
  Material: yt
});
const Rn = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function(t, e, n) {
    return Rn.isTypedArray(t) ? new t.constructor(t.subarray(e, n !== void 0 ? n : t.length)) : t.slice(e, n);
  },
  // converts an array to a specific type
  convertArray: function(t, e, n) {
    return !t || // let 'undefined' and 'null' pass
    !n && t.constructor === e ? t : typeof e.BYTES_PER_ELEMENT == "number" ? new e(t) : Array.prototype.slice.call(t);
  },
  isTypedArray: function(t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function(t) {
    function e(i, r) {
      return t[i] - t[r];
    }
    const n = t.length, s = new Array(n);
    for (let i = 0; i !== n; ++i)
      s[i] = i;
    return s.sort(e), s;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function(t, e, n) {
    const s = t.length, i = new t.constructor(s);
    for (let r = 0, o = 0; o !== s; ++r) {
      const a = n[r] * e;
      for (let c = 0; c !== e; ++c)
        i[o++] = t[a + c];
    }
    return i;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function(t, e, n, s) {
    let i = 1, r = t[0];
    for (; r !== void 0 && r[s] === void 0; )
      r = t[i++];
    if (r === void 0)
      return;
    let o = r[s];
    if (o !== void 0)
      if (Array.isArray(o))
        do
          o = r[s], o !== void 0 && (e.push(r.time), n.push.apply(n, o)), r = t[i++];
        while (r !== void 0);
      else if (o.toArray !== void 0)
        do
          o = r[s], o !== void 0 && (e.push(r.time), o.toArray(n, n.length)), r = t[i++];
        while (r !== void 0);
      else
        do
          o = r[s], o !== void 0 && (e.push(r.time), n.push(o)), r = t[i++];
        while (r !== void 0);
  },
  subclip: function(t, e, n, s, i) {
    i = i || 30;
    const r = t.clone();
    r.name = e;
    const o = [];
    for (let c = 0; c < r.tracks.length; ++c) {
      const l = r.tracks[c], u = l.getValueSize(), h = [], d = [];
      for (let f = 0; f < l.times.length; ++f) {
        const p = l.times[f] * i;
        if (!(p < n || p >= s)) {
          h.push(l.times[f]);
          for (let y = 0; y < u; ++y)
            d.push(l.values[f * u + y]);
        }
      }
      h.length !== 0 && (l.times = Rn.convertArray(h, l.times.constructor), l.values = Rn.convertArray(d, l.values.constructor), o.push(l));
    }
    r.tracks = o;
    let a = 1 / 0;
    for (let c = 0; c < r.tracks.length; ++c)
      a > r.tracks[c].times[0] && (a = r.tracks[c].times[0]);
    for (let c = 0; c < r.tracks.length; ++c)
      r.tracks[c].shift(-1 * a);
    return r.resetDuration(), r;
  },
  makeClipAdditive: function(t, e, n, s) {
    e === void 0 && (e = 0), n === void 0 && (n = t), (s === void 0 || s <= 0) && (s = 30);
    const i = t.tracks.length, r = e / s;
    for (let o = 0; o < i; ++o) {
      const a = n.tracks[o], c = a.ValueTypeName;
      if (c === "bool" || c === "string")
        continue;
      const l = t.tracks.find(function(p) {
        return p.name === a.name && p.ValueTypeName === c;
      });
      if (l === void 0)
        continue;
      const u = a.getValueSize(), h = a.times.length - 1;
      let d;
      if (r <= a.times[0])
        d = Rn.arraySlice(a.values, 0, a.valueSize);
      else if (r >= a.times[h]) {
        const p = h * u;
        d = Rn.arraySlice(a.values, p);
      } else {
        const p = a.createInterpolant();
        p.evaluate(r), d = p.resultBuffer;
      }
      c === "quaternion" && new xs(
        d[0],
        d[1],
        d[2],
        d[3]
      ).normalize().conjugate().toArray(d);
      const f = l.times.length;
      for (let p = 0; p < f; ++p) {
        const y = p * u;
        if (c === "quaternion")
          xs.multiplyQuaternionsFlat(
            l.values,
            y,
            d,
            0,
            l.values,
            y
          );
        else
          for (let g = 0; g < u; ++g)
            l.values[y + g] -= d[g];
      }
    }
    return t.blendMode = OE, t;
  }
};
function Qi(t, e, n, s) {
  this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = s !== void 0 ? s : new e.constructor(n), this.sampleValues = e, this.valueSize = n;
}
Object.assign(Qi.prototype, {
  evaluate: function(t) {
    let e = this.parameterPositions, n = this._cachedIndex, s = e[n], i = e[n - 1];
    e: {
      t: {
        let r;
        n: {
          s:
            if (!(t < s)) {
              for (let o = n + 2; ; ) {
                if (s === void 0) {
                  if (t < i)
                    break s;
                  return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, i);
                }
                if (n === o)
                  break;
                if (i = s, s = e[++n], t < s)
                  break t;
              }
              r = e.length;
              break n;
            }
          if (!(t >= i)) {
            const o = e[1];
            t < o && (n = 2, i = o);
            for (let a = n - 2; ; ) {
              if (i === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, t, s);
              if (n === a)
                break;
              if (s = i, i = e[--n - 1], t >= i)
                break t;
            }
            r = n, n = 0;
            break n;
          }
          break e;
        }
        for (; n < r; ) {
          const o = n + r >>> 1;
          t < e[o] ? r = o : n = o + 1;
        }
        if (s = e[n], i = e[n - 1], i === void 0)
          return this._cachedIndex = 0, this.beforeStart_(0, t, s);
        if (s === void 0)
          return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, t);
      }
      this._cachedIndex = n, this.intervalChanged_(n, i, s);
    }
    return this.interpolate_(n, i, t, s);
  },
  settings: null,
  // optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.
  // --- Protected interface
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(t) {
    const e = this.resultBuffer, n = this.sampleValues, s = this.valueSize, i = t * s;
    for (let r = 0; r !== s; ++r)
      e[r] = n[i + r];
    return e;
  },
  // Template methods for derived classes:
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
Object.assign(Qi.prototype, {
  //( 0, t, t0 ), returns this.resultBuffer
  beforeStart_: Qi.prototype.copySampleValue_,
  //( N-1, tN-1, t ), returns this.resultBuffer
  afterEnd_: Qi.prototype.copySampleValue_
});
function ow(t, e, n, s) {
  Qi.call(this, t, e, n, s), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
}
ow.prototype = Object.assign(Object.create(Qi.prototype), {
  constructor: ow,
  DefaultSettings_: {
    endingStart: Ql,
    endingEnd: Ql
  },
  intervalChanged_: function(t, e, n) {
    let s = this.parameterPositions, i = t - 2, r = t + 1, o = s[i], a = s[r];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case zl:
          i = t, o = 2 * e - n;
          break;
        case Xg:
          i = s.length - 2, o = e + s[i] - s[i + 1];
          break;
        default:
          i = t, o = n;
      }
    if (a === void 0)
      switch (this.getSettings_().endingEnd) {
        case zl:
          r = t, a = 2 * n - e;
          break;
        case Xg:
          r = 1, a = n + s[1] - s[0];
          break;
        default:
          r = t - 1, a = e;
      }
    const c = (n - e) * 0.5, l = this.valueSize;
    this._weightPrev = c / (e - o), this._weightNext = c / (a - n), this._offsetPrev = i * l, this._offsetNext = r * l;
  },
  interpolate_: function(t, e, n, s) {
    const i = this.resultBuffer, r = this.sampleValues, o = this.valueSize, a = t * o, c = a - o, l = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, f = (n - e) / (s - e), p = f * f, y = p * f, g = -h * y + 2 * h * p - h * f, m = (1 + h) * y + (-1.5 - 2 * h) * p + (-0.5 + h) * f + 1, x = (-1 - d) * y + (1.5 + d) * p + 0.5 * f, v = d * y - d * p;
    for (let b = 0; b !== o; ++b)
      i[b] = g * r[l + b] + m * r[c + b] + x * r[a + b] + v * r[u + b];
    return i;
  }
});
function yy(t, e, n, s) {
  Qi.call(this, t, e, n, s);
}
yy.prototype = Object.assign(Object.create(Qi.prototype), {
  constructor: yy,
  interpolate_: function(t, e, n, s) {
    const i = this.resultBuffer, r = this.sampleValues, o = this.valueSize, a = t * o, c = a - o, l = (n - e) / (s - e), u = 1 - l;
    for (let h = 0; h !== o; ++h)
      i[h] = r[c + h] * u + r[a + h] * l;
    return i;
  }
});
function aw(t, e, n, s) {
  Qi.call(this, t, e, n, s);
}
aw.prototype = Object.assign(Object.create(Qi.prototype), {
  constructor: aw,
  interpolate_: function(t) {
    return this.copySampleValue_(t - 1);
  }
});
function Us(t, e, n, s) {
  if (t === void 0)
    throw new Error("THREE.KeyframeTrack: track name is undefined");
  if (e === void 0 || e.length === 0)
    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
  this.name = t, this.times = Rn.convertArray(e, this.TimeBufferType), this.values = Rn.convertArray(n, this.ValueBufferType), this.setInterpolation(s || this.DefaultInterpolation);
}
Object.assign(Us, {
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  toJSON: function(t) {
    const e = t.constructor;
    let n;
    if (e.toJSON !== void 0)
      n = e.toJSON(t);
    else {
      n = {
        name: t.name,
        times: Rn.convertArray(t.times, Array),
        values: Rn.convertArray(t.values, Array)
      };
      const s = t.getInterpolation();
      s !== t.DefaultInterpolation && (n.interpolation = s);
    }
    return n.type = t.ValueTypeName, n;
  }
});
Object.assign(Us.prototype, {
  constructor: Us,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: Pg,
  InterpolantFactoryMethodDiscrete: function(t) {
    return new aw(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodLinear: function(t) {
    return new yy(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodSmooth: function(t) {
    return new ow(this.times, this.values, this.getValueSize(), t);
  },
  setInterpolation: function(t) {
    let e;
    switch (t) {
      case qg:
        e = this.InterpolantFactoryMethodDiscrete;
        break;
      case Pg:
        e = this.InterpolantFactoryMethodLinear;
        break;
      case Fb:
        e = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (e === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (t !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = e, this;
  },
  getInterpolation: function() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return qg;
      case this.InterpolantFactoryMethodLinear:
        return Pg;
      case this.InterpolantFactoryMethodSmooth:
        return Fb;
    }
  },
  getValueSize: function() {
    return this.values.length / this.times.length;
  },
  // move all keyframes either forwards or backwards in time
  shift: function(t) {
    if (t !== 0) {
      const e = this.times;
      for (let n = 0, s = e.length; n !== s; ++n)
        e[n] += t;
    }
    return this;
  },
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale: function(t) {
    if (t !== 1) {
      const e = this.times;
      for (let n = 0, s = e.length; n !== s; ++n)
        e[n] *= t;
    }
    return this;
  },
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim: function(t, e) {
    const n = this.times, s = n.length;
    let i = 0, r = s - 1;
    for (; i !== s && n[i] < t; )
      ++i;
    for (; r !== -1 && n[r] > e; )
      --r;
    if (++r, i !== 0 || r !== s) {
      i >= r && (r = Math.max(r, 1), i = r - 1);
      const o = this.getValueSize();
      this.times = Rn.arraySlice(n, i, r), this.values = Rn.arraySlice(this.values, i * o, r * o);
    }
    return this;
  },
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate: function() {
    let t = !0;
    const e = this.getValueSize();
    e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
    const n = this.times, s = this.values, i = n.length;
    i === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
    let r = null;
    for (let o = 0; o !== i; o++) {
      const a = n[o];
      if (typeof a == "number" && isNaN(a)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, a), t = !1;
        break;
      }
      if (r !== null && r > a) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, a, r), t = !1;
        break;
      }
      r = a;
    }
    if (s !== void 0 && Rn.isTypedArray(s))
      for (let o = 0, a = s.length; o !== a; ++o) {
        const c = s[o];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), t = !1;
          break;
        }
      }
    return t;
  },
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize: function() {
    const t = Rn.arraySlice(this.times), e = Rn.arraySlice(this.values), n = this.getValueSize(), s = this.getInterpolation() === Fb, i = t.length - 1;
    let r = 1;
    for (let o = 1; o < i; ++o) {
      let a = !1;
      const c = t[o], l = t[o + 1];
      if (c !== l && (o !== 1 || c !== c[0]))
        if (s)
          a = !0;
        else {
          const u = o * n, h = u - n, d = u + n;
          for (let f = 0; f !== n; ++f) {
            const p = e[u + f];
            if (p !== e[h + f] || p !== e[d + f]) {
              a = !0;
              break;
            }
          }
        }
      if (a) {
        if (o !== r) {
          t[r] = t[o];
          const u = o * n, h = r * n;
          for (let d = 0; d !== n; ++d)
            e[h + d] = e[u + d];
        }
        ++r;
      }
    }
    if (i > 0) {
      t[r] = t[i];
      for (let o = i * n, a = r * n, c = 0; c !== n; ++c)
        e[a + c] = e[o + c];
      ++r;
    }
    return r !== t.length ? (this.times = Rn.arraySlice(t, 0, r), this.values = Rn.arraySlice(e, 0, r * n)) : (this.times = t, this.values = e), this;
  },
  clone: function() {
    const t = Rn.arraySlice(this.times, 0), e = Rn.arraySlice(this.values, 0), n = this.constructor, s = new n(this.name, t, e);
    return s.createInterpolant = this.createInterpolant, s;
  }
});
function cw(t, e, n) {
  Us.call(this, t, e, n);
}
cw.prototype = Object.assign(Object.create(Us.prototype), {
  constructor: cw,
  ValueTypeName: "bool",
  ValueBufferType: Array,
  DefaultInterpolation: qg,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
  // Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".
});
function lw(t, e, n, s) {
  Us.call(this, t, e, n, s);
}
lw.prototype = Object.assign(Object.create(Us.prototype), {
  constructor: lw,
  ValueTypeName: "color"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
  // Note: Very basic implementation and nothing special yet.
  // However, this is the place for color space parameterization.
});
function Jd(t, e, n, s) {
  Us.call(this, t, e, n, s);
}
Jd.prototype = Object.assign(Object.create(Us.prototype), {
  constructor: Jd,
  ValueTypeName: "number"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function uw(t, e, n, s) {
  Qi.call(this, t, e, n, s);
}
uw.prototype = Object.assign(Object.create(Qi.prototype), {
  constructor: uw,
  interpolate_: function(t, e, n, s) {
    const i = this.resultBuffer, r = this.sampleValues, o = this.valueSize, a = (n - e) / (s - e);
    let c = t * o;
    for (let l = c + o; c !== l; c += 4)
      xs.slerpFlat(i, 0, r, c - o, r, c, a);
    return i;
  }
});
function xy(t, e, n, s) {
  Us.call(this, t, e, n, s);
}
xy.prototype = Object.assign(Object.create(Us.prototype), {
  constructor: xy,
  ValueTypeName: "quaternion",
  // ValueBufferType is inherited
  DefaultInterpolation: Pg,
  InterpolantFactoryMethodLinear: function(t) {
    return new uw(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodSmooth: void 0
  // not yet implemented
});
function hw(t, e, n, s) {
  Us.call(this, t, e, n, s);
}
hw.prototype = Object.assign(Object.create(Us.prototype), {
  constructor: hw,
  ValueTypeName: "string",
  ValueBufferType: Array,
  DefaultInterpolation: qg,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
});
function Qd(t, e, n, s) {
  Us.call(this, t, e, n, s);
}
Qd.prototype = Object.assign(Object.create(Us.prototype), {
  constructor: Qd,
  ValueTypeName: "vector"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function yr(t, e, n, s) {
  this.name = t, this.tracks = n, this.duration = e !== void 0 ? e : -1, this.blendMode = s !== void 0 ? s : $1, this.uuid = Et.generateUUID(), this.duration < 0 && this.resetDuration();
}
function sV(t) {
  switch (t.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Jd;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Qd;
    case "color":
      return lw;
    case "quaternion":
      return xy;
    case "bool":
    case "boolean":
      return cw;
    case "string":
      return hw;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
}
function iV(t) {
  if (t.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = sV(t.type);
  if (t.times === void 0) {
    const n = [], s = [];
    Rn.flattenJSON(t.keys, n, s, "value"), t.times = n, t.values = s;
  }
  return e.parse !== void 0 ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
}
Object.assign(yr, {
  parse: function(t) {
    const e = [], n = t.tracks, s = 1 / (t.fps || 1);
    for (let i = 0, r = n.length; i !== r; ++i)
      e.push(iV(n[i]).scale(s));
    return new yr(t.name, t.duration, e, t.blendMode);
  },
  toJSON: function(t) {
    const e = [], n = t.tracks, s = {
      name: t.name,
      duration: t.duration,
      tracks: e,
      uuid: t.uuid,
      blendMode: t.blendMode
    };
    for (let i = 0, r = n.length; i !== r; ++i)
      e.push(Us.toJSON(n[i]));
    return s;
  },
  CreateFromMorphTargetSequence: function(t, e, n, s) {
    const i = e.length, r = [];
    for (let o = 0; o < i; o++) {
      let a = [], c = [];
      a.push(
        (o + i - 1) % i,
        o,
        (o + 1) % i
      ), c.push(0, 1, 0);
      const l = Rn.getKeyframeOrder(a);
      a = Rn.sortedArray(a, 1, l), c = Rn.sortedArray(c, 1, l), !s && a[0] === 0 && (a.push(i), c.push(c[0])), r.push(
        new Jd(
          ".morphTargetInfluences[" + e[o].name + "]",
          a,
          c
        ).scale(1 / n)
      );
    }
    return new yr(t, -1, r);
  },
  findByName: function(t, e) {
    let n = t;
    if (!Array.isArray(t)) {
      const s = t;
      n = s.geometry && s.geometry.animations || s.animations;
    }
    for (let s = 0; s < n.length; s++)
      if (n[s].name === e)
        return n[s];
    return null;
  },
  CreateClipsFromMorphTargetSequences: function(t, e, n) {
    const s = {}, i = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, a = t.length; o < a; o++) {
      const c = t[o], l = c.name.match(i);
      if (l && l.length > 1) {
        const u = l[1];
        let h = s[u];
        h || (s[u] = h = []), h.push(c);
      }
    }
    const r = [];
    for (const o in s)
      r.push(yr.CreateFromMorphTargetSequence(o, s[o], e, n));
    return r;
  },
  // parse the animation.hierarchy format
  parseAnimation: function(t, e) {
    if (!t)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(u, h, d, f, p) {
      if (d.length !== 0) {
        const y = [], g = [];
        Rn.flattenJSON(d, y, g, f), y.length !== 0 && p.push(new u(h, y, g));
      }
    }, s = [], i = t.name || "default", r = t.fps || 30, o = t.blendMode;
    let a = t.length || -1;
    const c = t.hierarchy || [];
    for (let u = 0; u < c.length; u++) {
      const h = c[u].keys;
      if (!(!h || h.length === 0))
        if (h[0].morphTargets) {
          const d = {};
          let f;
          for (f = 0; f < h.length; f++)
            if (h[f].morphTargets)
              for (let p = 0; p < h[f].morphTargets.length; p++)
                d[h[f].morphTargets[p]] = -1;
          for (const p in d) {
            const y = [], g = [];
            for (let m = 0; m !== h[f].morphTargets.length; ++m) {
              const x = h[f];
              y.push(x.time), g.push(x.morphTarget === p ? 1 : 0);
            }
            s.push(new Jd(".morphTargetInfluence[" + p + "]", y, g));
          }
          a = d.length * (r || 1);
        } else {
          const d = ".bones[" + e[u].name + "]";
          n(
            Qd,
            d + ".position",
            h,
            "pos",
            s
          ), n(
            xy,
            d + ".quaternion",
            h,
            "rot",
            s
          ), n(
            Qd,
            d + ".scale",
            h,
            "scl",
            s
          );
        }
    }
    return s.length === 0 ? null : new yr(i, a, s, o);
  }
});
Object.assign(yr.prototype, {
  resetDuration: function() {
    const t = this.tracks;
    let e = 0;
    for (let n = 0, s = t.length; n !== s; ++n) {
      const i = this.tracks[n];
      e = Math.max(e, i.times[i.times.length - 1]);
    }
    return this.duration = e, this;
  },
  trim: function() {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].trim(0, this.duration);
    return this;
  },
  validate: function() {
    let t = !0;
    for (let e = 0; e < this.tracks.length; e++)
      t = t && this.tracks[e].validate();
    return t;
  },
  optimize: function() {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].optimize();
    return this;
  },
  clone: function() {
    const t = [];
    for (let e = 0; e < this.tracks.length; e++)
      t.push(this.tracks[e].clone());
    return new yr(this.name, this.duration, t, this.blendMode);
  }
});
const Zr = {
  enabled: !1,
  files: {},
  add: function(t, e) {
    this.enabled !== !1 && (this.files[t] = e);
  },
  get: function(t) {
    if (this.enabled !== !1)
      return this.files[t];
  },
  remove: function(t) {
    delete this.files[t];
  },
  clear: function() {
    this.files = {};
  }
};
function rN(t, e, n) {
  const s = this;
  let i = !1, r = 0, o = 0, a;
  const c = [];
  this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(l) {
    o++, i === !1 && s.onStart !== void 0 && s.onStart(l, r, o), i = !0;
  }, this.itemEnd = function(l) {
    r++, s.onProgress !== void 0 && s.onProgress(l, r, o), r === o && (i = !1, s.onLoad !== void 0 && s.onLoad());
  }, this.itemError = function(l) {
    s.onError !== void 0 && s.onError(l);
  }, this.resolveURL = function(l) {
    return a ? a(l) : l;
  }, this.setURLModifier = function(l) {
    return a = l, this;
  }, this.addHandler = function(l, u) {
    return c.push(l, u), this;
  }, this.removeHandler = function(l) {
    const u = c.indexOf(l);
    return u !== -1 && c.splice(u, 2), this;
  }, this.getHandler = function(l) {
    for (let u = 0, h = c.length; u < h; u += 2) {
      const d = c[u], f = c[u + 1];
      if (d.global && (d.lastIndex = 0), d.test(l))
        return f;
    }
    return null;
  };
}
const rV = new rN();
function Xt(t) {
  this.manager = t !== void 0 ? t : rV, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = "", this.requestHeader = {};
}
Object.assign(Xt.prototype, {
  load: function() {
  },
  loadAsync: function(t, e) {
    const n = this;
    return new Promise(function(s, i) {
      n.load(t, s, e, i);
    });
  },
  parse: function() {
  },
  setCrossOrigin: function(t) {
    return this.crossOrigin = t, this;
  },
  setPath: function(t) {
    return this.path = t, this;
  },
  setResourcePath: function(t) {
    return this.resourcePath = t, this;
  },
  setRequestHeader: function(t) {
    return this.requestHeader = t, this;
  }
});
const ur = {};
function Sr(t) {
  Xt.call(this, t);
}
Sr.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: Sr,
  load: function(t, e, n, s) {
    t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    const i = this, r = Zr.get(t);
    if (r !== void 0)
      return i.manager.itemStart(t), setTimeout(function() {
        e && e(r), i.manager.itemEnd(t);
      }, 0), r;
    if (ur[t] !== void 0) {
      ur[t].push({
        onLoad: e,
        onProgress: n,
        onError: s
      });
      return;
    }
    const o = /^data:(.*?)(;base64)?,(.*)$/, a = t.match(o);
    let c;
    if (a) {
      const l = a[1], u = !!a[2];
      let h = a[3];
      h = decodeURIComponent(h), u && (h = atob(h));
      try {
        let d;
        const f = (this.responseType || "").toLowerCase();
        switch (f) {
          case "arraybuffer":
          case "blob":
            const p = new Uint8Array(h.length);
            for (let g = 0; g < h.length; g++)
              p[g] = h.charCodeAt(g);
            f === "blob" ? d = new Blob([p.buffer], { type: l }) : d = p.buffer;
            break;
          case "document":
            d = new DOMParser().parseFromString(h, l);
            break;
          case "json":
            d = JSON.parse(h);
            break;
          default:
            d = h;
            break;
        }
        setTimeout(function() {
          e && e(d), i.manager.itemEnd(t);
        }, 0);
      } catch (d) {
        setTimeout(function() {
          s && s(d), i.manager.itemError(t), i.manager.itemEnd(t);
        }, 0);
      }
    } else {
      ur[t] = [], ur[t].push({
        onLoad: e,
        onProgress: n,
        onError: s
      }), c = new XMLHttpRequest(), c.open("GET", t, !0), c.addEventListener("load", function(l) {
        const u = this.response, h = ur[t];
        if (delete ur[t], this.status === 200 || this.status === 0) {
          this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), Zr.add(t, u);
          for (let d = 0, f = h.length; d < f; d++) {
            const p = h[d];
            p.onLoad && p.onLoad(u);
          }
          i.manager.itemEnd(t);
        } else {
          for (let d = 0, f = h.length; d < f; d++) {
            const p = h[d];
            p.onError && p.onError(l);
          }
          i.manager.itemError(t), i.manager.itemEnd(t);
        }
      }, !1), c.addEventListener("progress", function(l) {
        const u = ur[t];
        for (let h = 0, d = u.length; h < d; h++) {
          const f = u[h];
          f.onProgress && f.onProgress(l);
        }
      }, !1), c.addEventListener("error", function(l) {
        const u = ur[t];
        delete ur[t];
        for (let h = 0, d = u.length; h < d; h++) {
          const f = u[h];
          f.onError && f.onError(l);
        }
        i.manager.itemError(t), i.manager.itemEnd(t);
      }, !1), c.addEventListener("abort", function(l) {
        const u = ur[t];
        delete ur[t];
        for (let h = 0, d = u.length; h < d; h++) {
          const f = u[h];
          f.onError && f.onError(l);
        }
        i.manager.itemError(t), i.manager.itemEnd(t);
      }, !1), this.responseType !== void 0 && (c.responseType = this.responseType), this.withCredentials !== void 0 && (c.withCredentials = this.withCredentials), c.overrideMimeType && c.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (const l in this.requestHeader)
        c.setRequestHeader(l, this.requestHeader[l]);
      c.send(null);
    }
    return i.manager.itemStart(t), c;
  },
  setResponseType: function(t) {
    return this.responseType = t, this;
  },
  setWithCredentials: function(t) {
    return this.withCredentials = t, this;
  },
  setMimeType: function(t) {
    return this.mimeType = t, this;
  }
});
function GC(t) {
  Xt.call(this, t);
}
GC.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: GC,
  load: function(t, e, n, s) {
    const i = this, r = new Sr(i.manager);
    r.setPath(i.path), r.setRequestHeader(i.requestHeader), r.load(t, function(o) {
      try {
        e(i.parse(JSON.parse(o)));
      } catch (a) {
        s ? s(a) : console.error(a), i.manager.itemError(t);
      }
    }, n, s);
  },
  parse: function(t) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
      const s = yr.parse(t[n]);
      e.push(s);
    }
    return e;
  }
});
function WC(t) {
  Xt.call(this, t);
}
WC.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: WC,
  load: function(t, e, n, s) {
    const i = this, r = [], o = new Ld();
    o.image = r;
    const a = new Sr(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader);
    let c = 0;
    function l(u) {
      a.load(t[u], function(h) {
        const d = i.parse(h, !0);
        r[u] = {
          width: d.width,
          height: d.height,
          format: d.format,
          mipmaps: d.mipmaps
        }, c += 1, c === 6 && (d.mipmapCount === 1 && (o.minFilter = Vs), o.format = d.format, o.needsUpdate = !0, e && e(o));
      }, n, s);
    }
    if (Array.isArray(t))
      for (let u = 0, h = t.length; u < h; ++u)
        l(u);
    else
      a.load(t, function(u) {
        const h = i.parse(u, !0);
        if (h.isCubemap) {
          const d = h.mipmaps.length / h.mipmapCount;
          for (let f = 0; f < d; f++) {
            r[f] = { mipmaps: [] };
            for (let p = 0; p < h.mipmapCount; p++)
              r[f].mipmaps.push(h.mipmaps[f * h.mipmapCount + p]), r[f].format = h.format, r[f].width = h.width, r[f].height = h.height;
          }
        } else
          o.image.width = h.width, o.image.height = h.height, o.mipmaps = h.mipmaps;
        h.mipmapCount === 1 && (o.minFilter = Vs), o.format = h.format, o.needsUpdate = !0, e && e(o);
      }, n, s);
    return o;
  }
});
function HC(t) {
  Xt.call(this, t);
}
HC.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: HC,
  load: function(t, e, n, s) {
    const i = this, r = new tu(), o = new Sr(this.manager);
    return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.load(t, function(a) {
      const c = i.parse(a);
      c && (c.image !== void 0 ? r.image = c.image : c.data !== void 0 && (r.image.width = c.width, r.image.height = c.height, r.image.data = c.data), r.wrapS = c.wrapS !== void 0 ? c.wrapS : hi, r.wrapT = c.wrapT !== void 0 ? c.wrapT : hi, r.magFilter = c.magFilter !== void 0 ? c.magFilter : Vs, r.minFilter = c.minFilter !== void 0 ? c.minFilter : Vs, r.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.format !== void 0 && (r.format = c.format), c.type !== void 0 && (r.type = c.type), c.mipmaps !== void 0 && (r.mipmaps = c.mipmaps, r.minFilter = ux), c.mipmapCount === 1 && (r.minFilter = Vs), r.needsUpdate = !0, e && e(r, c));
    }, n, s), r;
  }
});
function ef(t) {
  Xt.call(this, t);
}
ef.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: ef,
  load: function(t, e, n, s) {
    this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    const i = this, r = Zr.get(t);
    if (r !== void 0)
      return i.manager.itemStart(t), setTimeout(function() {
        e && e(r), i.manager.itemEnd(t);
      }, 0), r;
    const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function a() {
      o.removeEventListener("load", a, !1), o.removeEventListener("error", c, !1), Zr.add(t, this), e && e(this), i.manager.itemEnd(t);
    }
    function c(l) {
      o.removeEventListener("load", a, !1), o.removeEventListener("error", c, !1), s && s(l), i.manager.itemError(t), i.manager.itemEnd(t);
    }
    return o.addEventListener("load", a, !1), o.addEventListener("error", c, !1), t.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(t), o.src = t, o;
  }
});
function dw(t) {
  Xt.call(this, t);
}
dw.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: dw,
  load: function(t, e, n, s) {
    const i = new xa(), r = new ef(this.manager);
    r.setCrossOrigin(this.crossOrigin), r.setPath(this.path);
    let o = 0;
    function a(c) {
      r.load(t[c], function(l) {
        i.images[c] = l, o++, o === 6 && (i.needsUpdate = !0, e && e(i));
      }, void 0, s);
    }
    for (let c = 0; c < t.length; ++c)
      a(c);
    return i;
  }
});
function by(t) {
  Xt.call(this, t);
}
by.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: by,
  load: function(t, e, n, s) {
    const i = new dn(), r = new ef(this.manager);
    return r.setCrossOrigin(this.crossOrigin), r.setPath(this.path), r.load(t, function(o) {
      i.image = o;
      const a = t.search(/\.jpe?g($|\?)/i) > 0 || t.search(/^data\:image\/jpeg/) === 0;
      i.format = a ? xc : Zi, i.needsUpdate = !0, e !== void 0 && e(i);
    }, n, s), i;
  }
});
function ht() {
  this.type = "Curve", this.arcLengthDivisions = 200;
}
Object.assign(ht.prototype, {
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint: function() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  },
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt: function(t, e) {
    const n = this.getUtoTmapping(t);
    return this.getPoint(n, e);
  },
  // Get sequence of points using getPoint( t )
  getPoints: function(t) {
    t === void 0 && (t = 5);
    const e = [];
    for (let n = 0; n <= t; n++)
      e.push(this.getPoint(n / t));
    return e;
  },
  // Get sequence of points using getPointAt( u )
  getSpacedPoints: function(t) {
    t === void 0 && (t = 5);
    const e = [];
    for (let n = 0; n <= t; n++)
      e.push(this.getPointAt(n / t));
    return e;
  },
  // Get total curve arc length
  getLength: function() {
    const t = this.getLengths();
    return t[t.length - 1];
  },
  // Get list of cumulative segment lengths
  getLengths: function(t) {
    if (t === void 0 && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const e = [];
    let n, s = this.getPoint(0), i = 0;
    e.push(0);
    for (let r = 1; r <= t; r++)
      n = this.getPoint(r / t), i += n.distanceTo(s), e.push(i), s = n;
    return this.cacheArcLengths = e, e;
  },
  updateArcLengths: function() {
    this.needsUpdate = !0, this.getLengths();
  },
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping: function(t, e) {
    const n = this.getLengths();
    let s = 0, i = n.length, r;
    e ? r = e : r = t * n[i - 1];
    let o = 0, a = i - 1, c;
    for (; o <= a; )
      if (s = Math.floor(o + (a - o) / 2), c = n[s] - r, c < 0)
        o = s + 1;
      else if (c > 0)
        a = s - 1;
      else {
        a = s;
        break;
      }
    if (s = a, n[s] === r)
      return s / (i - 1);
    const l = n[s], h = n[s + 1] - l, d = (r - l) / h;
    return (s + d) / (i - 1);
  },
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent: function(t, e) {
    let s = t - 1e-4, i = t + 1e-4;
    s < 0 && (s = 0), i > 1 && (i = 1);
    const r = this.getPoint(s), o = this.getPoint(i), a = e || (r.isVector2 ? new Ce() : new P());
    return a.copy(o).sub(r).normalize(), a;
  },
  getTangentAt: function(t, e) {
    const n = this.getUtoTmapping(t);
    return this.getTangent(n, e);
  },
  computeFrenetFrames: function(t, e) {
    const n = new P(), s = [], i = [], r = [], o = new P(), a = new Mt();
    for (let d = 0; d <= t; d++) {
      const f = d / t;
      s[d] = this.getTangentAt(f, new P()), s[d].normalize();
    }
    i[0] = new P(), r[0] = new P();
    let c = Number.MAX_VALUE;
    const l = Math.abs(s[0].x), u = Math.abs(s[0].y), h = Math.abs(s[0].z);
    l <= c && (c = l, n.set(1, 0, 0)), u <= c && (c = u, n.set(0, 1, 0)), h <= c && n.set(0, 0, 1), o.crossVectors(s[0], n).normalize(), i[0].crossVectors(s[0], o), r[0].crossVectors(s[0], i[0]);
    for (let d = 1; d <= t; d++) {
      if (i[d] = i[d - 1].clone(), r[d] = r[d - 1].clone(), o.crossVectors(s[d - 1], s[d]), o.length() > Number.EPSILON) {
        o.normalize();
        const f = Math.acos(Et.clamp(s[d - 1].dot(s[d]), -1, 1));
        i[d].applyMatrix4(a.makeRotationAxis(o, f));
      }
      r[d].crossVectors(s[d], i[d]);
    }
    if (e === !0) {
      let d = Math.acos(Et.clamp(i[0].dot(i[t]), -1, 1));
      d /= t, s[0].dot(o.crossVectors(i[0], i[t])) > 0 && (d = -d);
      for (let f = 1; f <= t; f++)
        i[f].applyMatrix4(a.makeRotationAxis(s[f], d * f)), r[f].crossVectors(s[f], i[f]);
    }
    return {
      tangents: s,
      normals: i,
      binormals: r
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  },
  toJSON: function() {
    const t = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
  },
  fromJSON: function(t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  }
});
function sr(t, e, n, s, i, r, o, a) {
  ht.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = s || 1, this.aStartAngle = i || 0, this.aEndAngle = r || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = a || 0;
}
sr.prototype = Object.create(ht.prototype);
sr.prototype.constructor = sr;
sr.prototype.isEllipseCurve = !0;
sr.prototype.getPoint = function(t, e) {
  const n = e || new Ce(), s = Math.PI * 2;
  let i = this.aEndAngle - this.aStartAngle;
  const r = Math.abs(i) < Number.EPSILON;
  for (; i < 0; )
    i += s;
  for (; i > s; )
    i -= s;
  i < Number.EPSILON && (r ? i = 0 : i = s), this.aClockwise === !0 && !r && (i === s ? i = -s : i = i - s);
  const o = this.aStartAngle + t * i;
  let a = this.aX + this.xRadius * Math.cos(o), c = this.aY + this.yRadius * Math.sin(o);
  if (this.aRotation !== 0) {
    const l = Math.cos(this.aRotation), u = Math.sin(this.aRotation), h = a - this.aX, d = c - this.aY;
    a = h * l - d * u + this.aX, c = h * u + d * l + this.aY;
  }
  return n.set(a, c);
};
sr.prototype.copy = function(t) {
  return ht.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
};
sr.prototype.toJSON = function() {
  const t = ht.prototype.toJSON.call(this);
  return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
};
sr.prototype.fromJSON = function(t) {
  return ht.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
};
function tf(t, e, n, s, i, r) {
  sr.call(this, t, e, n, n, s, i, r), this.type = "ArcCurve";
}
tf.prototype = Object.create(sr.prototype);
tf.prototype.constructor = tf;
tf.prototype.isArcCurve = !0;
function P1() {
  let t = 0, e = 0, n = 0, s = 0;
  function i(r, o, a, c) {
    t = r, e = a, n = -3 * r + 3 * o - 2 * a - c, s = 2 * r - 2 * o + a + c;
  }
  return {
    initCatmullRom: function(r, o, a, c, l) {
      i(o, a, l * (a - r), l * (c - o));
    },
    initNonuniformCatmullRom: function(r, o, a, c, l, u, h) {
      let d = (o - r) / l - (a - r) / (l + u) + (a - o) / u, f = (a - o) / u - (c - o) / (u + h) + (c - a) / h;
      d *= u, f *= u, i(o, a, d, f);
    },
    calc: function(r) {
      const o = r * r, a = o * r;
      return t + e * r + n * o + s * a;
    }
  };
}
const sg = new P(), cv = new P1(), lv = new P1(), uv = new P1();
function Oi(t, e, n, s) {
  ht.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = s !== void 0 ? s : 0.5;
}
Oi.prototype = Object.create(ht.prototype);
Oi.prototype.constructor = Oi;
Oi.prototype.isCatmullRomCurve3 = !0;
Oi.prototype.getPoint = function(t, e) {
  const n = e || new P(), s = this.points, i = s.length, r = (i - (this.closed ? 0 : 1)) * t;
  let o = Math.floor(r), a = r - o;
  this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / i) + 1) * i : a === 0 && o === i - 1 && (o = i - 2, a = 1);
  let c, l, u, h;
  if (this.closed || o > 0 ? c = s[(o - 1) % i] : (sg.subVectors(s[0], s[1]).add(s[0]), c = sg), l = s[o % i], u = s[(o + 1) % i], this.closed || o + 2 < i ? h = s[(o + 2) % i] : (sg.subVectors(s[i - 1], s[i - 2]).add(s[i - 1]), h = sg), this.curveType === "centripetal" || this.curveType === "chordal") {
    const d = this.curveType === "chordal" ? 0.5 : 0.25;
    let f = Math.pow(c.distanceToSquared(l), d), p = Math.pow(l.distanceToSquared(u), d), y = Math.pow(u.distanceToSquared(h), d);
    p < 1e-4 && (p = 1), f < 1e-4 && (f = p), y < 1e-4 && (y = p), cv.initNonuniformCatmullRom(c.x, l.x, u.x, h.x, f, p, y), lv.initNonuniformCatmullRom(c.y, l.y, u.y, h.y, f, p, y), uv.initNonuniformCatmullRom(c.z, l.z, u.z, h.z, f, p, y);
  } else
    this.curveType === "catmullrom" && (cv.initCatmullRom(c.x, l.x, u.x, h.x, this.tension), lv.initCatmullRom(c.y, l.y, u.y, h.y, this.tension), uv.initCatmullRom(c.z, l.z, u.z, h.z, this.tension));
  return n.set(
    cv.calc(a),
    lv.calc(a),
    uv.calc(a)
  ), n;
};
Oi.prototype.copy = function(t) {
  ht.prototype.copy.call(this, t), this.points = [];
  for (let e = 0, n = t.points.length; e < n; e++) {
    const s = t.points[e];
    this.points.push(s.clone());
  }
  return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
};
Oi.prototype.toJSON = function() {
  const t = ht.prototype.toJSON.call(this);
  t.points = [];
  for (let e = 0, n = this.points.length; e < n; e++) {
    const s = this.points[e];
    t.points.push(s.toArray());
  }
  return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
};
Oi.prototype.fromJSON = function(t) {
  ht.prototype.fromJSON.call(this, t), this.points = [];
  for (let e = 0, n = t.points.length; e < n; e++) {
    const s = t.points[e];
    this.points.push(new P().fromArray(s));
  }
  return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
};
function jC(t, e, n, s, i) {
  const r = (s - e) * 0.5, o = (i - n) * 0.5, a = t * t, c = t * a;
  return (2 * n - 2 * s + r + o) * c + (-3 * n + 3 * s - 2 * r - o) * a + r * t + n;
}
function oV(t, e) {
  const n = 1 - t;
  return n * n * e;
}
function aV(t, e) {
  return 2 * (1 - t) * t * e;
}
function cV(t, e) {
  return t * t * e;
}
function Td(t, e, n, s) {
  return oV(t, e) + aV(t, n) + cV(t, s);
}
function lV(t, e) {
  const n = 1 - t;
  return n * n * n * e;
}
function uV(t, e) {
  const n = 1 - t;
  return 3 * n * n * t * e;
}
function hV(t, e) {
  return 3 * (1 - t) * t * t * e;
}
function dV(t, e) {
  return t * t * t * e;
}
function Cd(t, e, n, s, i) {
  return lV(t, e) + uV(t, n) + hV(t, s) + dV(t, i);
}
function Jr(t, e, n, s) {
  ht.call(this), this.type = "CubicBezierCurve", this.v0 = t || new Ce(), this.v1 = e || new Ce(), this.v2 = n || new Ce(), this.v3 = s || new Ce();
}
Jr.prototype = Object.create(ht.prototype);
Jr.prototype.constructor = Jr;
Jr.prototype.isCubicBezierCurve = !0;
Jr.prototype.getPoint = function(t, e) {
  const n = e || new Ce(), s = this.v0, i = this.v1, r = this.v2, o = this.v3;
  return n.set(
    Cd(t, s.x, i.x, r.x, o.x),
    Cd(t, s.y, i.y, r.y, o.y)
  ), n;
};
Jr.prototype.copy = function(t) {
  return ht.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
};
Jr.prototype.toJSON = function() {
  const t = ht.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
};
Jr.prototype.fromJSON = function(t) {
  return ht.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
};
function ko(t, e, n, s) {
  ht.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new P(), this.v1 = e || new P(), this.v2 = n || new P(), this.v3 = s || new P();
}
ko.prototype = Object.create(ht.prototype);
ko.prototype.constructor = ko;
ko.prototype.isCubicBezierCurve3 = !0;
ko.prototype.getPoint = function(t, e) {
  const n = e || new P(), s = this.v0, i = this.v1, r = this.v2, o = this.v3;
  return n.set(
    Cd(t, s.x, i.x, r.x, o.x),
    Cd(t, s.y, i.y, r.y, o.y),
    Cd(t, s.z, i.z, r.z, o.z)
  ), n;
};
ko.prototype.copy = function(t) {
  return ht.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
};
ko.prototype.toJSON = function() {
  const t = ht.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
};
ko.prototype.fromJSON = function(t) {
  return ht.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
};
function Li(t, e) {
  ht.call(this), this.type = "LineCurve", this.v1 = t || new Ce(), this.v2 = e || new Ce();
}
Li.prototype = Object.create(ht.prototype);
Li.prototype.constructor = Li;
Li.prototype.isLineCurve = !0;
Li.prototype.getPoint = function(t, e) {
  const n = e || new Ce();
  return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
};
Li.prototype.getPointAt = function(t, e) {
  return this.getPoint(t, e);
};
Li.prototype.getTangent = function(t, e) {
  const n = e || new Ce();
  return n.copy(this.v2).sub(this.v1).normalize(), n;
};
Li.prototype.copy = function(t) {
  return ht.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
};
Li.prototype.toJSON = function() {
  const t = ht.prototype.toJSON.call(this);
  return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
};
Li.prototype.fromJSON = function(t) {
  return ht.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
};
function Qr(t, e) {
  ht.call(this), this.type = "LineCurve3", this.v1 = t || new P(), this.v2 = e || new P();
}
Qr.prototype = Object.create(ht.prototype);
Qr.prototype.constructor = Qr;
Qr.prototype.isLineCurve3 = !0;
Qr.prototype.getPoint = function(t, e) {
  const n = e || new P();
  return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
};
Qr.prototype.getPointAt = function(t, e) {
  return this.getPoint(t, e);
};
Qr.prototype.copy = function(t) {
  return ht.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
};
Qr.prototype.toJSON = function() {
  const t = ht.prototype.toJSON.call(this);
  return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
};
Qr.prototype.fromJSON = function(t) {
  return ht.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
};
function eo(t, e, n) {
  ht.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new Ce(), this.v1 = e || new Ce(), this.v2 = n || new Ce();
}
eo.prototype = Object.create(ht.prototype);
eo.prototype.constructor = eo;
eo.prototype.isQuadraticBezierCurve = !0;
eo.prototype.getPoint = function(t, e) {
  const n = e || new Ce(), s = this.v0, i = this.v1, r = this.v2;
  return n.set(
    Td(t, s.x, i.x, r.x),
    Td(t, s.y, i.y, r.y)
  ), n;
};
eo.prototype.copy = function(t) {
  return ht.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
};
eo.prototype.toJSON = function() {
  const t = ht.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
};
eo.prototype.fromJSON = function(t) {
  return ht.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
};
function Ao(t, e, n) {
  ht.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new P(), this.v1 = e || new P(), this.v2 = n || new P();
}
Ao.prototype = Object.create(ht.prototype);
Ao.prototype.constructor = Ao;
Ao.prototype.isQuadraticBezierCurve3 = !0;
Ao.prototype.getPoint = function(t, e) {
  const n = e || new P(), s = this.v0, i = this.v1, r = this.v2;
  return n.set(
    Td(t, s.x, i.x, r.x),
    Td(t, s.y, i.y, r.y),
    Td(t, s.z, i.z, r.z)
  ), n;
};
Ao.prototype.copy = function(t) {
  return ht.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
};
Ao.prototype.toJSON = function() {
  const t = ht.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
};
Ao.prototype.fromJSON = function(t) {
  return ht.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
};
function to(t) {
  ht.call(this), this.type = "SplineCurve", this.points = t || [];
}
to.prototype = Object.create(ht.prototype);
to.prototype.constructor = to;
to.prototype.isSplineCurve = !0;
to.prototype.getPoint = function(t, e) {
  const n = e || new Ce(), s = this.points, i = (s.length - 1) * t, r = Math.floor(i), o = i - r, a = s[r === 0 ? r : r - 1], c = s[r], l = s[r > s.length - 2 ? s.length - 1 : r + 1], u = s[r > s.length - 3 ? s.length - 1 : r + 2];
  return n.set(
    jC(o, a.x, c.x, l.x, u.x),
    jC(o, a.y, c.y, l.y, u.y)
  ), n;
};
to.prototype.copy = function(t) {
  ht.prototype.copy.call(this, t), this.points = [];
  for (let e = 0, n = t.points.length; e < n; e++) {
    const s = t.points[e];
    this.points.push(s.clone());
  }
  return this;
};
to.prototype.toJSON = function() {
  const t = ht.prototype.toJSON.call(this);
  t.points = [];
  for (let e = 0, n = this.points.length; e < n; e++) {
    const s = this.points[e];
    t.points.push(s.toArray());
  }
  return t;
};
to.prototype.fromJSON = function(t) {
  ht.prototype.fromJSON.call(this, t), this.points = [];
  for (let e = 0, n = t.points.length; e < n; e++) {
    const s = t.points[e];
    this.points.push(new Ce().fromArray(s));
  }
  return this;
};
var fw = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: tf,
  CatmullRomCurve3: Oi,
  CubicBezierCurve: Jr,
  CubicBezierCurve3: ko,
  EllipseCurve: sr,
  LineCurve: Li,
  LineCurve3: Qr,
  QuadraticBezierCurve: eo,
  QuadraticBezierCurve3: Ao,
  SplineCurve: to
});
function aa() {
  ht.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
}
aa.prototype = Object.assign(Object.create(ht.prototype), {
  constructor: aa,
  add: function(t) {
    this.curves.push(t);
  },
  closePath: function() {
    const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
    t.equals(e) || this.curves.push(new Li(e, t));
  },
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint: function(t) {
    const e = t * this.getLength(), n = this.getCurveLengths();
    let s = 0;
    for (; s < n.length; ) {
      if (n[s] >= e) {
        const i = n[s] - e, r = this.curves[s], o = r.getLength(), a = o === 0 ? 0 : 1 - i / o;
        return r.getPointAt(a);
      }
      s++;
    }
    return null;
  },
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength: function() {
    const t = this.getCurveLengths();
    return t[t.length - 1];
  },
  // cacheLengths must be recalculated.
  updateArcLengths: function() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  },
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths: function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const t = [];
    let e = 0;
    for (let n = 0, s = this.curves.length; n < s; n++)
      e += this.curves[n].getLength(), t.push(e);
    return this.cacheLengths = t, t;
  },
  getSpacedPoints: function(t) {
    t === void 0 && (t = 40);
    const e = [];
    for (let n = 0; n <= t; n++)
      e.push(this.getPoint(n / t));
    return this.autoClose && e.push(e[0]), e;
  },
  getPoints: function(t) {
    t = t || 12;
    const e = [];
    let n;
    for (let s = 0, i = this.curves; s < i.length; s++) {
      const r = i[s], o = r && r.isEllipseCurve ? t * 2 : r && (r.isLineCurve || r.isLineCurve3) ? 1 : r && r.isSplineCurve ? t * r.points.length : t, a = r.getPoints(o);
      for (let c = 0; c < a.length; c++) {
        const l = a[c];
        n && n.equals(l) || (e.push(l), n = l);
      }
    }
    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
  },
  copy: function(t) {
    ht.prototype.copy.call(this, t), this.curves = [];
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const s = t.curves[e];
      this.curves.push(s.clone());
    }
    return this.autoClose = t.autoClose, this;
  },
  toJSON: function() {
    const t = ht.prototype.toJSON.call(this);
    t.autoClose = this.autoClose, t.curves = [];
    for (let e = 0, n = this.curves.length; e < n; e++) {
      const s = this.curves[e];
      t.curves.push(s.toJSON());
    }
    return t;
  },
  fromJSON: function(t) {
    ht.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const s = t.curves[e];
      this.curves.push(new fw[s.type]().fromJSON(s));
    }
    return this;
  }
});
function Ur(t) {
  aa.call(this), this.type = "Path", this.currentPoint = new Ce(), t && this.setFromPoints(t);
}
Ur.prototype = Object.assign(Object.create(aa.prototype), {
  constructor: Ur,
  setFromPoints: function(t) {
    this.moveTo(t[0].x, t[0].y);
    for (let e = 1, n = t.length; e < n; e++)
      this.lineTo(t[e].x, t[e].y);
    return this;
  },
  moveTo: function(t, e) {
    return this.currentPoint.set(t, e), this;
  },
  lineTo: function(t, e) {
    const n = new Li(this.currentPoint.clone(), new Ce(t, e));
    return this.curves.push(n), this.currentPoint.set(t, e), this;
  },
  quadraticCurveTo: function(t, e, n, s) {
    const i = new eo(
      this.currentPoint.clone(),
      new Ce(t, e),
      new Ce(n, s)
    );
    return this.curves.push(i), this.currentPoint.set(n, s), this;
  },
  bezierCurveTo: function(t, e, n, s, i, r) {
    const o = new Jr(
      this.currentPoint.clone(),
      new Ce(t, e),
      new Ce(n, s),
      new Ce(i, r)
    );
    return this.curves.push(o), this.currentPoint.set(i, r), this;
  },
  splineThru: function(t) {
    const e = [this.currentPoint.clone()].concat(t), n = new to(e);
    return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this;
  },
  arc: function(t, e, n, s, i, r) {
    const o = this.currentPoint.x, a = this.currentPoint.y;
    return this.absarc(
      t + o,
      e + a,
      n,
      s,
      i,
      r
    ), this;
  },
  absarc: function(t, e, n, s, i, r) {
    return this.absellipse(t, e, n, n, s, i, r), this;
  },
  ellipse: function(t, e, n, s, i, r, o, a) {
    const c = this.currentPoint.x, l = this.currentPoint.y;
    return this.absellipse(t + c, e + l, n, s, i, r, o, a), this;
  },
  absellipse: function(t, e, n, s, i, r, o, a) {
    const c = new sr(t, e, n, s, i, r, o, a);
    if (this.curves.length > 0) {
      const u = c.getPoint(0);
      u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
    }
    this.curves.push(c);
    const l = c.getPoint(1);
    return this.currentPoint.copy(l), this;
  },
  copy: function(t) {
    return aa.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this;
  },
  toJSON: function() {
    const t = aa.prototype.toJSON.call(this);
    return t.currentPoint = this.currentPoint.toArray(), t;
  },
  fromJSON: function(t) {
    return aa.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this;
  }
});
function bc(t) {
  Ur.call(this, t), this.uuid = Et.generateUUID(), this.type = "Shape", this.holes = [];
}
bc.prototype = Object.assign(Object.create(Ur.prototype), {
  constructor: bc,
  getPointsHoles: function(t) {
    const e = [];
    for (let n = 0, s = this.holes.length; n < s; n++)
      e[n] = this.holes[n].getPoints(t);
    return e;
  },
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints: function(t) {
    return {
      shape: this.getPoints(t),
      holes: this.getPointsHoles(t)
    };
  },
  copy: function(t) {
    Ur.prototype.copy.call(this, t), this.holes = [];
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const s = t.holes[e];
      this.holes.push(s.clone());
    }
    return this;
  },
  toJSON: function() {
    const t = Ur.prototype.toJSON.call(this);
    t.uuid = this.uuid, t.holes = [];
    for (let e = 0, n = this.holes.length; e < n; e++) {
      const s = this.holes[e];
      t.holes.push(s.toJSON());
    }
    return t;
  },
  fromJSON: function(t) {
    Ur.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const s = t.holes[e];
      this.holes.push(new Ur().fromJSON(s));
    }
    return this;
  }
});
function Sn(t, e) {
  qe.call(this), this.type = "Light", this.color = new st(t), this.intensity = e !== void 0 ? e : 1, this.receiveShadow = void 0;
}
Sn.prototype = Object.assign(Object.create(qe.prototype), {
  constructor: Sn,
  isLight: !0,
  copy: function(t) {
    return qe.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this;
  },
  toJSON: function(t) {
    const e = qe.prototype.toJSON.call(this, t);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), e;
  }
});
function pw(t, e, n) {
  Sn.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(qe.DefaultUp), this.updateMatrix(), this.groundColor = new st(e);
}
pw.prototype = Object.assign(Object.create(Sn.prototype), {
  constructor: pw,
  isHemisphereLight: !0,
  copy: function(t) {
    return Sn.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
  }
});
function Mo(t) {
  this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Ce(512, 512), this.map = null, this.mapPass = null, this.matrix = new Mt(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Of(), this._frameExtents = new Ce(1, 1), this._viewportCount = 1, this._viewports = [
    new en(0, 0, 1, 1)
  ];
}
Object.assign(Mo.prototype, {
  _projScreenMatrix: new Mt(),
  _lightPositionWorld: new P(),
  _lookTarget: new P(),
  getViewportCount: function() {
    return this._viewportCount;
  },
  getFrustum: function() {
    return this._frustum;
  },
  updateMatrices: function(t) {
    const e = this.camera, n = this.matrix, s = this._projScreenMatrix, i = this._lookTarget, r = this._lightPositionWorld;
    r.setFromMatrixPosition(t.matrixWorld), e.position.copy(r), i.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(i), e.updateMatrixWorld(), s.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(s), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse);
  },
  getViewport: function(t) {
    return this._viewports[t];
  },
  getFrameExtents: function() {
    return this._frameExtents;
  },
  copy: function(t) {
    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    const t = {};
    return this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
  }
});
function mw() {
  Mo.call(this, new Yn(50, 1, 0.5, 500));
}
mw.prototype = Object.assign(Object.create(Mo.prototype), {
  constructor: mw,
  isSpotLightShadow: !0,
  updateMatrices: function(t) {
    const e = this.camera, n = Et.RAD2DEG * 2 * t.angle, s = this.mapSize.width / this.mapSize.height, i = t.distance || e.far;
    (n !== e.fov || s !== e.aspect || i !== e.far) && (e.fov = n, e.aspect = s, e.far = i, e.updateProjectionMatrix()), Mo.prototype.updateMatrices.call(this, t);
  }
});
function gw(t, e, n, s, i, r) {
  Sn.call(this, t, e), this.type = "SpotLight", this.position.copy(qe.DefaultUp), this.updateMatrix(), this.target = new qe(), Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * Math.PI;
    },
    set: function(o) {
      this.intensity = o / Math.PI;
    }
  }), this.distance = n !== void 0 ? n : 0, this.angle = s !== void 0 ? s : Math.PI / 3, this.penumbra = i !== void 0 ? i : 0, this.decay = r !== void 0 ? r : 1, this.shadow = new mw();
}
gw.prototype = Object.assign(Object.create(Sn.prototype), {
  constructor: gw,
  isSpotLight: !0,
  copy: function(t) {
    return Sn.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
});
function yw() {
  Mo.call(this, new Yn(90, 1, 0.5, 500)), this._frameExtents = new Ce(4, 2), this._viewportCount = 6, this._viewports = [
    // These viewports map a cube-map onto a 2D texture with the
    // following orientation:
    //
    //  xzXZ
    //   y Y
    //
    // X - Positive x direction
    // x - Negative x direction
    // Y - Positive y direction
    // y - Negative y direction
    // Z - Positive z direction
    // z - Negative z direction
    // positive X
    new en(2, 1, 1, 1),
    // negative X
    new en(0, 1, 1, 1),
    // positive Z
    new en(3, 1, 1, 1),
    // negative Z
    new en(1, 1, 1, 1),
    // positive Y
    new en(3, 0, 1, 1),
    // negative Y
    new en(1, 0, 1, 1)
  ], this._cubeDirections = [
    new P(1, 0, 0),
    new P(-1, 0, 0),
    new P(0, 0, 1),
    new P(0, 0, -1),
    new P(0, 1, 0),
    new P(0, -1, 0)
  ], this._cubeUps = [
    new P(0, 1, 0),
    new P(0, 1, 0),
    new P(0, 1, 0),
    new P(0, 1, 0),
    new P(0, 0, 1),
    new P(0, 0, -1)
  ];
}
yw.prototype = Object.assign(Object.create(Mo.prototype), {
  constructor: yw,
  isPointLightShadow: !0,
  updateMatrices: function(t, e) {
    e === void 0 && (e = 0);
    const n = this.camera, s = this.matrix, i = this._lightPositionWorld, r = this._lookTarget, o = this._projScreenMatrix;
    i.setFromMatrixPosition(t.matrixWorld), n.position.copy(i), r.copy(n.position), r.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(r), n.updateMatrixWorld(), s.makeTranslation(-i.x, -i.y, -i.z), o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(o);
  }
});
function xw(t, e, n, s) {
  Sn.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * 4 * Math.PI;
    },
    set: function(i) {
      this.intensity = i / (4 * Math.PI);
    }
  }), this.distance = n !== void 0 ? n : 0, this.decay = s !== void 0 ? s : 1, this.shadow = new yw();
}
xw.prototype = Object.assign(Object.create(Sn.prototype), {
  constructor: xw,
  isPointLight: !0,
  copy: function(t) {
    return Sn.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
  }
});
function nf(t, e, n, s, i, r) {
  Eo.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t !== void 0 ? t : -1, this.right = e !== void 0 ? e : 1, this.top = n !== void 0 ? n : 1, this.bottom = s !== void 0 ? s : -1, this.near = i !== void 0 ? i : 0.1, this.far = r !== void 0 ? r : 2e3, this.updateProjectionMatrix();
}
nf.prototype = Object.assign(Object.create(Eo.prototype), {
  constructor: nf,
  isOrthographicCamera: !0,
  copy: function(t, e) {
    return Eo.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
  },
  setViewOffset: function(t, e, n, s, i, r) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = s, this.view.width = i, this.view.height = r, this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
    let i = n - t, r = n + t, o = s + e, a = s - e;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, l = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      i += c * this.view.offsetX, r = i + c * this.view.width, o -= l * this.view.offsetY, a = o - l * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(i, r, o, a, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function(t) {
    const e = qe.prototype.toJSON.call(this, t);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
});
function bw() {
  Mo.call(this, new nf(-5, 5, 5, -5, 0.5, 500));
}
bw.prototype = Object.assign(Object.create(Mo.prototype), {
  constructor: bw,
  isDirectionalLightShadow: !0,
  updateMatrices: function(t) {
    Mo.prototype.updateMatrices.call(this, t);
  }
});
function vw(t, e) {
  Sn.call(this, t, e), this.type = "DirectionalLight", this.position.copy(qe.DefaultUp), this.updateMatrix(), this.target = new qe(), this.shadow = new bw();
}
vw.prototype = Object.assign(Object.create(Sn.prototype), {
  constructor: vw,
  isDirectionalLight: !0,
  copy: function(t) {
    return Sn.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
});
function vy(t, e) {
  Sn.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0;
}
vy.prototype = Object.assign(Object.create(Sn.prototype), {
  constructor: vy,
  isAmbientLight: !0
});
function ww(t, e, n, s) {
  Sn.call(this, t, e), this.type = "RectAreaLight", this.width = n !== void 0 ? n : 10, this.height = s !== void 0 ? s : 10;
}
ww.prototype = Object.assign(Object.create(Sn.prototype), {
  constructor: ww,
  isRectAreaLight: !0,
  copy: function(t) {
    return Sn.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this;
  },
  toJSON: function(t) {
    const e = Sn.prototype.toJSON.call(this, t);
    return e.object.width = this.width, e.object.height = this.height, e;
  }
});
function B1() {
  this.coefficients = [];
  for (let t = 0; t < 9; t++)
    this.coefficients.push(new P());
}
Object.assign(B1.prototype, {
  isSphericalHarmonics3: !0,
  set: function(t) {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].copy(t[e]);
    return this;
  },
  zero: function() {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].set(0, 0, 0);
    return this;
  },
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt: function(t, e) {
    const n = t.x, s = t.y, i = t.z, r = this.coefficients;
    return e.copy(r[0]).multiplyScalar(0.282095), e.addScaledVector(r[1], 0.488603 * s), e.addScaledVector(r[2], 0.488603 * i), e.addScaledVector(r[3], 0.488603 * n), e.addScaledVector(r[4], 1.092548 * (n * s)), e.addScaledVector(r[5], 1.092548 * (s * i)), e.addScaledVector(r[6], 0.315392 * (3 * i * i - 1)), e.addScaledVector(r[7], 1.092548 * (n * i)), e.addScaledVector(r[8], 0.546274 * (n * n - s * s)), e;
  },
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt: function(t, e) {
    const n = t.x, s = t.y, i = t.z, r = this.coefficients;
    return e.copy(r[0]).multiplyScalar(0.886227), e.addScaledVector(r[1], 2 * 0.511664 * s), e.addScaledVector(r[2], 2 * 0.511664 * i), e.addScaledVector(r[3], 2 * 0.511664 * n), e.addScaledVector(r[4], 2 * 0.429043 * n * s), e.addScaledVector(r[5], 2 * 0.429043 * s * i), e.addScaledVector(r[6], 0.743125 * i * i - 0.247708), e.addScaledVector(r[7], 2 * 0.429043 * n * i), e.addScaledVector(r[8], 0.429043 * (n * n - s * s)), e;
  },
  add: function(t) {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].add(t.coefficients[e]);
    return this;
  },
  addScaledSH: function(t, e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(t.coefficients[n], e);
    return this;
  },
  scale: function(t) {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].multiplyScalar(t);
    return this;
  },
  lerp: function(t, e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(t.coefficients[n], e);
    return this;
  },
  equals: function(t) {
    for (let e = 0; e < 9; e++)
      if (!this.coefficients[e].equals(t.coefficients[e]))
        return !1;
    return !0;
  },
  copy: function(t) {
    return this.set(t.coefficients);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  fromArray: function(t, e) {
    e === void 0 && (e = 0);
    const n = this.coefficients;
    for (let s = 0; s < 9; s++)
      n[s].fromArray(t, e + s * 3);
    return this;
  },
  toArray: function(t, e) {
    t === void 0 && (t = []), e === void 0 && (e = 0);
    const n = this.coefficients;
    for (let s = 0; s < 9; s++)
      n[s].toArray(t, e + s * 3);
    return t;
  }
});
Object.assign(B1, {
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  getBasisAt: function(t, e) {
    const n = t.x, s = t.y, i = t.z;
    e[0] = 0.282095, e[1] = 0.488603 * s, e[2] = 0.488603 * i, e[3] = 0.488603 * n, e[4] = 1.092548 * n * s, e[5] = 1.092548 * s * i, e[6] = 0.315392 * (3 * i * i - 1), e[7] = 1.092548 * n * i, e[8] = 0.546274 * (n * n - s * s);
  }
});
function xr(t, e) {
  Sn.call(this, void 0, e), this.type = "LightProbe", this.sh = t !== void 0 ? t : new B1();
}
xr.prototype = Object.assign(Object.create(Sn.prototype), {
  constructor: xr,
  isLightProbe: !0,
  copy: function(t) {
    return Sn.prototype.copy.call(this, t), this.sh.copy(t.sh), this;
  },
  fromJSON: function(t) {
    return this.intensity = t.intensity, this.sh.fromArray(t.sh), this;
  },
  toJSON: function(t) {
    const e = Sn.prototype.toJSON.call(this, t);
    return e.object.sh = this.sh.toArray(), e;
  }
});
function wy(t) {
  Xt.call(this, t), this.textures = {};
}
wy.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: wy,
  load: function(t, e, n, s) {
    const i = this, r = new Sr(i.manager);
    r.setPath(i.path), r.setRequestHeader(i.requestHeader), r.load(t, function(o) {
      try {
        e(i.parse(JSON.parse(o)));
      } catch (a) {
        s ? s(a) : console.error(a), i.manager.itemError(t);
      }
    }, n, s);
  },
  parse: function(t) {
    const e = this.textures;
    function n(i) {
      return e[i] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", i), e[i];
    }
    const s = new nV[t.type]();
    if (t.uuid !== void 0 && (s.uuid = t.uuid), t.name !== void 0 && (s.name = t.name), t.color !== void 0 && s.color.setHex(t.color), t.roughness !== void 0 && (s.roughness = t.roughness), t.metalness !== void 0 && (s.metalness = t.metalness), t.sheen !== void 0 && (s.sheen = new st().setHex(t.sheen)), t.emissive !== void 0 && s.emissive.setHex(t.emissive), t.specular !== void 0 && s.specular.setHex(t.specular), t.shininess !== void 0 && (s.shininess = t.shininess), t.clearcoat !== void 0 && (s.clearcoat = t.clearcoat), t.clearcoatRoughness !== void 0 && (s.clearcoatRoughness = t.clearcoatRoughness), t.fog !== void 0 && (s.fog = t.fog), t.flatShading !== void 0 && (s.flatShading = t.flatShading), t.blending !== void 0 && (s.blending = t.blending), t.combine !== void 0 && (s.combine = t.combine), t.side !== void 0 && (s.side = t.side), t.opacity !== void 0 && (s.opacity = t.opacity), t.transparent !== void 0 && (s.transparent = t.transparent), t.alphaTest !== void 0 && (s.alphaTest = t.alphaTest), t.depthTest !== void 0 && (s.depthTest = t.depthTest), t.depthWrite !== void 0 && (s.depthWrite = t.depthWrite), t.colorWrite !== void 0 && (s.colorWrite = t.colorWrite), t.stencilWrite !== void 0 && (s.stencilWrite = t.stencilWrite), t.stencilWriteMask !== void 0 && (s.stencilWriteMask = t.stencilWriteMask), t.stencilFunc !== void 0 && (s.stencilFunc = t.stencilFunc), t.stencilRef !== void 0 && (s.stencilRef = t.stencilRef), t.stencilFuncMask !== void 0 && (s.stencilFuncMask = t.stencilFuncMask), t.stencilFail !== void 0 && (s.stencilFail = t.stencilFail), t.stencilZFail !== void 0 && (s.stencilZFail = t.stencilZFail), t.stencilZPass !== void 0 && (s.stencilZPass = t.stencilZPass), t.wireframe !== void 0 && (s.wireframe = t.wireframe), t.wireframeLinewidth !== void 0 && (s.wireframeLinewidth = t.wireframeLinewidth), t.wireframeLinecap !== void 0 && (s.wireframeLinecap = t.wireframeLinecap), t.wireframeLinejoin !== void 0 && (s.wireframeLinejoin = t.wireframeLinejoin), t.rotation !== void 0 && (s.rotation = t.rotation), t.linewidth !== 1 && (s.linewidth = t.linewidth), t.dashSize !== void 0 && (s.dashSize = t.dashSize), t.gapSize !== void 0 && (s.gapSize = t.gapSize), t.scale !== void 0 && (s.scale = t.scale), t.polygonOffset !== void 0 && (s.polygonOffset = t.polygonOffset), t.polygonOffsetFactor !== void 0 && (s.polygonOffsetFactor = t.polygonOffsetFactor), t.polygonOffsetUnits !== void 0 && (s.polygonOffsetUnits = t.polygonOffsetUnits), t.skinning !== void 0 && (s.skinning = t.skinning), t.morphTargets !== void 0 && (s.morphTargets = t.morphTargets), t.morphNormals !== void 0 && (s.morphNormals = t.morphNormals), t.dithering !== void 0 && (s.dithering = t.dithering), t.vertexTangents !== void 0 && (s.vertexTangents = t.vertexTangents), t.visible !== void 0 && (s.visible = t.visible), t.toneMapped !== void 0 && (s.toneMapped = t.toneMapped), t.userData !== void 0 && (s.userData = t.userData), t.vertexColors !== void 0 && (typeof t.vertexColors == "number" ? s.vertexColors = t.vertexColors > 0 : s.vertexColors = t.vertexColors), t.uniforms !== void 0)
      for (const i in t.uniforms) {
        const r = t.uniforms[i];
        switch (s.uniforms[i] = {}, r.type) {
          case "t":
            s.uniforms[i].value = n(r.value);
            break;
          case "c":
            s.uniforms[i].value = new st().setHex(r.value);
            break;
          case "v2":
            s.uniforms[i].value = new Ce().fromArray(r.value);
            break;
          case "v3":
            s.uniforms[i].value = new P().fromArray(r.value);
            break;
          case "v4":
            s.uniforms[i].value = new en().fromArray(r.value);
            break;
          case "m3":
            s.uniforms[i].value = new Js().fromArray(r.value);
          case "m4":
            s.uniforms[i].value = new Mt().fromArray(r.value);
            break;
          default:
            s.uniforms[i].value = r.value;
        }
      }
    if (t.defines !== void 0 && (s.defines = t.defines), t.vertexShader !== void 0 && (s.vertexShader = t.vertexShader), t.fragmentShader !== void 0 && (s.fragmentShader = t.fragmentShader), t.extensions !== void 0)
      for (const i in t.extensions)
        s.extensions[i] = t.extensions[i];
    if (t.shading !== void 0 && (s.flatShading = t.shading === 1), t.size !== void 0 && (s.size = t.size), t.sizeAttenuation !== void 0 && (s.sizeAttenuation = t.sizeAttenuation), t.map !== void 0 && (s.map = n(t.map)), t.matcap !== void 0 && (s.matcap = n(t.matcap)), t.alphaMap !== void 0 && (s.alphaMap = n(t.alphaMap)), t.bumpMap !== void 0 && (s.bumpMap = n(t.bumpMap)), t.bumpScale !== void 0 && (s.bumpScale = t.bumpScale), t.normalMap !== void 0 && (s.normalMap = n(t.normalMap)), t.normalMapType !== void 0 && (s.normalMapType = t.normalMapType), t.normalScale !== void 0) {
      let i = t.normalScale;
      Array.isArray(i) === !1 && (i = [i, i]), s.normalScale = new Ce().fromArray(i);
    }
    return t.displacementMap !== void 0 && (s.displacementMap = n(t.displacementMap)), t.displacementScale !== void 0 && (s.displacementScale = t.displacementScale), t.displacementBias !== void 0 && (s.displacementBias = t.displacementBias), t.roughnessMap !== void 0 && (s.roughnessMap = n(t.roughnessMap)), t.metalnessMap !== void 0 && (s.metalnessMap = n(t.metalnessMap)), t.emissiveMap !== void 0 && (s.emissiveMap = n(t.emissiveMap)), t.emissiveIntensity !== void 0 && (s.emissiveIntensity = t.emissiveIntensity), t.specularMap !== void 0 && (s.specularMap = n(t.specularMap)), t.envMap !== void 0 && (s.envMap = n(t.envMap)), t.envMapIntensity !== void 0 && (s.envMapIntensity = t.envMapIntensity), t.reflectivity !== void 0 && (s.reflectivity = t.reflectivity), t.refractionRatio !== void 0 && (s.refractionRatio = t.refractionRatio), t.lightMap !== void 0 && (s.lightMap = n(t.lightMap)), t.lightMapIntensity !== void 0 && (s.lightMapIntensity = t.lightMapIntensity), t.aoMap !== void 0 && (s.aoMap = n(t.aoMap)), t.aoMapIntensity !== void 0 && (s.aoMapIntensity = t.aoMapIntensity), t.gradientMap !== void 0 && (s.gradientMap = n(t.gradientMap)), t.clearcoatMap !== void 0 && (s.clearcoatMap = n(t.clearcoatMap)), t.clearcoatRoughnessMap !== void 0 && (s.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), t.clearcoatNormalMap !== void 0 && (s.clearcoatNormalMap = n(t.clearcoatNormalMap)), t.clearcoatNormalScale !== void 0 && (s.clearcoatNormalScale = new Ce().fromArray(t.clearcoatNormalScale)), t.transmission !== void 0 && (s.transmission = t.transmission), t.transmissionMap !== void 0 && (s.transmissionMap = n(t.transmissionMap)), s;
  },
  setTextures: function(t) {
    return this.textures = t, this;
  }
});
const oN = {
  decodeText: function(t) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(t);
    let e = "";
    for (let n = 0, s = t.length; n < s; n++)
      e += String.fromCharCode(t[n]);
    try {
      return decodeURIComponent(escape(e));
    } catch {
      return e;
    }
  },
  extractUrlBase: function(t) {
    const e = t.lastIndexOf("/");
    return e === -1 ? "./" : t.substr(0, e + 1);
  }
};
function Sy() {
  et.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
}
Sy.prototype = Object.assign(Object.create(et.prototype), {
  constructor: Sy,
  isInstancedBufferGeometry: !0,
  copy: function(t) {
    return et.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    const t = et.prototype.toJSON.call(this);
    return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t;
  }
});
function Sw(t, e, n, s) {
  typeof n == "number" && (s = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), ut.call(this, t, e, n), this.meshPerAttribute = s || 1;
}
Sw.prototype = Object.assign(Object.create(ut.prototype), {
  constructor: Sw,
  isInstancedBufferAttribute: !0,
  copy: function(t) {
    return ut.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
  },
  toJSON: function() {
    const t = ut.prototype.toJSON.call(this);
    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t;
  }
});
function _w(t) {
  Xt.call(this, t);
}
_w.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: _w,
  load: function(t, e, n, s) {
    const i = this, r = new Sr(i.manager);
    r.setPath(i.path), r.setRequestHeader(i.requestHeader), r.load(t, function(o) {
      try {
        e(i.parse(JSON.parse(o)));
      } catch (a) {
        s ? s(a) : console.error(a), i.manager.itemError(t);
      }
    }, n, s);
  },
  parse: function(t) {
    const e = {}, n = {};
    function s(d, f) {
      if (e[f] !== void 0)
        return e[f];
      const y = d.interleavedBuffers[f], g = i(d, y.buffer), m = new ig[y.type](g), x = new Hi(m, y.stride);
      return x.uuid = y.uuid, e[f] = x, x;
    }
    function i(d, f) {
      if (n[f] !== void 0)
        return n[f];
      const y = d.arrayBuffers[f], g = new Uint32Array(y).buffer;
      return n[f] = g, g;
    }
    const r = t.isInstancedBufferGeometry ? new Sy() : new et(), o = t.data.index;
    if (o !== void 0) {
      const d = new ig[o.type](o.array);
      r.setIndex(new ut(d, 1));
    }
    const a = t.data.attributes;
    for (const d in a) {
      const f = a[d];
      let p;
      if (f.isInterleavedBufferAttribute) {
        const y = s(t.data, f.data);
        p = new Mc(y, f.itemSize, f.offset, f.normalized);
      } else {
        const y = new ig[f.type](f.array), g = f.isInstancedBufferAttribute ? Sw : ut;
        p = new g(y, f.itemSize, f.normalized);
      }
      f.name !== void 0 && (p.name = f.name), r.setAttribute(d, p);
    }
    const c = t.data.morphAttributes;
    if (c)
      for (const d in c) {
        const f = c[d], p = [];
        for (let y = 0, g = f.length; y < g; y++) {
          const m = f[y];
          let x;
          if (m.isInterleavedBufferAttribute) {
            const v = s(t.data, m.data);
            x = new Mc(v, m.itemSize, m.offset, m.normalized);
          } else {
            const v = new ig[m.type](m.array);
            x = new ut(v, m.itemSize, m.normalized);
          }
          m.name !== void 0 && (x.name = m.name), p.push(x);
        }
        r.morphAttributes[d] = p;
      }
    t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
    const u = t.data.groups || t.data.drawcalls || t.data.offsets;
    if (u !== void 0)
      for (let d = 0, f = u.length; d !== f; ++d) {
        const p = u[d];
        r.addGroup(p.start, p.count, p.materialIndex);
      }
    const h = t.data.boundingSphere;
    if (h !== void 0) {
      const d = new P();
      h.center !== void 0 && d.fromArray(h.center), r.boundingSphere = new Bo(d, h.radius);
    }
    return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r;
  }
});
const ig = {
  Int8Array,
  Uint8Array,
  // Workaround for IE11 pre KB2929437. See #11440
  Uint8ClampedArray: typeof Uint8ClampedArray < "u" ? Uint8ClampedArray : Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function Tw(t) {
  Xt.call(this, t);
}
Tw.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: Tw,
  load: function(t, e, n, s) {
    const i = this, r = this.path === "" ? oN.extractUrlBase(t) : this.path;
    this.resourcePath = this.resourcePath || r;
    const o = new Sr(i.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.load(t, function(a) {
      let c = null;
      try {
        c = JSON.parse(a);
      } catch (u) {
        s !== void 0 && s(u), console.error("THREE:ObjectLoader: Can't parse " + t + ".", u.message);
        return;
      }
      const l = c.metadata;
      if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + t);
        return;
      }
      i.parse(c, e);
    }, n, s);
  },
  parse: function(t, e) {
    const n = this.parseShape(t.shapes), s = this.parseGeometries(t.geometries, n), i = this.parseImages(t.images, function() {
      e !== void 0 && e(a);
    }), r = this.parseTextures(t.textures, i), o = this.parseMaterials(t.materials, r), a = this.parseObject(t.object, s, o);
    return t.animations && (a.animations = this.parseAnimations(t.animations)), (t.images === void 0 || t.images.length === 0) && e !== void 0 && e(a), a;
  },
  parseShape: function(t) {
    const e = {};
    if (t !== void 0)
      for (let n = 0, s = t.length; n < s; n++) {
        const i = new bc().fromJSON(t[n]);
        e[i.uuid] = i;
      }
    return e;
  },
  parseGeometries: function(t, e) {
    const n = {};
    let s;
    if (t !== void 0) {
      const i = new _w();
      for (let r = 0, o = t.length; r < o; r++) {
        let a;
        const c = t[r];
        switch (c.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            a = new Ys[c.type](
              c.width,
              c.height,
              c.widthSegments,
              c.heightSegments
            );
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
          case "CubeGeometry":
            a = new Ys[c.type](
              c.width,
              c.height,
              c.depth,
              c.widthSegments,
              c.heightSegments,
              c.depthSegments
            );
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            a = new Ys[c.type](
              c.radius,
              c.segments,
              c.thetaStart,
              c.thetaLength
            );
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            a = new Ys[c.type](
              c.radiusTop,
              c.radiusBottom,
              c.height,
              c.radialSegments,
              c.heightSegments,
              c.openEnded,
              c.thetaStart,
              c.thetaLength
            );
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            a = new Ys[c.type](
              c.radius,
              c.height,
              c.radialSegments,
              c.heightSegments,
              c.openEnded,
              c.thetaStart,
              c.thetaLength
            );
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            a = new Ys[c.type](
              c.radius,
              c.widthSegments,
              c.heightSegments,
              c.phiStart,
              c.phiLength,
              c.thetaStart,
              c.thetaLength
            );
            break;
          case "DodecahedronGeometry":
          case "DodecahedronBufferGeometry":
          case "IcosahedronGeometry":
          case "IcosahedronBufferGeometry":
          case "OctahedronGeometry":
          case "OctahedronBufferGeometry":
          case "TetrahedronGeometry":
          case "TetrahedronBufferGeometry":
            a = new Ys[c.type](
              c.radius,
              c.detail
            );
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            a = new Ys[c.type](
              c.innerRadius,
              c.outerRadius,
              c.thetaSegments,
              c.phiSegments,
              c.thetaStart,
              c.thetaLength
            );
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            a = new Ys[c.type](
              c.radius,
              c.tube,
              c.radialSegments,
              c.tubularSegments,
              c.arc
            );
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            a = new Ys[c.type](
              c.radius,
              c.tube,
              c.tubularSegments,
              c.radialSegments,
              c.p,
              c.q
            );
            break;
          case "TubeGeometry":
          case "TubeBufferGeometry":
            a = new Ys[c.type](
              new fw[c.path.type]().fromJSON(c.path),
              c.tubularSegments,
              c.radius,
              c.radialSegments,
              c.closed
            );
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            a = new Ys[c.type](
              c.points,
              c.segments,
              c.phiStart,
              c.phiLength
            );
            break;
          case "PolyhedronGeometry":
          case "PolyhedronBufferGeometry":
            a = new Ys[c.type](
              c.vertices,
              c.indices,
              c.radius,
              c.details
            );
            break;
          case "ShapeGeometry":
          case "ShapeBufferGeometry":
            s = [];
            for (let u = 0, h = c.shapes.length; u < h; u++) {
              const d = e[c.shapes[u]];
              s.push(d);
            }
            a = new Ys[c.type](
              s,
              c.curveSegments
            );
            break;
          case "ExtrudeGeometry":
          case "ExtrudeBufferGeometry":
            s = [];
            for (let u = 0, h = c.shapes.length; u < h; u++) {
              const d = e[c.shapes[u]];
              s.push(d);
            }
            const l = c.options.extrudePath;
            l !== void 0 && (c.options.extrudePath = new fw[l.type]().fromJSON(l)), a = new Ys[c.type](
              s,
              c.options
            );
            break;
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = i.parse(c);
            break;
          case "Geometry":
            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + c.type + '"');
            continue;
        }
        a.uuid = c.uuid, c.name !== void 0 && (a.name = c.name), a.isBufferGeometry === !0 && c.userData !== void 0 && (a.userData = c.userData), n[c.uuid] = a;
      }
    }
    return n;
  },
  parseMaterials: function(t, e) {
    const n = {}, s = {};
    if (t !== void 0) {
      const i = new wy();
      i.setTextures(e);
      for (let r = 0, o = t.length; r < o; r++) {
        const a = t[r];
        if (a.type === "MultiMaterial") {
          const c = [];
          for (let l = 0; l < a.materials.length; l++) {
            const u = a.materials[l];
            n[u.uuid] === void 0 && (n[u.uuid] = i.parse(u)), c.push(n[u.uuid]);
          }
          s[a.uuid] = c;
        } else
          n[a.uuid] === void 0 && (n[a.uuid] = i.parse(a)), s[a.uuid] = n[a.uuid];
      }
    }
    return s;
  },
  parseAnimations: function(t) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
      const s = t[n], i = yr.parse(s);
      s.uuid !== void 0 && (i.uuid = s.uuid), e.push(i);
    }
    return e;
  },
  parseImages: function(t, e) {
    const n = this, s = {};
    let i;
    function r(o) {
      return n.manager.itemStart(o), i.load(o, function() {
        n.manager.itemEnd(o);
      }, void 0, function() {
        n.manager.itemError(o), n.manager.itemEnd(o);
      });
    }
    if (t !== void 0 && t.length > 0) {
      const o = new rN(e);
      i = new ef(o), i.setCrossOrigin(this.crossOrigin);
      for (let a = 0, c = t.length; a < c; a++) {
        const l = t[a], u = l.url;
        if (Array.isArray(u)) {
          s[l.uuid] = [];
          for (let h = 0, d = u.length; h < d; h++) {
            const f = u[h], p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : n.resourcePath + f;
            s[l.uuid].push(r(p));
          }
        } else {
          const h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : n.resourcePath + l.url;
          s[l.uuid] = r(h);
        }
      }
    }
    return s;
  },
  parseTextures: function(t, e) {
    function n(i, r) {
      return typeof i == "number" ? i : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", i), r[i]);
    }
    const s = {};
    if (t !== void 0)
      for (let i = 0, r = t.length; i < r; i++) {
        const o = t[i];
        o.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), e[o.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", o.image);
        let a;
        Array.isArray(e[o.image]) ? a = new xa(e[o.image]) : a = new dn(e[o.image]), a.needsUpdate = !0, a.uuid = o.uuid, o.name !== void 0 && (a.name = o.name), o.mapping !== void 0 && (a.mapping = n(o.mapping, fV)), o.offset !== void 0 && a.offset.fromArray(o.offset), o.repeat !== void 0 && a.repeat.fromArray(o.repeat), o.center !== void 0 && a.center.fromArray(o.center), o.rotation !== void 0 && (a.rotation = o.rotation), o.wrap !== void 0 && (a.wrapS = n(o.wrap[0], qC), a.wrapT = n(o.wrap[1], qC)), o.format !== void 0 && (a.format = o.format), o.type !== void 0 && (a.type = o.type), o.encoding !== void 0 && (a.encoding = o.encoding), o.minFilter !== void 0 && (a.minFilter = n(o.minFilter, XC)), o.magFilter !== void 0 && (a.magFilter = n(o.magFilter, XC)), o.anisotropy !== void 0 && (a.anisotropy = o.anisotropy), o.flipY !== void 0 && (a.flipY = o.flipY), o.premultiplyAlpha !== void 0 && (a.premultiplyAlpha = o.premultiplyAlpha), o.unpackAlignment !== void 0 && (a.unpackAlignment = o.unpackAlignment), s[o.uuid] = a;
      }
    return s;
  },
  parseObject: function(t, e, n) {
    let s;
    function i(c) {
      return e[c] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", c), e[c];
    }
    function r(c) {
      if (c !== void 0) {
        if (Array.isArray(c)) {
          const l = [];
          for (let u = 0, h = c.length; u < h; u++) {
            const d = c[u];
            n[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", d), l.push(n[d]);
          }
          return l;
        }
        return n[c] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", c), n[c];
      }
    }
    let o, a;
    switch (t.type) {
      case "Scene":
        s = new kd(), t.background !== void 0 && Number.isInteger(t.background) && (s.background = new st(t.background)), t.fog !== void 0 && (t.fog.type === "Fog" ? s.fog = new Zv(t.fog.color, t.fog.near, t.fog.far) : t.fog.type === "FogExp2" && (s.fog = new Yv(t.fog.color, t.fog.density)));
        break;
      case "PerspectiveCamera":
        s = new Yn(t.fov, t.aspect, t.near, t.far), t.focus !== void 0 && (s.focus = t.focus), t.zoom !== void 0 && (s.zoom = t.zoom), t.filmGauge !== void 0 && (s.filmGauge = t.filmGauge), t.filmOffset !== void 0 && (s.filmOffset = t.filmOffset), t.view !== void 0 && (s.view = Object.assign({}, t.view));
        break;
      case "OrthographicCamera":
        s = new nf(t.left, t.right, t.top, t.bottom, t.near, t.far), t.zoom !== void 0 && (s.zoom = t.zoom), t.view !== void 0 && (s.view = Object.assign({}, t.view));
        break;
      case "AmbientLight":
        s = new vy(t.color, t.intensity);
        break;
      case "DirectionalLight":
        s = new vw(t.color, t.intensity);
        break;
      case "PointLight":
        s = new xw(t.color, t.intensity, t.distance, t.decay);
        break;
      case "RectAreaLight":
        s = new ww(t.color, t.intensity, t.width, t.height);
        break;
      case "SpotLight":
        s = new gw(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
        break;
      case "HemisphereLight":
        s = new pw(t.color, t.groundColor, t.intensity);
        break;
      case "LightProbe":
        s = new xr().fromJSON(t);
        break;
      case "SkinnedMesh":
        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
      case "Mesh":
        o = i(t.geometry), a = r(t.material), s = new cn(o, a);
        break;
      case "InstancedMesh":
        o = i(t.geometry), a = r(t.material);
        const c = t.count, l = t.instanceMatrix;
        s = new tw(o, a, c), s.instanceMatrix = new ut(new Float32Array(l.array), 16);
        break;
      case "LOD":
        s = new Zg();
        break;
      case "Line":
        s = new nr(i(t.geometry), r(t.material), t.mode);
        break;
      case "LineLoop":
        s = new nw(i(t.geometry), r(t.material));
        break;
      case "LineSegments":
        s = new ns(i(t.geometry), r(t.material));
        break;
      case "PointCloud":
      case "Points":
        s = new Jg(i(t.geometry), r(t.material));
        break;
      case "Sprite":
        s = new Jv(r(t.material));
        break;
      case "Group":
        s = new oa();
        break;
      default:
        s = new qe();
    }
    if (s.uuid = t.uuid, t.name !== void 0 && (s.name = t.name), t.matrix !== void 0 ? (s.matrix.fromArray(t.matrix), t.matrixAutoUpdate !== void 0 && (s.matrixAutoUpdate = t.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (t.position !== void 0 && s.position.fromArray(t.position), t.rotation !== void 0 && s.rotation.fromArray(t.rotation), t.quaternion !== void 0 && s.quaternion.fromArray(t.quaternion), t.scale !== void 0 && s.scale.fromArray(t.scale)), t.castShadow !== void 0 && (s.castShadow = t.castShadow), t.receiveShadow !== void 0 && (s.receiveShadow = t.receiveShadow), t.shadow && (t.shadow.bias !== void 0 && (s.shadow.bias = t.shadow.bias), t.shadow.normalBias !== void 0 && (s.shadow.normalBias = t.shadow.normalBias), t.shadow.radius !== void 0 && (s.shadow.radius = t.shadow.radius), t.shadow.mapSize !== void 0 && s.shadow.mapSize.fromArray(t.shadow.mapSize), t.shadow.camera !== void 0 && (s.shadow.camera = this.parseObject(t.shadow.camera))), t.visible !== void 0 && (s.visible = t.visible), t.frustumCulled !== void 0 && (s.frustumCulled = t.frustumCulled), t.renderOrder !== void 0 && (s.renderOrder = t.renderOrder), t.userData !== void 0 && (s.userData = t.userData), t.layers !== void 0 && (s.layers.mask = t.layers), t.children !== void 0) {
      const c = t.children;
      for (let l = 0; l < c.length; l++)
        s.add(this.parseObject(c[l], e, n));
    }
    if (t.type === "LOD") {
      t.autoUpdate !== void 0 && (s.autoUpdate = t.autoUpdate);
      const c = t.levels;
      for (let l = 0; l < c.length; l++) {
        const u = c[l], h = s.getObjectByProperty("uuid", u.object);
        h !== void 0 && s.addLevel(h, u.distance);
      }
    }
    return s;
  }
});
const fV = {
  UVMapping: A1,
  CubeReflectionMapping: M1,
  CubeRefractionMapping: R1,
  EquirectangularReflectionMapping: DE,
  EquirectangularRefractionMapping: D1,
  CubeUVReflectionMapping: Df,
  CubeUVRefractionMapping: lx
}, qC = {
  RepeatWrapping: Gg,
  ClampToEdgeWrapping: hi,
  MirroredRepeatWrapping: Wg
}, XC = {
  NearestFilter: ps,
  NearestMipmapNearestFilter: zv,
  NearestMipmapLinearFilter: Vv,
  LinearFilter: Vs,
  LinearMipmapNearestFilter: $E,
  LinearMipmapLinearFilter: ux
};
function KC(t) {
  typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Xt.call(this, t), this.options = { premultiplyAlpha: "none" };
}
KC.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: KC,
  isImageBitmapLoader: !0,
  setOptions: function(e) {
    return this.options = e, this;
  },
  load: function(t, e, n, s) {
    t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    const i = this, r = Zr.get(t);
    if (r !== void 0)
      return i.manager.itemStart(t), setTimeout(function() {
        e && e(r), i.manager.itemEnd(t);
      }, 0), r;
    fetch(t).then(function(o) {
      return o.blob();
    }).then(function(o) {
      return createImageBitmap(o, i.options);
    }).then(function(o) {
      Zr.add(t, o), e && e(o), i.manager.itemEnd(t);
    }).catch(function(o) {
      s && s(o), i.manager.itemError(t), i.manager.itemEnd(t);
    }), i.manager.itemStart(t);
  }
});
function aN() {
  this.type = "ShapePath", this.color = new st(), this.subPaths = [], this.currentPath = null;
}
Object.assign(aN.prototype, {
  moveTo: function(t, e) {
    return this.currentPath = new Ur(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this;
  },
  lineTo: function(t, e) {
    return this.currentPath.lineTo(t, e), this;
  },
  quadraticCurveTo: function(t, e, n, s) {
    return this.currentPath.quadraticCurveTo(t, e, n, s), this;
  },
  bezierCurveTo: function(t, e, n, s, i, r) {
    return this.currentPath.bezierCurveTo(t, e, n, s, i, r), this;
  },
  splineThru: function(t) {
    return this.currentPath.splineThru(t), this;
  },
  toShapes: function(t, e) {
    function n(m) {
      const x = [];
      for (let v = 0, b = m.length; v < b; v++) {
        const w = m[v], S = new bc();
        S.curves = w.curves, x.push(S);
      }
      return x;
    }
    function s(m, x) {
      const v = x.length;
      let b = !1;
      for (let w = v - 1, S = 0; S < v; w = S++) {
        let _ = x[w], E = x[S], I = E.x - _.x, k = E.y - _.y;
        if (Math.abs(k) > Number.EPSILON) {
          if (k < 0 && (_ = x[S], I = -I, E = x[w], k = -k), m.y < _.y || m.y > E.y)
            continue;
          if (m.y === _.y) {
            if (m.x === _.x)
              return !0;
          } else {
            const M = k * (m.x - _.x) - I * (m.y - _.y);
            if (M === 0)
              return !0;
            if (M < 0)
              continue;
            b = !b;
          }
        } else {
          if (m.y !== _.y)
            continue;
          if (E.x <= m.x && m.x <= _.x || _.x <= m.x && m.x <= E.x)
            return !0;
        }
      }
      return b;
    }
    const i = fa.isClockWise, r = this.subPaths;
    if (r.length === 0)
      return [];
    if (e === !0)
      return n(r);
    let o, a, c, l = [];
    if (r.length === 1)
      return a = r[0], c = new bc(), c.curves = a.curves, l.push(c), l;
    let u = !i(r[0].getPoints());
    u = t ? !u : u;
    const h = [], d = [];
    let f = [], p = 0, y;
    d[p] = void 0, f[p] = [];
    for (let m = 0, x = r.length; m < x; m++)
      a = r[m], y = a.getPoints(), o = i(y), o = t ? !o : o, o ? (!u && d[p] && p++, d[p] = { s: new bc(), p: y }, d[p].s.curves = a.curves, u && p++, f[p] = []) : f[p].push({ h: a, p: y[0] });
    if (!d[0])
      return n(r);
    if (d.length > 1) {
      let m = !1;
      const x = [];
      for (let v = 0, b = d.length; v < b; v++)
        h[v] = [];
      for (let v = 0, b = d.length; v < b; v++) {
        const w = f[v];
        for (let S = 0; S < w.length; S++) {
          const _ = w[S];
          let E = !0;
          for (let I = 0; I < d.length; I++)
            s(_.p, d[I].p) && (v !== I && x.push({ froms: v, tos: I, hole: S }), E ? (E = !1, h[I].push(_)) : m = !0);
          E && h[v].push(_);
        }
      }
      x.length > 0 && (m || (f = h));
    }
    let g;
    for (let m = 0, x = d.length; m < x; m++) {
      c = d[m].s, l.push(c), g = f[m];
      for (let v = 0, b = g.length; v < b; v++)
        c.holes.push(g[v].h);
    }
    return l;
  }
});
function cN(t) {
  this.type = "Font", this.data = t;
}
Object.assign(cN.prototype, {
  isFont: !0,
  generateShapes: function(t, e) {
    e === void 0 && (e = 100);
    const n = [], s = pV(t, e, this.data);
    for (let i = 0, r = s.length; i < r; i++)
      Array.prototype.push.apply(n, s[i].toShapes());
    return n;
  }
});
function pV(t, e, n) {
  const s = Array.from ? Array.from(t) : String(t).split(""), i = e / n.resolution, r = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i, o = [];
  let a = 0, c = 0;
  for (let l = 0; l < s.length; l++) {
    const u = s[l];
    if (u === `
`)
      a = 0, c -= r;
    else {
      const h = mV(u, i, a, c, n);
      a += h.offsetX, o.push(h.path);
    }
  }
  return o;
}
function mV(t, e, n, s, i) {
  const r = i.glyphs[t] || i.glyphs["?"];
  if (!r) {
    console.error('THREE.Font: character "' + t + '" does not exists in font family ' + i.familyName + ".");
    return;
  }
  const o = new aN();
  let a, c, l, u, h, d, f, p;
  if (r.o) {
    const y = r._cachedOutline || (r._cachedOutline = r.o.split(" "));
    for (let g = 0, m = y.length; g < m; )
      switch (y[g++]) {
        case "m":
          a = y[g++] * e + n, c = y[g++] * e + s, o.moveTo(a, c);
          break;
        case "l":
          a = y[g++] * e + n, c = y[g++] * e + s, o.lineTo(a, c);
          break;
        case "q":
          l = y[g++] * e + n, u = y[g++] * e + s, h = y[g++] * e + n, d = y[g++] * e + s, o.quadraticCurveTo(h, d, l, u);
          break;
        case "b":
          l = y[g++] * e + n, u = y[g++] * e + s, h = y[g++] * e + n, d = y[g++] * e + s, f = y[g++] * e + n, p = y[g++] * e + s, o.bezierCurveTo(h, d, f, p, l, u);
          break;
      }
  }
  return { offsetX: r.ha * e, path: o };
}
function YC(t) {
  Xt.call(this, t);
}
YC.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: YC,
  load: function(t, e, n, s) {
    const i = this, r = new Sr(this.manager);
    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.load(t, function(o) {
      let a;
      try {
        a = JSON.parse(o);
      } catch {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), a = JSON.parse(o.substring(65, o.length - 2));
      }
      const c = i.parse(a);
      e && e(c);
    }, n, s);
  },
  parse: function(t) {
    return new cN(t);
  }
});
let rg;
const lN = {
  getContext: function() {
    return rg === void 0 && (rg = new (window.AudioContext || window.webkitAudioContext)()), rg;
  },
  setContext: function(t) {
    rg = t;
  }
};
function Cw(t) {
  Xt.call(this, t);
}
Cw.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: Cw,
  load: function(t, e, n, s) {
    const i = this, r = new Sr(i.manager);
    r.setResponseType("arraybuffer"), r.setPath(i.path), r.setRequestHeader(i.requestHeader), r.load(t, function(o) {
      try {
        const a = o.slice(0);
        lN.getContext().decodeAudioData(a, function(l) {
          e(l);
        });
      } catch (a) {
        s ? s(a) : console.error(a), i.manager.itemError(t);
      }
    }, n, s);
  }
});
function ZC(t, e, n) {
  xr.call(this, void 0, n);
  const s = new st().set(t), i = new st().set(e), r = new P(s.r, s.g, s.b), o = new P(i.r, i.g, i.b), a = Math.sqrt(Math.PI), c = a * Math.sqrt(0.75);
  this.sh.coefficients[0].copy(r).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(r).sub(o).multiplyScalar(c);
}
ZC.prototype = Object.assign(Object.create(xr.prototype), {
  constructor: ZC,
  isHemisphereLightProbe: !0,
  copy: function(t) {
    return xr.prototype.copy.call(this, t), this;
  },
  toJSON: function(t) {
    return xr.prototype.toJSON.call(this, t);
  }
});
function JC(t, e) {
  xr.call(this, void 0, e);
  const n = new st().set(t);
  this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}
JC.prototype = Object.assign(Object.create(xr.prototype), {
  constructor: JC,
  isAmbientLightProbe: !0,
  copy: function(t) {
    return xr.prototype.copy.call(this, t), this;
  },
  toJSON: function(t) {
    return xr.prototype.toJSON.call(this, t);
  }
});
const QC = new Mt(), e2 = new Mt();
function gV() {
  this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Yn(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Yn(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
    focus: null,
    fov: null,
    aspect: null,
    near: null,
    far: null,
    zoom: null,
    eyeSep: null
  };
}
Object.assign(gV.prototype, {
  update: function(t) {
    const e = this._cache;
    if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
      e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
      const s = t.projectionMatrix.clone(), i = e.eyeSep / 2, r = i * e.near / e.focus, o = e.near * Math.tan(Et.DEG2RAD * e.fov * 0.5) / e.zoom;
      let a, c;
      e2.elements[12] = -i, QC.elements[12] = i, a = -o * e.aspect + r, c = o * e.aspect + r, s.elements[0] = 2 * e.near / (c - a), s.elements[8] = (c + a) / (c - a), this.cameraL.projectionMatrix.copy(s), a = -o * e.aspect - r, c = o * e.aspect - r, s.elements[0] = 2 * e.near / (c - a), s.elements[8] = (c + a) / (c - a), this.cameraR.projectionMatrix.copy(s);
    }
    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(e2), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(QC);
  }
});
function uN(t) {
  this.autoStart = t !== void 0 ? t : !0, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
}
Object.assign(uN.prototype, {
  start: function() {
    this.startTime = (typeof performance > "u" ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  },
  stop: function() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  },
  getElapsedTime: function() {
    return this.getDelta(), this.elapsedTime;
  },
  getDelta: function() {
    let t = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const e = (typeof performance > "u" ? Date : performance).now();
      t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
    }
    return t;
  }
});
const ec = new P(), t2 = new xs(), yV = new P(), tc = new P();
function n2() {
  qe.call(this), this.type = "AudioListener", this.context = lN.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new uN();
}
n2.prototype = Object.assign(Object.create(qe.prototype), {
  constructor: n2,
  getInput: function() {
    return this.gain;
  },
  removeFilter: function() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  },
  getFilter: function() {
    return this.filter;
  },
  setFilter: function(t) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  },
  getMasterVolume: function() {
    return this.gain.gain.value;
  },
  setMasterVolume: function(t) {
    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
  },
  updateMatrixWorld: function(t) {
    qe.prototype.updateMatrixWorld.call(this, t);
    const e = this.context.listener, n = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ec, t2, yV), tc.set(0, 0, -1).applyQuaternion(t2), e.positionX) {
      const s = this.context.currentTime + this.timeDelta;
      e.positionX.linearRampToValueAtTime(ec.x, s), e.positionY.linearRampToValueAtTime(ec.y, s), e.positionZ.linearRampToValueAtTime(ec.z, s), e.forwardX.linearRampToValueAtTime(tc.x, s), e.forwardY.linearRampToValueAtTime(tc.y, s), e.forwardZ.linearRampToValueAtTime(tc.z, s), e.upX.linearRampToValueAtTime(n.x, s), e.upY.linearRampToValueAtTime(n.y, s), e.upZ.linearRampToValueAtTime(n.z, s);
    } else
      e.setPosition(ec.x, ec.y, ec.z), e.setOrientation(tc.x, tc.y, tc.z, n.x, n.y, n.z);
  }
});
function sf(t) {
  qe.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this.filters = [];
}
sf.prototype = Object.assign(Object.create(qe.prototype), {
  constructor: sf,
  getOutput: function() {
    return this.gain;
  },
  setNodeSource: function(t) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this;
  },
  setMediaElementSource: function(t) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
  },
  setMediaStreamSource: function(t) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this;
  },
  setBuffer: function(t) {
    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
  },
  play: function(t) {
    if (t === void 0 && (t = 0), this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + t;
    const e = this.context.createBufferSource();
    return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  },
  pause: function() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  },
  stop: function() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
  },
  connect: function() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let t = 1, e = this.filters.length; t < e; t++)
        this.filters[t - 1].connect(this.filters[t]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this;
  },
  disconnect: function() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let t = 1, e = this.filters.length; t < e; t++)
        this.filters[t - 1].disconnect(this.filters[t]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this;
  },
  getFilters: function() {
    return this.filters;
  },
  setFilters: function(t) {
    return t || (t = []), this.isPlaying === !0 ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this;
  },
  setDetune: function(t) {
    if (this.detune = t, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  },
  getDetune: function() {
    return this.detune;
  },
  getFilter: function() {
    return this.getFilters()[0];
  },
  setFilter: function(t) {
    return this.setFilters(t ? [t] : []);
  },
  setPlaybackRate: function(t) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = t, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  },
  getPlaybackRate: function() {
    return this.playbackRate;
  },
  onEnded: function() {
    this.isPlaying = !1;
  },
  getLoop: function() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  },
  setLoop: function(t) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = t, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  },
  setLoopStart: function(t) {
    return this.loopStart = t, this;
  },
  setLoopEnd: function(t) {
    return this.loopEnd = t, this;
  },
  getVolume: function() {
    return this.gain.gain.value;
  },
  setVolume: function(t) {
    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
  }
});
const nc = new P(), s2 = new xs(), xV = new P(), sc = new P();
function i2(t) {
  sf.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
}
i2.prototype = Object.assign(Object.create(sf.prototype), {
  constructor: i2,
  getOutput: function() {
    return this.panner;
  },
  getRefDistance: function() {
    return this.panner.refDistance;
  },
  setRefDistance: function(t) {
    return this.panner.refDistance = t, this;
  },
  getRolloffFactor: function() {
    return this.panner.rolloffFactor;
  },
  setRolloffFactor: function(t) {
    return this.panner.rolloffFactor = t, this;
  },
  getDistanceModel: function() {
    return this.panner.distanceModel;
  },
  setDistanceModel: function(t) {
    return this.panner.distanceModel = t, this;
  },
  getMaxDistance: function() {
    return this.panner.maxDistance;
  },
  setMaxDistance: function(t) {
    return this.panner.maxDistance = t, this;
  },
  setDirectionalCone: function(t, e, n) {
    return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this;
  },
  updateMatrixWorld: function(t) {
    if (qe.prototype.updateMatrixWorld.call(this, t), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(nc, s2, xV), sc.set(0, 0, 1).applyQuaternion(s2);
    const e = this.panner;
    if (e.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      e.positionX.linearRampToValueAtTime(nc.x, n), e.positionY.linearRampToValueAtTime(nc.y, n), e.positionZ.linearRampToValueAtTime(nc.z, n), e.orientationX.linearRampToValueAtTime(sc.x, n), e.orientationY.linearRampToValueAtTime(sc.y, n), e.orientationZ.linearRampToValueAtTime(sc.z, n);
    } else
      e.setPosition(nc.x, nc.y, nc.z), e.setOrientation(sc.x, sc.y, sc.z);
  }
});
function hN(t, e) {
  this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e !== void 0 ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser);
}
Object.assign(hN.prototype, {
  getFrequencyData: function() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  },
  getAverageFrequency: function() {
    let t = 0;
    const e = this.getFrequencyData();
    for (let n = 0; n < e.length; n++)
      t += e[n];
    return t / e.length;
  }
});
function dN(t, e, n) {
  this.binding = t, this.valueSize = n;
  let s, i, r;
  switch (e) {
    case "quaternion":
      s = this._slerp, i = this._slerpAdditive, r = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
      break;
    case "string":
    case "bool":
      s = this._select, i = this._select, r = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
      break;
    default:
      s = this._lerp, i = this._lerpAdditive, r = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
  }
  this._mixBufferRegion = s, this._mixBufferRegionAdditive = i, this._setIdentity = r, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
}
Object.assign(dN.prototype, {
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate: function(t, e) {
    const n = this.buffer, s = this.valueSize, i = t * s + s;
    let r = this.cumulativeWeight;
    if (r === 0) {
      for (let o = 0; o !== s; ++o)
        n[i + o] = n[o];
      r = e;
    } else {
      r += e;
      const o = e / r;
      this._mixBufferRegion(n, i, 0, o, s);
    }
    this.cumulativeWeight = r;
  },
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive: function(t) {
    const e = this.buffer, n = this.valueSize, s = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e, s, 0, t, n), this.cumulativeWeightAdditive += t;
  },
  // apply the state of 'accu<i>' to the binding when accus differ
  apply: function(t) {
    const e = this.valueSize, n = this.buffer, s = t * e + e, i = this.cumulativeWeight, r = this.cumulativeWeightAdditive, o = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
      const a = e * this._origIndex;
      this._mixBufferRegion(
        n,
        s,
        a,
        1 - i,
        e
      );
    }
    r > 0 && this._mixBufferRegionAdditive(n, s, this._addIndex * e, 1, e);
    for (let a = e, c = e + e; a !== c; ++a)
      if (n[a] !== n[a + e]) {
        o.setValue(n, s);
        break;
      }
  },
  // remember the state of the bound property and copy it to both accus
  saveOriginalState: function() {
    const t = this.binding, e = this.buffer, n = this.valueSize, s = n * this._origIndex;
    t.getValue(e, s);
    for (let i = n, r = s; i !== r; ++i)
      e[i] = e[s + i % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  },
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState: function() {
    const t = this.valueSize * 3;
    this.binding.setValue(this.buffer, t);
  },
  _setAdditiveIdentityNumeric: function() {
    const t = this._addIndex * this.valueSize, e = t + this.valueSize;
    for (let n = t; n < e; n++)
      this.buffer[n] = 0;
  },
  _setAdditiveIdentityQuaternion: function() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * 4 + 3] = 1;
  },
  _setAdditiveIdentityOther: function() {
    const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[e + n] = this.buffer[t + n];
  },
  // mix functions
  _select: function(t, e, n, s, i) {
    if (s >= 0.5)
      for (let r = 0; r !== i; ++r)
        t[e + r] = t[n + r];
  },
  _slerp: function(t, e, n, s) {
    xs.slerpFlat(t, e, t, e, t, n, s);
  },
  _slerpAdditive: function(t, e, n, s, i) {
    const r = this._workIndex * i;
    xs.multiplyQuaternionsFlat(t, r, t, e, t, n), xs.slerpFlat(t, e, t, e, t, r, s);
  },
  _lerp: function(t, e, n, s, i) {
    const r = 1 - s;
    for (let o = 0; o !== i; ++o) {
      const a = e + o;
      t[a] = t[a] * r + t[n + o] * s;
    }
  },
  _lerpAdditive: function(t, e, n, s, i) {
    for (let r = 0; r !== i; ++r) {
      const o = e + r;
      t[o] = t[o] + t[n + r] * s;
    }
  }
});
const z1 = "\\[\\]\\.:\\/", bV = new RegExp("[" + z1 + "]", "g"), V1 = "[^" + z1 + "]", vV = "[^" + z1.replace("\\.", "") + "]", wV = /((?:WC+[\/:])*)/.source.replace("WC", V1), SV = /(WCOD+)?/.source.replace("WCOD", vV), _V = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", V1), TV = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", V1), CV = new RegExp(
  "^" + wV + SV + _V + TV + "$"
), IV = ["material", "materials", "bones"];
function fN(t, e, n) {
  const s = n || ei.parseTrackName(e);
  this._targetGroup = t, this._bindings = t.subscribe_(e, s);
}
Object.assign(fN.prototype, {
  getValue: function(t, e) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, s = this._bindings[n];
    s !== void 0 && s.getValue(t, e);
  },
  setValue: function(t, e) {
    const n = this._bindings;
    for (let s = this._targetGroup.nCachedObjects_, i = n.length; s !== i; ++s)
      n[s].setValue(t, e);
  },
  bind: function() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].bind();
  },
  unbind: function() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].unbind();
  }
});
function ei(t, e, n) {
  this.path = e, this.parsedPath = n || ei.parseTrackName(e), this.node = ei.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t;
}
Object.assign(ei, {
  Composite: fN,
  create: function(t, e, n) {
    return t && t.isAnimationObjectGroup ? new ei.Composite(t, e, n) : new ei(t, e, n);
  },
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  sanitizeNodeName: function(t) {
    return t.replace(/\s/g, "_").replace(bV, "");
  },
  parseTrackName: function(t) {
    const e = CV.exec(t);
    if (!e)
      throw new Error("PropertyBinding: Cannot parse trackName: " + t);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: e[2],
      objectName: e[3],
      objectIndex: e[4],
      propertyName: e[5],
      // required
      propertyIndex: e[6]
    }, s = n.nodeName && n.nodeName.lastIndexOf(".");
    if (s !== void 0 && s !== -1) {
      const i = n.nodeName.substring(s + 1);
      IV.indexOf(i) !== -1 && (n.nodeName = n.nodeName.substring(0, s), n.objectName = i);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
    return n;
  },
  findNode: function(t, e) {
    if (!e || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid)
      return t;
    if (t.skeleton) {
      const n = t.skeleton.getBoneByName(e);
      if (n !== void 0)
        return n;
    }
    if (t.children) {
      const n = function(i) {
        for (let r = 0; r < i.length; r++) {
          const o = i[r];
          if (o.name === e || o.uuid === e)
            return o;
          const a = n(o.children);
          if (a)
            return a;
        }
        return null;
      }, s = n(t.children);
      if (s)
        return s;
    }
    return null;
  }
});
Object.assign(ei.prototype, {
  // prototype, continued
  // these are used to "bind" a nonexistent property
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function(e, n) {
      e[n] = this.node[this.propertyName];
    },
    function(e, n) {
      const s = this.resolvedProperty;
      for (let i = 0, r = s.length; i !== r; ++i)
        e[n++] = s[i];
    },
    function(e, n) {
      e[n] = this.resolvedProperty[this.propertyIndex];
    },
    function(e, n) {
      this.resolvedProperty.toArray(e, n);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      // Direct
      function(e, n) {
        this.targetObject[this.propertyName] = e[n];
      },
      function(e, n) {
        this.targetObject[this.propertyName] = e[n], this.targetObject.needsUpdate = !0;
      },
      function(e, n) {
        this.targetObject[this.propertyName] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // EntireArray
      function(e, n) {
        const s = this.resolvedProperty;
        for (let i = 0, r = s.length; i !== r; ++i)
          s[i] = e[n++];
      },
      function(e, n) {
        const s = this.resolvedProperty;
        for (let i = 0, r = s.length; i !== r; ++i)
          s[i] = e[n++];
        this.targetObject.needsUpdate = !0;
      },
      function(e, n) {
        const s = this.resolvedProperty;
        for (let i = 0, r = s.length; i !== r; ++i)
          s[i] = e[n++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // ArrayElement
      function(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n];
      },
      function(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.needsUpdate = !0;
      },
      function(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // HasToFromArray
      function(e, n) {
        this.resolvedProperty.fromArray(e, n);
      },
      function(e, n) {
        this.resolvedProperty.fromArray(e, n), this.targetObject.needsUpdate = !0;
      },
      function(e, n) {
        this.resolvedProperty.fromArray(e, n), this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ]
  ],
  getValue: function(e, n) {
    this.bind(), this.getValue(e, n);
  },
  setValue: function(e, n) {
    this.bind(), this.setValue(e, n);
  },
  // create getter / setter pair for a property in the scene graph
  bind: function() {
    let t = this.node, e = this.parsedPath, n = e.objectName, s = e.propertyName, i = e.propertyIndex;
    if (t || (t = ei.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (n) {
      let c = e.objectIndex;
      switch (n) {
        case "materials":
          if (!t.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!t.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          t = t.material.materials;
          break;
        case "bones":
          if (!t.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          t = t.skeleton.bones;
          for (let l = 0; l < t.length; l++)
            if (t[l].name === c) {
              c = l;
              break;
            }
          break;
        default:
          if (t[n] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          t = t[n];
      }
      if (c !== void 0) {
        if (t[c] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
          return;
        }
        t = t[c];
      }
    }
    const r = t[s];
    if (r === void 0) {
      const c = e.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + s + " but it wasn't found.", t);
      return;
    }
    let o = this.Versioning.None;
    this.targetObject = t, t.needsUpdate !== void 0 ? o = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
    let a = this.BindingType.Direct;
    if (i !== void 0) {
      if (s === "morphTargetInfluences") {
        if (!t.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (t.geometry.isBufferGeometry) {
          if (!t.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          t.morphTargetDictionary[i] !== void 0 && (i = t.morphTargetDictionary[i]);
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      a = this.BindingType.ArrayElement, this.resolvedProperty = r, this.propertyIndex = i;
    } else
      r.fromArray !== void 0 && r.toArray !== void 0 ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = r) : Array.isArray(r) ? (a = this.BindingType.EntireArray, this.resolvedProperty = r) : this.propertyName = s;
    this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o];
  },
  unbind: function() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
});
Object.assign(ei.prototype, {
  // initial state of these methods that calls 'bind'
  _getValue_unbound: ei.prototype.getValue,
  _setValue_unbound: ei.prototype.setValue
});
function EV() {
  this.uuid = Et.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
  const t = {};
  this._indicesByUUID = t;
  for (let n = 0, s = arguments.length; n !== s; ++n)
    t[arguments[n].uuid] = n;
  this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
  const e = this;
  this.stats = {
    objects: {
      get total() {
        return e._objects.length;
      },
      get inUse() {
        return this.total - e.nCachedObjects_;
      }
    },
    get bindingsPerObject() {
      return e._bindings.length;
    }
  };
}
Object.assign(EV.prototype, {
  isAnimationObjectGroup: !0,
  add: function() {
    const t = this._objects, e = this._indicesByUUID, n = this._paths, s = this._parsedPaths, i = this._bindings, r = i.length;
    let o, a = t.length, c = this.nCachedObjects_;
    for (let l = 0, u = arguments.length; l !== u; ++l) {
      const h = arguments[l], d = h.uuid;
      let f = e[d];
      if (f === void 0) {
        f = a++, e[d] = f, t.push(h);
        for (let p = 0, y = r; p !== y; ++p)
          i[p].push(new ei(h, n[p], s[p]));
      } else if (f < c) {
        o = t[f];
        const p = --c, y = t[p];
        e[y.uuid] = f, t[f] = y, e[d] = p, t[p] = h;
        for (let g = 0, m = r; g !== m; ++g) {
          const x = i[g], v = x[p];
          let b = x[f];
          x[f] = v, b === void 0 && (b = new ei(h, n[g], s[g])), x[p] = b;
        }
      } else
        t[f] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = c;
  },
  remove: function() {
    const t = this._objects, e = this._indicesByUUID, n = this._bindings, s = n.length;
    let i = this.nCachedObjects_;
    for (let r = 0, o = arguments.length; r !== o; ++r) {
      const a = arguments[r], c = a.uuid, l = e[c];
      if (l !== void 0 && l >= i) {
        const u = i++, h = t[u];
        e[h.uuid] = l, t[l] = h, e[c] = u, t[u] = a;
        for (let d = 0, f = s; d !== f; ++d) {
          const p = n[d], y = p[u], g = p[l];
          p[l] = y, p[u] = g;
        }
      }
    }
    this.nCachedObjects_ = i;
  },
  // remove & forget
  uncache: function() {
    const t = this._objects, e = this._indicesByUUID, n = this._bindings, s = n.length;
    let i = this.nCachedObjects_, r = t.length;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const c = arguments[o], l = c.uuid, u = e[l];
      if (u !== void 0)
        if (delete e[l], u < i) {
          const h = --i, d = t[h], f = --r, p = t[f];
          e[d.uuid] = u, t[u] = d, e[p.uuid] = h, t[h] = p, t.pop();
          for (let y = 0, g = s; y !== g; ++y) {
            const m = n[y], x = m[h], v = m[f];
            m[u] = x, m[h] = v, m.pop();
          }
        } else {
          const h = --r, d = t[h];
          e[d.uuid] = u, t[u] = d, t.pop();
          for (let f = 0, p = s; f !== p; ++f) {
            const y = n[f];
            y[u] = y[h], y.pop();
          }
        }
    }
    this.nCachedObjects_ = i;
  },
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_: function(t, e) {
    let n = this._bindingsIndicesByPath, s = n[t], i = this._bindings;
    if (s !== void 0)
      return i[s];
    const r = this._paths, o = this._parsedPaths, a = this._objects, c = a.length, l = this.nCachedObjects_, u = new Array(c);
    s = i.length, n[t] = s, r.push(t), o.push(e), i.push(u);
    for (let h = l, d = a.length; h !== d; ++h) {
      const f = a[h];
      u[h] = new ei(f, t, e);
    }
    return u;
  },
  unsubscribe_: function(t) {
    const e = this._bindingsIndicesByPath, n = e[t];
    if (n !== void 0) {
      const s = this._paths, i = this._parsedPaths, r = this._bindings, o = r.length - 1, a = r[o], c = t[o];
      e[c] = n, r[n] = a, r.pop(), i[n] = i[o], i.pop(), s[n] = s[o], s.pop();
    }
  }
});
function pN(t, e, n, s) {
  this._mixer = t, this._clip = e, this._localRoot = n || null, this.blendMode = s || e.blendMode;
  const i = e.tracks, r = i.length, o = new Array(r), a = {
    endingStart: Ql,
    endingEnd: Ql
  };
  for (let c = 0; c !== r; ++c) {
    const l = i[c].createInterpolant(null);
    o[c] = l, l.settings = a;
  }
  this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = mF, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
}
Object.assign(pN.prototype, {
  // State & Scheduling
  play: function() {
    return this._mixer._activateAction(this), this;
  },
  stop: function() {
    return this._mixer._deactivateAction(this), this.reset();
  },
  reset: function() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  },
  isRunning: function() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  },
  // return true when play has been called
  isScheduled: function() {
    return this._mixer._isActiveAction(this);
  },
  startAt: function(t) {
    return this._startTime = t, this;
  },
  setLoop: function(t, e) {
    return this.loop = t, this.repetitions = e, this;
  },
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight: function(t) {
    return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
  },
  // return the weight considering fading and .enabled
  getEffectiveWeight: function() {
    return this._effectiveWeight;
  },
  fadeIn: function(t) {
    return this._scheduleFading(t, 0, 1);
  },
  fadeOut: function(t) {
    return this._scheduleFading(t, 1, 0);
  },
  crossFadeFrom: function(t, e, n) {
    if (t.fadeOut(e), this.fadeIn(e), n) {
      const s = this._clip.duration, i = t._clip.duration, r = i / s, o = s / i;
      t.warp(1, r, e), this.warp(o, 1, e);
    }
    return this;
  },
  crossFadeTo: function(t, e, n) {
    return t.crossFadeFrom(this, e, n);
  },
  stopFading: function() {
    let t = this._weightInterpolant;
    return t !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
  },
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale: function(t) {
    return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
  },
  // return the time scale considering warping and .paused
  getEffectiveTimeScale: function() {
    return this._effectiveTimeScale;
  },
  setDuration: function(t) {
    return this.timeScale = this._clip.duration / t, this.stopWarping();
  },
  syncWith: function(t) {
    return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
  },
  halt: function(t) {
    return this.warp(this._effectiveTimeScale, 0, t);
  },
  warp: function(t, e, n) {
    const s = this._mixer, i = s.time, r = this.timeScale;
    let o = this._timeScaleInterpolant;
    o === null && (o = s._lendControlInterpolant(), this._timeScaleInterpolant = o);
    const a = o.parameterPositions, c = o.sampleValues;
    return a[0] = i, a[1] = i + n, c[0] = t / r, c[1] = e / r, this;
  },
  stopWarping: function() {
    let t = this._timeScaleInterpolant;
    return t !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
  },
  // Object Accessors
  getMixer: function() {
    return this._mixer;
  },
  getClip: function() {
    return this._clip;
  },
  getRoot: function() {
    return this._localRoot || this._mixer._root;
  },
  // Interna
  _update: function(t, e, n, s) {
    if (!this.enabled) {
      this._updateWeight(t);
      return;
    }
    const i = this._startTime;
    if (i !== null) {
      const a = (t - i) * n;
      if (a < 0 || n === 0)
        return;
      this._startTime = null, e = n * a;
    }
    e *= this._updateTimeScale(t);
    const r = this._updateTime(e), o = this._updateWeight(t);
    if (o > 0) {
      const a = this._interpolants, c = this._propertyBindings;
      switch (this.blendMode) {
        case OE:
          for (let l = 0, u = a.length; l !== u; ++l)
            a[l].evaluate(r), c[l].accumulateAdditive(o);
          break;
        case $1:
        default:
          for (let l = 0, u = a.length; l !== u; ++l)
            a[l].evaluate(r), c[l].accumulate(s, o);
      }
    }
  },
  _updateWeight: function(t) {
    let e = 0;
    if (this.enabled) {
      e = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const s = n.evaluate(t)[0];
        e *= s, t > n.parameterPositions[1] && (this.stopFading(), s === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = e, e;
  },
  _updateTimeScale: function(t) {
    let e = 0;
    if (!this.paused) {
      e = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const s = n.evaluate(t)[0];
        e *= s, t > n.parameterPositions[1] && (this.stopWarping(), e === 0 ? this.paused = !0 : this.timeScale = e);
      }
    }
    return this._effectiveTimeScale = e, e;
  },
  _updateTime: function(t) {
    const e = this._clip.duration, n = this.loop;
    let s = this.time + t, i = this._loopCount;
    const r = n === gF;
    if (t === 0)
      return i === -1 ? s : r && (i & 1) === 1 ? e - s : s;
    if (n === pF) {
      i === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (s >= e)
          s = e;
        else if (s < 0)
          s = 0;
        else {
          this.time = s;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = s, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: t < 0 ? -1 : 1
        });
      }
    } else {
      if (i === -1 && (t >= 0 ? (i = 0, this._setEndings(!0, this.repetitions === 0, r)) : this._setEndings(this.repetitions === 0, !0, r)), s >= e || s < 0) {
        const o = Math.floor(s / e);
        s -= e * o, i += Math.abs(o);
        const a = this.repetitions - i;
        if (a <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, s = t > 0 ? e : 0, this.time = s, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: t > 0 ? 1 : -1
          });
        else {
          if (a === 1) {
            const c = t < 0;
            this._setEndings(c, !c, r);
          } else
            this._setEndings(!1, !1, r);
          this._loopCount = i, this.time = s, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: o
          });
        }
      } else
        this.time = s;
      if (r && (i & 1) === 1)
        return e - s;
    }
    return s;
  },
  _setEndings: function(t, e, n) {
    const s = this._interpolantSettings;
    n ? (s.endingStart = zl, s.endingEnd = zl) : (t ? s.endingStart = this.zeroSlopeAtStart ? zl : Ql : s.endingStart = Xg, e ? s.endingEnd = this.zeroSlopeAtEnd ? zl : Ql : s.endingEnd = Xg);
  },
  _scheduleFading: function(t, e, n) {
    const s = this._mixer, i = s.time;
    let r = this._weightInterpolant;
    r === null && (r = s._lendControlInterpolant(), this._weightInterpolant = r);
    const o = r.parameterPositions, a = r.sampleValues;
    return o[0] = i, a[0] = e, o[1] = i + t, a[1] = n, this;
  }
});
function r2(t) {
  this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
}
r2.prototype = Object.assign(Object.create(Po.prototype), {
  constructor: r2,
  _bindAction: function(t, e) {
    const n = t._localRoot || this._root, s = t._clip.tracks, i = s.length, r = t._propertyBindings, o = t._interpolants, a = n.uuid, c = this._bindingsByRootAndName;
    let l = c[a];
    l === void 0 && (l = {}, c[a] = l);
    for (let u = 0; u !== i; ++u) {
      const h = s[u], d = h.name;
      let f = l[d];
      if (f !== void 0)
        r[u] = f;
      else {
        if (f = r[u], f !== void 0) {
          f._cacheIndex === null && (++f.referenceCount, this._addInactiveBinding(f, a, d));
          continue;
        }
        const p = e && e._propertyBindings[u].binding.parsedPath;
        f = new dN(
          ei.create(n, d, p),
          h.ValueTypeName,
          h.getValueSize()
        ), ++f.referenceCount, this._addInactiveBinding(f, a, d), r[u] = f;
      }
      o[u].resultBuffer = f.buffer;
    }
  },
  _activateAction: function(t) {
    if (!this._isActiveAction(t)) {
      if (t._cacheIndex === null) {
        const n = (t._localRoot || this._root).uuid, s = t._clip.uuid, i = this._actionsByClip[s];
        this._bindAction(
          t,
          i && i.knownActions[0]
        ), this._addInactiveAction(t, s, n);
      }
      const e = t._propertyBindings;
      for (let n = 0, s = e.length; n !== s; ++n) {
        const i = e[n];
        i.useCount++ === 0 && (this._lendBinding(i), i.saveOriginalState());
      }
      this._lendAction(t);
    }
  },
  _deactivateAction: function(t) {
    if (this._isActiveAction(t)) {
      const e = t._propertyBindings;
      for (let n = 0, s = e.length; n !== s; ++n) {
        const i = e[n];
        --i.useCount === 0 && (i.restoreOriginalState(), this._takeBackBinding(i));
      }
      this._takeBackAction(t);
    }
  },
  // Memory manager
  _initMemoryManager: function() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const t = this;
    this.stats = {
      actions: {
        get total() {
          return t._actions.length;
        },
        get inUse() {
          return t._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return t._bindings.length;
        },
        get inUse() {
          return t._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return t._controlInterpolants.length;
        },
        get inUse() {
          return t._nActiveControlInterpolants;
        }
      }
    };
  },
  // Memory management for AnimationAction objects
  _isActiveAction: function(t) {
    const e = t._cacheIndex;
    return e !== null && e < this._nActiveActions;
  },
  _addInactiveAction: function(t, e, n) {
    const s = this._actions, i = this._actionsByClip;
    let r = i[e];
    if (r === void 0)
      r = {
        knownActions: [t],
        actionByRoot: {}
      }, t._byClipCacheIndex = 0, i[e] = r;
    else {
      const o = r.knownActions;
      t._byClipCacheIndex = o.length, o.push(t);
    }
    t._cacheIndex = s.length, s.push(t), r.actionByRoot[n] = t;
  },
  _removeInactiveAction: function(t) {
    const e = this._actions, n = e[e.length - 1], s = t._cacheIndex;
    n._cacheIndex = s, e[s] = n, e.pop(), t._cacheIndex = null;
    const i = t._clip.uuid, r = this._actionsByClip, o = r[i], a = o.knownActions, c = a[a.length - 1], l = t._byClipCacheIndex;
    c._byClipCacheIndex = l, a[l] = c, a.pop(), t._byClipCacheIndex = null;
    const u = o.actionByRoot, h = (t._localRoot || this._root).uuid;
    delete u[h], a.length === 0 && delete r[i], this._removeInactiveBindingsForAction(t);
  },
  _removeInactiveBindingsForAction: function(t) {
    const e = t._propertyBindings;
    for (let n = 0, s = e.length; n !== s; ++n) {
      const i = e[n];
      --i.referenceCount === 0 && this._removeInactiveBinding(i);
    }
  },
  _lendAction: function(t) {
    const e = this._actions, n = t._cacheIndex, s = this._nActiveActions++, i = e[s];
    t._cacheIndex = s, e[s] = t, i._cacheIndex = n, e[n] = i;
  },
  _takeBackAction: function(t) {
    const e = this._actions, n = t._cacheIndex, s = --this._nActiveActions, i = e[s];
    t._cacheIndex = s, e[s] = t, i._cacheIndex = n, e[n] = i;
  },
  // Memory management for PropertyMixer objects
  _addInactiveBinding: function(t, e, n) {
    const s = this._bindingsByRootAndName, i = this._bindings;
    let r = s[e];
    r === void 0 && (r = {}, s[e] = r), r[n] = t, t._cacheIndex = i.length, i.push(t);
  },
  _removeInactiveBinding: function(t) {
    const e = this._bindings, n = t.binding, s = n.rootNode.uuid, i = n.path, r = this._bindingsByRootAndName, o = r[s], a = e[e.length - 1], c = t._cacheIndex;
    a._cacheIndex = c, e[c] = a, e.pop(), delete o[i], Object.keys(o).length === 0 && delete r[s];
  },
  _lendBinding: function(t) {
    const e = this._bindings, n = t._cacheIndex, s = this._nActiveBindings++, i = e[s];
    t._cacheIndex = s, e[s] = t, i._cacheIndex = n, e[n] = i;
  },
  _takeBackBinding: function(t) {
    const e = this._bindings, n = t._cacheIndex, s = --this._nActiveBindings, i = e[s];
    t._cacheIndex = s, e[s] = t, i._cacheIndex = n, e[n] = i;
  },
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant: function() {
    const t = this._controlInterpolants, e = this._nActiveControlInterpolants++;
    let n = t[e];
    return n === void 0 && (n = new yy(
      new Float32Array(2),
      new Float32Array(2),
      1,
      this._controlInterpolantsResultBuffer
    ), n.__cacheIndex = e, t[e] = n), n;
  },
  _takeBackControlInterpolant: function(t) {
    const e = this._controlInterpolants, n = t.__cacheIndex, s = --this._nActiveControlInterpolants, i = e[s];
    t.__cacheIndex = s, e[s] = t, i.__cacheIndex = n, e[n] = i;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction: function(t, e, n) {
    const s = e || this._root, i = s.uuid;
    let r = typeof t == "string" ? yr.findByName(s, t) : t;
    const o = r !== null ? r.uuid : t;
    let a = this._actionsByClip[o], c = null;
    if (n === void 0 && (r !== null ? n = r.blendMode : n = $1), a !== void 0) {
      const u = a.actionByRoot[i];
      if (u !== void 0 && u.blendMode === n)
        return u;
      c = a.knownActions[0], r === null && (r = c._clip);
    }
    if (r === null)
      return null;
    const l = new pN(this, r, e, n);
    return this._bindAction(l, c), this._addInactiveAction(l, o, i), l;
  },
  // get an existing action
  existingAction: function(t, e) {
    const n = e || this._root, s = n.uuid, i = typeof t == "string" ? yr.findByName(n, t) : t, r = i ? i.uuid : t, o = this._actionsByClip[r];
    return o !== void 0 && o.actionByRoot[s] || null;
  },
  // deactivates all previously scheduled actions
  stopAllAction: function() {
    const t = this._actions, e = this._nActiveActions;
    for (let n = e - 1; n >= 0; --n)
      t[n].stop();
    return this;
  },
  // advance the time and update apply the animation
  update: function(t) {
    t *= this.timeScale;
    const e = this._actions, n = this._nActiveActions, s = this.time += t, i = Math.sign(t), r = this._accuIndex ^= 1;
    for (let c = 0; c !== n; ++c)
      e[c]._update(s, t, i, r);
    const o = this._bindings, a = this._nActiveBindings;
    for (let c = 0; c !== a; ++c)
      o[c].apply(r);
    return this;
  },
  // Allows you to seek to a specific time in an animation.
  setTime: function(t) {
    this.time = 0;
    for (let e = 0; e < this._actions.length; e++)
      this._actions[e].time = 0;
    return this.update(t);
  },
  // return this mixer's root target object
  getRoot: function() {
    return this._root;
  },
  // free all resources specific to a particular clip
  uncacheClip: function(t) {
    const e = this._actions, n = t.uuid, s = this._actionsByClip, i = s[n];
    if (i !== void 0) {
      const r = i.knownActions;
      for (let o = 0, a = r.length; o !== a; ++o) {
        const c = r[o];
        this._deactivateAction(c);
        const l = c._cacheIndex, u = e[e.length - 1];
        c._cacheIndex = null, c._byClipCacheIndex = null, u._cacheIndex = l, e[l] = u, e.pop(), this._removeInactiveBindingsForAction(c);
      }
      delete s[n];
    }
  },
  // free all resources specific to a particular root target object
  uncacheRoot: function(t) {
    const e = t.uuid, n = this._actionsByClip;
    for (const r in n) {
      const o = n[r].actionByRoot, a = o[e];
      a !== void 0 && (this._deactivateAction(a), this._removeInactiveAction(a));
    }
    const s = this._bindingsByRootAndName, i = s[e];
    if (i !== void 0)
      for (const r in i) {
        const o = i[r];
        o.restoreOriginalState(), this._removeInactiveBinding(o);
      }
  },
  // remove a targeted clip from the cache
  uncacheAction: function(t, e) {
    const n = this.existingAction(t, e);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
});
function Iw(t) {
  typeof t == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t;
}
Iw.prototype.clone = function() {
  return new Iw(this.value.clone === void 0 ? this.value : this.value.clone());
};
function o2(t, e, n) {
  Hi.call(this, t, e), this.meshPerAttribute = n || 1;
}
o2.prototype = Object.assign(Object.create(Hi.prototype), {
  constructor: o2,
  isInstancedInterleavedBuffer: !0,
  copy: function(t) {
    return Hi.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
  },
  clone: function(t) {
    const e = Hi.prototype.clone.call(this, t);
    return e.meshPerAttribute = this.meshPerAttribute, e;
  },
  toJSON: function(t) {
    const e = Hi.prototype.toJSON.call(this, t);
    return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e;
  }
});
function mN(t, e, n, s) {
  this.ray = new $u(t, e), this.near = n || 0, this.far = s || 1 / 0, this.camera = null, this.layers = new F1(), this.params = {
    Mesh: {},
    Line: { threshold: 1 },
    LOD: {},
    Points: { threshold: 1 },
    Sprite: {}
  }, Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points;
      }
    }
  });
}
function a2(t, e) {
  return t.distance - e.distance;
}
function Ew(t, e, n, s) {
  if (t.layers.test(e.layers) && t.raycast(e, n), s === !0) {
    const i = t.children;
    for (let r = 0, o = i.length; r < o; r++)
      Ew(i[r], e, n, !0);
  }
}
Object.assign(mN.prototype, {
  set: function(t, e) {
    this.ray.set(t, e);
  },
  setFromCamera: function(t, e) {
    e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type.");
  },
  intersectObject: function(t, e, n) {
    const s = n || [];
    return Ew(t, this, s, e), s.sort(a2), s;
  },
  intersectObjects: function(t, e, n) {
    const s = n || [];
    if (Array.isArray(t) === !1)
      return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), s;
    for (let i = 0, r = t.length; i < r; i++)
      Ew(t[i], this, s, e);
    return s.sort(a2), s;
  }
});
function NV(t, e, n) {
  return this.radius = t !== void 0 ? t : 1, this.theta = e !== void 0 ? e : 0, this.y = n !== void 0 ? n : 0, this;
}
Object.assign(NV.prototype, {
  set: function(t, e, n) {
    return this.radius = t, this.theta = e, this.y = n, this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this;
  },
  setFromVector3: function(t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z);
  },
  setFromCartesianCoords: function(t, e, n) {
    return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this;
  }
});
const c2 = new Ce();
function gN(t, e) {
  this.min = t !== void 0 ? t : new Ce(1 / 0, 1 / 0), this.max = e !== void 0 ? e : new Ce(-1 / 0, -1 / 0);
}
Object.assign(gN.prototype, {
  set: function(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  },
  setFromPoints: function(t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e++)
      this.expandByPoint(t[e]);
    return this;
  },
  setFromCenterAndSize: function(t, e) {
    const n = c2.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  },
  makeEmpty: function() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  getCenter: function(t) {
    return t === void 0 && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new Ce()), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(t) {
    return t === void 0 && (console.warn("THREE.Box2: .getSize() target is now required"), t = new Ce()), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
  },
  expandByPoint: function(t) {
    return this.min.min(t), this.max.max(t), this;
  },
  expandByVector: function(t) {
    return this.min.sub(t), this.max.add(t), this;
  },
  expandByScalar: function(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  },
  containsPoint: function(t) {
    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y);
  },
  containsBox: function(t) {
    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
  },
  getParameter: function(t, e) {
    return e === void 0 && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new Ce()), e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y)
    );
  },
  intersectsBox: function(t) {
    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y);
  },
  clampPoint: function(t, e) {
    return e === void 0 && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new Ce()), e.copy(t).clamp(this.min, this.max);
  },
  distanceToPoint: function(t) {
    return c2.copy(t).clamp(this.min, this.max).sub(t).length();
  },
  intersect: function(t) {
    return this.min.max(t.min), this.max.min(t.max), this;
  },
  union: function(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  },
  translate: function(t) {
    return this.min.add(t), this.max.add(t), this;
  },
  equals: function(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
});
const l2 = new P(), og = new P();
function yN(t, e) {
  this.start = t !== void 0 ? t : new P(), this.end = e !== void 0 ? e : new P();
}
Object.assign(yN.prototype, {
  set: function(t, e) {
    return this.start.copy(t), this.end.copy(e), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.start.copy(t.start), this.end.copy(t.end), this;
  },
  getCenter: function(t) {
    return t === void 0 && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new P()), t.addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function(t) {
    return t === void 0 && (console.warn("THREE.Line3: .delta() target is now required"), t = new P()), t.subVectors(this.end, this.start);
  },
  distanceSq: function() {
    return this.start.distanceToSquared(this.end);
  },
  distance: function() {
    return this.start.distanceTo(this.end);
  },
  at: function(t, e) {
    return e === void 0 && (console.warn("THREE.Line3: .at() target is now required"), e = new P()), this.delta(e).multiplyScalar(t).add(this.start);
  },
  closestPointToPointParameter: function(t, e) {
    l2.subVectors(t, this.start), og.subVectors(this.end, this.start);
    const n = og.dot(og);
    let i = og.dot(l2) / n;
    return e && (i = Et.clamp(i, 0, 1)), i;
  },
  closestPointToPoint: function(t, e, n) {
    const s = this.closestPointToPointParameter(t, e);
    return n === void 0 && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new P()), this.delta(n).multiplyScalar(s).add(this.start);
  },
  applyMatrix4: function(t) {
    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
  },
  equals: function(t) {
    return t.start.equals(this.start) && t.end.equals(this.end);
  }
});
function _y(t) {
  qe.call(this), this.material = t, this.render = function() {
  }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
}
_y.prototype = Object.create(qe.prototype);
_y.prototype.constructor = _y;
_y.prototype.isImmediateRenderObject = !0;
const u2 = new P();
function rf(t, e) {
  qe.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
  const n = new et(), s = [
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    -1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    -1,
    1
  ];
  for (let r = 0, o = 1, a = 32; r < a; r++, o++) {
    const c = r / a * Math.PI * 2, l = o / a * Math.PI * 2;
    s.push(
      Math.cos(c),
      Math.sin(c),
      1,
      Math.cos(l),
      Math.sin(l),
      1
    );
  }
  n.setAttribute("position", new Ze(s, 3));
  const i = new Bn({ fog: !1, toneMapped: !1 });
  this.cone = new ns(n, i), this.add(this.cone), this.update();
}
rf.prototype = Object.create(qe.prototype);
rf.prototype.constructor = rf;
rf.prototype.dispose = function() {
  this.cone.geometry.dispose(), this.cone.material.dispose();
};
rf.prototype.update = function() {
  this.light.updateMatrixWorld();
  const t = this.light.distance ? this.light.distance : 1e3, e = t * Math.tan(this.light.angle);
  this.cone.scale.set(e, e, t), u2.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(u2), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
};
const sa = new P(), ag = new Mt(), hv = new Mt();
function xN(t) {
  const e = [];
  t && t.isBone && e.push(t);
  for (let n = 0; n < t.children.length; n++)
    e.push.apply(e, xN(t.children[n]));
  return e;
}
function gu(t) {
  const e = xN(t), n = new et(), s = [], i = [], r = new st(0, 0, 1), o = new st(0, 1, 0);
  for (let c = 0; c < e.length; c++) {
    const l = e[c];
    l.parent && l.parent.isBone && (s.push(0, 0, 0), s.push(0, 0, 0), i.push(r.r, r.g, r.b), i.push(o.r, o.g, o.b));
  }
  n.setAttribute("position", new Ze(s, 3)), n.setAttribute("color", new Ze(i, 3));
  const a = new Bn({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
  ns.call(this, n, a), this.type = "SkeletonHelper", this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1;
}
gu.prototype = Object.create(ns.prototype);
gu.prototype.constructor = gu;
gu.prototype.isSkeletonHelper = !0;
gu.prototype.updateMatrixWorld = function(t) {
  const e = this.bones, n = this.geometry, s = n.getAttribute("position");
  hv.getInverse(this.root.matrixWorld);
  for (let i = 0, r = 0; i < e.length; i++) {
    const o = e[i];
    o.parent && o.parent.isBone && (ag.multiplyMatrices(hv, o.matrixWorld), sa.setFromMatrixPosition(ag), s.setXYZ(r, sa.x, sa.y, sa.z), ag.multiplyMatrices(hv, o.parent.matrixWorld), sa.setFromMatrixPosition(ag), s.setXYZ(r + 1, sa.x, sa.y, sa.z), r += 2);
  }
  n.getAttribute("position").needsUpdate = !0, qe.prototype.updateMatrixWorld.call(this, t);
};
function of(t, e, n) {
  this.light = t, this.light.updateMatrixWorld(), this.color = n;
  const s = new ou(e, 4, 2), i = new er({ wireframe: !0, fog: !1, toneMapped: !1 });
  cn.call(this, s, i), this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
}
of.prototype = Object.create(cn.prototype);
of.prototype.constructor = of;
of.prototype.dispose = function() {
  this.geometry.dispose(), this.material.dispose();
};
of.prototype.update = function() {
  this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
};
const kV = new P(), h2 = new st(), d2 = new st();
function af(t, e, n) {
  qe.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
  const s = new su(e);
  s.rotateY(Math.PI * 0.5), this.material = new er({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
  const i = s.getAttribute("position"), r = new Float32Array(i.count * 3);
  s.setAttribute("color", new ut(r, 3)), this.add(new cn(s, this.material)), this.update();
}
af.prototype = Object.create(qe.prototype);
af.prototype.constructor = af;
af.prototype.dispose = function() {
  this.children[0].geometry.dispose(), this.children[0].material.dispose();
};
af.prototype.update = function() {
  const t = this.children[0];
  if (this.color !== void 0)
    this.material.color.set(this.color);
  else {
    const e = t.geometry.getAttribute("color");
    h2.copy(this.light.color), d2.copy(this.light.groundColor);
    for (let n = 0, s = e.count; n < s; n++) {
      const i = n < s / 2 ? h2 : d2;
      e.setXYZ(n, i.r, i.g, i.b);
    }
    e.needsUpdate = !0;
  }
  t.lookAt(kV.setFromMatrixPosition(this.light.matrixWorld).negate());
};
function Ty(t, e, n, s) {
  t = t || 10, e = e || 10, n = new st(n !== void 0 ? n : 4473924), s = new st(s !== void 0 ? s : 8947848);
  const i = e / 2, r = t / e, o = t / 2, a = [], c = [];
  for (let h = 0, d = 0, f = -o; h <= e; h++, f += r) {
    a.push(-o, 0, f, o, 0, f), a.push(f, 0, -o, f, 0, o);
    const p = h === i ? n : s;
    p.toArray(c, d), d += 3, p.toArray(c, d), d += 3, p.toArray(c, d), d += 3, p.toArray(c, d), d += 3;
  }
  const l = new et();
  l.setAttribute("position", new Ze(a, 3)), l.setAttribute("color", new Ze(c, 3));
  const u = new Bn({ vertexColors: !0, toneMapped: !1 });
  ns.call(this, l, u), this.type = "GridHelper";
}
Ty.prototype = Object.create(ns.prototype);
Ty.prototype.constructor = Ty;
function Nw(t, e, n, s, i, r) {
  t = t || 10, e = e || 16, n = n || 8, s = s || 64, i = new st(i !== void 0 ? i : 4473924), r = new st(r !== void 0 ? r : 8947848);
  const o = [], a = [];
  for (let u = 0; u <= e; u++) {
    const h = u / e * (Math.PI * 2), d = Math.sin(h) * t, f = Math.cos(h) * t;
    o.push(0, 0, 0), o.push(d, 0, f);
    const p = u & 1 ? i : r;
    a.push(p.r, p.g, p.b), a.push(p.r, p.g, p.b);
  }
  for (let u = 0; u <= n; u++) {
    const h = u & 1 ? i : r, d = t - t / n * u;
    for (let f = 0; f < s; f++) {
      let p = f / s * (Math.PI * 2), y = Math.sin(p) * d, g = Math.cos(p) * d;
      o.push(y, 0, g), a.push(h.r, h.g, h.b), p = (f + 1) / s * (Math.PI * 2), y = Math.sin(p) * d, g = Math.cos(p) * d, o.push(y, 0, g), a.push(h.r, h.g, h.b);
    }
  }
  const c = new et();
  c.setAttribute("position", new Ze(o, 3)), c.setAttribute("color", new Ze(a, 3));
  const l = new Bn({ vertexColors: !0, toneMapped: !1 });
  ns.call(this, c, l), this.type = "PolarGridHelper";
}
Nw.prototype = Object.create(ns.prototype);
Nw.prototype.constructor = Nw;
const f2 = new P(), cg = new P(), p2 = new P();
function cf(t, e, n) {
  qe.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, e === void 0 && (e = 1);
  let s = new et();
  s.setAttribute("position", new Ze([
    -e,
    e,
    0,
    e,
    e,
    0,
    e,
    -e,
    0,
    -e,
    -e,
    0,
    -e,
    e,
    0
  ], 3));
  const i = new Bn({ fog: !1, toneMapped: !1 });
  this.lightPlane = new nr(s, i), this.add(this.lightPlane), s = new et(), s.setAttribute("position", new Ze([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new nr(s, i), this.add(this.targetLine), this.update();
}
cf.prototype = Object.create(qe.prototype);
cf.prototype.constructor = cf;
cf.prototype.dispose = function() {
  this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
};
cf.prototype.update = function() {
  f2.setFromMatrixPosition(this.light.matrixWorld), cg.setFromMatrixPosition(this.light.target.matrixWorld), p2.subVectors(cg, f2), this.lightPlane.lookAt(cg), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(cg), this.targetLine.scale.z = p2.length();
};
const lg = new P(), Fn = new Eo();
function Cy(t) {
  const e = new et(), n = new Bn({ color: 16777215, vertexColors: !0, toneMapped: !1 }), s = [], i = [], r = {}, o = new st(16755200), a = new st(16711680), c = new st(43775), l = new st(16777215), u = new st(3355443);
  h("n1", "n2", o), h("n2", "n4", o), h("n4", "n3", o), h("n3", "n1", o), h("f1", "f2", o), h("f2", "f4", o), h("f4", "f3", o), h("f3", "f1", o), h("n1", "f1", o), h("n2", "f2", o), h("n3", "f3", o), h("n4", "f4", o), h("p", "n1", a), h("p", "n2", a), h("p", "n3", a), h("p", "n4", a), h("u1", "u2", c), h("u2", "u3", c), h("u3", "u1", c), h("c", "t", l), h("p", "c", u), h("cn1", "cn2", u), h("cn3", "cn4", u), h("cf1", "cf2", u), h("cf3", "cf4", u);
  function h(f, p, y) {
    d(f, y), d(p, y);
  }
  function d(f, p) {
    s.push(0, 0, 0), i.push(p.r, p.g, p.b), r[f] === void 0 && (r[f] = []), r[f].push(s.length / 3 - 1);
  }
  e.setAttribute("position", new Ze(s, 3)), e.setAttribute("color", new Ze(i, 3)), ns.call(this, e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = r, this.update();
}
Cy.prototype = Object.create(ns.prototype);
Cy.prototype.constructor = Cy;
Cy.prototype.update = function() {
  const t = this.geometry, e = this.pointMap, n = 1, s = 1;
  Fn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Hn("c", e, t, Fn, 0, 0, -1), Hn("t", e, t, Fn, 0, 0, 1), Hn("n1", e, t, Fn, -n, -s, -1), Hn("n2", e, t, Fn, n, -s, -1), Hn("n3", e, t, Fn, -n, s, -1), Hn("n4", e, t, Fn, n, s, -1), Hn("f1", e, t, Fn, -n, -s, 1), Hn("f2", e, t, Fn, n, -s, 1), Hn("f3", e, t, Fn, -n, s, 1), Hn("f4", e, t, Fn, n, s, 1), Hn("u1", e, t, Fn, n * 0.7, s * 1.1, -1), Hn("u2", e, t, Fn, -n * 0.7, s * 1.1, -1), Hn("u3", e, t, Fn, 0, s * 2, -1), Hn("cf1", e, t, Fn, -n, 0, 1), Hn("cf2", e, t, Fn, n, 0, 1), Hn("cf3", e, t, Fn, 0, -s, 1), Hn("cf4", e, t, Fn, 0, s, 1), Hn("cn1", e, t, Fn, -n, 0, -1), Hn("cn2", e, t, Fn, n, 0, -1), Hn("cn3", e, t, Fn, 0, -s, -1), Hn("cn4", e, t, Fn, 0, s, -1), t.getAttribute("position").needsUpdate = !0;
};
function Hn(t, e, n, s, i, r, o) {
  lg.set(i, r, o).unproject(s);
  const a = e[t];
  if (a !== void 0) {
    const c = n.getAttribute("position");
    for (let l = 0, u = a.length; l < u; l++)
      c.setXYZ(a[l], lg.x, lg.y, lg.z);
  }
}
const ug = new co();
function yu(t, e) {
  this.object = t, e === void 0 && (e = 16776960);
  const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), s = new Float32Array(8 * 3), i = new et();
  i.setIndex(new ut(n, 1)), i.setAttribute("position", new ut(s, 3)), ns.call(this, i, new Bn({ color: e, toneMapped: !1 })), this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
}
yu.prototype = Object.create(ns.prototype);
yu.prototype.constructor = yu;
yu.prototype.update = function(t) {
  if (t !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && ug.setFromObject(this.object), ug.isEmpty())
    return;
  const e = ug.min, n = ug.max, s = this.geometry.attributes.position, i = s.array;
  i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = e.x, i[4] = n.y, i[5] = n.z, i[6] = e.x, i[7] = e.y, i[8] = n.z, i[9] = n.x, i[10] = e.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = e.z, i[15] = e.x, i[16] = n.y, i[17] = e.z, i[18] = e.x, i[19] = e.y, i[20] = e.z, i[21] = n.x, i[22] = e.y, i[23] = e.z, s.needsUpdate = !0, this.geometry.computeBoundingSphere();
};
yu.prototype.setFromObject = function(t) {
  return this.object = t, this.update(), this;
};
yu.prototype.copy = function(t) {
  return ns.prototype.copy.call(this, t), this.object = t.object, this;
};
function Iy(t, e) {
  this.type = "Box3Helper", this.box = t, e === void 0 && (e = 16776960);
  const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), s = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], i = new et();
  i.setIndex(new ut(n, 1)), i.setAttribute("position", new Ze(s, 3)), ns.call(this, i, new Bn({ color: e, toneMapped: !1 })), this.type = "Box3Helper", this.geometry.computeBoundingSphere();
}
Iy.prototype = Object.create(ns.prototype);
Iy.prototype.constructor = Iy;
Iy.prototype.updateMatrixWorld = function(t) {
  const e = this.box;
  e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(0.5), qe.prototype.updateMatrixWorld.call(this, t));
};
function Ey(t, e, n) {
  this.plane = t, this.size = e === void 0 ? 1 : e;
  const s = n !== void 0 ? n : 16776960, i = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], r = new et();
  r.setAttribute("position", new Ze(i, 3)), r.computeBoundingSphere(), nr.call(this, r, new Bn({ color: s, toneMapped: !1 })), this.type = "PlaneHelper";
  const o = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], a = new et();
  a.setAttribute("position", new Ze(o, 3)), a.computeBoundingSphere(), this.add(new cn(a, new er({ color: s, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
}
Ey.prototype = Object.create(nr.prototype);
Ey.prototype.constructor = Ey;
Ey.prototype.updateMatrixWorld = function(t) {
  let e = -this.plane.constant;
  Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, e), this.children[0].material.side = e < 0 ? is : Rf, this.lookAt(this.plane.normal), qe.prototype.updateMatrixWorld.call(this, t);
};
const m2 = new P();
let hg, dv;
function Oc(t, e, n, s, i, r) {
  qe.call(this), this.type = "ArrowHelper", t === void 0 && (t = new P(0, 0, 1)), e === void 0 && (e = new P(0, 0, 0)), n === void 0 && (n = 1), s === void 0 && (s = 16776960), i === void 0 && (i = 0.2 * n), r === void 0 && (r = 0.2 * i), hg === void 0 && (hg = new et(), hg.setAttribute("position", new Ze([0, 0, 0, 0, 1, 0], 3)), dv = new wa(0, 0.5, 1, 5, 1), dv.translate(0, -0.5, 0)), this.position.copy(e), this.line = new nr(hg, new Bn({ color: s, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new cn(dv, new er({ color: s, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, i, r);
}
Oc.prototype = Object.create(qe.prototype);
Oc.prototype.constructor = Oc;
Oc.prototype.setDirection = function(t) {
  if (t.y > 0.99999)
    this.quaternion.set(0, 0, 0, 1);
  else if (t.y < -0.99999)
    this.quaternion.set(1, 0, 0, 0);
  else {
    m2.set(t.z, 0, -t.x).normalize();
    const e = Math.acos(t.y);
    this.quaternion.setFromAxisAngle(m2, e);
  }
};
Oc.prototype.setLength = function(t, e, n) {
  e === void 0 && (e = 0.2 * t), n === void 0 && (n = 0.2 * e), this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix();
};
Oc.prototype.setColor = function(t) {
  this.line.material.color.set(t), this.cone.material.color.set(t);
};
Oc.prototype.copy = function(t) {
  return qe.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this;
};
function kw(t) {
  t = t || 1;
  const e = [
    0,
    0,
    0,
    t,
    0,
    0,
    0,
    0,
    0,
    0,
    t,
    0,
    0,
    0,
    0,
    0,
    0,
    t
  ], n = [
    1,
    0,
    0,
    1,
    0.6,
    0,
    0,
    1,
    0,
    0.6,
    1,
    0,
    0,
    0,
    1,
    0,
    0.6,
    1
  ], s = new et();
  s.setAttribute("position", new Ze(e, 3)), s.setAttribute("color", new Ze(n, 3));
  const i = new Bn({ vertexColors: !0, toneMapped: !1 });
  ns.call(this, s, i), this.type = "AxesHelper";
}
kw.prototype = Object.create(ns.prototype);
kw.prototype.constructor = kw;
const Xl = 4, pa = 8, Or = Math.pow(2, pa), bN = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], vN = pa - Xl + 1 + bN.length, Fl = 20, Gr = {
  [gi]: 0,
  [hx]: 1,
  [L1]: 2,
  [LE]: 3,
  [FE]: 4,
  [PE]: 5,
  [O1]: 6
}, fv = new nf(), { _lodPlanes: id, _sizeLods: g2, _sigmas: dg } = MV();
let pv = null;
const ac = (1 + Math.sqrt(5)) / 2, Rl = 1 / ac, y2 = [
  new P(1, 1, 1),
  new P(-1, 1, 1),
  new P(1, 1, -1),
  new P(-1, 1, -1),
  new P(0, ac, Rl),
  new P(0, ac, -Rl),
  new P(Rl, 0, ac),
  new P(-Rl, 0, ac),
  new P(ac, Rl, 0),
  new P(-ac, Rl, 0)
];
function x2(t) {
  this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = RV(Fl), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
}
x2.prototype = {
  constructor: x2,
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene: function(t, e = 0, n = 0.1, s = 100) {
    pv = this._renderer.getRenderTarget();
    const i = this._allocateTargets();
    return this._sceneToCubeUV(t, n, s, i), e > 0 && this._blur(i, 0, 0, e), this._applyPMREM(i), this._cleanup(i), i;
  },
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular: function(t) {
    return this._fromTexture(t);
  },
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap: function(t) {
    return this._fromTexture(t);
  },
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader: function() {
    this._cubemapShader === null && (this._cubemapShader = w2(), this._compileMaterial(this._cubemapShader));
  },
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader: function() {
    this._equirectShader === null && (this._equirectShader = v2(), this._compileMaterial(this._equirectShader));
  },
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose: function() {
    this._blurMaterial.dispose(), this._cubemapShader !== null && this._cubemapShader.dispose(), this._equirectShader !== null && this._equirectShader.dispose();
    for (let t = 0; t < id.length; t++)
      id[t].dispose();
  },
  // private interface
  _cleanup: function(t) {
    this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(pv), t.scissorTest = !1, fg(t, 0, 0, t.width, t.height);
  },
  _fromTexture: function(t) {
    pv = this._renderer.getRenderTarget();
    const e = this._allocateTargets(t);
    return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e;
  },
  _allocateTargets: function(t) {
    const e = {
      magFilter: ps,
      minFilter: ps,
      generateMipmaps: !1,
      type: $f,
      format: ML,
      encoding: AV(t) ? t.encoding : L1,
      depthBuffer: !1,
      stencilBuffer: !1
    }, n = b2(e);
    return n.depthBuffer = !t, this._pingPongRenderTarget = b2(e), n;
  },
  _compileMaterial: function(t) {
    const e = new cn(id[0], t);
    this._renderer.compile(e, fv);
  },
  _sceneToCubeUV: function(t, e, n, s) {
    const o = new Yn(90, 1, e, n), a = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], l = this._renderer, u = l.outputEncoding, h = l.toneMapping, d = l.getClearColor(), f = l.getClearAlpha();
    l.toneMapping = jl, l.outputEncoding = gi;
    let p = t.background;
    if (p && p.isColor) {
      p.convertSRGBToLinear();
      const y = Math.max(p.r, p.g, p.b), g = Math.min(Math.max(Math.ceil(Math.log2(y)), -128), 127);
      p = p.multiplyScalar(Math.pow(2, -g));
      const m = (g + 128) / 255;
      l.setClearColor(p, m), t.background = null;
    }
    for (let y = 0; y < 6; y++) {
      const g = y % 3;
      g == 0 ? (o.up.set(0, a[y], 0), o.lookAt(c[y], 0, 0)) : g == 1 ? (o.up.set(0, 0, a[y]), o.lookAt(0, c[y], 0)) : (o.up.set(0, a[y], 0), o.lookAt(0, 0, c[y])), fg(
        s,
        g * Or,
        y > 2 ? Or : 0,
        Or,
        Or
      ), l.setRenderTarget(s), l.render(t, o);
    }
    l.toneMapping = h, l.outputEncoding = u, l.setClearColor(d, f);
  },
  _textureToCubeUV: function(t, e) {
    const n = this._renderer;
    t.isCubeTexture ? this._cubemapShader == null && (this._cubemapShader = w2()) : this._equirectShader == null && (this._equirectShader = v2());
    const s = t.isCubeTexture ? this._cubemapShader : this._equirectShader, i = new cn(id[0], s), r = s.uniforms;
    r.envMap.value = t, t.isCubeTexture || r.texelSize.value.set(1 / t.image.width, 1 / t.image.height), r.inputEncoding.value = Gr[t.encoding], r.outputEncoding.value = Gr[e.texture.encoding], fg(e, 0, 0, 3 * Or, 2 * Or), n.setRenderTarget(e), n.render(i, fv);
  },
  _applyPMREM: function(t) {
    const e = this._renderer, n = e.autoClear;
    e.autoClear = !1;
    for (let s = 1; s < vN; s++) {
      const i = Math.sqrt(dg[s] * dg[s] - dg[s - 1] * dg[s - 1]), r = y2[(s - 1) % y2.length];
      this._blur(t, s - 1, s, i, r);
    }
    e.autoClear = n;
  },
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur: function(t, e, n, s, i) {
    const r = this._pingPongRenderTarget;
    this._halfBlur(
      t,
      r,
      e,
      n,
      s,
      "latitudinal",
      i
    ), this._halfBlur(
      r,
      t,
      n,
      n,
      s,
      "longitudinal",
      i
    );
  },
  _halfBlur: function(t, e, n, s, i, r, o) {
    const a = this._renderer, c = this._blurMaterial;
    r !== "latitudinal" && r !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const l = 3, u = new cn(id[s], c), h = c.uniforms, d = g2[n] - 1, f = isFinite(i) ? Math.PI / (2 * d) : 2 * Math.PI / (2 * Fl - 1), p = i / f, y = isFinite(i) ? 1 + Math.floor(l * p) : Fl;
    y > Fl && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${Fl}`);
    const g = [];
    let m = 0;
    for (let w = 0; w < Fl; ++w) {
      const S = w / p, _ = Math.exp(-S * S / 2);
      g.push(_), w == 0 ? m += _ : w < y && (m += 2 * _);
    }
    for (let w = 0; w < g.length; w++)
      g[w] = g[w] / m;
    h.envMap.value = t.texture, h.samples.value = y, h.weights.value = g, h.latitudinal.value = r === "latitudinal", o && (h.poleAxis.value = o), h.dTheta.value = f, h.mipInt.value = pa - n, h.inputEncoding.value = Gr[t.texture.encoding], h.outputEncoding.value = Gr[t.texture.encoding];
    const x = g2[s], v = 3 * Math.max(0, Or - 2 * x), b = (s === 0 ? 0 : 2 * Or) + 2 * x * (s > pa - Xl ? s - pa + Xl : 0);
    fg(e, v, b, 3 * x, 2 * x), a.setRenderTarget(e), a.render(u, fv);
  }
};
function AV(t) {
  return t === void 0 || t.type !== $f ? !1 : t.encoding === gi || t.encoding === hx || t.encoding === O1;
}
function MV() {
  const t = [], e = [], n = [];
  let s = pa;
  for (let i = 0; i < vN; i++) {
    const r = Math.pow(2, s);
    e.push(r);
    let o = 1 / r;
    i > pa - Xl ? o = bN[i - pa + Xl - 1] : i == 0 && (o = 0), n.push(o);
    const a = 1 / (r - 1), c = -a / 2, l = 1 + a / 2, u = [c, c, l, c, l, l, c, c, l, l, c, l], h = 6, d = 6, f = 3, p = 2, y = 1, g = new Float32Array(f * d * h), m = new Float32Array(p * d * h), x = new Float32Array(y * d * h);
    for (let b = 0; b < h; b++) {
      const w = b % 3 * 2 / 3 - 1, S = b > 2 ? 0 : -1, _ = [
        w,
        S,
        0,
        w + 2 / 3,
        S,
        0,
        w + 2 / 3,
        S + 1,
        0,
        w,
        S,
        0,
        w + 2 / 3,
        S + 1,
        0,
        w,
        S + 1,
        0
      ];
      g.set(_, f * d * b), m.set(u, p * d * b);
      const E = [b, b, b, b, b, b];
      x.set(E, y * d * b);
    }
    const v = new et();
    v.setAttribute("position", new ut(g, f)), v.setAttribute("uv", new ut(m, p)), v.setAttribute("faceIndex", new ut(x, y)), t.push(v), s > Xl && s--;
  }
  return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
}
function b2(t) {
  const e = new Ji(3 * Or, 3 * Or, t);
  return e.texture.mapping = Df, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e;
}
function fg(t, e, n, s, i) {
  t.viewport.set(e, n, s, i), t.scissor.set(e, n, s, i);
}
function RV(t) {
  const e = new Float32Array(t), n = new P(0, 1, 0);
  return new Sa({
    name: "SphericalGaussianBlur",
    defines: { n: t },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: e },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: n },
      inputEncoding: { value: Gr[gi] },
      outputEncoding: { value: Gr[gi] }
    },
    vertexShader: U1(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${G1()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: ha,
    depthTest: !1,
    depthWrite: !1
  });
}
function v2() {
  const t = new Ce(1, 1);
  return new Sa({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null },
      texelSize: { value: t },
      inputEncoding: { value: Gr[gi] },
      outputEncoding: { value: Gr[gi] }
    },
    vertexShader: U1(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${G1()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: ha,
    depthTest: !1,
    depthWrite: !1
  });
}
function w2() {
  return new Sa({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      inputEncoding: { value: Gr[gi] },
      outputEncoding: { value: Gr[gi] }
    },
    vertexShader: U1(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${G1()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: ha,
    depthTest: !1,
    depthWrite: !1
  });
}
function U1() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function G1() {
  return (
    /* glsl */
    `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
  );
}
ht.create = function(t, e) {
  return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(ht.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t;
};
Object.assign(aa.prototype, {
  createPointsGeometry: function(t) {
    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    const e = this.getPoints(t);
    return this.createGeometry(e);
  },
  createSpacedPointsGeometry: function(t) {
    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    const e = this.getSpacedPoints(t);
    return this.createGeometry(e);
  },
  createGeometry: function(t) {
    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    const e = new xt();
    for (let n = 0, s = t.length; n < s; n++) {
      const i = t[n];
      e.vertices.push(new P(i.x, i.y, i.z || 0));
    }
    return e;
  }
});
Object.assign(Ur.prototype, {
  fromPoints: function(t) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t);
  }
});
Object.create(Oi.prototype);
Object.create(Oi.prototype);
function wN(t) {
  console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Oi.call(this, t), this.type = "catmullrom";
}
wN.prototype = Object.create(Oi.prototype);
Object.assign(wN.prototype, {
  initFromArray: function() {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  },
  getControlPointsArray: function() {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  },
  reparametrizeByArcLength: function() {
    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
  }
});
Ty.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
gu.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Object.assign(Xt.prototype, {
  extractUrlBase: function(t) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), oN.extractUrlBase(t);
  }
});
Xt.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
Object.assign(Tw.prototype, {
  setTexturePath: function(t) {
    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t);
  }
});
Object.assign(gN.prototype, {
  center: function(t) {
    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t);
  },
  empty: function() {
    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function(t) {
    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
  },
  size: function(t) {
    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t);
  }
});
Object.assign(co.prototype, {
  center: function(t) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
  },
  empty: function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function(t) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
  },
  isIntersectionSphere: function(t) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
  },
  size: function(t) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
  }
});
Object.assign(Bo.prototype, {
  empty: function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }
});
Of.prototype.setFromMatrix = function(t) {
  return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t);
};
yN.prototype.center = function(t) {
  return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t);
};
Object.assign(Et, {
  random16: function() {
    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random();
  },
  nearestPowerOfTwo: function(t) {
    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Et.floorPowerOfTwo(t);
  },
  nextPowerOfTwo: function(t) {
    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Et.ceilPowerOfTwo(t);
  }
});
Object.assign(Js.prototype, {
  flattenToArrayOffset: function(t, e) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
  },
  multiplyVector3: function(t) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  },
  applyToBufferAttribute: function(t) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }
});
Object.assign(Mt.prototype, {
  extractPosition: function(t) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t);
  },
  flattenToArrayOffset: function(t, e) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
  },
  getPosition: function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new P().setFromMatrixColumn(this, 3);
  },
  setRotationFromQuaternion: function(t) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t);
  },
  multiplyToArray: function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  },
  multiplyVector3: function(t) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  multiplyVector4: function(t) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  },
  rotateAxis: function(t) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this);
  },
  crossVector: function(t) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  translate: function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  },
  rotateX: function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  },
  rotateY: function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  },
  rotateZ: function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  },
  rotateByAxis: function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  },
  applyToBufferAttribute: function(t) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  },
  makeFrustum: function(t, e, n, s, i, r) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, s, n, i, r);
  }
});
Fr.prototype.isIntersectionLine = function(t) {
  return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t);
};
xs.prototype.multiplyVector3 = function(t) {
  return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this);
};
Object.assign($u.prototype, {
  isIntersectionBox: function(t) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
  },
  isIntersectionPlane: function(t) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t);
  },
  isIntersectionSphere: function(t) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
  }
});
Object.assign(Es.prototype, {
  area: function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
  },
  barycoordFromPoint: function(t, e) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e);
  },
  midpoint: function(t) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t);
  },
  normal: function(t) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t);
  },
  plane: function(t) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
  }
});
Object.assign(Es, {
  barycoordFromPoint: function(t, e, n, s, i) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Es.getBarycoord(t, e, n, s, i);
  },
  normal: function(t, e, n, s) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Es.getNormal(t, e, n, s);
  }
});
Object.assign(bc.prototype, {
  extractAllPoints: function(t) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t);
  },
  extrude: function(t) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ru(this, t);
  },
  makeGeometry: function(t) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new au(this, t);
  }
});
Object.assign(Ce.prototype, {
  fromAttribute: function(t, e, n) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
  },
  distanceToManhattan: function(t) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(P.prototype, {
  setEulerFromRotationMatrix: function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  },
  setEulerFromQuaternion: function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  },
  getPositionFromMatrix: function(t) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t);
  },
  getScaleFromMatrix: function(t) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t);
  },
  getColumnFromMatrix: function(t, e) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t);
  },
  applyProjection: function(t) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t);
  },
  fromAttribute: function(t, e, n) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
  },
  distanceToManhattan: function(t) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(en.prototype, {
  fromAttribute: function(t, e, n) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(xt.prototype, {
  computeTangents: function() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  },
  computeLineDistances: function() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  },
  applyMatrix: function(t) {
    return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
  }
});
Object.assign(qe.prototype, {
  getChildByName: function(t) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t);
  },
  renderDepth: function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  },
  translate: function(t, e) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t);
  },
  getWorldRotation: function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  },
  applyMatrix: function(t) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
  }
});
Object.defineProperties(qe.prototype, {
  eulerOrder: {
    get: function() {
      return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
    },
    set: function(t) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Object.assign(cn.prototype, {
  setDrawMode: function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  }
});
Object.defineProperties(cn.prototype, {
  drawMode: {
    get: function() {
      return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), yF;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
Object.defineProperties(Zg.prototype, {
  objects: {
    get: function() {
      return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
    }
  }
});
Object.defineProperty(ew.prototype, "useVertexTexture", {
  get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
});
Qv.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(ht.prototype, "__arcLengthDivisions", {
  get: function() {
    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions;
  },
  set: function(t) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t;
  }
});
Yn.prototype.setLens = function(t, e) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), e !== void 0 && (this.filmGauge = e), this.setFocalLength(t);
};
Object.defineProperties(Sn.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t;
    }
  },
  shadowCameraLeft: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t;
    }
  },
  shadowCameraRight: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t;
    }
  },
  shadowCameraTop: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t;
    }
  },
  shadowCameraBottom: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t;
    }
  },
  shadowCameraNear: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t;
    }
  },
  shadowCameraFar: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(t) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(t) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t;
    }
  },
  shadowMapHeight: {
    set: function(t) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t;
    }
  }
});
Object.defineProperties(ut.prototype, {
  length: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
    }
  },
  dynamic: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Nd;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Nd);
    }
  }
});
Object.assign(ut.prototype, {
  setDynamic: function(t) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t === !0 ? Nd : dx), this;
  },
  copyIndicesArray: function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  },
  setArray: function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }
});
Object.assign(et.prototype, {
  addIndex: function(t) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t);
  },
  addAttribute: function(t, e) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new ut(arguments[1], arguments[2]))) : t === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e);
  },
  addDrawCall: function(t, e, n) {
    n !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e);
  },
  clearDrawCalls: function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
  },
  computeTangents: function() {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  },
  computeOffsets: function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  },
  removeAttribute: function(t) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t);
  },
  applyMatrix: function(t) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
  }
});
Object.defineProperties(et.prototype, {
  drawcalls: {
    get: function() {
      return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
    }
  },
  offsets: {
    get: function() {
      return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
    }
  }
});
Object.defineProperties(Sy.prototype, {
  maxInstancedCount: {
    get: function() {
      return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount;
    },
    set: function(t) {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t;
    }
  }
});
Object.defineProperties(mN.prototype, {
  linePrecision: {
    get: function() {
      return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold;
    },
    set: function(t) {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t;
    }
  }
});
Object.defineProperties(Hi.prototype, {
  dynamic: {
    get: function() {
      return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === Nd;
    },
    set: function(t) {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t);
    }
  }
});
Object.assign(Hi.prototype, {
  setDynamic: function(t) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t === !0 ? Nd : dx), this;
  },
  setArray: function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }
});
Object.assign(No.prototype, {
  getArrays: function() {
    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
  },
  addShapeList: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
  },
  addShape: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
  }
});
Object.defineProperties(Iw.prototype, {
  dynamic: {
    set: function() {
      console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
    }
  },
  onUpdate: {
    value: function() {
      return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
    }
  }
});
Object.defineProperties(yt.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      return console.warn("THREE.Material: .wrapRGB has been removed."), new st();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(t) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === AE;
    }
  },
  stencilMask: {
    get: function() {
      return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
    },
    set: function(t) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t;
    }
  }
});
Object.defineProperties($c.prototype, {
  metal: {
    get: function() {
      return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1;
    },
    set: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
});
Object.defineProperties(Dc.prototype, {
  transparency: {
    get: function() {
      return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission;
    },
    set: function(t) {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = t;
    }
  }
});
Object.defineProperties(yi.prototype, {
  derivatives: {
    get: function() {
      return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
    },
    set: function(t) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t;
    }
  }
});
Object.assign(Lf.prototype, {
  clearTarget: function(t, e, n, s) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, s);
  },
  animate: function(t) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t);
  },
  getCurrentRenderTarget: function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
  },
  getMaxAnisotropy: function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
  },
  resetGLState: function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
  },
  supportsFloatTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
  },
  supportsHalfFloatTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
  },
  supportsStandardDerivatives: function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
  },
  supportsCompressedTextureS3TC: function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
  },
  supportsCompressedTexturePVRTC: function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
  },
  supportsBlendMinMax: function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
  },
  supportsVertexTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
  },
  enableScissorTest: function(t) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t);
  },
  initMaterial: function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  },
  addPrePlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  },
  addPostPlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  },
  updateShadowMap: function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  },
  setFaceCulling: function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  },
  allocTextureUnit: function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  },
  setTexture: function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  },
  setTexture2D: function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  },
  setTextureCube: function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  },
  getActiveMipMapLevel: function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
  }
});
Object.defineProperties(Lf.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
    }
  },
  vr: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
    }
  },
  gammaInput: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = t === !0 ? hx : gi;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(ZE.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(Ji.prototype, {
  wrapS: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t;
    }
  },
  wrapT: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t;
    }
  },
  magFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t;
    }
  },
  minFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t;
    }
  },
  anisotropy: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t;
    }
  },
  offset: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t;
    }
  },
  repeat: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t;
    }
  },
  format: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t;
    }
  },
  type: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t;
    }
  },
  generateMipmaps: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t;
    }
  }
});
Object.defineProperties(sf.prototype, {
  load: {
    value: function(t) {
      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
      const e = this;
      return new Cw().load(t, function(s) {
        e.setBuffer(s);
      }), this;
    }
  },
  startTime: {
    set: function() {
      console.warn("THREE.Audio: .startTime is now .play( delay ).");
    }
  }
});
hN.prototype.getData = function() {
  return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
};
Rd.prototype.updateCubeMap = function(t, e) {
  return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e);
};
Nc.crossOrigin = void 0;
Nc.loadTexture = function(t, e, n, s) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const i = new by();
  i.setCrossOrigin(this.crossOrigin);
  const r = i.load(t, n, void 0, s);
  return e && (r.mapping = e), r;
};
Nc.loadTextureCube = function(t, e, n, s) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const i = new dw();
  i.setCrossOrigin(this.crossOrigin);
  const r = i.load(t, n, void 0, s);
  return e && (r.mapping = e), r;
};
Nc.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
Nc.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: jO
} }));
const bo = function() {
  const [t, e] = arguments;
  /\/1\/601-tinified/.test(e) && console.log(...arguments);
}, Rs = {};
class DV extends Xt {
  constructor(e) {
    super(e);
  }
  load(e, n, s, i, r) {
    bo("load", e), e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = Zr.get(e);
    if (o !== void 0)
      return bo("cached", e), this.manager.itemStart(e), setTimeout(() => {
        n && n(o), this.manager.itemEnd(e);
      }, 0), o;
    if (Rs[e] !== void 0) {
      Rs[e].push({
        onLoad: n,
        onProgress: s,
        onError: i
      }), bo("return", e, Rs[e]);
      return;
    }
    Rs[e] = [], Rs[e].push({
      onLoad: n,
      onProgress: s,
      onError: i
    }), bo("push", e, Rs[e]);
    const a = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), c = this.mimeType, l = this.responseType;
    bo("started fetch", e), fetch(a, r).then((u) => {
      if (u.status === 200 || u.status === 0) {
        if (u.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || u.body === void 0 || u.body.getReader === void 0)
          return u;
        const h = Rs[e], d = u.body.getReader(), f = u.headers.get("Content-Length"), p = f ? parseInt(f) : 0, y = p !== 0;
        let g = 0;
        const m = new ReadableStream({
          start(x) {
            v();
            function v() {
              d.read().then(({ done: b, value: w }) => {
                if (b)
                  x.close();
                else {
                  g += w.byteLength;
                  const S = new ProgressEvent("progress", {
                    lengthComputable: y,
                    loaded: g,
                    total: p
                  });
                  for (let _ = 0, E = h.length; _ < E; _++) {
                    const I = h[_];
                    I.onProgress && I.onProgress(S);
                  }
                  x.enqueue(w), v();
                }
              }).catch((b) => {
                delete Rs[e];
              });
            }
          }
        });
        return new Response(m);
      } else
        throw Error(
          `fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`
        );
    }).then((u) => {
      switch (l) {
        case "arraybuffer":
          return u.arrayBuffer();
        case "blob":
          return u.blob();
        case "document":
          return u.text().then((h) => new DOMParser().parseFromString(h, c));
        case "json":
          return u.json();
        default:
          if (c === void 0)
            return u.text();
          {
            const d = /charset="?([^;"\s]*)"?/i.exec(c), f = d && d[1] ? d[1].toLowerCase() : void 0, p = new TextDecoder(f);
            return u.arrayBuffer().then((y) => p.decode(y));
          }
      }
    }).then((u) => {
      Zr.add(e, u);
      const h = Rs[e];
      bo("then delete", e, Rs[e]), delete Rs[e];
      for (let d = 0, f = h.length; d < f; d++) {
        const p = h[d];
        p.onLoad && p.onLoad(u);
      }
    }).catch((u) => {
      const h = Rs[e];
      if (bo("err delete", e, Rs[e]), delete Rs[e], h === void 0)
        throw this.manager.itemError(e), u;
      for (let d = 0, f = h.length; d < f; d++) {
        const p = h[d];
        p.onError && p.onError(u);
      }
      this.manager.itemError(e);
    }).finally(() => {
      bo("finally delete", e, Rs[e]), delete Rs[e], this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
const $V = function(t) {
  const e = Zr, { signal: n } = t;
  e.enabled = !0;
  const s = new by(), i = new DV();
  i.setResponseType("blob");
  function r(o, a, c, l, u = 1) {
    i.load(
      o,
      h,
      c,
      (p) => {
        console.error("loader err", p), l();
      },
      { signal: n }
    );
    function h(p) {
      if (bo("cache image called", o, p), p.tagName != "IMG") {
        const y = URL.createObjectURL(p), g = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "img"
        );
        g.onload = () => {
          e.add(o, g), URL.revokeObjectURL(y), document.body.removeChild(g), u == 1 ? d() : f(g);
        }, g.src = y, g.style.visibility = "hidden", document.body.appendChild(g);
      } else
        u == 1 ? d() : f(p);
    }
    function d() {
      s.load(o, a, () => {
      }, l);
    }
    function f(p) {
      const y = document.createElement("canvas"), g = y.getContext("2d");
      y.width = p.width, y.height = p.height, g.filter = `brightness(${u})`, g.drawImage(p, 0, 0, p.width, p.height);
      const m = new Fd(y);
      a(m), y.remove();
    }
  }
  return Object.assign({}, s, { load: r });
}, Aw = function() {
  this.logging = {
    enabled: !1,
    debug: !1
  };
  let t = this;
  this.callbacks = {
    onProgress: function(e) {
      t._onProgress(e);
    },
    onAssetAvailable: function(e) {
      t._onAssetAvailable(e);
    },
    onError: function(e) {
      t._onError(e);
    },
    onLoad: function(e, n) {
      t._onLoad(e, n);
    }
  }, this.contentRef = null, this.legacyMode = !1, this.materials = {}, this.materialPerSmoothingGroup = !1, this.useOAsMesh = !1, this.useIndices = !1, this.disregardNormals = !1, this.vertices = [], this.colors = [], this.normals = [], this.uvs = [], this.rawMesh = {
    objectName: "",
    groupName: "",
    activeMtlName: "",
    mtllibName: "",
    // reset with new mesh
    faceType: -1,
    subGroups: [],
    subGroupInUse: null,
    smoothingGroup: {
      splitMaterials: !1,
      normalized: -1,
      real: -1
    },
    counts: {
      doubleIndicesCount: 0,
      faceCount: 0,
      mtlCount: 0,
      smoothingGroupCount: 0
    }
  }, this.inputObjectCount = 1, this.outputObjectCount = 1, this.globalCounts = {
    vertices: 0,
    faces: 0,
    doubleIndicesCount: 0,
    lineByte: 0,
    currentByte: 0,
    totalBytes: 0
  };
};
Aw.prototype = {
  constructor: Aw,
  _resetRawMesh: function() {
    this.rawMesh.subGroups = [], this.rawMesh.subGroupInUse = null, this.rawMesh.smoothingGroup.normalized = -1, this.rawMesh.smoothingGroup.real = -1, this._pushSmoothingGroup(1), this.rawMesh.counts.doubleIndicesCount = 0, this.rawMesh.counts.faceCount = 0, this.rawMesh.counts.mtlCount = 0, this.rawMesh.counts.smoothingGroupCount = 0;
  },
  /**
   * Tells whether a material shall be created per smoothing group.
   *
   * @param {boolean} materialPerSmoothingGroup=false
   * @return {OBJLoader2Parser}
   */
  setMaterialPerSmoothingGroup: function(t) {
    return this.materialPerSmoothingGroup = t === !0, this;
  },
  /**
   * Usually 'o' is meta-information and does not result in creation of new meshes, but mesh creation on occurrence of "o" can be enforced.
   *
   * @param {boolean} useOAsMesh=false
   * @return {OBJLoader2Parser}
   */
  setUseOAsMesh: function(t) {
    return this.useOAsMesh = t === !0, this;
  },
  /**
   * Instructs loaders to create indexed {@link BufferGeometry}.
   *
   * @param {boolean} useIndices=false
   * @return {OBJLoader2Parser}
   */
  setUseIndices: function(t) {
    return this.useIndices = t === !0, this;
  },
  /**
   * Tells whether normals should be completely disregarded and regenerated.
   *
   * @param {boolean} disregardNormals=false
   * @return {OBJLoader2Parser}
   */
  setDisregardNormals: function(t) {
    return this.disregardNormals = t === !0, this;
  },
  /**
   * Clears materials object and sets the new ones.
   *
   * @param {Object} materials Object with named materials
   */
  setMaterials: function(t) {
    this.materials = Object.assign({}, t);
  },
  /**
   * Register a function that is called once an asset (mesh/material) becomes available.
   *
   * @param onAssetAvailable
   * @return {OBJLoader2Parser}
   */
  setCallbackOnAssetAvailable: function(t) {
    return t != null && t instanceof Function && (this.callbacks.onAssetAvailable = t), this;
  },
  /**
   * Register a function that is used to report overall processing progress.
   *
   * @param {Function} onProgress
   * @return {OBJLoader2Parser}
   */
  setCallbackOnProgress: function(t) {
    return t != null && t instanceof Function && (this.callbacks.onProgress = t), this;
  },
  /**
   * Register an error handler function that is called if errors occur. It can decide to just log or to throw an exception.
   *
   * @param {Function} onError
   * @return {OBJLoader2Parser}
   */
  setCallbackOnError: function(t) {
    return t != null && t instanceof Function && (this.callbacks.onError = t), this;
  },
  /**
   * Register a function that is called when parsing was completed.
   *
   * @param {Function} onLoad
   * @return {OBJLoader2Parser}
   */
  setCallbackOnLoad: function(t) {
    return t != null && t instanceof Function && (this.callbacks.onLoad = t), this;
  },
  /**
   * Announce parse progress feedback which is logged to the console.
   * @private
   *
   * @param {string} text Textual description of the event
   */
  _onProgress: function(t) {
    let e = t || "";
    this.logging.enabled && this.logging.debug && console.log(e);
  },
  /**
   * Announce error feedback which is logged as error message.
   * @private
   *
   * @param {String} errorMessage The event containing the error
   */
  _onError: function(t) {
    this.logging.enabled && this.logging.debug && console.error(t);
  },
  _onAssetAvailable: function(t) {
    let e = "OBJLoader2Parser does not provide implementation for onAssetAvailable. Aborting...";
    throw this.callbacks.onError(e), e;
  },
  _onLoad: function(t, e) {
    console.log("You reached parser default onLoad callback: " + e);
  },
  /**
   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.
   *
   * @param {boolean} enabled True or false.
   * @param {boolean} debug True or false.
   *
   * @return {OBJLoader2Parser}
   */
  setLogging: function(t, e) {
    return this.logging.enabled = t === !0, this.logging.debug = e === !0, this;
  },
  _configure: function() {
    if (this._pushSmoothingGroup(1), this.logging.enabled) {
      let t = Object.keys(this.materials), n = "OBJLoader.Parser configuration:" + (t.length > 0 ? `
	materialNames:
		- ` + t.join(`
		- `) : `
	materialNames: None`) + `
	materialPerSmoothingGroup: ` + this.materialPerSmoothingGroup + `
	useOAsMesh: ` + this.useOAsMesh + `
	useIndices: ` + this.useIndices + `
	disregardNormals: ` + this.disregardNormals;
      n += `
	callbacks.onProgress: ` + this.callbacks.onProgress.name, n += `
	callbacks.onAssetAvailable: ` + this.callbacks.onAssetAvailable.name, n += `
	callbacks.onError: ` + this.callbacks.onError.name, console.info(n);
    }
  },
  /**
   * Parse the provided arraybuffer
   *
   * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array
   */
  execute: function(t) {
    this.logging.enabled && console.time("OBJLoader2Parser.execute"), this._configure();
    let e = new Uint8Array(t);
    this.contentRef = e;
    let n = e.byteLength;
    this.globalCounts.totalBytes = n;
    let s = new Array(128), i = 0, r = 0, o = "", a = 0;
    for (let c, l = 0; l < n; l++)
      switch (c = e[l], c) {
        case 32:
          o.length > 0 && (s[i++] = o), o = "";
          break;
        case 47:
          o.length > 0 && (s[i++] = o), r++, o = "";
          break;
        case 10:
          this._processLine(s, i, r, o, l), o = "", i = 0, r = 0;
          break;
        case 13:
          break;
        default:
          o += String.fromCharCode(c);
          break;
      }
    this._processLine(s, i, r, o, a), this._finalizeParsing(), this.logging.enabled && console.timeEnd("OBJLoader2Parser.execute");
  },
  /**
   * Parse the provided text
   *
   * @param {string} text OBJ data as string
   */
  executeLegacy: function(t) {
    this.logging.enabled && console.time("OBJLoader2Parser.executeLegacy"), this._configure(), this.legacyMode = !0, this.contentRef = t;
    let e = t.length;
    this.globalCounts.totalBytes = e;
    let n = new Array(128), s = 0, i = 0, r = "", o = 0;
    for (let a; o < e; o++)
      switch (a = t[o], a) {
        case " ":
          r.length > 0 && (n[s++] = r), r = "";
          break;
        case "/":
          r.length > 0 && (n[s++] = r), i++, r = "";
          break;
        case `
`:
          this._processLine(n, s, i, r, o), r = "", s = 0, i = 0;
          break;
        case "\r":
          break;
        default:
          r += a;
      }
    this._processLine(n, s, r, i), this._finalizeParsing(), this.logging.enabled && console.timeEnd("OBJLoader2Parser.executeLegacy");
  },
  _processLine: function(t, e, n, s, i) {
    if (this.globalCounts.lineByte = this.globalCounts.currentByte, this.globalCounts.currentByte = i, e < 1)
      return;
    s.length > 0 && (t[e++] = s);
    let r = function(u, h, d, f) {
      let p = "";
      if (f > d) {
        let y;
        if (h)
          for (y = d; y < f; y++)
            p += u[y];
        else
          for (y = d; y < f; y++)
            p += String.fromCharCode(u[y]);
        p = p.trim();
      }
      return p;
    }, o, a, c, l;
    switch (l = t[0], l) {
      case "v":
        this.vertices.push(parseFloat(t[1])), this.vertices.push(parseFloat(t[2])), this.vertices.push(parseFloat(t[3])), e > 4 && (this.colors.push(parseFloat(t[4])), this.colors.push(parseFloat(t[5])), this.colors.push(parseFloat(t[6])));
        break;
      case "vt":
        this.uvs.push(parseFloat(t[1])), this.uvs.push(parseFloat(t[2]));
        break;
      case "vn":
        this.normals.push(parseFloat(t[1])), this.normals.push(parseFloat(t[2])), this.normals.push(parseFloat(t[3]));
        break;
      case "f":
        if (o = e - 1, n === 0)
          for (this._checkFaceType(0), c = 2, a = o; c < a; c++)
            this._buildFace(t[1]), this._buildFace(t[c]), this._buildFace(t[c + 1]);
        else if (o === n * 2)
          for (this._checkFaceType(1), c = 3, a = o - 2; c < a; c += 2)
            this._buildFace(t[1], t[2]), this._buildFace(t[c], t[c + 1]), this._buildFace(t[c + 2], t[c + 3]);
        else if (o * 2 === n * 3)
          for (this._checkFaceType(2), c = 4, a = o - 3; c < a; c += 3)
            this._buildFace(t[1], t[2], t[3]), this._buildFace(t[c], t[c + 1], t[c + 2]), this._buildFace(t[c + 3], t[c + 4], t[c + 5]);
        else
          for (this._checkFaceType(3), c = 3, a = o - 2; c < a; c += 2)
            this._buildFace(t[1], void 0, t[2]), this._buildFace(t[c], void 0, t[c + 1]), this._buildFace(t[c + 2], void 0, t[c + 3]);
        break;
      case "l":
      case "p":
        if (o = e - 1, o === n * 2)
          for (this._checkFaceType(4), c = 1, a = o + 1; c < a; c += 2)
            this._buildFace(t[c], t[c + 1]);
        else
          for (this._checkFaceType(l === "l" ? 5 : 6), c = 1, a = o + 1; c < a; c++)
            this._buildFace(t[c]);
        break;
      case "s":
        this._pushSmoothingGroup(t[1]);
        break;
      case "g":
        this._processCompletedMesh(), this.rawMesh.groupName = r(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);
        break;
      case "o":
        this.useOAsMesh && this._processCompletedMesh(), this.rawMesh.objectName = r(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);
        break;
      case "mtllib":
        this.rawMesh.mtllibName = r(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);
        break;
      case "usemtl":
        let u = r(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);
        u !== "" && this.rawMesh.activeMtlName !== u && (this.rawMesh.activeMtlName = u, this.rawMesh.counts.mtlCount++, this._checkSubGroup());
        break;
    }
  },
  _pushSmoothingGroup: function(t) {
    let e = parseInt(t);
    isNaN(e) && (e = t === "off" ? 0 : 1);
    let n = this.rawMesh.smoothingGroup.normalized;
    this.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? e : e === 0 ? 0 : 1, this.rawMesh.smoothingGroup.real = e, n !== e && (this.rawMesh.counts.smoothingGroupCount++, this._checkSubGroup());
  },
  /**
   * Expanded faceTypes include all four face types, both line types and the point type
   * faceType = 0: "f vertex ..."
   * faceType = 1: "f vertex/uv ..."
   * faceType = 2: "f vertex/uv/normal ..."
   * faceType = 3: "f vertex//normal ..."
   * faceType = 4: "l vertex/uv ..." or "l vertex ..."
   * faceType = 5: "l vertex ..."
   * faceType = 6: "p vertex ..."
   */
  _checkFaceType: function(t) {
    this.rawMesh.faceType !== t && (this._processCompletedMesh(), this.rawMesh.faceType = t, this._checkSubGroup());
  },
  _checkSubGroup: function() {
    let t = this.rawMesh.activeMtlName + "|" + this.rawMesh.smoothingGroup.normalized;
    this.rawMesh.subGroupInUse = this.rawMesh.subGroups[t], (this.rawMesh.subGroupInUse === void 0 || this.rawMesh.subGroupInUse === null) && (this.rawMesh.subGroupInUse = {
      index: t,
      objectName: this.rawMesh.objectName,
      groupName: this.rawMesh.groupName,
      materialName: this.rawMesh.activeMtlName,
      smoothingGroup: this.rawMesh.smoothingGroup.normalized,
      vertices: [],
      indexMappingsCount: 0,
      indexMappings: [],
      indices: [],
      colors: [],
      uvs: [],
      normals: []
    }, this.rawMesh.subGroups[t] = this.rawMesh.subGroupInUse);
  },
  _buildFace: function(t, e, n) {
    let s = this.rawMesh.subGroupInUse, i = this, r = function() {
      let o = parseInt(t), a = 3 * (o > 0 ? o - 1 : o + i.vertices.length / 3), c = i.colors.length > 0 ? a : null, l = s.vertices;
      if (l.push(i.vertices[a++]), l.push(i.vertices[a++]), l.push(i.vertices[a]), c !== null) {
        let u = s.colors;
        u.push(i.colors[c++]), u.push(i.colors[c++]), u.push(i.colors[c]);
      }
      if (e) {
        let u = parseInt(e), h = 2 * (u > 0 ? u - 1 : u + i.uvs.length / 2), d = s.uvs;
        d.push(i.uvs[h++]), d.push(i.uvs[h]);
      }
      if (n && !i.disregardNormals) {
        let u = parseInt(n), h = 3 * (u > 0 ? u - 1 : u + i.normals.length / 3), d = s.normals;
        d.push(i.normals[h++]), d.push(i.normals[h++]), d.push(i.normals[h]);
      }
    };
    if (this.useIndices) {
      this.disregardNormals && (n = void 0);
      let o = t + (e ? "_" + e : "_n") + (n ? "_" + n : "_n"), a = s.indexMappings[o];
      a == null ? (a = this.rawMesh.subGroupInUse.vertices.length / 3, r(), s.indexMappings[o] = a, s.indexMappingsCount++) : this.rawMesh.counts.doubleIndicesCount++, s.indices.push(a);
    } else
      r();
    this.rawMesh.counts.faceCount++;
  },
  _createRawMeshReport: function(t) {
    return "Input Object number: " + t + `
	Object name: ` + this.rawMesh.objectName + `
	Group name: ` + this.rawMesh.groupName + `
	Mtllib name: ` + this.rawMesh.mtllibName + `
	Vertex count: ` + this.vertices.length / 3 + `
	Normal count: ` + this.normals.length / 3 + `
	UV count: ` + this.uvs.length / 2 + `
	SmoothingGroup count: ` + this.rawMesh.counts.smoothingGroupCount + `
	Material count: ` + this.rawMesh.counts.mtlCount + `
	Real MeshOutputGroup count: ` + this.rawMesh.subGroups.length;
  },
  /**
   * Clear any empty subGroup and calculate absolute vertex, normal and uv counts
   */
  _finalizeRawMesh: function() {
    let t = [], e, n = 0, s = 0, i = 0, r = 0, o = 0, a = 0, c;
    for (let u in this.rawMesh.subGroups)
      if (e = this.rawMesh.subGroups[u], e.vertices.length > 0) {
        if (c = e.indices, c.length > 0 && s > 0)
          for (let h = 0; h < c.length; h++)
            c[h] = c[h] + s;
        t.push(e), n += e.vertices.length, s += e.indexMappingsCount, i += e.indices.length, r += e.colors.length, a += e.uvs.length, o += e.normals.length;
      }
    let l = null;
    return t.length > 0 && (l = {
      name: this.rawMesh.groupName !== "" ? this.rawMesh.groupName : this.rawMesh.objectName,
      subGroups: t,
      absoluteVertexCount: n,
      absoluteIndexCount: i,
      absoluteColorCount: r,
      absoluteNormalCount: o,
      absoluteUvCount: a,
      faceCount: this.rawMesh.counts.faceCount,
      doubleIndicesCount: this.rawMesh.counts.doubleIndicesCount
    }), l;
  },
  _processCompletedMesh: function() {
    let t = this._finalizeRawMesh(), e = t !== null;
    if (e) {
      this.colors.length > 0 && this.colors.length !== this.vertices.length && this.callbacks.onError("Vertex Colors were detected, but vertex count and color count do not match!"), this.logging.enabled && this.logging.debug && console.debug(this._createRawMeshReport(this.inputObjectCount)), this.inputObjectCount++, this._buildMesh(t);
      let n = this.globalCounts.currentByte / this.globalCounts.totalBytes;
      this._onProgress("Completed [o: " + this.rawMesh.objectName + " g:" + this.rawMesh.groupName + "] Total progress: " + (n * 100).toFixed(2) + "%"), this._resetRawMesh();
    }
    return e;
  },
  /**
   * SubGroups are transformed to too intermediate format that is forwarded to the MeshReceiver.
   * It is ensured that SubGroups only contain objects with vertices (no need to check).
   *
   * @param result
   */
  _buildMesh: function(t) {
    let e = t.subGroups, n = new Float32Array(t.absoluteVertexCount);
    this.globalCounts.vertices += t.absoluteVertexCount / 3, this.globalCounts.faces += t.faceCount, this.globalCounts.doubleIndicesCount += t.doubleIndicesCount;
    let s = t.absoluteIndexCount > 0 ? new Uint32Array(t.absoluteIndexCount) : null, i = t.absoluteColorCount > 0 ? new Float32Array(t.absoluteColorCount) : null, r = t.absoluteNormalCount > 0 ? new Float32Array(t.absoluteNormalCount) : null, o = t.absoluteUvCount > 0 ? new Float32Array(t.absoluteUvCount) : null, a = i !== null, c, l = [], u = e.length > 1, h = 0, d = [], f, p, y = [], g = 0, m = 0, x = 0, v = 0, b = 0, w = 0, S = 0, _, E, I, k;
    for (let M in e)
      if (e.hasOwnProperty(M)) {
        if (c = e[M], k = c.materialName, this.rawMesh.faceType < 4 ? I = k + (a ? "_vertexColor" : "") + (c.smoothingGroup === 0 ? "_flat" : "") : I = this.rawMesh.faceType === 6 ? "defaultPointMaterial" : "defaultLineMaterial", _ = this.materials[k], E = this.materials[I], _ == null && E == null && (I = a ? "defaultVertexColorMaterial" : "defaultMaterial", E = this.materials[I], this.logging.enabled && console.info('object_group "' + c.objectName + "_" + c.groupName + '" was defined with unresolvable material "' + k + '"! Assigning "' + I + '".')), E == null) {
          let L = {
            materialNameOrg: k,
            materialName: I,
            materialProperties: {
              vertexColors: a ? 2 : 0,
              flatShading: c.smoothingGroup === 0
            }
          }, O = {
            cmd: "assetAvailable",
            type: "material",
            materials: {
              materialCloneInstructions: L
            }
          };
          this.callbacks.onAssetAvailable(O);
          let $ = this.materials[I];
          $ == null && (this.materials[I] = L);
        }
        if (u ? (f = d[I], f || (f = h, d[I] = h, l.push(I), h++), S = this.useIndices ? c.indices.length : c.vertices.length / 3, p = {
          start: w,
          count: S,
          index: f
        }, y.push(p), w += S) : l.push(I), n.set(c.vertices, g), g += c.vertices.length, s && (s.set(c.indices, m), m += c.indices.length), i && (i.set(c.colors, x), x += c.colors.length), r && (r.set(c.normals, v), v += c.normals.length), o && (o.set(c.uvs, b), b += c.uvs.length), this.logging.enabled && this.logging.debug) {
          let L = "";
          f && (L = `
		materialIndex: ` + f);
          let O = "	Output Object no.: " + this.outputObjectCount + `
		groupName: ` + c.groupName + `
		Index: ` + c.index + `
		faceType: ` + this.rawMesh.faceType + `
		materialName: ` + c.materialName + `
		smoothingGroup: ` + c.smoothingGroup + L + `
		objectName: ` + c.objectName + `
		#vertices: ` + c.vertices.length / 3 + `
		#indices: ` + c.indices.length + `
		#colors: ` + c.colors.length / 3 + `
		#uvs: ` + c.uvs.length / 2 + `
		#normals: ` + c.normals.length / 3;
          console.debug(O);
        }
      }
    this.outputObjectCount++, this.callbacks.onAssetAvailable(
      {
        cmd: "assetAvailable",
        type: "mesh",
        progress: {
          numericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes
        },
        params: {
          meshName: t.name
        },
        materials: {
          multiMaterial: u,
          materialNames: l,
          materialGroups: y
        },
        buffers: {
          vertices: n,
          indices: s,
          colors: i,
          normals: r,
          uvs: o
        },
        // 0: mesh, 1: line, 2: point
        geometryType: this.rawMesh.faceType < 4 ? 0 : this.rawMesh.faceType === 6 ? 2 : 1
      },
      [n.buffer],
      s !== null ? [s.buffer] : null,
      i !== null ? [i.buffer] : null,
      r !== null ? [r.buffer] : null,
      o !== null ? [o.buffer] : null
    );
  },
  _finalizeParsing: function() {
    if (this.logging.enabled && console.info("Global output object count: " + this.outputObjectCount), this._processCompletedMesh() && this.logging.enabled) {
      let t = `Overall counts: 
	Vertices: ` + this.globalCounts.vertices + `
	Faces: ` + this.globalCounts.faces + `
	Multiple definitions: ` + this.globalCounts.doubleIndicesCount;
      console.info(t);
    }
  }
};
const Mw = function(t) {
  this.logging = {
    enabled: !1,
    debug: !1
  }, this.callbacks = {
    onProgress: null,
    onMeshAlter: null
  }, this.materialHandler = t;
};
Mw.prototype = {
  constructor: Mw,
  /**
   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.
   *
   * @param {boolean} enabled True or false.
   * @param {boolean} debug True or false.
   */
  setLogging: function(t, e) {
    this.logging.enabled = t === !0, this.logging.debug = e === !0;
  },
  /**
   *
   * @param {Function} onProgress
   * @param {Function} onMeshAlter
   * @private
   */
  _setCallbacks: function(t, e) {
    t != null && t instanceof Function && (this.callbacks.onProgress = t), e != null && e instanceof Function && (this.callbacks.onMeshAlter = e);
  },
  /**
   * Builds one or multiple meshes from the data described in the payload (buffers, params, material info).
   *
   * @param {Object} meshPayload Raw mesh description (buffers, params, materials) used to build one to many meshes.
   * @returns {Mesh[]} mesh Array of {@link Mesh}
   */
  buildMeshes: function(t) {
    let e = t.params.meshName, n = t.buffers, s = new et();
    n.vertices !== void 0 && n.vertices !== null && s.setAttribute("position", new ut(new Float32Array(n.vertices), 3)), n.indices !== void 0 && n.indices !== null && s.setIndex(new ut(new Uint32Array(n.indices), 1)), n.colors !== void 0 && n.colors !== null && s.setAttribute("color", new ut(new Float32Array(n.colors), 3)), n.normals !== void 0 && n.normals !== null ? s.setAttribute("normal", new ut(new Float32Array(n.normals), 3)) : s.computeVertexNormals(), n.uvs !== void 0 && n.uvs !== null && s.setAttribute("uv", new ut(new Float32Array(n.uvs), 2)), n.skinIndex !== void 0 && n.skinIndex !== null && s.setAttribute("skinIndex", new ut(new Uint16Array(n.skinIndex), 4)), n.skinWeight !== void 0 && n.skinWeight !== null && s.setAttribute("skinWeight", new ut(new Float32Array(n.skinWeight), 4));
    let i, r, o, a = t.materials.materialNames, c = t.materials.multiMaterial, l = [];
    for (o in a)
      r = a[o], i = this.materialHandler.getMaterial(r), c && l.push(i);
    if (c) {
      i = l;
      let g = t.materials.materialGroups, m;
      for (o in g)
        m = g[o], s.addGroup(m.start, m.count, m.index);
    }
    let u = [], h, d, f = !0, p = t.geometryType === null ? 0 : t.geometryType;
    if (this.callbacks.onMeshAlter && (d = this.callbacks.onMeshAlter(
      {
        detail: {
          meshName: e,
          bufferGeometry: s,
          material: i,
          geometryType: p
        }
      }
    )), d) {
      if (d.isDisregardMesh())
        f = !1;
      else if (d.providesAlteredMeshes()) {
        for (let g in d.meshes)
          u.push(d.meshes[g]);
        f = !1;
      }
    }
    f && (t.computeBoundingSphere && s.computeBoundingSphere(), p === 0 ? h = new cn(s, i) : p === 1 ? h = new ns(s, i) : h = new Jg(s, i), h.name = e, u.push(h));
    let y = t.params.meshName;
    if (u.length > 0) {
      let g = [];
      for (let m in u)
        h = u[m], g[m] = h.name;
      y += ": Adding mesh(es) (" + g.length + ": " + g + ") from input mesh: " + e, y += " (" + (t.progress.numericalValue * 100).toFixed(2) + "%)";
    } else
      y += ": Not adding mesh: " + e, y += " (" + (t.progress.numericalValue * 100).toFixed(2) + "%)";
    return this.callbacks.onProgress && this.callbacks.onProgress("progress", y, t.progress.numericalValue), u;
  }
};
const S2 = function(t, e) {
  this.disregardMesh = t === !0, this.alteredMesh = e === !0, this.meshes = [];
};
S2.prototype = {
  constructor: S2,
  /**
   * Add a mesh created within callback.
   *
   * @param {Mesh} mesh
   */
  addMesh: function(t) {
    this.meshes.push(t), this.alteredMesh = !0;
  },
  /**
   * Answers if mesh shall be disregarded completely.
   *
   * @returns {boolean}
   */
  isDisregardMesh: function() {
    return this.disregardMesh;
  },
  /**
   * Answers if new mesh(es) were created.
   *
   * @returns {boolean}
   */
  providesAlteredMeshes: function() {
    return this.alteredMesh;
  }
};
const Rw = function() {
  this.logging = {
    enabled: !1,
    debug: !1
  }, this.callbacks = {
    onLoadMaterials: null
  }, this.materials = {};
};
Rw.prototype = {
  constructor: Rw,
  /**
   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.
   *
   * @param {boolean} enabled True or false.
   * @param {boolean} debug True or false.
   */
  setLogging: function(t, e) {
    this.logging.enabled = t === !0, this.logging.debug = e === !0;
  },
  _setCallbacks: function(t) {
    t != null && t instanceof Function && (this.callbacks.onLoadMaterials = t);
  },
  /**
   * Creates default materials and adds them to the materials object.
   *
   * @param overrideExisting boolean Override existing material
   */
  createDefaultMaterials: function(t) {
    let e = new wr({ color: 14479871 });
    e.name = "defaultMaterial";
    let n = new wr({ color: 14479871 });
    n.name = "defaultVertexColorMaterial", n.vertexColors = !0;
    let s = new Bn();
    s.name = "defaultLineMaterial";
    let i = new ba({ size: 0.1 });
    i.name = "defaultPointMaterial";
    let r = {};
    r[e.name] = e, r[n.name] = n, r[s.name] = s, r[i.name] = i, this.addMaterials(r, t);
  },
  /**
   * Updates the materials with contained material objects (sync) or from alteration instructions (async).
   *
   * @param {Object} materialPayload Material update instructions
   * @returns {Object} Map of {@link Material}
   */
  addPayloadMaterials: function(t) {
    let e, n, s = t.materials.materialCloneInstructions, i = {};
    if (s != null) {
      let o = s.materialNameOrg;
      o = o ?? "";
      let a = this.materials[o];
      a ? (e = a.clone(), n = s.materialName, e.name = n, Object.assign(e, s.materialProperties), this.materials[n] = e, i[n] = e) : this.logging.enabled && console.info('Requested material "' + o + '" is not available!');
    }
    let r = t.materials.serializedMaterials;
    if (r != null && Object.keys(r).length > 0) {
      let o = new wy(), a;
      for (n in r)
        a = r[n], a != null && (e = o.parse(a), this.logging.enabled && console.info('De-serialized material with name "' + n + '" will be added.'), this.materials[n] = e, i[n] = e);
    }
    return r = t.materials.runtimeMaterials, i = this.addMaterials(r, !0, i), i;
  },
  /**
   * Set materials loaded by any supplier of an Array of {@link Material}.
   *
   * @param materials Object with named {@link Material}
   * @param overrideExisting boolean Override existing material
   * @param newMaterials [Object] with named {@link Material}
   */
  addMaterials: function(t, e, n) {
    if (n == null && (n = {}), t != null && Object.keys(t).length > 0) {
      let s, i, r;
      for (let o in t)
        s = t[o], r = e === !0, r || (i = this.materials[o], r = i == null), r && (this.materials[o] = s, n[o] = s), this.logging.enabled && this.logging.debug && console.info('Material with name "' + o + '" was added.');
    }
    return this.callbacks.onLoadMaterials && this.callbacks.onLoadMaterials(n), n;
  },
  /**
   * Returns the mapping object of material name and corresponding material.
   *
   * @returns {Object} Map of {@link Material}
   */
  getMaterials: function() {
    return this.materials;
  },
  /**
   *
   * @param {String} materialName
   * @returns {Material}
   */
  getMaterial: function(t) {
    return this.materials[t];
  },
  /**
   * Returns the mapping object of material name and corresponding jsonified material.
   *
   * @returns {Object} Map of Materials in JSON representation
   */
  getMaterialsJSON: function() {
    let t = {}, e;
    for (let n in this.materials)
      e = this.materials[n], t[n] = e.toJSON();
    return t;
  },
  /**
   * Removes all materials
   */
  clearMaterials: function() {
    this.materials = {};
  }
};
const lf = function(t) {
  Xt.call(this, t), this.parser = new Aw(), this.modelName = "", this.instanceNo = 0, this.baseObject3d = new qe(), this.materialHandler = new Rw(), this.meshReceiver = new Mw(this.materialHandler);
  let e = this, n = function(s) {
    e._onAssetAvailable(s);
  };
  this.parser.setCallbackOnAssetAvailable(n);
};
lf.OBJLOADER2_VERSION = "3.2.0";
console.info("Using OBJLoader2 version: " + lf.OBJLOADER2_VERSION);
lf.prototype = Object.assign(Object.create(Xt.prototype), {
  constructor: lf,
  /**
   * See {@link OBJLoader2Parser.setLogging}
   * @return {OBJLoader2}
   */
  setLogging: function(t, e) {
    return this.parser.setLogging(t, e), this;
  },
  /**
   * See {@link OBJLoader2Parser.setMaterialPerSmoothingGroup}
   * @return {OBJLoader2}
   */
  setMaterialPerSmoothingGroup: function(t) {
    return this.parser.setMaterialPerSmoothingGroup(t), this;
  },
  /**
   * See {@link OBJLoader2Parser.setUseOAsMesh}
   * @return {OBJLoader2}
   */
  setUseOAsMesh: function(t) {
    return this.parser.setUseOAsMesh(t), this;
  },
  /**
   * See {@link OBJLoader2Parser.setUseIndices}
   * @return {OBJLoader2}
   */
  setUseIndices: function(t) {
    return this.parser.setUseIndices(t), this;
  },
  /**
   * See {@link OBJLoader2Parser.setDisregardNormals}
   * @return {OBJLoader2}
   */
  setDisregardNormals: function(t) {
    return this.parser.setDisregardNormals(t), this;
  },
  /**
   * Set the name of the model.
   *
   * @param {string} modelName
   * @return {OBJLoader2}
   */
  setModelName: function(t) {
    return this.modelName = t || this.modelName, this;
  },
  /**
   * Set the node where the loaded objects will be attached directly.
   *
   * @param {Object3D} baseObject3d Object already attached to scenegraph where new meshes will be attached to
   * @return {OBJLoader2}
   */
  setBaseObject3d: function(t) {
    return this.baseObject3d = t ?? this.baseObject3d, this;
  },
  /**
   * Add materials as associated array.
   *
   * @param {Object} materials Object with named {@link Material}
   * @param overrideExisting boolean Override existing material
   * @return {OBJLoader2}
   */
  addMaterials: function(t, e) {
    return this.materialHandler.addMaterials(t, e), this;
  },
  /**
   * See {@link OBJLoader2Parser.setCallbackOnAssetAvailable}
   * @return {OBJLoader2}
   */
  setCallbackOnAssetAvailable: function(t) {
    return this.parser.setCallbackOnAssetAvailable(t), this;
  },
  /**
   * See {@link OBJLoader2Parser.setCallbackOnProgress}
   * @return {OBJLoader2}
   */
  setCallbackOnProgress: function(t) {
    return this.parser.setCallbackOnProgress(t), this;
  },
  /**
   * See {@link OBJLoader2Parser.setCallbackOnError}
   * @return {OBJLoader2}
   */
  setCallbackOnError: function(t) {
    return this.parser.setCallbackOnError(t), this;
  },
  /**
   * See {@link OBJLoader2Parser.setCallbackOnLoad}
   * @return {OBJLoader2}
   */
  setCallbackOnLoad: function(t) {
    return this.parser.setCallbackOnLoad(t), this;
  },
  /**
   * Register a function that is called once a single mesh is available and it could be altered by the supplied function.
   *
   * @param {Function} [onMeshAlter]
   * @return {OBJLoader2}
   */
  setCallbackOnMeshAlter: function(t) {
    return this.meshReceiver._setCallbacks(this.parser.callbacks.onProgress, t), this;
  },
  /**
   * Register a function that is called once all materials have been loaded and they could be altered by the supplied function.
   *
   * @param {Function} [onLoadMaterials]
   * @return {OBJLoader2}
   */
  setCallbackOnLoadMaterials: function(t) {
    return this.materialHandler._setCallbacks(t), this;
  },
  /**
   * Use this convenient method to load a file at the given URL. By default the fileLoader uses an ArrayBuffer.
   *
   * @param {string}  url A string containing the path/URL of the file to be loaded.
   * @param {function} onLoad A function to be called after loading is successfully completed. The function receives loaded Object3D as an argument.
   * @param {function} [onFileLoadProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.
   * @param {function} [onError] A function to be called if an error occurs during loading. The function receives the error as an argument.
   * @param {function} [onMeshAlter] Called after every single mesh is made available by the parser
   */
  load: function(t, e, n, s, i) {
    let r = this;
    if (e == null || !(e instanceof Function)) {
      let h = "onLoad is not a function! Aborting...";
      throw r.parser.callbacks.onError(h), h;
    } else
      this.parser.setCallbackOnLoad(e);
    (s == null || !(s instanceof Function)) && (s = function(h) {
      let d = h;
      h.currentTarget && h.currentTarget.statusText !== null && (d = `Error occurred while downloading!
url: ` + h.currentTarget.responseURL + `
status: ` + h.currentTarget.statusText), r.parser.callbacks.onError(d);
    }), t || s("An invalid url was provided. Unable to continue!");
    let o = new URL(t, window.location.href).href, a = o, c = o.split("/");
    if (c.length > 2 && (a = c[c.length - 1], this.path = c.slice(0, c.length - 1).join("/") + "/"), n == null || !(n instanceof Function)) {
      let h = 0, d = 0;
      n = function(f) {
        if (f.lengthComputable && (d = f.loaded / f.total, d > h)) {
          h = d;
          let p = 'Download of "' + t + '": ' + (d * 100).toFixed(2) + "%";
          r.parser.callbacks.onProgress("progressLoad", p, d);
        }
      };
    }
    this.setCallbackOnMeshAlter(i);
    let l = function(h) {
      r.parser.callbacks.onLoad(r.parse(h), "OBJLoader2#load: Parsing completed");
    }, u = new Sr(this.manager);
    u.setPath(this.path || this.resourcePath), u.setResponseType("arraybuffer"), u.load(a, l, n, s);
  },
  /**
   * Parses OBJ data synchronously from arraybuffer or string and returns the {@link Object3D}.
   *
   * @param {arraybuffer|string} content OBJ data as Uint8Array or String
   * @return {Object3D}
   */
  parse: function(t) {
    if (t == null)
      throw "Provided content is not a valid ArrayBuffer or String. Unable to continue parsing";
    return this.parser.logging.enabled && console.time("OBJLoader parse: " + this.modelName), this.materialHandler.createDefaultMaterials(!1), this.parser.setMaterials(this.materialHandler.getMaterials()), t instanceof ArrayBuffer || t instanceof Uint8Array ? (this.parser.logging.enabled && console.info("Parsing arrayBuffer..."), this.parser.execute(t)) : typeof t == "string" || t instanceof String ? (this.parser.logging.enabled && console.info("Parsing text..."), this.parser.executeLegacy(t)) : this.parser.callbacks.onError("Provided content was neither of type String nor Uint8Array! Aborting..."), this.parser.logging.enabled && console.timeEnd("OBJLoader parse: " + this.modelName), this.baseObject3d;
  },
  _onAssetAvailable: function(t) {
    if (t.cmd === "assetAvailable")
      if (t.type === "mesh") {
        let e = this.meshReceiver.buildMeshes(t);
        for (let n of e)
          this.baseObject3d.add(n);
      } else
        t.type === "material" && this.materialHandler.addPayloadMaterials(t);
  }
});
const OV = function() {
  let t = {};
  const e = function(n) {
    delete t[n];
  };
  this.add = function(n) {
    const s = performance.now() + "";
    return t[s] = n, n.then(() => e(s)), n;
  }, this.done = function(n) {
    Promise.all(Object.values(t)).then(() => {
      n();
    });
  };
}, Lr = (t, e = {}, n = "") => {
  const s = document.createElement(t);
  for (let i in e)
    s.setAttribute(i, e[i]);
  return s.innerHTML = n, s;
}, LV = (t, e) => (document.getElementById(t) || document.getElementsByTagName("head")[0].prepend(Lr("STYLE", { type: "text/css" }, e)), !0), Ds = function(t) {
  let e = t, n = [];
  return function(i, r = {}) {
    return arguments.length > 0 ? typeof i == "function" ? (r.prepend ? n.unshift(i) : n.push(i), r.dontCallOnRegistration || i(e), () => {
      const o = n.indexOf(i);
      o !== -1 && n.splice(o, 1);
    }) : (e !== i && JSON.stringify(e) !== JSON.stringify(i) && (e = i, n.forEach((o) => o(e))), e) : e;
  };
}, FV = function(t, e = {}) {
  LV("geocam-viewer", `
    .geocam-viewer {
      position: relative;
      z-index: 1;
    }

    .geocam-viewer-hidden {
      display: none;
    }

    .geocam-viewer-control {
      pointer-events: auto;
    }

    .geocam-viewer-control-button {
      background-color: rgba(255,255,255,0.5);
      border-radius: 4px;
      border: 1px solid #666;
      color: rgba(0,0,0,0);
      width: 32px;
      height: 32px;
      display: block;
      background-size: cover;
      background-position: center;
      cursor: pointer;
    }

    .geocam-viewer-controls {
        position: absolute;
        pointer-events: none;
        display: flex;
        left: 16px;
        top: 16px;
        right: 16px;
        bottom: 16px;
        --gap: 16px;
    }

    .geocam-viewer-controls-left, .geocam-viewer-controls-right {
      display: flex;
      flex-justify: space-between;
      flex-direction: column;
    }

    .geocam-viewer-controls-left-top, .geocam-viewer-controls-right-top {
      display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: var(--gap);
        row-gap: 8px;
    }

    .geocam-viewer-controls-left-bottom,   .geocam-viewer-controls-right-bottom {
      display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: var(--gap);
        row-gap: 8px;
    }

    .geocam-viewer-controls-center {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .geocam-viewer-controls-top,  .geocam-viewer-controls-bottom {
      display: flex;
      justify-content: center;
      gap: var(--gap);
    } 

    .geocam-viewer-controls-mid {
      flex: 1;
    }
  `);
  const s = 0.5, i = {
    aspect: 2,
    // standard defaults if not overridden by rigConfig
    near: 0.1,
    fov: 35,
    far: 100,
    scale: 1,
    xOffset: 0,
    yOffset: 0,
    rotationOffsets: [0, 0, 0],
    hemispheres: [
      () => D(0),
      () => D(1),
      () => D(2)
    ]
  }, r = e.plugins, o = new OV(), a = {
    shot: Ds(),
    capture: Ds(),
    fov: Ds(),
    yaw: Ds(0),
    rotation: Ds([]),
    brightness: Ds([]),
    facing: Ds(0),
    horizon: Ds(0),
    urls: Ds([]),
    visible: Ds(!1),
    hemispheres: Ds([])
  }, c = [Ds(1), Ds(1), Ds(1)], l = Ds(window.performance.now());
  let u = !1, h, d, f, p, y = 0, g = 0, m = 0, x = 0, v = [null, null, null], b = null, w = !1, S, _, E = [], I, k, M, L = JSON.stringify([]), O = JSON.stringify([]);
  const $ = function(X) {
    return (270 - X) * (Math.PI / 180);
  }, D = function(X) {
    const pe = new Xd(
      12,
      32,
      32,
      0,
      2 * Math.PI,
      Math.PI / 3 * X,
      Math.PI / 3
    ), Oe = new er({}), Ie = new cn(pe, Oe);
    return Ie.material.side = is, Ie;
  }, z = function() {
    p.style.top = y + "px", p.style.left = g + "px", p.style.width = m + "px", p.style.height = x + "px";
  }, W = function(X, pe = !1) {
    const Oe = X.domElement, Ie = p.parentNode.clientWidth, Be = p.parentNode.clientHeight, Ue = pe || Math.abs(Oe.clientWidth - Ie) > 1 || Math.abs(Oe.clientHeight - Be) > 1;
    if (Ue) {
      console.log("Resizing canvas:", { displayWidth: Ie, displayHeight: Be }), p.style.width = Ie + "px", p.style.height = Be + "px", X.setSize(Ie, Be, !0);
      const Ke = X.domElement;
      d.aspect = Ke.clientWidth / Ke.clientHeight, w = !0, console.log("Canvas after resize:", {
        clientWidth: Ke.clientWidth,
        clientHeight: Ke.clientHeight,
        width: Ke.width,
        height: Ke.height
      });
    }
    return Ue;
  }, j = (X) => {
    if (!Ge)
      return;
    W(F);
    const pe = a.horizon(), Oe = a.facing();
    a.facing((360 + Oe) % 360), a.horizon(Math.max(-85, Math.min(85, pe)));
    const Ie = (90 - pe) * (Math.PI / 180), Be = Oe * (Math.PI / 180), Ue = 10;
    {
      const Ke = Ue * Math.sin(Ie) * Math.sin(Be), wt = -Ue * Math.cos(Ie), Yt = Ue * Math.sin(Ie) * Math.cos(Be);
      d.up.set(0, 0, 1), d.lookAt(Ke, Yt, wt);
    }
    w && (d.updateProjectionMatrix(), w = !1), F.render(V, d), S = requestAnimationFrame((Ke) => j());
  }, J = function(X) {
    return new Promise((pe, Oe) => {
      typeof X == "function" ? pe(X()) : new lf().load(X, (Be) => {
        Be.traverse(function(Ue) {
          Ue instanceof cn && (Ue.material.side = 2, Ue.material.flatShading = !0, Ue.material.transparent = !0, Ue.rotation.set(0, 0, 0), pe(Ue));
        });
      });
    });
  }, ne = function(X) {
    return console.log("loadMeshes"), o.add(
      new Promise((pe, Oe) => {
        let Ie = v.length;
        X.forEach((Be, Ue) => {
          J(Be).then((Ke) => {
            v[Ue] = Ke, Ie -= 1, Ie <= 0 && pe();
          });
        });
      })
    );
  }, re = function() {
    v.forEach((X, pe) => X ? b.remove(X) : null), V.remove(b), F.renderLists.dispose(), v = [null, null, null], b = null;
  }, fe = function() {
    I && (I(), I = null);
  }, ae = function() {
    M && (M(), M = null);
  }, ve = function(X, ...pe) {
    return Object.assign(X, ...pe);
  }, me = async function(X) {
    let pe;
    X && X.length > 0 && L !== (pe = JSON.stringify(X)) && (L = pe, fe(), b && re(), await ne(X), b = new oa(), v.forEach((Oe, Ie) => {
      b.add(Oe), Oe.name = `${Ie}`;
    }), V.add(b), I = a.urls((Oe) => {
      const Ie = JSON.stringify(Oe);
      Ie !== O && Oe.length > 0 && (O = Ie, xe(Oe, a.brightness()));
    }));
  }, te = async function(X = {}) {
    ae(), re(), f = ve(i, X);
    const pe = a.fov() || f.fov;
    return a.fov(pe), d = new Yn(
      pe,
      f.aspect,
      f.near,
      f.far
    ), M = a.hemispheres(me), W(F, !0), this;
  }, $e = function() {
    v.forEach((X, pe) => {
      X && X.material && (X.material.opacity = s);
    }), c.forEach((X) => X(0));
  }, _e = function(X, pe, Oe, Ie, Be, Ue) {
    X.material.opacity = s;
    const Ke = parseInt(X.name);
    c[Ke](0), new $V(_).load(
      pe,
      (wt) => {
        window.tex = wt, X.material.map = wt, window.mat = X.material, X.material.opacity = 1, wt.repeat.set(f.scale, f.scale), wt.offset.set(f.yOffset, f.xOffset), wt.rotation = f.rotationOffsets[Ke], X.material.needsUpdate = !0, c[Ke](1), Oe && Oe(X, pe);
      },
      (wt) => {
        const Yt = wt.loaded / wt.total;
        Ie && Ie(X, pe, Yt);
      },
      (wt) => {
        Be ? Be(X, pe, wt) : console.error("error loading image", wt, Ke, pe);
      },
      Ue
    );
  }, ke = function(X, pe, Oe, Ie, Be) {
    const Ue = function(wt, Yt, St, Mr) {
      const fo = parseInt(wt.name);
      let ar = Yt.length - St;
      const zi = Yt[St];
      _e(
        wt,
        zi,
        () => {
          c[fo]((St + 1) / Yt.length), Ie && ar == Yt.length && Ie(wt, zi), Oe && ar <= 1 && Oe(wt, zi), St += 1, St < Yt.length && Ue(wt, Yt, St);
        },
        (ja, po, on) => {
          c[fo]((St + on) / Yt.length);
        },
        null,
        1
      );
    }, Ke = parseInt(X.name);
    if (Array.isArray(pe))
      Ue(X, pe, 0);
    else {
      const wt = pe;
      _e(
        X,
        wt,
        () => {
          c[Ke](1), Ie && Ie(X, wt), Oe && Oe(X, pe);
        },
        (Yt, St, Mr) => {
          c[Ke](Mr);
        },
        null,
        // nothing to do on error
        Be
        // assume a single brightness value too.
      );
    }
  }, Re = function(X) {
    r.push(X), u && X.init.apply(X, [this]);
  }, ce = function() {
    const X = a.rotation();
    var pe = new Mt();
    X.length == 9 ? pe.set(
      X[0],
      X[1],
      X[2],
      0,
      X[3],
      X[4],
      X[5],
      0,
      X[6],
      X[7],
      X[8],
      0,
      0,
      0,
      0,
      1
    ) : pe.makeRotationY($(a.yaw() - 90));
    {
      var Oe = new Mt();
      Oe.makeRotationX(Math.PI / 2), pe.premultiply(Oe);
    }
    b.setRotationFromMatrix(pe);
  }, xe = async function(X, pe = [1, 1, 1]) {
    _ && _.abort(), _ = new AbortController();
    let Oe = v.length;
    v.length, ce(), v.forEach((Ie, Be) => {
      const Ue = X[Be];
      ke(
        Ie,
        Ue,
        (Ke, wt) => {
          if (Oe -= 1, Oe <= 0)
            return !0;
        },
        (Ke, wt) => {
        },
        pe[Be]
      );
    }), j();
  }, we = function(X, pe, Oe, Ie, Be) {
    const Ue = Be ? JSON.parse(Be) : [1, 1, 1];
    Oe && Oe.length > 0 && a.hemispheres(Oe);
    const Ke = typeof Ie == "string" ? JSON.parse(Ie) : Ie;
    a.rotation(Ke || []), a.brightness(Ue), a.yaw(parseFloat(pe || 0)), a.urls(X), a.visible(!0), W(F, !0);
  }, Pe = function(X) {
    const pe = a.urls();
    pe && pe.length >= v.length && (X && a.brightness(JSON.parse(X)), xe(pe, a.brightness())), W(F, !0);
  }, Me = function() {
    a.visible(!1), a.shot(null);
  };
  let Ge = !1, F = new Lf({ preserveDrawingBuffer: !0 });
  F.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  let V = new kd(), Ae = new vy(16777215, 1);
  V.add(Ae);
  const ge = t.getBoundingClientRect();
  p = Lr("DIV", { class: "geocam-viewer" }), h = Lr("DIV", { class: "geocam-viewer-controls" }), h.append(
    Lr(
      "DIV",
      { class: "geocam-viewer-controls-left" },
      '<div class="geocam-viewer-controls-left-top"></div><div class="geocam-viewer-controls-left-bottom"></div>'
    )
  );
  const ee = Lr(
    "DIV",
    { class: "geocam-viewer-controls-center" },
    '<div class="geocam-viewer-controls-top"></div><div class="geocam-viewer-controls-mid"></div><div class="geocam-viewer-controls-bottom"></div>'
  );
  ee.append(Lr("DIV")), ee.append(Lr("DIV")), ee.append(Lr("DIV")), h.append(ee), h.append(
    Lr(
      "DIV",
      { class: "geocam-viewer-controls-right" },
      '<div class="geocam-viewer-controls-right-top"></div><div class="geocam-viewer-controls-right-bottom"></div>'
    )
  ), p.appendChild(h), m = ge.width, x = ge.height, z(), p.appendChild(F.domElement), k = a.visible((X) => {
    X ? p.classList.remove("geocam-viewer-hidden") : p.classList.add("geocam-viewer-hidden"), Ge = X;
  }), t.appendChild(p), E.push(
    a.fov((X) => {
      d && X !== null && (d.fov = X, w = !0);
    })
  );
  const De = function() {
    if (S && (cancelAnimationFrame(S), S = null), Ge = !1, _ && (_.abort(), _ = null), E.forEach((X) => X()), E = [], k && (k(), k = null), fe(), ae(), r.forEach((X) => {
      "destroy" in X && X.destroy.apply(X);
    }), v && (v.forEach((X) => {
      X && (X.geometry && X.geometry.dispose(), X.material && (X.material.map && X.material.map.dispose(), X.material.dispose()), b && b.remove(X));
    }), v = [null, null, null]), b && (V.remove(b), b = null), Ae && (V.remove(Ae), Ae = null), V) {
      for (V.traverse((X) => {
        X.geometry && X.geometry.dispose(), X.material && (Array.isArray(X.material) ? X.material.forEach((pe) => {
          pe.map && pe.map.dispose(), pe.dispose();
        }) : (X.material.map && X.material.map.dispose(), X.material.dispose()));
      }); V.children.length > 0; )
        V.remove(V.children[0]);
      V = null;
    }
    if (F) {
      F.renderLists.dispose(), F.dispose();
      const X = F.getContext();
      if (X && X.getExtension) {
        const pe = X.getExtension("WEBGL_lose_context");
        pe && pe.loseContext();
      }
      F.domElement && p && p.removeChild(F.domElement), F = null;
    }
    Zr.clear(), p && t && (t.removeChild(p), p = null), d = null, h = null, f = null, Object.keys(a).forEach((X) => {
      if (a[X] && typeof a[X] == "function")
        try {
          a[X](null);
        } catch {
        }
    });
  }, Fe = function(X, pe = null) {
    return a[X] || this[X] ? (console.info(
      "geocam viewer attempt to add store that already exists",
      X
    ), a[X]() === null && pe !== null && a[X](pe)) : (a[X] = Ds(pe), this[X] = a[X], l(window.performance.now())), a[X];
  }, tt = function(X, pe, Oe = {}) {
    const Ie = document.getElementsByClassName(
      `geocam-viewer-controls-${pe}`
    )[0];
    Ie ? (X.classList.add("geocam-viewer-control"), Oe.after ? Oe.after.parentNode.insertBefore(X, Oe.after.nextSibling) : Oe.prepend ? Ie.prepend(X) : Ie.appendChild(X)) : console.error(
      "geocam viewer unable to add control no matching location",
      X,
      pe
    );
  };
  this.setup = te, this.show = we, this.reload = Pe, this.hide = Me, this.resetProgress = $e, this.plugin = Re, this.destroy = De, Object.defineProperty(this, "camera", {
    get: function() {
      return d;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(this, "meshGroup", {
    get: function() {
      return b;
    },
    enumerable: !0,
    configurable: !0
  }), this.renderer = F, this.element = t, this.wrapper = p, this.done = o.done, this.progress = c, this.newstoreadded = l, this.stores = a;
  for (let X in a)
    this[X] = a[X];
  this.store = Fe, this.addControl = tt, r.forEach((X) => {
    "init" in X && X.init.apply(X, [this]);
  }), te(e.config), j(), u = !0;
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const PV = 1e-7, BV = 1e-4;
class W1 {
  constructor(e, n) {
    this.backend = e, this.dataMover = n, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
  }
  get(e) {
    return this.data.has(e) || this.dataMover.moveData(this.backend, e), this.data.get(e);
  }
  set(e, n) {
    this.dataIdsCount++, this.data.set(e, n);
  }
  has(e) {
    return this.data.has(e);
  }
  delete(e) {
    return this.dataIdsCount--, this.data.delete(e);
  }
  numDataIds() {
    return this.dataIdsCount;
  }
}
class mx {
  refCount(e) {
    return ai("refCount");
  }
  incRef(e) {
    return ai("incRef");
  }
  timerAvailable() {
    return !0;
  }
  time(e) {
    return ai("time");
  }
  read(e) {
    return ai("read");
  }
  readSync(e) {
    return ai("readSync");
  }
  readToGPU(e, n) {
    return ai("readToGPU");
  }
  numDataIds() {
    return ai("numDataIds");
  }
  disposeData(e, n) {
    return ai("disposeData");
  }
  write(e, n, s) {
    return ai("write");
  }
  move(e, n, s, i, r) {
    return ai("move");
  }
  createTensorFromGPUData(e, n, s) {
    return ai("createTensorFromGPUData");
  }
  memory() {
    return ai("memory");
  }
  /** Returns the highest precision for floats in bits (e.g. 16 or 32) */
  floatPrecision() {
    return ai("floatPrecision");
  }
  /** Returns the smallest representable number.  */
  epsilon() {
    return this.floatPrecision() === 32 ? PV : BV;
  }
  dispose() {
    return ai("dispose");
  }
}
function ai(t) {
  throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function H1(t) {
  let e = t.length, n = 0;
  for (; e > 0; )
    n = Math.random() * e | 0, e--, To(t, e, n);
}
function zV(t, e) {
  if (t.length !== e.length)
    throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);
  let n = t.length, s = 0;
  for (; n > 0; )
    s = Math.random() * n | 0, n--, To(t, n, s), To(e, n, s);
}
function _a(t, e, n) {
  return Math.max(t, Math.min(e, n));
}
function gx(t) {
  return t % 2 === 0 ? t : t + 1;
}
function To(t, e, n) {
  const s = t[e];
  t[e] = t[n], t[n] = s;
}
function SN(t) {
  let e = 0;
  for (let n = 0; n < t.length; n++)
    e += t[n];
  return e;
}
function VV(t, e) {
  const n = Math.random();
  return e * n + (1 - n) * t;
}
function UV(t, e) {
  let n = 0;
  for (let s = 0; s < t.length; s++) {
    const i = Number(t[s]) - Number(e[s]);
    n += i * i;
  }
  return n;
}
function A(t, e) {
  if (!t)
    throw new Error(typeof e == "string" ? e : e());
}
function ws(t, e, n = "") {
  A(Bt(t, e), () => n + ` Shapes ${t} and ${e} must match`);
}
function Yc(t) {
  A(t != null, () => "The input to the tensor constructor must be a non-null value.");
}
function ue(t) {
  if (t.length === 0)
    return 1;
  let e = t[0];
  for (let n = 1; n < t.length; n++)
    e *= t[n];
  return e;
}
function GV(t) {
  return t.length === 0;
}
function _N(t, e) {
  if (t === e)
    return !0;
  if (t == null || e == null || t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== null && e[n] !== null && t[n] !== e[n])
      return !1;
  return !0;
}
function Bt(t, e) {
  if (t === e)
    return !0;
  if (t == null || e == null || t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function Lc(t) {
  return t % 1 === 0;
}
function WV(t) {
  if (Math.tanh != null)
    return Math.tanh(t);
  if (t === 1 / 0)
    return 1;
  if (t === -1 / 0)
    return -1;
  {
    const e = Math.exp(2 * t);
    return (e - 1) / (e + 1);
  }
}
function Ny(t) {
  const e = Math.ceil(Math.sqrt(t));
  return [e, Math.ceil(t / e)];
}
function HV(t) {
  const e = new Uint32Array(t);
  for (let n = 0; n < t; ++n)
    e[n] = n;
  return H1(e), e;
}
function vc(t, e) {
  return e <= t.length ? t : t + " ".repeat(e - t.length);
}
function Dw(t, e = (i) => 0, n, s) {
  return new Promise((i, r) => {
    let o = 0;
    const a = () => {
      if (t()) {
        i();
        return;
      }
      o++;
      const c = e(o);
      if (n != null && o >= n) {
        r();
        return;
      }
      s != null ? s(a, c) : setTimeout(a, c);
    };
    a();
  });
}
function j1(t, e) {
  let n = 1, s = -1;
  for (let r = 0; r < t.length; ++r)
    if (t[r] >= 0)
      n *= t[r];
    else if (t[r] === -1) {
      if (s !== -1)
        throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${r}`);
      s = r;
    } else if (t[r] < 0)
      throw Error(`Shapes can not be < 0. Found ${t[r]} at dim ${r}`);
  if (s === -1) {
    if (e > 0 && e !== n)
      throw Error(`Size(${e}) must match the product of shape ${t}`);
    return t;
  }
  if (n === 0)
    throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);
  if (e % n !== 0)
    throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);
  const i = t.slice();
  return i[s] = e / n, i;
}
function Rt(t, e) {
  const n = e.length;
  return t = t == null ? e.map((s, i) => i) : [].concat(t), A(t.every((s) => s >= -n && s < n), () => `All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`), A(t.every((s) => Lc(s)), () => `All values in axis param must be integers but got axis ${t}`), t.map((s) => s < 0 ? n + s : s);
}
function zo(t, e) {
  const n = [], s = [], i = e != null && Array.isArray(e) && e.length === 0, r = e == null || i ? null : Rt(e, t).sort();
  let o = 0;
  for (let a = 0; a < t.length; ++a) {
    if (r != null) {
      if (r[o] === a && t[a] !== 1)
        throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);
      (r[o] == null || r[o] > a) && t[a] === 1 && (n.push(t[a]), s.push(a)), r[o] <= a && o++;
    }
    t[a] !== 1 && (n.push(t[a]), s.push(a));
  }
  return { newShape: n, keptDims: s };
}
function ls(t, e) {
  return $n(t, e);
}
function $n(t, e) {
  let n = null;
  if (t == null || t === "float32")
    n = new Float32Array(e);
  else if (t === "int32")
    n = new Int32Array(e);
  else if (t === "bool")
    n = new Uint8Array(e);
  else if (t === "string")
    n = new Array(e);
  else
    throw new Error(`Unknown data type ${t}`);
  return n;
}
function TN(t, e) {
  for (let n = 0; n < t.length; n++) {
    const s = t[n];
    if (isNaN(s) || !isFinite(s))
      throw Error(`A tensor of type ${e} being uploaded contains ${s}.`);
  }
}
function CN(t) {
  return t === "bool" || t === "complex64" || t === "float32" || t === "int32" || t === "string";
}
function q1(t, e) {
  return !(e === "complex64" || e === "float32" && t !== "complex64" || e === "int32" && t !== "float32" && t !== "complex64" || e === "bool" && t === "bool");
}
function uf(t) {
  if (t === "float32" || t === "int32")
    return 4;
  if (t === "complex64")
    return 8;
  if (t === "bool")
    return 1;
  throw new Error(`Unknown dtype ${t}`);
}
function IN(t) {
  if (t == null)
    return 0;
  let e = 0;
  return t.forEach((n) => e += n.length), e;
}
function Wr(t) {
  return typeof t == "string" || t instanceof String;
}
function EN(t) {
  return typeof t == "boolean";
}
function ky(t) {
  return typeof t == "number";
}
function Zc(t) {
  return Array.isArray(t) ? Zc(t[0]) : t instanceof Float32Array ? "float32" : t instanceof Int32Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray ? "int32" : ky(t) ? "float32" : Wr(t) ? "string" : EN(t) ? "bool" : "float32";
}
function Ta(t) {
  return !!(t && t.constructor && t.call && t.apply);
}
function Ay(t, e) {
  for (let n = e; n < t; ++n)
    if (t % n === 0)
      return n;
  return t;
}
function ct(t) {
  const e = t.length;
  if (e < 2)
    return [];
  const n = new Array(e - 1);
  n[e - 2] = t[e - 1];
  for (let s = e - 3; s >= 0; --s)
    n[s] = n[s + 1] * t[s + 1];
  return n;
}
function NN(t, e, n, s = !1) {
  const i = new Array();
  if (e.length === 1) {
    const r = e[0] * (s ? 2 : 1);
    for (let o = 0; o < r; o++)
      i[o] = n[t + o];
  } else {
    const r = e[0], o = e.slice(1), a = o.reduce((c, l) => c * l) * (s ? 2 : 1);
    for (let c = 0; c < r; c++)
      i[c] = NN(t + c * a, o, n, s);
  }
  return i;
}
function Ai(t, e, n = !1) {
  if (t.length === 0)
    return e[0];
  const s = t.reduce((i, r) => i * r) * (n ? 2 : 1);
  if (s === 0)
    return [];
  if (s !== e.length)
    throw new Error(`[${t}] does not match the input size ${e.length}${n ? " for a complex tensor" : ""}.`);
  return NN(0, t, e, n);
}
function kN(t, e) {
  if (Array.isArray(t))
    return t;
  if (e === "float32")
    return t instanceof Float32Array ? t : new Float32Array(t);
  if (e === "int32")
    return t instanceof Int32Array ? t : new Int32Array(t);
  if (e === "bool" || e === "string")
    return Uint8Array.from(new Int32Array(t));
  throw new Error(`Unknown dtype ${e}`);
}
function yx(t, e) {
  const n = vs(t, e);
  for (let s = 0; s < n.length; s++)
    n[s] = 1;
  return n;
}
function vs(t, e) {
  if (e == null || e === "float32" || e === "complex64")
    return new Float32Array(t);
  if (e === "int32")
    return new Int32Array(t);
  if (e === "bool")
    return new Uint8Array(t);
  throw new Error(`Unknown data type ${e}`);
}
function X1(t, e) {
  const n = t.reduce((s, i) => s * i, 1);
  if (e == null || e === "float32")
    return Ai(t, new Float32Array(n));
  if (e === "int32")
    return Ai(t, new Int32Array(n));
  if (e === "bool")
    return Ai(t, new Uint8Array(n));
  throw new Error(`Unknown data type ${e}`);
}
function _i(t) {
  t.forEach((e) => {
    A(Number.isInteger(e) && e >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${t}].`);
  });
}
function br(t, e, n) {
  if (e === 0)
    return 0;
  if (e === 1)
    return t[0];
  let s = t[t.length - 1];
  for (let i = 0; i < t.length - 1; ++i)
    s += n[i] * t[i];
  return s;
}
function Jc(t, e, n) {
  if (e === 0)
    return [];
  if (e === 1)
    return [t];
  const s = new Array(e);
  for (let i = 0; i < s.length - 1; ++i)
    s[i] = Math.floor(t / n[i]), t -= s[i] * n[i];
  return s[s.length - 1] = t, s;
}
function Ca(t) {
  return t && t.then && typeof t.then == "function";
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _2 = "tfjsflags";
class AN {
  // tslint:disable-next-line: no-any
  constructor(e) {
    this.global = e, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = jV, this.populateURLFlags();
  }
  setPlatform(e, n) {
    this.platform != null && (ie().getBool("IS_TEST") || ie().getBool("PROD") || console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)), this.platformName = e, this.platform = n;
  }
  registerFlag(e, n, s) {
    if (this.flagRegistry[e] = { evaluationFn: n, setHook: s }, this.urlFlags[e] != null) {
      const i = this.urlFlags[e];
      ie().getBool("IS_TEST") || ie().getBool("PROD") || console.warn(`Setting feature override from URL ${e}: ${i}.`), this.set(e, i);
    }
  }
  async getAsync(e) {
    return e in this.flags ? this.flags[e] : (this.flags[e] = await this.evaluateFlag(e), this.flags[e]);
  }
  get(e) {
    if (e in this.flags)
      return this.flags[e];
    const n = this.evaluateFlag(e);
    if (Ca(n))
      throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);
    return this.flags[e] = n, this.flags[e];
  }
  getNumber(e) {
    return this.get(e);
  }
  getBool(e) {
    return this.get(e);
  }
  getString(e) {
    return this.get(e);
  }
  getFlags() {
    return this.flags;
  }
  // For backwards compatibility.
  get features() {
    return this.flags;
  }
  set(e, n) {
    if (this.flagRegistry[e] == null)
      throw new Error(`Cannot set flag ${e} as it has not been registered.`);
    this.flags[e] = n, this.flagRegistry[e].setHook != null && this.flagRegistry[e].setHook(n);
  }
  evaluateFlag(e) {
    if (this.flagRegistry[e] == null)
      throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);
    return this.flagRegistry[e].evaluationFn();
  }
  setFlags(e) {
    this.flags = Object.assign({}, e);
  }
  reset() {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }
  populateURLFlags() {
    if (typeof this.global > "u" || typeof this.global.location > "u" || typeof this.global.location.search > "u")
      return;
    const e = this.getQueryParams(this.global.location.search);
    _2 in e && e[_2].split(",").forEach((s) => {
      const [i, r] = s.split(":");
      this.urlFlags[i] = XV(i, r);
    });
  }
}
function jV(t) {
  const e = {};
  return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (n, ...s) => (qV(e, s[0], s[1]), s.join("="))), e;
}
function qV(t, e, n) {
  t[decodeURIComponent(e)] = decodeURIComponent(n || "");
}
function XV(t, e) {
  const n = e.toLowerCase();
  return n === "true" || n === "false" ? n === "true" : `${+n}` === n ? +n : e;
}
function ie() {
  return K1;
}
let K1 = null;
function KV(t) {
  K1 = t;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let mv;
function MN() {
  if (mv == null) {
    let t;
    if (typeof window < "u")
      t = window;
    else if (typeof global < "u")
      t = global;
    else if (typeof process < "u")
      t = process;
    else if (typeof self < "u")
      t = self;
    else
      throw new Error("Could not find a global object");
    mv = t;
  }
  return mv;
}
function YV() {
  const t = MN();
  return t._tfGlobals == null && (t._tfGlobals = /* @__PURE__ */ new Map()), t._tfGlobals;
}
function Y1(t, e) {
  const n = YV();
  if (n.has(t))
    return n.get(t);
  {
    const s = e();
    return n.set(t, s), n.get(t);
  }
}
const Ff = "Abs", Lu = "Acos", Fu = "Acosh", Qc = "Add", Pf = "AddN", xx = "All", bx = "Any", Bf = "ArgMax", zf = "ArgMin", Pu = "Asin", Bu = "Asinh", zu = "Atan", Vu = "Atanh", Uu = "Atan2", Vf = "AvgPool", vx = "AvgPoolGrad", Uf = "AvgPool3D", wx = "AvgPool3DGrad", Gf = "BatchMatMul", Wf = "BatchToSpaceND", Sx = "Bincount", Hf = "BitwiseAnd", RN = "BroadcastTo", _x = "BroadcastArgs", Gu = "Cast", Wu = "Ceil", Hu = "ClipByValue", Tx = "Complex", jf = "ComplexAbs", qf = "Concat", Xf = "Conv2D", Cx = "Conv2DBackpropFilter", Kf = "Conv2DBackpropInput", Yf = "Conv3D", Ix = "Conv3DBackpropFilterV2", Ex = "Conv3DBackpropInputV2", ju = "Cos", qu = "Cosh", Nx = "Cumprod", Zf = "Cumsum", kx = "CropAndResize", Ax = "DenseBincount", Mx = "DepthToSpace", Jf = "DepthwiseConv2dNative", Rx = "DepthwiseConv2dNativeBackpropFilter", Dx = "DepthwiseConv2dNativeBackpropInput", $x = "Diag", Qf = "Dilation2D", My = "Dilation2DBackpropInput", Ry = "Dilation2DBackpropFilter", Ox = "Draw", Xu = "RealDiv", Lx = "Einsum", Ku = "Elu", Fx = "EluGrad", Yu = "Erf", ep = "Equal", Zu = "Exp", tp = "ExpandDims", Ju = "Expm1", Px = "FFT", Bx = "Fill", zx = "FlipLeftRight", Qu = "Floor", eh = "FloorDiv", np = "FusedBatchNorm", sp = "GatherV2", Vx = "GatherNd", ip = "Greater", th = "GreaterEqual", nh = "Identity", Ux = "IFFT", Gx = "Imag", sh = "IsFinite", ih = "IsInf", rh = "IsNan", rp = "LeakyRelu", op = "Less", ap = "LessEqual", Wx = "LinSpace", oh = "Log", ah = "Log1p", cp = "LogicalAnd", lp = "LogicalNot", up = "LogicalOr", ZV = "LogicalXor", DN = "LogSoftmax", JV = "LowerBound", hp = "LRN", Hx = "LRNGrad", QV = "MatrixBandPart", dp = "Max", ch = "Maximum", fp = "MaxPool", jx = "MaxPoolGrad", pp = "MaxPool3D", qx = "MaxPool3DGrad", Xx = "MaxPoolWithArgmax", mp = "Mean", gp = "Min", lh = "Minimum", yp = "MirrorPad", uh = "Mod", Kx = "Multinomial", hh = "Multiply", xp = "Neg", bp = "NotEqual", Yx = "NonMaxSuppressionV3", Zx = "NonMaxSuppressionV4", Jx = "NonMaxSuppressionV5", vp = "OnesLike", wp = "OneHot", Sp = "Pack", _p = "PadV2", eU = "Pool", dh = "Pow", Tp = "Prelu", Cp = "Prod", Qx = "RaggedGather", e0 = "RaggedRange", t0 = "RaggedTensorToTensor", n0 = "Range", s0 = "Real", fh = "Reciprocal", ph = "Relu", Ip = "Reshape", Ep = "ResizeNearestNeighbor", i0 = "ResizeNearestNeighborGrad", Np = "ResizeBilinear", r0 = "ResizeBilinearGrad", mh = "Relu6", kp = "Reverse", gh = "Round", yh = "Rsqrt", o0 = "ScatterNd", a0 = "TensorScatterUpdate", c0 = "SearchSorted", Ap = "Select", xh = "Selu", Mp = "Slice", bh = "Sin", vh = "Sinh", wh = "Sign", Sh = "Sigmoid", _h = "Softplus", Th = "Sqrt", Rp = "Sum", Dp = "SpaceToBatchND", $p = "SplitV", Op = "Softmax", l0 = "SparseFillEmptyRows", u0 = "SparseReshape", h0 = "SparseSegmentMean", d0 = "SparseSegmentSum", f0 = "SparseToDense", Ch = "SquaredDifference", p0 = "Square", Lp = "StaticRegexReplace", m0 = "StridedSlice", g0 = "StringNGrams", y0 = "StringSplit", x0 = "StringToHashBucketFast", Ih = "Sub", Eh = "Tan", Nh = "Tanh", kh = "Tile", b0 = "TopK", v0 = "Transform", wc = "Transpose", w0 = "Unique", Fp = "Unpack", Pp = "UnsortedSegmentSum", tU = "UpperBound", Bp = "ZerosLike", Ah = "Step", Dy = "FromPixels", S0 = "RotateWithOffset", hf = "_FusedMatMul", df = "FusedConv2D", ff = "FusedDepthwiseConv2D";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ei(...t) {
  ie().getBool("IS_TEST") || ie().getBool("PROD") || console.warn(...t);
}
function nU(...t) {
  ie().getBool("IS_TEST") || ie().getBool("PROD") || console.log(...t);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xu = Y1("kernelRegistry", () => /* @__PURE__ */ new Map()), pf = Y1("gradRegistry", () => /* @__PURE__ */ new Map());
function mf(t, e) {
  const n = Z1(t, e);
  return xu.get(n);
}
function $w(t) {
  return pf.get(t);
}
function $y(t) {
  const e = xu.entries(), n = [];
  for (; ; ) {
    const { done: s, value: i } = e.next();
    if (s)
      break;
    const [r, o] = i, [a] = r.split("_");
    a === t && n.push(o);
  }
  return n;
}
function _0(t) {
  const { kernelName: e, backendName: n } = t, s = Z1(e, n);
  xu.has(s) && Ei(`The kernel '${e}' for backend '${n}' is already registered`), xu.set(s, t);
}
function $N(t) {
  const { kernelName: e } = t;
  pf.has(e) && ie().getBool("DEBUG") && Ei(`Overriding the gradient for '${e}'`), pf.set(e, t);
}
function sU(t, e) {
  const n = Z1(t, e);
  if (!xu.has(n))
    throw new Error(`The kernel '${t}' for backend '${e}' is not registered`);
  xu.delete(n);
}
function iU(t) {
  if (!pf.has(t))
    throw new Error(`The gradient '${t}' for backend is not registered`);
  pf.delete(t);
}
function rU(t, e) {
  $y(t).forEach((s) => {
    const i = Object.assign({}, s, { backendName: e });
    _0(i);
  });
}
function Z1(t, e) {
  return `${e}_${t}`;
}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ON(t) {
  return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray;
}
var el = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function oU(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function aU(t) {
  if (t.__esModule)
    return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function s() {
      if (this instanceof s) {
        var i = [null];
        i.push.apply(i, arguments);
        var r = Function.bind.apply(e, i);
        return new r();
      }
      return e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(s) {
    var i = Object.getOwnPropertyDescriptor(t, s);
    Object.defineProperty(n, s, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[s];
      }
    });
  }), n;
}
var LN = xn, ji = null;
try {
  ji = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch {
}
function xn(t, e, n) {
  this.low = t | 0, this.high = e | 0, this.unsigned = !!n;
}
xn.prototype.__isLong__;
Object.defineProperty(xn.prototype, "__isLong__", { value: !0 });
function Ti(t) {
  return (t && t.__isLong__) === !0;
}
xn.isLong = Ti;
var T2 = {}, C2 = {};
function tl(t, e) {
  var n, s, i;
  return e ? (t >>>= 0, (i = 0 <= t && t < 256) && (s = C2[t], s) ? s : (n = bn(t, (t | 0) < 0 ? -1 : 0, !0), i && (C2[t] = n), n)) : (t |= 0, (i = -128 <= t && t < 128) && (s = T2[t], s) ? s : (n = bn(t, t < 0 ? -1 : 0, !1), i && (T2[t] = n), n));
}
xn.fromInt = tl;
function qi(t, e) {
  if (isNaN(t))
    return e ? mc : Xi;
  if (e) {
    if (t < 0)
      return mc;
    if (t >= FN)
      return zN;
  } else {
    if (t <= -E2)
      return fi;
    if (t + 1 >= E2)
      return BN;
  }
  return t < 0 ? qi(-t, e).neg() : bn(t % bu | 0, t / bu | 0, e);
}
xn.fromNumber = qi;
function bn(t, e, n) {
  return new xn(t, e, n);
}
xn.fromBits = bn;
var Oy = Math.pow;
function J1(t, e, n) {
  if (t.length === 0)
    throw Error("empty string");
  if (t === "NaN" || t === "Infinity" || t === "+Infinity" || t === "-Infinity")
    return Xi;
  if (typeof e == "number" ? (n = e, e = !1) : e = !!e, n = n || 10, n < 2 || 36 < n)
    throw RangeError("radix");
  var s;
  if ((s = t.indexOf("-")) > 0)
    throw Error("interior hyphen");
  if (s === 0)
    return J1(t.substring(1), e, n).neg();
  for (var i = qi(Oy(n, 8)), r = Xi, o = 0; o < t.length; o += 8) {
    var a = Math.min(8, t.length - o), c = parseInt(t.substring(o, o + a), n);
    if (a < 8) {
      var l = qi(Oy(n, a));
      r = r.mul(l).add(qi(c));
    } else
      r = r.mul(i), r = r.add(qi(c));
  }
  return r.unsigned = e, r;
}
xn.fromString = J1;
function Er(t, e) {
  return typeof t == "number" ? qi(t, e) : typeof t == "string" ? J1(t, e) : bn(t.low, t.high, typeof e == "boolean" ? e : t.unsigned);
}
xn.fromValue = Er;
var I2 = 65536, cU = 1 << 24, bu = I2 * I2, FN = bu * bu, E2 = FN / 2, N2 = tl(cU), Xi = tl(0);
xn.ZERO = Xi;
var mc = tl(0, !0);
xn.UZERO = mc;
var Hl = tl(1);
xn.ONE = Hl;
var PN = tl(1, !0);
xn.UONE = PN;
var Ow = tl(-1);
xn.NEG_ONE = Ow;
var BN = bn(-1, 2147483647, !1);
xn.MAX_VALUE = BN;
var zN = bn(-1, -1, !0);
xn.MAX_UNSIGNED_VALUE = zN;
var fi = bn(0, -2147483648, !1);
xn.MIN_VALUE = fi;
var Ve = xn.prototype;
Ve.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
Ve.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * bu + (this.low >>> 0) : this.high * bu + (this.low >>> 0);
};
Ve.toString = function(e) {
  if (e = e || 10, e < 2 || 36 < e)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative())
    if (this.eq(fi)) {
      var n = qi(e), s = this.div(n), i = s.mul(n).sub(this);
      return s.toString(e) + i.toInt().toString(e);
    } else
      return "-" + this.neg().toString(e);
  for (var r = qi(Oy(e, 6), this.unsigned), o = this, a = ""; ; ) {
    var c = o.div(r), l = o.sub(c.mul(r)).toInt() >>> 0, u = l.toString(e);
    if (o = c, o.isZero())
      return u + a;
    for (; u.length < 6; )
      u = "0" + u;
    a = "" + u + a;
  }
};
Ve.getHighBits = function() {
  return this.high;
};
Ve.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
Ve.getLowBits = function() {
  return this.low;
};
Ve.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
Ve.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(fi) ? 64 : this.neg().getNumBitsAbs();
  for (var e = this.high != 0 ? this.high : this.low, n = 31; n > 0 && !(e & 1 << n); n--)
    ;
  return this.high != 0 ? n + 33 : n + 1;
};
Ve.isZero = function() {
  return this.high === 0 && this.low === 0;
};
Ve.eqz = Ve.isZero;
Ve.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
Ve.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
Ve.isOdd = function() {
  return (this.low & 1) === 1;
};
Ve.isEven = function() {
  return (this.low & 1) === 0;
};
Ve.equals = function(e) {
  return Ti(e) || (e = Er(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;
};
Ve.eq = Ve.equals;
Ve.notEquals = function(e) {
  return !this.eq(
    /* validates */
    e
  );
};
Ve.neq = Ve.notEquals;
Ve.ne = Ve.notEquals;
Ve.lessThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) < 0;
};
Ve.lt = Ve.lessThan;
Ve.lessThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) <= 0;
};
Ve.lte = Ve.lessThanOrEqual;
Ve.le = Ve.lessThanOrEqual;
Ve.greaterThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) > 0;
};
Ve.gt = Ve.greaterThan;
Ve.greaterThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) >= 0;
};
Ve.gte = Ve.greaterThanOrEqual;
Ve.ge = Ve.greaterThanOrEqual;
Ve.compare = function(e) {
  if (Ti(e) || (e = Er(e)), this.eq(e))
    return 0;
  var n = this.isNegative(), s = e.isNegative();
  return n && !s ? -1 : !n && s ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
};
Ve.comp = Ve.compare;
Ve.negate = function() {
  return !this.unsigned && this.eq(fi) ? fi : this.not().add(Hl);
};
Ve.neg = Ve.negate;
Ve.add = function(e) {
  Ti(e) || (e = Er(e));
  var n = this.high >>> 16, s = this.high & 65535, i = this.low >>> 16, r = this.low & 65535, o = e.high >>> 16, a = e.high & 65535, c = e.low >>> 16, l = e.low & 65535, u = 0, h = 0, d = 0, f = 0;
  return f += r + l, d += f >>> 16, f &= 65535, d += i + c, h += d >>> 16, d &= 65535, h += s + a, u += h >>> 16, h &= 65535, u += n + o, u &= 65535, bn(d << 16 | f, u << 16 | h, this.unsigned);
};
Ve.subtract = function(e) {
  return Ti(e) || (e = Er(e)), this.add(e.neg());
};
Ve.sub = Ve.subtract;
Ve.multiply = function(e) {
  if (this.isZero())
    return Xi;
  if (Ti(e) || (e = Er(e)), ji) {
    var n = ji.mul(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return bn(n, ji.get_high(), this.unsigned);
  }
  if (e.isZero())
    return Xi;
  if (this.eq(fi))
    return e.isOdd() ? fi : Xi;
  if (e.eq(fi))
    return this.isOdd() ? fi : Xi;
  if (this.isNegative())
    return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative())
    return this.mul(e.neg()).neg();
  if (this.lt(N2) && e.lt(N2))
    return qi(this.toNumber() * e.toNumber(), this.unsigned);
  var s = this.high >>> 16, i = this.high & 65535, r = this.low >>> 16, o = this.low & 65535, a = e.high >>> 16, c = e.high & 65535, l = e.low >>> 16, u = e.low & 65535, h = 0, d = 0, f = 0, p = 0;
  return p += o * u, f += p >>> 16, p &= 65535, f += r * u, d += f >>> 16, f &= 65535, f += o * l, d += f >>> 16, f &= 65535, d += i * u, h += d >>> 16, d &= 65535, d += r * l, h += d >>> 16, d &= 65535, d += o * c, h += d >>> 16, d &= 65535, h += s * u + i * l + r * c + o * a, h &= 65535, bn(f << 16 | p, h << 16 | d, this.unsigned);
};
Ve.mul = Ve.multiply;
Ve.divide = function(e) {
  if (Ti(e) || (e = Er(e)), e.isZero())
    throw Error("division by zero");
  if (ji) {
    if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1)
      return this;
    var n = (this.unsigned ? ji.div_u : ji.div_s)(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return bn(n, ji.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? mc : Xi;
  var s, i, r;
  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this))
      return mc;
    if (e.gt(this.shru(1)))
      return PN;
    r = mc;
  } else {
    if (this.eq(fi)) {
      if (e.eq(Hl) || e.eq(Ow))
        return fi;
      if (e.eq(fi))
        return Hl;
      var o = this.shr(1);
      return s = o.div(e).shl(1), s.eq(Xi) ? e.isNegative() ? Hl : Ow : (i = this.sub(e.mul(s)), r = s.add(i.div(e)), r);
    } else if (e.eq(fi))
      return this.unsigned ? mc : Xi;
    if (this.isNegative())
      return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative())
      return this.div(e.neg()).neg();
    r = Xi;
  }
  for (i = this; i.gte(e); ) {
    s = Math.max(1, Math.floor(i.toNumber() / e.toNumber()));
    for (var a = Math.ceil(Math.log(s) / Math.LN2), c = a <= 48 ? 1 : Oy(2, a - 48), l = qi(s), u = l.mul(e); u.isNegative() || u.gt(i); )
      s -= c, l = qi(s, this.unsigned), u = l.mul(e);
    l.isZero() && (l = Hl), r = r.add(l), i = i.sub(u);
  }
  return r;
};
Ve.div = Ve.divide;
Ve.modulo = function(e) {
  if (Ti(e) || (e = Er(e)), ji) {
    var n = (this.unsigned ? ji.rem_u : ji.rem_s)(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return bn(n, ji.get_high(), this.unsigned);
  }
  return this.sub(this.div(e).mul(e));
};
Ve.mod = Ve.modulo;
Ve.rem = Ve.modulo;
Ve.not = function() {
  return bn(~this.low, ~this.high, this.unsigned);
};
Ve.and = function(e) {
  return Ti(e) || (e = Er(e)), bn(this.low & e.low, this.high & e.high, this.unsigned);
};
Ve.or = function(e) {
  return Ti(e) || (e = Er(e)), bn(this.low | e.low, this.high | e.high, this.unsigned);
};
Ve.xor = function(e) {
  return Ti(e) || (e = Er(e)), bn(this.low ^ e.low, this.high ^ e.high, this.unsigned);
};
Ve.shiftLeft = function(e) {
  return Ti(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? bn(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : bn(0, this.low << e - 32, this.unsigned);
};
Ve.shl = Ve.shiftLeft;
Ve.shiftRight = function(e) {
  return Ti(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? bn(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : bn(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
Ve.shr = Ve.shiftRight;
Ve.shiftRightUnsigned = function(e) {
  if (Ti(e) && (e = e.toInt()), e &= 63, e === 0)
    return this;
  var n = this.high;
  if (e < 32) {
    var s = this.low;
    return bn(s >>> e | n << 32 - e, n >>> e, this.unsigned);
  } else
    return e === 32 ? bn(n, 0, this.unsigned) : bn(n >>> e - 32, 0, this.unsigned);
};
Ve.shru = Ve.shiftRightUnsigned;
Ve.shr_u = Ve.shiftRightUnsigned;
Ve.toSigned = function() {
  return this.unsigned ? bn(this.low, this.high, !1) : this;
};
Ve.toUnsigned = function() {
  return this.unsigned ? this : bn(this.low, this.high, !0);
};
Ve.toBytes = function(e) {
  return e ? this.toBytesLE() : this.toBytesBE();
};
Ve.toBytesLE = function() {
  var e = this.high, n = this.low;
  return [
    n & 255,
    n >>> 8 & 255,
    n >>> 16 & 255,
    n >>> 24,
    e & 255,
    e >>> 8 & 255,
    e >>> 16 & 255,
    e >>> 24
  ];
};
Ve.toBytesBE = function() {
  var e = this.high, n = this.low;
  return [
    e >>> 24,
    e >>> 16 & 255,
    e >>> 8 & 255,
    e & 255,
    n >>> 24,
    n >>> 16 & 255,
    n >>> 8 & 255,
    n & 255
  ];
};
xn.fromBytes = function(e, n, s) {
  return s ? xn.fromBytesLE(e, n) : xn.fromBytesBE(e, n);
};
xn.fromBytesLE = function(e, n) {
  return new xn(
    e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24,
    e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24,
    n
  );
};
xn.fromBytesBE = function(e, n) {
  return new xn(
    e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7],
    e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3],
    n
  );
};
const VN = /* @__PURE__ */ oU(LN), lU = /* @__PURE__ */ HO({
  __proto__: null,
  default: VN
}, [LN]);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uc = (
  // tslint:disable-next-line
  VN || lU
);
function zp(t) {
  return uc.fromString(t, !0, 16);
}
const UN = zp("c3a5c85c97cb3127"), cc = zp("b492b66fbe98f273"), Ps = zp("9ae16a3b2f90404f");
function Lw(t) {
  return t.xor(t.shru(47));
}
function GN(t, e, n) {
  const s = t.slice(e, e + n);
  return uc.fromBytes(Array.from(s), !0, !0);
}
function un(t, e) {
  return GN(t, e, 8);
}
function k2(t, e) {
  return GN(t, e, 4);
}
function rs(t, e) {
  return e === 0 ? t : t.shru(e).or(t.shl(64 - e));
}
function ma(t, e, n = zp("9ddfea08eb382d69")) {
  let s = t.xor(e).mul(n);
  s = s.xor(s.shru(47));
  let i = e.xor(s).mul(n);
  return i = i.xor(i.shru(47)), i = i.mul(n), i;
}
function uU(t, e, n, s, i, r) {
  i = i.add(t), r = rs(r.add(i).add(s), 21);
  const o = i;
  return i = i.add(e), i = i.add(n), r = r.add(rs(i, 44)), [i.add(s), r.add(o)];
}
function pg(t, e, n, s) {
  return uU(un(t, e), un(t, e + 8), un(t, e + 16), un(t, e + 24), n, s);
}
function hU(t, e = t.length) {
  if (e >= 8) {
    const n = Ps.add(e * 2), s = un(t, 0).add(Ps), i = un(t, e - 8), r = rs(i, 37).mul(n).add(s), o = rs(s, 25).add(i).mul(n);
    return ma(r, o, n);
  }
  if (e >= 4) {
    const n = Ps.add(e * 2), s = k2(t, 0);
    return ma(s.shl(3).add(e), k2(t, e - 4), n);
  }
  if (e > 0) {
    const n = t[0], s = t[e >> 1], i = t[e - 1], r = n + (s << 8), o = e + (i << 2);
    return Lw(Ps.mul(r).xor(UN.mul(o))).mul(Ps);
  }
  return Ps;
}
function dU(t, e = t.length) {
  const n = Ps.add(e * 2), s = un(t, 0).mul(cc), i = un(t, 8), r = un(t, e - 8).mul(n), o = un(t, e - 16).mul(Ps);
  return ma(rs(s.add(i), 43).add(rs(r, 30)).add(o), s.add(rs(i.add(Ps), 18)).add(r), n);
}
function fU(t, e = t.length) {
  const n = Ps.add(e * 2), s = un(t, 0).mul(Ps), i = un(t, 8), r = un(t, e - 8).mul(n), o = un(t, e - 16).mul(Ps), a = rs(s.add(i), 43).add(rs(r, 30)).add(o), c = ma(a, s.add(rs(i.add(Ps), 18)).add(r), n), l = un(t, 16).mul(n), u = un(t, 24), h = a.add(un(t, e - 32)).mul(n), d = c.add(un(t, e - 24)).mul(n);
  return ma(rs(l.add(u), 43).add(rs(h, 30)).add(d), l.add(rs(u.add(s), 18)).add(h), n);
}
function WN(t, e = t.length) {
  const n = uc.fromNumber(81, !0);
  if (e <= 32)
    return e <= 16 ? hU(t, e) : dU(t, e);
  if (e <= 64)
    return fU(t, e);
  let s = n, i = n.mul(cc).add(113), r = Lw(i.mul(Ps).add(113)).mul(Ps), o = [uc.UZERO, uc.UZERO], a = [uc.UZERO, uc.UZERO];
  s = s.mul(Ps).add(un(t, 0));
  let c = 0;
  const l = (e - 1 >> 6) * 64, u = l + (e - 1 & 63) - 63;
  do
    s = rs(s.add(i).add(o[0]).add(un(t, c + 8)), 37).mul(cc), i = rs(i.add(o[1]).add(un(t, c + 48)), 42).mul(cc), s = s.xor(a[1]), i = i.add(o[0]).add(un(t, c + 40)), r = rs(r.add(a[0]), 33).mul(cc), o = pg(t, c, o[1].mul(cc), s.add(a[0])), a = pg(t, c + 32, r.add(a[1]), i.add(un(t, c + 16))), [r, s] = [s, r], c += 64;
  while (c !== l);
  const h = cc.add(r.and(255).shl(1));
  return c = u, a[0] = a[0].add(e - 1 & 63), o[0] = o[0].add(a[0]), a[0] = a[0].add(o[0]), s = rs(s.add(i).add(o[0]).add(un(t, c + 8)), 37).mul(h), i = rs(i.add(o[1]).add(un(t, c + 48)), 42).mul(h), s = s.xor(a[1].mul(9)), i = i.add(o[0].mul(9).add(un(t, c + 40))), r = rs(r.add(a[0]), 33).mul(h), o = pg(t, c, o[1].mul(h), s.add(a[0])), a = pg(t, c + 32, r.add(a[1]), i.add(un(t, c + 16))), [r, s] = [s, r], ma(ma(o[0], a[0], h).add(Lw(i).mul(UN)).add(r), ma(o[1], a[1], h).add(s), h);
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Vo(t, e) {
  return e === "string" ? jr(t) : La([t], e);
}
function pU(t, e) {
  return t instanceof Float32Array && e === "float32" || t instanceof Int32Array && e === "int32" || t instanceof Uint8Array && e === "bool";
}
function La(t, e) {
  if (e === "string")
    throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(t) && (t = no(t)), ie().getBool("DEBUG") && TN(t, e), pU(t, e))
    return t;
  if (e == null || e === "float32" || e === "complex64")
    return new Float32Array(t);
  if (e === "int32")
    return new Int32Array(t);
  if (e === "bool") {
    const n = new Uint8Array(t.length);
    for (let s = 0; s < n.length; ++s)
      Math.round(t[s]) !== 0 && (n[s] = 1);
    return n;
  } else
    throw new Error(`Unknown data type ${e}`);
}
function Ls() {
  return ie().platform.now();
}
function mU(t, e) {
  return ie().platform.fetch(t, e);
}
function jr(t, e = "utf-8") {
  return e = e || "utf-8", ie().platform.encode(t, e);
}
function Ro(t, e = "utf-8") {
  return e = e || "utf-8", ie().platform.decode(t, e);
}
function os(t) {
  return ie().platform.isTypedArray != null ? ie().platform.isTypedArray(t) : ON(t);
}
function no(t, e = [], n = !1) {
  if (e == null && (e = []), typeof t == "boolean" || typeof t == "number" || typeof t == "string" || Ca(t) || t == null || os(t) && n)
    e.push(t);
  else if (Array.isArray(t) || os(t))
    for (let s = 0; s < t.length; ++s)
      no(t[s], e, n);
  else {
    let s = -1;
    for (const i of Object.keys(t))
      /^([1-9]+[0-9]*|0)$/.test(i) && (s = Math.max(s, Number(i)));
    for (let i = 0; i <= s; i++)
      no(t[i], e, n);
  }
  return e;
}
const gU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arraysEqual: Bt,
  arraysEqualWithNull: _N,
  assert: A,
  assertNonNegativeIntegerDimensions: _i,
  assertNonNull: Yc,
  assertShapesMatch: ws,
  bytesFromStringArray: IN,
  bytesPerElement: uf,
  checkConversionForErrors: TN,
  clamp: _a,
  computeStrides: ct,
  convertBackendValuesAndArrayBuffer: kN,
  createScalarValue: Vo,
  createShuffledIndices: HV,
  decodeString: Ro,
  distSquared: UV,
  encodeString: jr,
  fetch: mU,
  fingerPrint64: WN,
  flatten: no,
  getArrayFromDType: $n,
  getTypedArrayFromDType: ls,
  hasEncodingLoss: q1,
  hexToLong: zp,
  indexToLoc: Jc,
  inferDtype: Zc,
  inferFromImplicitShape: j1,
  isBoolean: EN,
  isFunction: Ta,
  isInt: Lc,
  isNumber: ky,
  isPromise: Ca,
  isScalarShape: GV,
  isString: Wr,
  isTypedArray: os,
  isValidDtype: CN,
  locToIndex: br,
  makeOnesTypedArray: yx,
  makeZerosNestedTypedArray: X1,
  makeZerosTypedArray: vs,
  nearestDivisor: Ay,
  nearestLargerEven: gx,
  now: Ls,
  parseAxisParam: Rt,
  randUniform: VV,
  repeatedTry: Dw,
  rightPad: vc,
  shuffle: H1,
  shuffleCombo: zV,
  sizeFromShape: ue,
  sizeToSquarishShape: Ny,
  squeezeShape: zo,
  sum: SN,
  swap: To,
  tanh: WV,
  toNestedArray: Ai,
  toTypedArray: La
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class yU {
  constructor(e, n) {
    this.backendTimer = e, this.logger = n, n == null && (this.logger = new bU());
  }
  profileKernel(e, n, s) {
    let i;
    const r = () => {
      i = s();
    };
    let o;
    const a = Ls();
    if (this.backendTimer.timerAvailable())
      o = this.backendTimer.time(r);
    else {
      r();
      for (const l of i)
        l.dataSync();
      o = Promise.resolve({ kernelMs: Ls() - a });
    }
    if (ie().getBool("CHECK_COMPUTATION_FOR_ERRORS"))
      for (let l = 0; l < i.length; l++) {
        const u = i[l];
        u.data().then((h) => {
          xU(h, u.dtype, e);
        });
      }
    return {
      kernelName: e,
      outputs: i,
      inputs: n,
      timeMs: o.then((l) => l.kernelMs),
      extraInfo: o.then((l) => l.getExtraProfileInfo != null ? l.getExtraProfileInfo() : "")
    };
  }
  logKernelProfile(e) {
    const { kernelName: n, outputs: s, timeMs: i, inputs: r, extraInfo: o } = e;
    s.forEach((a) => {
      Promise.all([a.data(), i, o]).then((c) => {
        this.logger.logKernelProfile(n, a, c[0], c[1], r, c[2]);
      });
    });
  }
}
function xU(t, e, n) {
  if (e !== "float32")
    return !1;
  for (let s = 0; s < t.length; s++) {
    const i = t[s];
    if (isNaN(i) || !isFinite(i))
      return console.warn(`Found ${i} in the result of '${n}'`), !0;
  }
  return !1;
}
class bU {
  logKernelProfile(e, n, s, i, r, o) {
    const a = typeof i == "number" ? vc(`${i}ms`, 9) : i.error, c = vc(e, 25), l = n.rank, u = n.size, h = vc(n.shape.toString(), 14);
    let d = "";
    for (const f in r) {
      const p = r[f];
      if (p != null) {
        const y = p.shape || n.shape, g = y.length;
        d += `${f}: ${g}D ${g > 0 ? y : ""} `;
      }
    }
    console.log(`%c${c}	%c${a}	%c${l}D ${h}	%c${u}	%c${d}	%c${o}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vU(t, e, n) {
  const s = {}, i = {};
  for (let c = 0; c < e.length; c++)
    s[e[c].id] = !0;
  for (let c = 0; c < t.length; c++) {
    const l = t[c], u = l.inputs;
    for (const h in u) {
      const d = u[h];
      let f = !1;
      for (let p = 0; p < e.length; p++)
        if (s[d.id]) {
          l.outputs.forEach((y) => s[y.id] = !0), f = !0, i[l.id] = !0;
          break;
        }
      if (f)
        break;
    }
  }
  const r = {};
  r[n.id] = !0;
  const o = {};
  for (let c = t.length - 1; c >= 0; c--) {
    const l = t[c], u = l.inputs;
    for (let h = 0; h < l.outputs.length; h++)
      if (r[l.outputs[h].id]) {
        for (const d in u)
          r[u[d].id] = !0, o[l.id] = !0;
        break;
      }
  }
  const a = [];
  for (let c = 0; c < t.length; c++) {
    const l = t[c];
    if (i[l.id] && o[l.id]) {
      const u = {};
      for (const d in l.inputs) {
        const f = l.inputs[d];
        s[f.id] && (u[d] = f);
      }
      const h = Object.assign({}, l);
      h.inputs = u, h.outputs = l.outputs, a.push(h);
    }
  }
  return a;
}
function wU(t, e, n, s) {
  for (let i = e.length - 1; i >= 0; i--) {
    const r = e[i], o = [];
    if (r.outputs.forEach((c) => {
      const l = t[c.id];
      l != null ? o.push(l) : o.push(null);
    }), r.gradient == null)
      throw new Error(`Cannot compute gradient: gradient function not found for ${r.kernelName}.`);
    const a = r.gradient(o);
    for (const c in r.inputs) {
      if (!(c in a))
        throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(a)}.`);
      const l = n(() => a[c]());
      if (l.dtype !== "float32")
        throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${l.dtype}'`);
      const u = r.inputs[c];
      if (!Bt(l.shape, u.shape))
        throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input '${c}' has shape '${l.shape}', which does not match the shape of the input '${u.shape}'`);
      if (t[u.id] == null)
        t[u.id] = l;
      else {
        const h = t[u.id];
        t[u.id] = s(h, l), h.dispose();
      }
    }
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const A2 = 20, rd = 3, gv = 7;
function SU(t, e, n, s) {
  const i = ct(e), r = _U(t, e, n, i), o = e.length, a = Bg(t, e, n, i, r), c = ["Tensor"];
  return s && (c.push(`  dtype: ${n}`), c.push(`  rank: ${o}`), c.push(`  shape: [${e}]`), c.push("  values:")), c.push(a.map((l) => "    " + l).join(`
`)), c.join(`
`);
}
function _U(t, e, n, s) {
  const i = ue(e), r = s[s.length - 1], o = new Array(r).fill(0), a = e.length, c = n === "complex64" ? fd(t) : t;
  if (a > 1)
    for (let l = 0; l < i / r; l++) {
      const u = l * r;
      for (let h = 0; h < r; h++)
        o[h] = Math.max(o[h], dd(c[u + h], 0, n).length);
    }
  return o;
}
function dd(t, e, n) {
  let s;
  return Array.isArray(t) ? s = `${parseFloat(t[0].toFixed(gv))} + ${parseFloat(t[1].toFixed(gv))}j` : Wr(t) ? s = `'${t}'` : n === "bool" ? s = HN(t) : s = parseFloat(t.toFixed(gv)).toString(), vc(s, e);
}
function HN(t) {
  return t === 0 ? "false" : "true";
}
function Bg(t, e, n, s, i, r = !0) {
  const o = n === "complex64" ? 2 : 1, a = e[0], c = e.length;
  if (c === 0) {
    if (n === "complex64") {
      const y = fd(t);
      return [dd(y[0], 0, n)];
    }
    return n === "bool" ? [HN(t[0])] : [t[0].toString()];
  }
  if (c === 1) {
    if (a > A2) {
      const g = rd * o;
      let m = Array.from(t.slice(0, g)), x = Array.from(t.slice((a - rd) * o, a * o));
      return n === "complex64" && (m = fd(m), x = fd(x)), [
        "[" + m.map((v, b) => dd(v, i[b], n)).join(", ") + ", ..., " + x.map((v, b) => dd(v, i[a - rd + b], n)).join(", ") + "]"
      ];
    }
    return [
      "[" + (n === "complex64" ? fd(t) : Array.from(t)).map((g, m) => dd(g, i[m], n)).join(", ") + "]"
    ];
  }
  const l = e.slice(1), u = s.slice(1), h = s[0] * o, d = [];
  if (a > A2) {
    for (let y = 0; y < rd; y++) {
      const g = y * h, m = g + h;
      d.push(...Bg(
        t.slice(g, m),
        l,
        n,
        u,
        i,
        !1
        /* isLast */
      ));
    }
    d.push("...");
    for (let y = a - rd; y < a; y++) {
      const g = y * h, m = g + h;
      d.push(...Bg(
        t.slice(g, m),
        l,
        n,
        u,
        i,
        y === a - 1
        /* isLast */
      ));
    }
  } else
    for (let y = 0; y < a; y++) {
      const g = y * h, m = g + h;
      d.push(...Bg(
        t.slice(g, m),
        l,
        n,
        u,
        i,
        y === a - 1
        /* isLast */
      ));
    }
  const f = c === 2 ? "," : "";
  d[0] = "[" + (a > 0 ? d[0] + f : "");
  for (let y = 1; y < d.length - 1; y++)
    d[y] = " " + d[y] + f;
  let p = `,
`;
  for (let y = 2; y < c; y++)
    p += `
`;
  return d[d.length - 1] = " " + d[d.length - 1] + "]" + (r ? "" : p), d;
}
function fd(t) {
  const e = [];
  for (let n = 0; n < t.length; n += 2)
    e.push([t[n], t[n + 1]]);
  return e;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Xn {
  constructor(e, n, s) {
    if (this.dtype = n, this.shape = e.slice(), this.size = ue(e), s != null) {
      const i = s.length;
      A(i === this.size, () => `Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`);
    }
    if (n === "complex64")
      throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = s || $n(n, this.size), this.strides = ct(e);
  }
  /**
   * Sets a value in the buffer at a given location.
   *
   * @param value The value to set.
   * @param locs  The location indices.
   *
   * @doc {heading: 'Tensors', subheading: 'Creation'}
   */
  set(e, ...n) {
    n.length === 0 && (n = [0]), A(n.length === this.rank, () => `The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);
    const s = this.locToIndex(n);
    this.values[s] = e;
  }
  /**
   * Returns the value in the buffer at the provided location.
   *
   * @param locs The location indices.
   *
   * @doc {heading: 'Tensors', subheading: 'Creation'}
   */
  get(...e) {
    e.length === 0 && (e = [0]);
    let n = 0;
    for (const i of e) {
      if (i < 0 || i >= this.shape[n]) {
        const r = `Requested out of range element at ${e}.   Buffer shape=${this.shape}`;
        throw new Error(r);
      }
      n++;
    }
    let s = e[e.length - 1];
    for (let i = 0; i < e.length - 1; ++i)
      s += this.strides[i] * e[i];
    return this.values[s];
  }
  locToIndex(e) {
    if (this.rank === 0)
      return 0;
    if (this.rank === 1)
      return e[0];
    let n = e[e.length - 1];
    for (let s = 0; s < e.length - 1; ++s)
      n += this.strides[s] * e[s];
    return n;
  }
  indexToLoc(e) {
    if (this.rank === 0)
      return [];
    if (this.rank === 1)
      return [e];
    const n = new Array(this.shape.length);
    for (let s = 0; s < n.length - 1; ++s)
      n[s] = Math.floor(e / this.strides[s]), e -= n[s] * this.strides[s];
    return n[n.length - 1] = e, n;
  }
  get rank() {
    return this.shape.length;
  }
  /**
   * Creates an immutable `tf.Tensor` object from the buffer.
   *
   * @doc {heading: 'Tensors', subheading: 'Creation'}
   */
  toTensor() {
    return pr().makeTensor(this.values, this.shape, this.dtype);
  }
}
let pr = null, Pl = null;
function TU(t) {
  pr = t;
}
function CU(t) {
  Pl = t;
}
class Lt {
  constructor(e, n, s, i) {
    this.kept = !1, this.isDisposedInternal = !1, this.shape = e.slice(), this.dtype = n || "float32", this.size = ue(e), this.strides = ct(e), this.dataId = s, this.id = i, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }
  get rank() {
    return this.shape.length;
  }
  /**
   * Returns a promise of `tf.TensorBuffer` that holds the underlying data.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  async buffer() {
    const e = await this.data();
    return Pl.buffer(this.shape, this.dtype, e);
  }
  /**
   * Returns a `tf.TensorBuffer` that holds the underlying data.
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  bufferSync() {
    return Pl.buffer(this.shape, this.dtype, this.dataSync());
  }
  /**
   * Returns the tensor data as a nested array. The transfer of data is done
   * asynchronously.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  async array() {
    const e = await this.data();
    return Ai(this.shape, e, this.dtype === "complex64");
  }
  /**
   * Returns the tensor data as a nested array. The transfer of data is done
   * synchronously.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  arraySync() {
    return Ai(this.shape, this.dataSync(), this.dtype === "complex64");
  }
  /**
   * Asynchronously downloads the values from the `tf.Tensor`. Returns a
   * promise of `TypedArray` that resolves when the computation has finished.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  async data() {
    this.throwIfDisposed();
    const e = pr().read(this.dataId);
    if (this.dtype === "string") {
      const n = await e;
      try {
        return n.map((s) => Ro(s));
      } catch {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    }
    return e;
  }
  /**
   * Copy the tensor's data to a new GPU resource. Comparing to the `dataSync()`
   * and `data()`, this method prevents data from being downloaded to CPU.
   *
   * For WebGL backend, the data will be stored on a densely packed texture.
   * This means that the texture will use the RGBA channels to store value.
   *
   * For WebGPU backend, the data will be stored on a buffer. There is no
   * parameter, so can not use a user-defined size to create the buffer.
   *
   * @param options:
   *     For WebGL,
   *         - customTexShape: Optional. If set, will use the user defined
   *     texture shape to create the texture.
   *
   * @returns For WebGL backend, a GPUData contains the new texture and
   *     its information.
   *     {
   *        tensorRef: The tensor that is associated with this texture,
   *        texture: WebGLTexture,
   *        texShape: [number, number] // [height, width]
   *     }
   *
   *     For WebGPU backend, a GPUData contains the new buffer.
   *     {
   *        tensorRef: The tensor that is associated with this buffer,
   *        buffer: GPUBuffer,
   *     }
   *
   *     Remember to dispose the GPUData after it is used by
   *     `res.tensorRef.dispose()`.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  dataToGPU(e) {
    return this.throwIfDisposed(), pr().readToGPU(this.dataId, e);
  }
  /**
   * Synchronously downloads the values from the `tf.Tensor`. This blocks the
   * UI thread until the values are ready, which can cause performance issues.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  dataSync() {
    this.throwIfDisposed();
    const e = pr().readSync(this.dataId);
    if (this.dtype === "string")
      try {
        return e.map((n) => Ro(n));
      } catch {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    return e;
  }
  /** Returns the underlying bytes of the tensor's data. */
  async bytes() {
    this.throwIfDisposed();
    const e = await pr().read(this.dataId);
    return this.dtype === "string" ? e : new Uint8Array(e.buffer);
  }
  /**
   * Disposes `tf.Tensor` from memory.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  dispose() {
    this.isDisposed || (this.kerasMask && this.kerasMask.dispose(), pr().disposeTensor(this), this.isDisposedInternal = !0);
  }
  get isDisposed() {
    return this.isDisposedInternal;
  }
  throwIfDisposed() {
    if (this.isDisposed)
      throw new Error("Tensor is disposed.");
  }
  /**
   * Prints the `tf.Tensor`. See `tf.print` for details.
   *
   * @param verbose Whether to print verbose information about the tensor,
   *    including dtype and size.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  print(e = !1) {
    return Pl.print(this, e);
  }
  /**
   * Returns a copy of the tensor. See `tf.clone` for details.
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  clone() {
    return this.throwIfDisposed(), Pl.clone(this);
  }
  /**
   * Returns a human-readable description of the tensor. Useful for logging.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  toString(e = !1) {
    const n = this.dataSync();
    return SU(n, this.shape, this.dtype, e);
  }
  cast(e) {
    return this.throwIfDisposed(), Pl.cast(this, e);
  }
  variable(e = !0, n, s) {
    return this.throwIfDisposed(), pr().makeVariable(this, e, n, s);
  }
}
Object.defineProperty(Lt, Symbol.hasInstance, {
  value: (t) => !!t && t.data != null && t.dataSync != null && t.throwIfDisposed != null
});
function de() {
  return Y1("Tensor", () => Lt);
}
de();
class gf extends Lt {
  constructor(e, n, s, i) {
    super(e.shape, e.dtype, e.dataId, i), this.trainable = n, this.name = s;
  }
  /**
   * Assign a new `tf.Tensor` to this variable. The new `tf.Tensor` must have
   * the same shape and dtype as the old `tf.Tensor`.
   *
   * @param newValue New tensor to be assigned to this variable.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  assign(e) {
    if (e.dtype !== this.dtype)
      throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);
    if (!Bt(e.shape, this.shape))
      throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);
    pr().disposeTensor(this), this.dataId = e.dataId, pr().incRef(
      this,
      null
      /* backend */
    );
  }
  dispose() {
    pr().disposeVariable(this), this.isDisposedInternal = !0;
  }
}
Object.defineProperty(gf, Symbol.hasInstance, {
  value: (t) => t instanceof Lt && t.assign != null && t.assign instanceof Function
});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Fw;
(function(t) {
  t.R0 = "R0", t.R1 = "R1", t.R2 = "R2", t.R3 = "R3", t.R4 = "R4", t.R5 = "R5", t.R6 = "R6";
})(Fw || (Fw = {}));
var Pw;
(function(t) {
  t.float32 = "float32", t.int32 = "int32", t.bool = "int32", t.complex64 = "complex64";
})(Pw || (Pw = {}));
var Bw;
(function(t) {
  t.float32 = "float32", t.int32 = "int32", t.bool = "bool", t.complex64 = "complex64";
})(Bw || (Bw = {}));
var zw;
(function(t) {
  t.float32 = "float32", t.int32 = "float32", t.bool = "float32", t.complex64 = "complex64";
})(zw || (zw = {}));
var Vw;
(function(t) {
  t.float32 = "complex64", t.int32 = "complex64", t.bool = "complex64", t.complex64 = "complex64";
})(Vw || (Vw = {}));
const IU = {
  float32: zw,
  int32: Pw,
  bool: Bw,
  complex64: Vw
};
function ni(t, e) {
  if (t === "string" || e === "string") {
    if (t === "string" && e === "string")
      return "string";
    throw new Error(`Can not upcast ${t} with ${e}`);
  }
  return IU[t][e];
}
function T0(t) {
  return ni(t, "int32");
}
function jN(t) {
  return t != null && typeof t == "object" && "texture" in t && t.texture instanceof WebGLTexture;
}
function qN(t) {
  return typeof GPUBuffer < "u" && t != null && typeof t == "object" && "buffer" in t && t.buffer instanceof GPUBuffer;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kn(t, e) {
  if (t.dtype === e.dtype)
    return [t, e];
  const n = ni(t.dtype, e.dtype);
  return [t.cast(n), e.cast(n)];
}
function XN(t, e) {
  A(t.dtype === e.dtype, () => `The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`);
}
function EU(t, e) {
  return e.some((n) => n.id === t.id);
}
function Q1(t) {
  const e = [];
  return KN(t, e, /* @__PURE__ */ new Set()), e;
}
function KN(t, e, n) {
  if (t == null)
    return;
  if (t instanceof Lt) {
    e.push(t);
    return;
  }
  if (!NU(t))
    return;
  const s = t;
  for (const i in s) {
    const r = s[i];
    n.has(r) || (n.add(r), KN(r, e, n));
  }
}
function NU(t) {
  return Array.isArray(t) || typeof t == "object";
}
const kU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assertTypesMatch: XN,
  getTensorsInContainer: Q1,
  isTensorInList: EU,
  makeTypesMatch: kn
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yv(t) {
  return t.kernelName != null;
}
class M2 {
  constructor() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = !1, this.activeProfile = {
      newBytes: 0,
      newTensors: 0,
      peakBytes: 0,
      kernels: [],
      result: null,
      get kernelNames() {
        return Array.from(new Set(this.kernels.map((e) => e.name)));
      }
    };
  }
  dispose() {
    for (const e in this.registeredVariables)
      this.registeredVariables[e].dispose();
  }
}
class vu {
  constructor(e) {
    this.ENV = e, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new M2();
  }
  async ready() {
    if (this.pendingBackendInit != null)
      return this.pendingBackendInit.then(() => {
      });
    if (this.backendInstance != null)
      return;
    const e = this.getSortedBackends();
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (await this.initializeBackend(s).success) {
        await this.setBackend(s);
        return;
      }
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }
  get backend() {
    if (this.pendingBackendInit != null)
      throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
    if (this.backendInstance == null) {
      const { name: e, asyncInit: n } = this.initializeBackendsAndReturnBest();
      if (n)
        throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      this.setBackend(e);
    }
    return this.backendInstance;
  }
  backendNames() {
    return Object.keys(this.registryFactory);
  }
  findBackend(e) {
    if (!(e in this.registry))
      if (e in this.registryFactory) {
        const { asyncInit: n } = this.initializeBackend(e);
        if (n)
          return null;
      } else
        return null;
    return this.registry[e];
  }
  findBackendFactory(e) {
    return e in this.registryFactory ? this.registryFactory[e].factory : null;
  }
  registerBackend(e, n, s = 1) {
    return e in this.registryFactory ? (Ei(`${e} backend was already registered. Reusing existing backend factory.`), !1) : (this.registryFactory[e] = { factory: n, priority: s }, !0);
  }
  async setBackend(e) {
    if (this.registryFactory[e] == null)
      throw new Error(`Backend name '${e}' not found in registry`);
    if (this.backendName = e, this.registry[e] == null) {
      this.backendInstance = null;
      const { success: n, asyncInit: s } = this.initializeBackend(e);
      if (!(s ? await n : n))
        return !1;
    }
    return this.backendInstance = this.registry[e], this.setupRegisteredKernels(), this.profiler = new yU(this.backendInstance), !0;
  }
  setupRegisteredKernels() {
    $y(this.backendName).forEach((n) => {
      n.setupFunc != null && n.setupFunc(this.backendInstance);
    });
  }
  disposeRegisteredKernels(e) {
    $y(e).forEach((s) => {
      s.disposeFunc != null && s.disposeFunc(this.registry[e]);
    });
  }
  /**
   * Initializes a backend by looking up the backend name in the factory
   * registry and calling the factory method. Returns a boolean representing
   * whether the initialization of the backend succeeded. Throws an error if
   * there is no backend in the factory registry.
   */
  initializeBackend(e) {
    const n = this.registryFactory[e];
    if (n == null)
      throw new Error(`Cannot initialize backend ${e}, no registration found.`);
    try {
      const s = n.factory();
      if (s && !(s instanceof mx) && typeof s.then == "function") {
        const i = ++this.pendingBackendInitId, r = s.then((o) => i < this.pendingBackendInitId ? !1 : (this.registry[e] = o, this.pendingBackendInit = null, !0)).catch((o) => (i < this.pendingBackendInitId || (this.pendingBackendInit = null, Ei(`Initialization of backend ${e} failed`), Ei(o.stack || o.message)), !1));
        return this.pendingBackendInit = r, { success: r, asyncInit: !0 };
      } else
        return this.registry[e] = s, { success: !0, asyncInit: !1 };
    } catch (s) {
      return Ei(`Initialization of backend ${e} failed`), Ei(s.stack || s.message), { success: !1, asyncInit: !1 };
    }
  }
  removeBackend(e) {
    if (!(e in this.registryFactory))
      throw new Error(`${e} backend not found in registry`);
    this.backendName === e && this.pendingBackendInit != null && this.pendingBackendInitId++, e in this.registry && (this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e]), delete this.registryFactory[e], this.backendName === e && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }
  getSortedBackends() {
    if (Object.keys(this.registryFactory).length === 0)
      throw new Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort((e, n) => this.registryFactory[n].priority - this.registryFactory[e].priority);
  }
  initializeBackendsAndReturnBest() {
    const e = this.getSortedBackends();
    for (let n = 0; n < e.length; n++) {
      const s = e[n], { success: i, asyncInit: r } = this.initializeBackend(s);
      if (r || i)
        return { name: s, asyncInit: r };
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }
  moveData(e, n) {
    const s = this.state.tensorInfo.get(n), i = s.backend, r = this.readSync(n), o = i.refCount(n);
    i.disposeData(n, !0), s.backend = e, e.move(n, r, s.shape, s.dtype, o), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }
  tidy(e, n) {
    let s = null;
    if (n == null) {
      if (typeof e != "function")
        throw new Error("Please provide a function to tidy()");
      n = e;
    } else {
      if (typeof e != "string" && !(e instanceof String))
        throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if (typeof n != "function")
        throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      s = e;
    }
    let i;
    return this.scopedRun(() => this.startScope(s), () => this.endScope(i), () => (i = n(), i instanceof Promise && console.error("Cannot return a Promise inside of tidy."), i));
  }
  scopedRun(e, n, s) {
    e();
    try {
      const i = s();
      return n(), i;
    } catch (i) {
      throw n(), i;
    }
  }
  nextTensorId() {
    return vu.nextTensorId++;
  }
  nextVariableId() {
    return vu.nextVariableId++;
  }
  /**
   * This method is called instead of the public-facing tensor.clone() when
   * saving a tensor for backwards pass. It makes sure to add the clone
   * operation to the tape regardless of being called inside a kernel
   * execution.
   */
  clone(e) {
    const n = G.runKernel(nh, { x: e }), s = { x: e }, i = (o) => ({
      x: () => {
        const a = "float32", c = { x: o }, l = { dtype: a };
        return G.runKernel(
          Gu,
          c,
          // tslint:disable-next-line: no-unnecessary-type-assertion
          l
        );
      }
    }), r = [];
    return this.addTapeNode(this.state.activeScope.name, s, [n], i, r, {}), n;
  }
  /**
   * Execute a kernel with the given name and return the output tensor.
   *
   * @param kernelName The name of the kernel to execute.
   * @param inputs A map of input names to tensors.
   * @param attrs A map of attribute names to their values. An attribute is a
   *     primitive (non-tensor) input to the kernel.
   * @param inputsToSave A list of tensors, inputs to save for the backprop
   *     computation.
   * @param outputsToSave A list of booleans, specifying which output to save
   *     for the backprop computation. These are booleans since the output
   * tensors are not visible to the user.
   */
  runKernel(e, n, s) {
    if (this.backendName == null && this.backend, !(mf(e, this.backendName) != null))
      throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);
    return this.runKernelFunc({ kernelName: e, inputs: n, attrs: s });
  }
  shouldCheckForMemLeaks() {
    return this.ENV.getBool("IS_TEST");
  }
  checkKernelForMemLeak(e, n, s) {
    const i = this.backend.numDataIds();
    let r = 0;
    s.forEach((c) => {
      r += c.dtype === "complex64" ? 3 : 1;
    });
    const o = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], a = i - n - r - o;
    if (a > 0)
      throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`);
  }
  /**
   * Internal helper method to execute a kernel Func
   *
   * Use `runKernel` to execute kernels from outside of engine.
   */
  runKernelFunc(e) {
    let n, s = [];
    const i = this.isTapeOn(), r = this.state.numBytes, o = this.state.numTensors;
    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    let a;
    this.backendName == null && this.backend;
    let c;
    const l = yv(e) ? e.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
    if (yv(e)) {
      const { kernelName: p, inputs: y, attrs: g } = e;
      this.backendName == null && this.backend;
      const m = mf(p, this.backendName);
      A(m != null, () => `Cannot find registered kernel '${p}' for backend '${this.backendName}'`), a = () => {
        const x = this.backend.numDataIds();
        c = m.kernelFunc({ inputs: y, attrs: g, backend: this.backend });
        const v = Array.isArray(c) ? c : [c];
        this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(p, x, v);
        const b = v.map((w) => w.rank != null ? w : this.makeTensorFromTensorInfo(w));
        if (i) {
          const w = this.getTensorsForGradient(p, y, b);
          s = this.saveTensorsForBackwardMode(w);
        }
        return b;
      };
    } else {
      const { forwardFunc: p } = e, y = (g) => {
        i && (s = g.map((m) => this.keep(this.clone(m))));
      };
      a = () => {
        const g = this.backend.numDataIds();
        c = this.tidy(() => p(this.backend, y));
        const m = Array.isArray(c) ? c : [c];
        return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(l, g, m), m;
      };
    }
    const { inputs: u, attrs: h } = e, d = yv(e) ? null : e.backwardsFunc;
    let f;
    return this.scopedRun(
      // Stop recording to a tape when running a kernel.
      () => this.state.kernelDepth++,
      () => this.state.kernelDepth--,
      () => {
        !this.ENV.getBool("DEBUG") && !this.state.profiling ? n = a() : (f = this.profiler.profileKernel(l, u, () => a()), this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(f), n = f.outputs);
      }
    ), i && this.addTapeNode(l, u, n, d, s, h), this.state.profiling && this.state.activeProfile.kernels.push({
      name: l,
      bytesAdded: this.state.numBytes - r,
      totalBytesSnapshot: this.state.numBytes,
      tensorsAdded: this.state.numTensors - o,
      totalTensorsSnapshot: this.state.numTensors,
      inputShapes: Object.keys(u).map((p) => u[p] != null ? u[p].shape : null),
      outputShapes: n.map((p) => p.shape),
      kernelTimeMs: f.timeMs,
      extraInfo: f.extraInfo
    }), Array.isArray(c) ? n : n[0];
  }
  /**
   * Saves tensors used in forward mode for use in backward mode.
   *
   * @param tensors the list of tensors to save.
   */
  saveTensorsForBackwardMode(e) {
    return e.map((s) => this.keep(this.clone(s)));
  }
  /**
   * Returns a list of tensors to save for a given gradient calculation.
   *
   * @param kernelName name of kernel to look up gradient for.
   * @param inputs a map of input tensors.
   * @param outputs an array of output tensors from forward mode of kernel.
   */
  getTensorsForGradient(e, n, s) {
    const i = $w(e);
    if (i != null) {
      const r = i.inputsToSave || [], o = i.outputsToSave || [];
      let a;
      i.saveAllInputs ? (A(Array.isArray(n), () => "saveAllInputs is true, expected inputs to be an array."), a = Object.keys(n).map((l) => n[l])) : a = r.map((l) => n[l]);
      const c = s.filter((l, u) => o[u]);
      return a.concat(c);
    }
    return [];
  }
  /**
   * Internal method used by public APIs for tensor creation. Makes a new
   * tensor with the provided shape, dtype and values. It always
   * creates a new data id and writes the values to the underlying backend.
   */
  makeTensor(e, n, s, i) {
    if (e == null)
      throw new Error("Values passed to engine.makeTensor() are null");
    s = s || "float32", i = i || this.backend;
    let r = e;
    s === "string" && Wr(e[0]) && (r = e.map((c) => jr(c)));
    const o = i.write(r, n, s), a = new Lt(n, s, o, this.nextTensorId());
    if (this.trackTensor(a, i), s === "string") {
      const c = this.state.tensorInfo.get(o), l = IN(r);
      this.state.numBytes += l - c.bytes, c.bytes = l;
    }
    return a;
  }
  /**
   * Internal method used by backends. Makes a new tensor
   * that is a wrapper around an existing data id. It doesn't create
   * a new data id, only increments the ref count used in memory tracking.
   * @deprecated
   */
  makeTensorFromDataId(e, n, s, i) {
    s = s || "float32";
    const r = { dataId: e, shape: n, dtype: s };
    return this.makeTensorFromTensorInfo(r, i);
  }
  /**
   * Internal method used by backends. Makes a new tensor that is a wrapper
   * around an existing data id in TensorInfo. It doesn't create a new data id,
   * only increments the ref count used in memory tracking.
   */
  makeTensorFromTensorInfo(e, n) {
    const { dataId: s, shape: i, dtype: r } = e, o = new Lt(i, r, s, this.nextTensorId());
    return this.trackTensor(o, n), o;
  }
  makeVariable(e, n = !0, s, i) {
    s = s || this.nextVariableId().toString(), i != null && i !== e.dtype && (e = e.cast(i));
    const r = new gf(e, n, s, this.nextTensorId());
    if (this.state.registeredVariables[r.name] != null)
      throw new Error(`Variable with name ${r.name} was already registered`);
    return this.state.registeredVariables[r.name] = r, this.incRef(r, this.backend), r;
  }
  trackTensor(e, n) {
    this.state.numTensors++, e.dtype === "string" && this.state.numStringTensors++;
    let s = 0;
    e.dtype !== "complex64" && e.dtype !== "string" && (s = e.size * uf(e.dtype)), this.state.numBytes += s, this.state.tensorInfo.has(e.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(e.dataId, {
      backend: n || this.backend,
      dtype: e.dtype,
      shape: e.shape,
      bytes: s
    })), e instanceof gf || this.track(e);
  }
  // Track the tensor by dataId and increase the refCount for the dataId in the
  // backend.
  // TODO(pyu10055): This is currently used by makeVariable method, to increase
  // refCount on the backend for the dataId. It can potentially be replaced with
  // Identity op indead of calling backend directly.
  incRef(e, n) {
    this.trackTensor(e, n), this.backend.incRef(e.dataId);
  }
  removeDataId(e, n) {
    this.state.tensorInfo.has(e) && this.state.tensorInfo.get(e).backend === n && (this.state.tensorInfo.delete(e), this.state.numDataBuffers--);
  }
  disposeTensor(e) {
    if (!this.state.tensorInfo.has(e.dataId))
      return;
    const n = this.state.tensorInfo.get(e.dataId);
    if (this.state.numTensors--, e.dtype === "string" && (this.state.numStringTensors--, this.state.numBytes -= n.bytes), e.dtype !== "complex64" && e.dtype !== "string") {
      const s = e.size * uf(e.dtype);
      this.state.numBytes -= s;
    }
    n.backend.disposeData(e.dataId) && this.removeDataId(e.dataId, n.backend);
  }
  disposeVariables() {
    for (const e in this.state.registeredVariables) {
      const n = this.state.registeredVariables[e];
      this.disposeVariable(n);
    }
  }
  disposeVariable(e) {
    this.disposeTensor(e), this.state.registeredVariables[e.name] != null && delete this.state.registeredVariables[e.name];
  }
  memory() {
    const e = this.backend.memory();
    return e.numTensors = this.state.numTensors, e.numDataBuffers = this.state.numDataBuffers, e.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e.unreliable = !0, e.reasons == null && (e.reasons = []), e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e;
  }
  async profile(e) {
    this.state.profiling = !0;
    const n = this.state.numBytes, s = this.state.numTensors;
    this.state.activeProfile.kernels = [], this.state.activeProfile.result = await e(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((i) => i.totalBytesSnapshot)), this.state.activeProfile.newBytes = this.state.numBytes - n, this.state.activeProfile.newTensors = this.state.numTensors - s;
    for (const i of this.state.activeProfile.kernels)
      i.kernelTimeMs = await i.kernelTimeMs, i.extraInfo = await i.extraInfo;
    return this.state.activeProfile;
  }
  isTapeOn() {
    return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
  }
  addTapeNode(e, n, s, i, r, o) {
    const a = { id: this.state.nextTapeNodeId++, kernelName: e, inputs: n, outputs: s, saved: r }, c = $w(e);
    c != null && (i = c.gradFunc), i != null && (a.gradient = (l) => (l = l.map((u, h) => {
      if (u == null) {
        const d = s[h], f = vs(d.size, d.dtype);
        return this.makeTensor(f, d.shape, d.dtype);
      }
      return u;
    }), i(l.length > 1 ? l : l[0], r, o))), this.state.activeTape.push(a);
  }
  keep(e) {
    return e.kept = !0, e;
  }
  startTape() {
    this.state.gradientDepth === 0 && (this.state.activeTape = []), this.state.gradientDepth++;
  }
  endTape() {
    this.state.gradientDepth--;
  }
  /**
   * Start a scope. Use this with endScope() to achieve the same functionality
   * as scope() without the need for a function closure.
   */
  startScope(e) {
    const n = {
      track: [],
      name: "unnamed scope",
      id: this.state.nextScopeId++
    };
    e && (n.name = e), this.state.scopeStack.push(n), this.state.activeScope = n;
  }
  /**
   * End a scope. Use this with startScope() to achieve the same functionality
   * as scope() without the need for a function closure.
   */
  endScope(e) {
    const n = Q1(e), s = new Set(n.map((r) => r.id));
    for (let r = 0; r < this.state.activeScope.track.length; r++) {
      const o = this.state.activeScope.track[r];
      !o.kept && !s.has(o.id) && o.dispose();
    }
    const i = this.state.scopeStack.pop();
    this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n.forEach((r) => {
      !r.kept && r.scopeId === i.id && this.track(r);
    });
  }
  /**
   * Returns gradients of `f` with respect to each of the `xs`. The gradients
   * returned are of the same length as `xs`, but some might be null if `f`
   * was not a function of that `x`. It also takes optional dy to multiply the
   * gradient, which defaults to `1`.
   */
  gradients(e, n, s, i = !1) {
    if (A(n.length > 0, () => "gradients() received an empty list of xs."), s != null && s.dtype !== "float32")
      throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);
    const r = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", e));
    A(r instanceof Lt, () => "The result y returned by f() must be a tensor.");
    const o = vU(this.state.activeTape, n, r);
    if (!i && o.length === 0 && n.length > 0)
      throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", () => {
      const a = {};
      a[r.id] = s ?? AU(r.shape), wU(
        a,
        o,
        // Pass the tidy function to avoid circular dep with `tape.ts`.
        (l) => this.tidy(l),
        // Pass an add function to avoide a circular dep with `tape.ts`.
        MU
      );
      const c = n.map((l) => a[l.id]);
      return this.state.gradientDepth === 0 && (this.state.activeTape.forEach((l) => {
        for (const u of l.saved)
          u.dispose();
      }), this.state.activeTape = null), { value: r, grads: c };
    });
  }
  customGrad(e) {
    return A(Ta(e), () => "The f passed in customGrad(f) must be a function."), (...n) => {
      A(n.every((a) => a instanceof Lt), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
      let s;
      const i = {};
      n.forEach((a, c) => {
        i[c] = a;
      });
      const r = (a, c) => (s = e(...n, c), A(s.value instanceof Lt, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), A(Ta(s.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), s.value), o = (a, c) => {
        const l = s.gradFunc(a, c), u = Array.isArray(l) ? l : [l];
        A(u.length === n.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), A(u.every((d) => d instanceof Lt), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
        const h = {};
        return u.forEach((d, f) => {
          h[f] = () => d;
        }), h;
      };
      return this.runKernelFunc({
        forwardFunc: r,
        backwardsFunc: o,
        inputs: i
      });
    };
  }
  readSync(e) {
    return this.state.tensorInfo.get(e).backend.readSync(e);
  }
  read(e) {
    return this.state.tensorInfo.get(e).backend.read(e);
  }
  readToGPU(e, n) {
    return this.state.tensorInfo.get(e).backend.readToGPU(e, n);
  }
  async time(e) {
    const n = Ls(), s = await this.backend.time(e);
    return s.wallMs = Ls() - n, s;
  }
  /**
   * Tracks a Tensor in the current scope to be automatically cleaned up
   * when the current scope ends, and returns the value.
   *
   * @param result The Tensor to track in the current scope.
   */
  track(e) {
    return this.state.activeScope != null && (e.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e)), e;
  }
  get registeredVariables() {
    return this.state.registeredVariables;
  }
  /**
   * Resets the engine state. Removes all backends but does not remove
   * registered backend factories.
   */
  reset() {
    this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new M2();
    for (const e in this.registry)
      this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e];
    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }
}
vu.nextTensorId = 0;
vu.nextVariableId = 0;
function AU(t) {
  const e = yx(ue(t), "float32");
  return G.makeTensor(e, t, "float32");
}
function YN() {
  const t = MN();
  if (t._tfengine == null) {
    const e = new AN(t);
    t._tfengine = new vu(e);
  }
  return KV(t._tfengine.ENV), TU(() => t._tfengine), t._tfengine;
}
const G = YN();
function MU(t, e) {
  const n = { a: t, b: e };
  return G.runKernel(Qc, n);
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function RU() {
  return typeof navigator < "u" && navigator != null;
}
let Uw;
function DU(t) {
  Uw = t;
}
function eS(t) {
  if (Uw !== void 0)
    return Uw;
  if (t || RU()) {
    if (t || (t = navigator), t.product === "ReactNative")
      return !0;
    const e = t.userAgent || t.vendor || // tslint:disable-next-line:no-any
    (typeof window < "u" ? window.opera : "");
    if (!e) {
      const n = t;
      return n.userAgentData && n.userAgentData.mobile;
    }
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e) || // tslint:disable-next-line:max-line-length
    /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0, 4));
  }
  return !1;
}
function tS() {
  return typeof window < "u" && window.document != null || //@ts-ignore
  typeof WorkerGlobalScope < "u";
}
const $U = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isBrowser: tS,
  isMobile: eS,
  mockIsMobile: DU
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const si = ie();
si.registerFlag("DEBUG", () => !1, (t) => {
  t && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
});
si.registerFlag("IS_BROWSER", () => tS());
si.registerFlag("IS_NODE", () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u");
si.registerFlag("IS_CHROME", () => typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
si.registerFlag("IS_SAFARI", () => typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor));
si.registerFlag("PROD", () => !1);
si.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => si.getBool("DEBUG"));
si.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => !0);
si.registerFlag("IS_TEST", () => !1);
si.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => si.getBool("DEBUG"));
si.registerFlag("WRAP_TO_IMAGEBITMAP", () => !1);
si.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => !1);
si.registerFlag("USE_SETTIMEOUTCUSTOM", () => !1);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function so(t, e) {
  let n = t;
  if (os(t))
    return e === "string" ? [] : [t.length];
  if (jN(t)) {
    const i = t.channels || "RGBA";
    return [t.height, t.width * i.length];
  } else if (qN(t))
    return [t.buffer.size / (e == null ? 4 : uf(e))];
  if (!Array.isArray(t))
    return [];
  const s = [];
  for (; Array.isArray(n) || os(n) && e !== "string"; )
    s.push(n.length), n = n[0];
  return Array.isArray(t) && ie().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && ZN(t, s, []), s;
}
function ZN(t, e, n) {
  if (n = n || [], !Array.isArray(t) && !os(t)) {
    A(e.length === 0, () => `Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);
    return;
  }
  A(e.length > 0, () => `Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`), A(t.length === e[0], () => `Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);
  const s = e.slice(1);
  for (let i = 0; i < t.length; ++i)
    ZN(t[i], s, n.concat(i));
}
function R2(t, e, n, s) {
  if (t !== "string_or_numeric") {
    if (t == null)
      throw new Error("Expected dtype cannot be null.");
    if (t !== "numeric" && t !== e || t === "numeric" && e === "string")
      throw new Error(`Argument '${n}' passed to '${s}' must be ${t} tensor, but got ${e} tensor`);
  }
}
function R(t, e, n, s = "numeric") {
  if (t instanceof de())
    return R2(s, t.dtype, e, n), t;
  let i = Zc(t);
  if (i !== "string" && ["bool", "int32", "float32"].indexOf(s) >= 0 && (i = s), R2(s, i, e, n), t == null || !os(t) && !Array.isArray(t) && typeof t != "number" && typeof t != "boolean" && typeof t != "string") {
    const c = t == null ? "null" : t.constructor.name;
    throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${c}'`);
  }
  const r = so(t, i);
  !os(t) && !Array.isArray(t) && (t = [t]);
  const a = i !== "string" ? La(t, i) : no(t, [], !0);
  return G.makeTensor(a, r, i);
}
function yf(t, e, n, s = "numeric") {
  if (!Array.isArray(t))
    throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);
  return t.map((r, o) => R(r, `${e}[${o}]`, n, s));
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nS = "__op";
function H(t) {
  const e = Object.keys(t);
  if (e.length !== 1)
    throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);
  let n = e[0];
  const s = t[n];
  n.endsWith("_") && (n = n.substring(0, n.length - 1)), n = n + nS;
  const i = (...r) => {
    G.startScope(n);
    try {
      const o = s(...r);
      return Ca(o) && console.error("Cannot return a Promise inside of tidy."), G.endScope(o), o;
    } catch (o) {
      throw G.endScope(null), o;
    }
  };
  return Object.defineProperty(i, "name", { value: n, configurable: !0 }), i;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OU(t, e) {
  const n = R(t, "real", "complex"), s = R(e, "imag", "complex");
  ws(n.shape, s.shape, `real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);
  const i = { real: n, imag: s };
  return G.runKernel(Tx, i);
}
const Do = /* @__PURE__ */ H({ complex_: OU });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fa(t, e, n, s) {
  if (s == null)
    s = Zc(t);
  else if (s === "complex64")
    throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (qN(t) || jN(t)) {
    if (s !== "float32" && s !== "int32")
      throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);
    return G.backend.createTensorFromGPUData(t, e || n, s);
  }
  if (!os(t) && !Array.isArray(t) && typeof t != "number" && typeof t != "boolean" && typeof t != "string")
    throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  if (e != null) {
    _i(e);
    const i = ue(e), r = ue(n);
    A(i === r, () => `Based on the provided shape, [${e}], the tensor should have ${i} values but has ${r}`);
    for (let o = 0; o < n.length; ++o) {
      const a = n[o], c = o === n.length - 1 ? a !== ue(e.slice(o)) : !0;
      A(n[o] === e[o] || !c, () => `Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `);
    }
  }
  return !os(t) && !Array.isArray(t) && (t = [t]), e = e || n, t = s !== "string" ? La(t, s) : no(t, [], !0), G.makeTensor(t, e, s);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mi(t, e, n) {
  const s = so(t, n);
  return Fa(t, e, s, n);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Fc = {
  float32: 4,
  float16: 2,
  int32: 4,
  uint16: 2,
  uint8: 1,
  bool: 1,
  complex64: 8
};
class Nr {
  /**
   * Concatenate a number of ArrayBuffers into one.
   *
   * @param buffers An array of ArrayBuffers to concatenate, or a single
   *     ArrayBuffer.
   * @returns Result of concatenating `buffers` in order.
   */
  static join(e) {
    return new Nr(e).slice();
  }
  constructor(e) {
    if (this.shards = [], this.previousShardIndex = 0, e == null || (e instanceof Array || (e = [e]), e = e.map((s) => os(s) ? s.buffer : s), e.length === 0))
      return;
    this.bufferUniformSize = e[0].byteLength;
    let n = 0;
    for (let s = 0; s < e.length; s++) {
      const i = e[s];
      s !== e.length - 1 && i.byteLength !== this.bufferUniformSize && (this.bufferUniformSize = void 0);
      const r = n + i.byteLength;
      this.shards.push({ buffer: i, start: n, end: r }), n = r;
    }
    this.shards.length === 0 && (this.byteLength = 0), this.byteLength = this.shards[this.shards.length - 1].end;
  }
  slice(e = 0, n = this.byteLength) {
    if (this.shards.length === 0)
      return new ArrayBuffer(0);
    if (e = isNaN(Number(e)) ? 0 : e, n = isNaN(Number(n)) ? 0 : n, e = Math.max(0, e), n = Math.min(this.byteLength, n), n <= e)
      return new ArrayBuffer(0);
    const s = this.findShardForByte(e);
    if (s === -1)
      throw new Error(`Could not find start shard for byte ${e}`);
    const i = n - e, r = new ArrayBuffer(i), o = new Uint8Array(r);
    let a = 0;
    for (let c = s; c < this.shards.length; c++) {
      const l = this.shards[c], h = e + a - l.start, d = a, p = Math.min(n, l.end) - l.start, y = new Uint8Array(l.buffer, h, p - h);
      if (o.set(y, d), a += y.length, n < l.end)
        break;
    }
    return r;
  }
  /**
   * Get the index of the shard that contains the byte at `byteIndex`.
   */
  findShardForByte(e) {
    if (this.shards.length === 0 || e < 0 || e >= this.byteLength)
      return -1;
    if (this.bufferUniformSize != null)
      return this.previousShardIndex = Math.floor(e / this.bufferUniformSize), this.previousShardIndex;
    function n(i) {
      return e < i.start ? -1 : e >= i.end ? 1 : 0;
    }
    if (n(this.shards[this.previousShardIndex]) === 0)
      return this.previousShardIndex;
    const s = LU(this.shards, n);
    return s === -1 ? -1 : (this.previousShardIndex = s, this.previousShardIndex);
  }
}
function LU(t, e) {
  let n = 0, s = t.length;
  for (; n <= s; ) {
    const i = Math.floor((s - n) / 2) + n, r = e(t[i]);
    if (r === 0)
      return i;
    r < 0 ? s = i : n = i + 1;
  }
  return -1;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FU() {
  ie().set("PROD", !0);
}
function PU() {
  ie().set("DEBUG", !0);
}
function BU() {
  ie().set("DEPRECATION_WARNINGS_ENABLED", !1), console.warn("TensorFlow.js deprecation warnings have been disabled.");
}
function zU(t) {
  ie().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(t + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}
function VU() {
  G.disposeVariables();
}
function ui() {
  return G;
}
function Ly() {
  return G.memory();
}
function UU(t) {
  return G.profile(t);
}
function Q(t, e) {
  return G.tidy(t, e);
}
function At(t) {
  Q1(t).forEach((n) => n.dispose());
}
function Zn(t) {
  return G.keep(t);
}
function GU(t) {
  return G.time(t);
}
function WU(t) {
  return G.setBackend(t);
}
function HU() {
  return G.ready();
}
function C0() {
  return G.backendName;
}
function jU(t) {
  G.removeBackend(t);
}
function qU(t) {
  return G.findBackend(t);
}
function XU(t) {
  return G.findBackendFactory(t);
}
function sS(t, e, n = 1) {
  return G.registerBackend(t, e, n);
}
function Vp() {
  return G.backend;
}
function KU(t, e) {
  ie().setPlatform(t, e);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ia = 4;
async function Gw(t, e) {
  const n = [], s = [], i = Array.isArray(t) ? t.map((o) => o.name) : Object.keys(t);
  for (let o = 0; o < i.length; ++o) {
    const a = i[o], c = Array.isArray(t) ? t[o].tensor : t[a];
    if (c.dtype !== "float32" && c.dtype !== "int32" && c.dtype !== "bool" && c.dtype !== "string" && c.dtype !== "complex64")
      throw new Error(`Unsupported dtype in weight '${a}': ${c.dtype}`);
    const l = { name: a, shape: c.shape, dtype: c.dtype };
    if (c.dtype === "string") {
      const u = new Promise(async (h) => {
        const d = await c.bytes(), f = d.reduce((g, m) => g + m.length, 0) + Ia * d.length, p = new Uint8Array(f);
        let y = 0;
        for (let g = 0; g < d.length; g++) {
          const m = d[g], x = new Uint8Array(new Uint32Array([m.length]).buffer);
          p.set(x, y), y += Ia, p.set(m, y), y += m.length;
        }
        h(p);
      });
      s.push(u);
    } else
      s.push(c.data());
    e != null && (l.group = e), n.push(l);
  }
  const r = await Promise.all(s);
  return { data: JU(r), specs: n };
}
function JN(t, e) {
  const n = new Nr(t), s = {};
  let i = 0;
  for (const r of e) {
    const o = YU(r, (a, c) => n.slice(i + a, i + c));
    s[r.name] = QN(r, n.slice(i, i + o)), i += o;
  }
  return s;
}
function YU(t, e) {
  const n = ue(t.shape);
  let s;
  if ("quantization" in t) {
    const i = t.quantization;
    s = Fc[i.dtype];
  } else if (t.dtype === "string") {
    let i = 0;
    for (let r = 0; r < n; r++)
      i += Ia + new Uint32Array(e(i, i + Ia))[0];
    return i;
  } else
    s = Fc[t.dtype];
  return n * s;
}
async function ZU(t, e) {
  const n = ue(t.shape);
  let s;
  if ("quantization" in t) {
    const i = t.quantization;
    s = Fc[i.dtype];
  } else if (t.dtype === "string") {
    let i = 0;
    for (let r = 0; r < n; r++)
      i += Ia + new Uint32Array(await e(i, i + Ia))[0];
    return i;
  } else
    s = Fc[t.dtype];
  return n * s;
}
function QN(t, e) {
  const n = t.name, s = t.dtype, i = t.shape, r = ue(i);
  let o, a = 0;
  if ("quantization" in t) {
    const c = t.quantization;
    if (c.dtype === "uint8" || c.dtype === "uint16") {
      if (!("min" in c && "scale" in c))
        throw new Error(`Weight ${t.name} with quantization ${c.dtype} doesn't have corresponding metadata min and scale.`);
    } else if (c.dtype === "float16") {
      if (s !== "float32")
        throw new Error(`Weight ${t.name} is quantized with ${c.dtype} which only supports weights of type float32 not ${s}.`);
    } else
      throw new Error(`Weight ${t.name} has unknown quantization dtype ${c.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
    const l = Fc[c.dtype], u = c.dtype === "uint8" ? new Uint8Array(e) : new Uint16Array(e);
    if (s === "float32")
      if (c.dtype === "uint8" || c.dtype === "uint16") {
        o = new Float32Array(u.length);
        for (let h = 0; h < u.length; h++) {
          const d = u[h];
          o[h] = d * c.scale + c.min;
        }
      } else if (c.dtype === "float16")
        o = i4()(u);
      else
        throw new Error(`Unsupported quantization type ${c.dtype} for weight type float32.`);
    else if (s === "int32") {
      if (c.dtype !== "uint8" && c.dtype !== "uint16")
        throw new Error(`Unsupported quantization type ${c.dtype} for weight type int32.`);
      o = new Int32Array(u.length);
      for (let h = 0; h < u.length; h++) {
        const d = u[h];
        o[h] = Math.round(d * c.scale + c.min);
      }
    } else
      throw new Error(`Unsupported dtype in weight '${n}': ${s}`);
    a += r * l;
  } else if (s === "string") {
    const c = ue(t.shape);
    o = [];
    for (let l = 0; l < c; l++) {
      const u = new Uint32Array(e.slice(a, a + Ia))[0];
      a += Ia;
      const h = new Uint8Array(e.slice(a, a + u));
      o.push(h), a += u;
    }
  } else {
    const c = Fc[s];
    if (s === "float32")
      o = new Float32Array(e);
    else if (s === "int32")
      o = new Int32Array(e);
    else if (s === "bool")
      o = new Uint8Array(e);
    else if (s === "complex64") {
      o = new Float32Array(e);
      const l = new Float32Array(o.length / 2), u = new Float32Array(o.length / 2);
      for (let p = 0; p < l.length; p++)
        l[p] = o[p * 2], u[p] = o[p * 2 + 1];
      const h = Mi(l, i, "float32"), d = Mi(u, i, "float32"), f = Do(h, d);
      return h.dispose(), d.dispose(), f;
    } else
      throw new Error(`Unsupported dtype in weight '${n}': ${s}`);
    a += r * c;
  }
  return Mi(o, i, s);
}
async function D2(t, e, n) {
  let s = new Uint8Array(e);
  for (; s.byteLength < n; ) {
    const { done: i, value: r } = await t.read();
    if (i && r == null) {
      const a = n - s.byteLength;
      throw new Error(`Reader is done but ${a} bytes are still expected`);
    }
    const o = new Uint8Array(s.length + r.byteLength);
    o.set(s, 0), o.set(new Uint8Array(r), s.length), s = o;
  }
  return s.buffer;
}
async function ek(t, e) {
  const n = {}, s = t.getReader();
  let i = new ArrayBuffer(0);
  for (const r of e) {
    const o = await ZU(r, async (l, u) => (i = await D2(s, i, u), i.slice(l, u)));
    i = await D2(s, i, o);
    const a = i.slice(0, o);
    i = i.slice(o);
    const c = QN(r, a);
    if (n[r.name] = c, C0() === "webgpu") {
      const l = Vp();
      "uploadToGPU" in l && ue(c.shape) >= ie().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD") && l.uploadToGPU(c.dataId);
    }
  }
  return n;
}
function JU(t) {
  if (t === null)
    throw new Error(`Invalid input value: ${JSON.stringify(t)}`);
  let e = 0;
  const n = [];
  t.forEach((r) => {
    if (e += r.byteLength, n.push(r.byteLength === r.buffer.byteLength ? r : new r.constructor(r)), !(r instanceof Float32Array || r instanceof Int32Array || r instanceof Uint8Array))
      throw new Error(`Unsupported TypedArray subtype: ${r.constructor.name}`);
  });
  const s = new Uint8Array(e);
  let i = 0;
  return n.forEach((r) => {
    s.set(new Uint8Array(r.buffer), i), i += r.byteLength;
  }), s.buffer;
}
const iS = typeof Buffer < "u" && (typeof Blob > "u" || typeof atob > "u" || typeof btoa > "u");
function $2(t) {
  return iS ? Buffer.byteLength(t, "utf8") : new Blob([t]).size;
}
function QU(t) {
  if (iS)
    return Buffer.from(t).toString("base64");
  const e = new Uint8Array(t);
  let n = "";
  for (let s = 0, i = e.length; s < i; s++)
    n += String.fromCharCode(e[s]);
  return btoa(n);
}
function e4(t) {
  if (iS) {
    const s = Buffer.from(t, "base64");
    return s.buffer.slice(s.byteOffset, s.byteOffset + s.byteLength);
  }
  const e = atob(t), n = new Uint8Array(e.length);
  for (let s = 0; s < e.length; ++s)
    n.set([e.charCodeAt(s)], s);
  return n.buffer;
}
function tk(t) {
  return Nr.join(t);
}
function O2(t) {
  const e = "/";
  for (t = t.trim(); t.endsWith(e); )
    t = t.slice(0, t.length - 1);
  const n = t.split(e);
  return n[n.length - 1];
}
function nk(t, e) {
  const n = {
    modelTopology: t.modelTopology,
    format: t.format,
    generatedBy: t.generatedBy,
    convertedBy: t.convertedBy,
    weightsManifest: e
  };
  return t.signature != null && (n.signature = t.signature), t.userDefinedMetadata != null && (n.userDefinedMetadata = t.userDefinedMetadata), t.modelInitializer != null && (n.modelInitializer = t.modelInitializer), t.initializerSignature != null && (n.initializerSignature = t.initializerSignature), t.trainingConfig != null && (n.trainingConfig = t.trainingConfig), n;
}
function sk(t, e, n) {
  const s = {
    modelTopology: t.modelTopology,
    format: t.format,
    generatedBy: t.generatedBy,
    convertedBy: t.convertedBy
  };
  if (t.trainingConfig != null && (s.trainingConfig = t.trainingConfig), t.weightsManifest != null) {
    if (!e)
      throw new Error("modelJSON has weightsManifest but weightSpecs is null");
    if (!n)
      throw new Error("modelJSON has weightsManifest but weightData is null");
    s.weightSpecs = e, s.weightData = n;
  }
  return t.signature != null && (s.signature = t.signature), t.userDefinedMetadata != null && (s.userDefinedMetadata = t.userDefinedMetadata), t.modelInitializer != null && (s.modelInitializer = t.modelInitializer), t.initializerSignature != null && (s.initializerSignature = t.initializerSignature), s;
}
async function rS(t, e) {
  let n, s;
  return t.weightsManifest != null && ([n, s] = await e(t.weightsManifest)), sk(t, n, s);
}
function Up(t) {
  if (t.modelTopology instanceof ArrayBuffer)
    throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return {
    dateSaved: /* @__PURE__ */ new Date(),
    modelTopologyType: "JSON",
    modelTopologyBytes: t.modelTopology == null ? 0 : $2(JSON.stringify(t.modelTopology)),
    weightSpecsBytes: t.weightSpecs == null ? 0 : $2(JSON.stringify(t.weightSpecs)),
    weightDataBytes: t.weightData == null ? 0 : new Nr(t.weightData).byteLength
  };
}
function Ww(t) {
  const e = [];
  for (const n of t)
    e.push(...n.weights);
  return e;
}
function t4() {
  const t = (n) => {
    let s = n << 13, i = 0;
    for (; !(s & 8388608); )
      i -= 8388608, s <<= 1;
    return s &= -8388609, i += 947912704, s | i;
  }, e = new Uint32Array(2048);
  e[0] = 0;
  for (let n = 1; n < 1024; n++)
    e[n] = t(n);
  for (let n = 1024; n < 2048; n++)
    e[n] = 939524096 + (n - 1024 << 13);
  return e;
}
function n4() {
  const t = new Uint32Array(64);
  t[0] = 0, t[31] = 1199570944, t[32] = 2147483648, t[63] = 3347054592;
  for (let e = 1; e < 31; e++)
    t[e] = e << 23;
  for (let e = 33; e < 63; e++)
    t[e] = 2147483648 + (e - 32 << 23);
  return t;
}
function s4() {
  const t = new Uint32Array(64);
  for (let e = 0; e < 64; e++)
    t[e] = 1024;
  return t[0] = t[32] = 0, t;
}
function i4() {
  const t = t4(), e = n4(), n = s4();
  return (s) => {
    const i = new ArrayBuffer(4 * s.length), r = new Uint32Array(i);
    for (let o = 0; o < s.length; o++) {
      const a = s[o], c = t[n[a >> 10] + (a & 1023)] + e[a >> 10];
      r[o] = c;
    }
    return new Float32Array(i);
  };
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class In {
  constructor() {
    this.saveRouters = [], this.loadRouters = [];
  }
  static getInstance() {
    return In.instance == null && (In.instance = new In()), In.instance;
  }
  /**
   * Register a save-handler router.
   *
   * @param saveRouter A function that maps a URL-like string onto an instance
   * of `IOHandler` with the `save` method defined or `null`.
   */
  static registerSaveRouter(e) {
    In.getInstance().saveRouters.push(e);
  }
  /**
   * Register a load-handler router.
   *
   * @param loadRouter A function that maps a URL-like string onto an instance
   * of `IOHandler` with the `load` method defined or `null`.
   */
  static registerLoadRouter(e) {
    In.getInstance().loadRouters.push(e);
  }
  /**
   * Look up IOHandler for saving, given a URL-like string.
   *
   * @param url
   * @returns If only one match is found, an instance of IOHandler with the
   * `save` method defined. If no match is found, `null`.
   * @throws Error, if more than one match is found.
   */
  static getSaveHandlers(e) {
    return In.getHandlers(e, "save");
  }
  /**
   * Look up IOHandler for loading, given a URL-like string.
   *
   * @param url
   * @param loadOptions Optional, custom load options.
   * @returns All valid handlers for `url`, given the currently registered
   *   handler routers.
   */
  static getLoadHandlers(e, n) {
    return In.getHandlers(e, "load", n);
  }
  static getHandlers(e, n, s) {
    const i = [];
    return (n === "load" ? In.getInstance().loadRouters : In.getInstance().saveRouters).forEach((o) => {
      const a = o(e, s);
      a !== null && i.push(a);
    }), i;
  }
}
const r4 = (t) => In.registerSaveRouter(t), o4 = (t) => In.registerLoadRouter(t), ik = (t) => In.getSaveHandlers(t), a4 = (t, e) => In.getLoadHandlers(t, e);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Hw = "tensorflowjs", jw = 1, gc = "models_store", ca = "model_info_store";
function rk() {
  if (!ie().getBool("IS_BROWSER"))
    throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  const t = typeof window > "u" ? self : window, e = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB || t.shimIndexedDB;
  if (e == null)
    throw new Error("The current browser does not appear to support IndexedDB.");
  return e;
}
function qw(t) {
  const e = t.result;
  e.createObjectStore(gc, { keyPath: "modelPath" }), e.createObjectStore(ca, { keyPath: "modelPath" });
}
class Pc {
  constructor(e) {
    if (this.indexedDB = rk(), e == null || !e)
      throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = e;
  }
  async save(e) {
    if (e.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    return this.databaseAction(this.modelPath, e);
  }
  async load() {
    return this.databaseAction(this.modelPath);
  }
  /**
   * Perform database action to put model artifacts into or read model artifacts
   * from IndexedDB object store.
   *
   * Whether the action is put or get depends on whether `modelArtifacts` is
   * specified. If it is specified, the action will be put; otherwise the action
   * will be get.
   *
   * @param modelPath A unique string path for the model.
   * @param modelArtifacts If specified, it will be the model artifacts to be
   *   stored in IndexedDB.
   * @returns A `Promise` of `SaveResult`, if the action is put, or a `Promise`
   *   of `ModelArtifacts`, if the action is get.
   */
  databaseAction(e, n) {
    return new Promise((s, i) => {
      const r = this.indexedDB.open(Hw, jw);
      r.onupgradeneeded = () => qw(r), r.onsuccess = () => {
        const o = r.result;
        if (n == null) {
          const a = o.transaction(gc, "readonly"), l = a.objectStore(gc).get(this.modelPath);
          l.onsuccess = () => {
            if (l.result == null)
              return o.close(), i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
            s(l.result.modelArtifacts);
          }, l.onerror = (u) => (o.close(), i(l.error)), a.oncomplete = () => o.close();
        } else {
          n.weightData = Nr.join(n.weightData);
          const a = Up(n), c = o.transaction(ca, "readwrite");
          let l = c.objectStore(ca), u;
          try {
            u = l.put({ modelPath: this.modelPath, modelArtifactsInfo: a });
          } catch (d) {
            return i(d);
          }
          let h;
          u.onsuccess = () => {
            h = o.transaction(gc, "readwrite");
            const d = h.objectStore(gc);
            let f;
            try {
              f = d.put({
                modelPath: this.modelPath,
                modelArtifacts: n,
                modelArtifactsInfo: a
              });
            } catch (p) {
              return i(p);
            }
            f.onsuccess = () => s({ modelArtifactsInfo: a }), f.onerror = (p) => {
              l = c.objectStore(ca);
              const y = l.delete(this.modelPath);
              y.onsuccess = () => (o.close(), i(f.error)), y.onerror = (g) => (o.close(), i(f.error));
            };
          }, u.onerror = (d) => (o.close(), i(u.error)), c.oncomplete = () => {
            h == null ? o.close() : h.oncomplete = () => o.close();
          };
        }
      }, r.onerror = (o) => i(r.error);
    });
  }
}
Pc.URL_SCHEME = "indexeddb://";
const ok = (t) => ie().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(Pc.URL_SCHEME) ? c4(t.slice(Pc.URL_SCHEME.length)) : null;
In.registerSaveRouter(ok);
In.registerLoadRouter(ok);
function c4(t) {
  return new Pc(t);
}
function l4(t) {
  return t.startsWith(Pc.URL_SCHEME) ? t.slice(Pc.URL_SCHEME.length) : t;
}
class u4 {
  constructor() {
    this.indexedDB = rk();
  }
  async listModels() {
    return new Promise((e, n) => {
      const s = this.indexedDB.open(Hw, jw);
      s.onupgradeneeded = () => qw(s), s.onsuccess = () => {
        const i = s.result, r = i.transaction(ca, "readonly"), a = r.objectStore(ca).getAll();
        a.onsuccess = () => {
          const c = {};
          for (const l of a.result)
            c[l.modelPath] = l.modelArtifactsInfo;
          e(c);
        }, a.onerror = (c) => (i.close(), n(a.error)), r.oncomplete = () => i.close();
      }, s.onerror = (i) => n(s.error);
    });
  }
  async removeModel(e) {
    return e = l4(e), new Promise((n, s) => {
      const i = this.indexedDB.open(Hw, jw);
      i.onupgradeneeded = () => qw(i), i.onsuccess = () => {
        const r = i.result, o = r.transaction(ca, "readwrite"), a = o.objectStore(ca), c = a.get(e);
        let l;
        c.onsuccess = () => {
          if (c.result == null)
            return r.close(), s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));
          {
            const u = a.delete(e), h = () => {
              l = r.transaction(gc, "readwrite");
              const f = l.objectStore(gc).delete(e);
              f.onsuccess = () => n(c.result.modelArtifactsInfo), f.onerror = (p) => s(c.error);
            };
            u.onsuccess = h, u.onerror = (d) => (h(), r.close(), s(c.error));
          }
        }, c.onerror = (u) => (r.close(), s(c.error)), o.oncomplete = () => {
          l == null ? r.close() : l.oncomplete = () => r.close();
        };
      }, i.onerror = (r) => s(i.error);
    });
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Co = "/", Bl = "tensorflowjs_models", ak = "info", h4 = "model_topology", d4 = "weight_specs", f4 = "weight_data", p4 = "model_metadata";
function ck(t) {
  return {
    info: [Bl, t, ak].join(Co),
    topology: [Bl, t, h4].join(Co),
    weightSpecs: [Bl, t, d4].join(Co),
    weightData: [Bl, t, f4].join(Co),
    modelMetadata: [Bl, t, p4].join(Co)
  };
}
function lk(t) {
  for (const e of Object.values(t))
    window.localStorage.removeItem(e);
}
function m4(t) {
  const e = t.split(Co);
  if (e.length < 3)
    throw new Error(`Invalid key format: ${t}`);
  return e.slice(1, e.length - 1).join(Co);
}
function g4(t) {
  return t.startsWith(Bc.URL_SCHEME) ? t.slice(Bc.URL_SCHEME.length) : t;
}
class Bc {
  constructor(e) {
    if (!ie().getBool("IS_BROWSER") || typeof window > "u" || typeof window.localStorage > "u")
      throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, e == null || !e)
      throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = e, this.keys = ck(this.modelPath);
  }
  /**
   * Save model artifacts to browser local storage.
   *
   * See the documentation to `browserLocalStorage` for details on the saved
   * artifacts.
   *
   * @param modelArtifacts The model artifacts to be stored.
   * @returns An instance of SaveResult.
   */
  async save(e) {
    if (e.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    {
      const n = JSON.stringify(e.modelTopology), s = JSON.stringify(e.weightSpecs), i = Up(e), r = Nr.join(e.weightData);
      try {
        this.LS.setItem(this.keys.info, JSON.stringify(i)), this.LS.setItem(this.keys.topology, n), this.LS.setItem(this.keys.weightSpecs, s), this.LS.setItem(this.keys.weightData, QU(r));
        const o = {
          format: e.format,
          generatedBy: e.generatedBy,
          convertedBy: e.convertedBy,
          signature: e.signature != null ? e.signature : void 0,
          userDefinedMetadata: e.userDefinedMetadata != null ? e.userDefinedMetadata : void 0,
          modelInitializer: e.modelInitializer != null ? e.modelInitializer : void 0,
          initializerSignature: e.initializerSignature != null ? e.initializerSignature : void 0,
          trainingConfig: e.trainingConfig != null ? e.trainingConfig : void 0
        };
        return this.LS.setItem(this.keys.modelMetadata, JSON.stringify(o)), { modelArtifactsInfo: i };
      } catch {
        throw lk(this.keys), new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`);
      }
    }
  }
  /**
   * Load a model from local storage.
   *
   * See the documentation to `browserLocalStorage` for details on the saved
   * artifacts.
   *
   * @returns The loaded model (if loading succeeds).
   */
  async load() {
    const e = JSON.parse(this.LS.getItem(this.keys.info));
    if (e == null)
      throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
    if (e.modelTopologyType !== "JSON")
      throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
    const n = {}, s = JSON.parse(this.LS.getItem(this.keys.topology));
    if (s == null)
      throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
    n.modelTopology = s;
    const i = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
    if (i == null)
      throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
    n.weightSpecs = i;
    const r = this.LS.getItem(this.keys.modelMetadata);
    if (r != null) {
      const a = JSON.parse(r);
      n.format = a.format, n.generatedBy = a.generatedBy, n.convertedBy = a.convertedBy, a.signature != null && (n.signature = a.signature), a.userDefinedMetadata != null && (n.userDefinedMetadata = a.userDefinedMetadata), a.modelInitializer != null && (n.modelInitializer = a.modelInitializer), a.initializerSignature != null && (n.initializerSignature = a.initializerSignature), a.trainingConfig != null && (n.trainingConfig = a.trainingConfig);
    }
    const o = this.LS.getItem(this.keys.weightData);
    if (o == null)
      throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
    return n.weightData = e4(o), n;
  }
}
Bc.URL_SCHEME = "localstorage://";
const uk = (t) => ie().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(Bc.URL_SCHEME) ? y4(t.slice(Bc.URL_SCHEME.length)) : null;
In.registerSaveRouter(uk);
In.registerLoadRouter(uk);
function y4(t) {
  return new Bc(t);
}
class x4 {
  constructor() {
    A(ie().getBool("IS_BROWSER"), () => "Current environment is not a web browser"), A(typeof window > "u" || typeof window.localStorage < "u", () => "Current browser does not appear to support localStorage"), this.LS = window.localStorage;
  }
  async listModels() {
    const e = {}, n = Bl + Co, s = Co + ak;
    for (let i = 0; i < this.LS.length; ++i) {
      const r = this.LS.key(i);
      if (r.startsWith(n) && r.endsWith(s)) {
        const o = m4(r);
        e[o] = JSON.parse(this.LS.getItem(r));
      }
    }
    return e;
  }
  async removeModel(e) {
    e = g4(e);
    const n = ck(e);
    if (this.LS.getItem(n.info) == null)
      throw new Error(`Cannot find model at path '${e}'`);
    const s = JSON.parse(this.LS.getItem(n.info));
    return lk(n), s;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Kl = "://";
class Fs {
  constructor() {
    this.managers = {};
  }
  static getInstance() {
    return Fs.instance == null && (Fs.instance = new Fs()), Fs.instance;
  }
  /**
   * Register a save-handler router.
   *
   * @param saveRouter A function that maps a URL-like string onto an instance
   * of `IOHandler` with the `save` method defined or `null`.
   */
  static registerManager(e, n) {
    A(e != null, () => "scheme must not be undefined or null."), e.endsWith(Kl) && (e = e.slice(0, e.indexOf(Kl))), A(e.length > 0, () => "scheme must not be an empty string.");
    const s = Fs.getInstance();
    A(s.managers[e] == null, () => `A model store manager is already registered for scheme '${e}'.`), s.managers[e] = n;
  }
  static getManager(e) {
    const n = Fs.getInstance().managers[e];
    if (n == null)
      throw new Error(`Cannot find model manager for scheme '${e}'`);
    return n;
  }
  static getSchemes() {
    return Object.keys(Fs.getInstance().managers);
  }
}
function zg(t) {
  if (t.indexOf(Kl) === -1)
    throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Fs.getSchemes().join(",")}`);
  return {
    scheme: t.split(Kl)[0],
    path: t.split(Kl)[1]
  };
}
async function hk(t, e, n = !1) {
  A(t !== e, () => `Old path and new path are the same: '${t}'`);
  const s = In.getLoadHandlers(t);
  A(s.length > 0, () => `Copying failed because no load handler is found for source URL ${t}.`), A(s.length < 2, () => `Copying failed because more than one (${s.length}) load handlers for source URL ${t}.`);
  const i = s[0], r = In.getSaveHandlers(e);
  A(r.length > 0, () => `Copying failed because no save handler is found for destination URL ${e}.`), A(r.length < 2, () => `Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);
  const o = r[0], a = zg(t).scheme, c = zg(t).path, l = a === zg(t).scheme, u = await i.load();
  n && l && await Fs.getManager(a).removeModel(c);
  const h = await o.save(u);
  return n && !l && await Fs.getManager(a).removeModel(c), h.modelArtifactsInfo;
}
async function b4() {
  const t = Fs.getSchemes(), e = {};
  for (const n of t) {
    const s = await Fs.getManager(n).listModels();
    for (const i in s) {
      const r = n + Kl + i;
      e[r] = s[i];
    }
  }
  return e;
}
async function v4(t) {
  const e = zg(t);
  return Fs.getManager(e.scheme).removeModel(e.path);
}
async function w4(t, e) {
  return hk(t, e, !1);
}
async function S4(t, e) {
  return hk(t, e, !0);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class _4 {
  constructor() {
    this.messageName = "setTimeoutCustom", this.functionRefs = [], this.handledMessageCount = 0, this.hasEventListener = !1;
  }
  fetch(e, n) {
    return fetch(e, n);
  }
  now() {
    return performance.now();
  }
  encode(e, n) {
    if (n !== "utf-8" && n !== "utf8")
      throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);
    return this.textEncoder == null && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(e);
  }
  decode(e, n) {
    return new TextDecoder(n).decode(e);
  }
  // If the setTimeout nesting level is greater than 5 and timeout is less
  // than 4ms, timeout will be clamped to 4ms, which hurts the perf.
  // Interleaving window.postMessage and setTimeout will trick the browser and
  // avoid the clamp.
  setTimeoutCustom(e, n) {
    if (typeof window > "u" || !ie().getBool("USE_SETTIMEOUTCUSTOM")) {
      setTimeout(e, n);
      return;
    }
    this.functionRefs.push(e), setTimeout(() => {
      window.postMessage({ name: this.messageName, index: this.functionRefs.length - 1 }, "*");
    }, n), this.hasEventListener || (this.hasEventListener = !0, window.addEventListener("message", (s) => {
      if (s.source === window && s.data.name === this.messageName) {
        s.stopPropagation();
        const i = this.functionRefs[s.data.index];
        i(), this.handledMessageCount++, this.handledMessageCount === this.functionRefs.length && (this.functionRefs = [], this.handledMessageCount = 0);
      }
    }, !0));
  }
  isTypedArray(e) {
    return ON(e);
  }
}
if (ie().get("IS_BROWSER")) {
  ie().setPlatform("browser", new _4());
  try {
    Fs.registerManager(Bc.URL_SCHEME, new x4());
  } catch {
  }
  try {
    Fs.registerManager(Pc.URL_SCHEME, new u4());
  } catch {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const T4 = {
  // tslint:disable-next-line:no-require-imports
  importFetch: () => require("node-fetch")
};
let xv;
class C4 {
  constructor() {
    this.util = require("util"), this.textEncoder = new this.util.TextEncoder();
  }
  fetch(e, n) {
    return ie().global.fetch != null ? ie().global.fetch(e, n) : (xv == null && (xv = T4.importFetch()), xv(e, n));
  }
  now() {
    const e = process.hrtime();
    return e[0] * 1e3 + e[1] / 1e6;
  }
  encode(e, n) {
    if (n !== "utf-8" && n !== "utf8")
      throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);
    return this.textEncoder.encode(e);
  }
  decode(e, n) {
    return e.length === 0 ? "" : new this.util.TextDecoder(n).decode(e);
  }
  isTypedArray(e) {
    return this.util.types.isFloat32Array(e) || this.util.types.isInt32Array(e) || this.util.types.isUint8Array(e) || this.util.types.isUint8ClampedArray(e);
  }
}
ie().get("IS_NODE") && !ie().get("IS_BROWSER") && ie().setPlatform("node", new C4());
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function It(t, e = "float32", n) {
  return e = e || "float32", _i(t), new Xn(t, e, n);
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function I4(t, e) {
  const n = R(t, "x", "cast");
  if (!CN(e))
    throw new Error(`Failed to cast to unknown dtype ${e}`);
  if (e === "string" && n.dtype !== "string" || e !== "string" && n.dtype === "string")
    throw new Error("Only strings can be casted to strings");
  const s = { x: n }, i = { dtype: e };
  return G.runKernel(Gu, s, i);
}
const Le = /* @__PURE__ */ H({ cast_: I4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function E4(t) {
  const n = { x: R(t, "x", "clone", "string_or_numeric") };
  return G.runKernel(nh, n);
}
const qr = /* @__PURE__ */ H({ clone_: E4 });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oS(t, e = !1) {
  console.log(t.toString(e));
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
YN();
const N4 = {
  buffer: It,
  cast: Le,
  clone: qr,
  print: oS
};
CU(N4);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function k4(t, e) {
  let n = R(t, "a", "add"), s = R(e, "b", "add");
  [n, s] = kn(n, s);
  const i = { a: n, b: s };
  return G.runKernel(Qc, i);
}
const Se = /* @__PURE__ */ H({ add_: k4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function A4(t, e) {
  let n = R(t, "a", "floorDiv"), s = R(e, "b", "floorDiv");
  [n, s] = kn(n, s);
  const i = { a: n, b: s };
  return G.runKernel(eh, i);
}
const I0 = /* @__PURE__ */ H({ floorDiv_: A4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function M4(t, e) {
  let n = R(t, "a", "div"), s = R(e, "b", "div");
  if ([n, s] = kn(n, s), n.dtype === "int32" && s.dtype === "int32")
    return I0(n, s);
  const i = { a: n, b: s }, r = {};
  return G.runKernel(Xu, i, r);
}
const it = /* @__PURE__ */ H({ div_: M4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R4(t, e) {
  let n = R(t, "a", "mul"), s = R(e, "b", "mul");
  [n, s] = kn(n, s);
  const i = { a: n, b: s };
  return G.runKernel(hh, i);
}
const q = /* @__PURE__ */ H({ mul_: R4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function D4(t) {
  const e = R(t, "x", "abs");
  if (e.dtype === "complex64") {
    const n = { x: e };
    return G.runKernel(jf, n);
  } else {
    const n = { x: e };
    return G.runKernel(Ff, n);
  }
}
const jn = /* @__PURE__ */ H({ abs_: D4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $4(t) {
  const n = { x: R(t, "x", "acos") };
  return G.runKernel(Lu, n);
}
const aS = /* @__PURE__ */ H({ acos_: $4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function O4(t) {
  const n = { x: R(t, "x", "acosh") };
  return G.runKernel(Fu, n);
}
const cS = /* @__PURE__ */ H({ acosh_: O4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function L4(t) {
  A(Array.isArray(t), () => "The argument passed to tf.addN() must be a list of tensors"), A(t.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ${t.length}`);
  const e = t.map((i, r) => R(i, `tensors${r}`, "addN")), n = e[0];
  e.forEach((i) => {
    if (i.dtype !== n.dtype)
      throw new Error("All tensors passed to tf.addN() must have the same dtype");
  }), e.forEach((i) => {
    if (!Bt(i.shape, n.shape))
      throw new Error("All tensors passed to tf.addN() must have the same shape");
  });
  const s = e;
  return G.runKernel(Pf, s);
}
const dk = /* @__PURE__ */ H({ addN_: L4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function F4(t, e = null, n = !1) {
  const i = { x: R(t, "x", "all", "bool") }, r = { axis: e, keepDims: n };
  return G.runKernel(xx, i, r);
}
const E0 = /* @__PURE__ */ H({ all_: F4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function P4(t, e = null, n = !1) {
  const i = { x: R(t, "x", "any", "bool") }, r = { axis: e, keepDims: n };
  return G.runKernel(bx, i, r);
}
const xf = /* @__PURE__ */ H({ any_: P4 });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function B4(t, e = 0) {
  const s = { x: R(t, "x", "argMax") }, i = { axis: e };
  return G.runKernel(Bf, s, i);
}
const Ea = /* @__PURE__ */ H({ argMax_: B4 });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function z4(t, e = 0) {
  const s = { x: R(t, "x", "argMin") }, i = { axis: e };
  return G.runKernel(zf, s, i);
}
const lS = /* @__PURE__ */ H({ argMin_: z4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function V4(t) {
  const n = { x: R(t, "x", "asin") };
  return G.runKernel(Pu, n);
}
const uS = /* @__PURE__ */ H({ asin_: V4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function U4(t) {
  const n = { x: R(t, "x", "asinh") };
  return G.runKernel(Bu, n);
}
const hS = /* @__PURE__ */ H({ asinh_: U4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function G4(t) {
  const n = { x: R(t, "x", "atan") };
  return G.runKernel(zu, n);
}
const dS = /* @__PURE__ */ H({ atan_: G4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function W4(t, e) {
  let n = R(t, "a", "atan2"), s = R(e, "b", "atan2");
  [n, s] = kn(n, s);
  const i = { a: n, b: s };
  return G.runKernel(Uu, i);
}
const fS = /* @__PURE__ */ H({ atan2_: W4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function H4(t) {
  const n = { x: R(t, "x", "atanh") };
  return G.runKernel(Vu, n);
}
const pS = /* @__PURE__ */ H({ atanh_: H4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Gp(t, e, n, s, i = "NHWC", r) {
  const o = t[3], a = [...e, o], c = Go(i);
  return hs(t, a, n, r, s, null, null, c);
}
function ir(t, e, n, s, i, r, o = "channelsLast") {
  const [a, c] = bf(e);
  let l;
  if (o === "channelsLast")
    l = [a, c, t[3], t[3]];
  else if (o === "channelsFirst")
    l = [a, c, t[1], t[1]];
  else
    throw new Error(`Unknown dataFormat ${o}`);
  return hs(t, l, n, s, i, r, !1, o);
}
function Uo(t, e, n, s, i, r, o = "NDHWC") {
  const [a, c, l] = Xw(e);
  let u, h;
  if (o === "NDHWC")
    h = "channelsLast", u = [a, c, l, t[4], t[4]];
  else if (o === "NCDHW")
    h = "channelsFirst", u = [a, c, l, t[1], t[1]];
  else
    throw new Error(`Unknown dataFormat ${o}`);
  return Pa(t, u, n, s, i, !1, h, r);
}
function hs(t, e, n, s, i, r, o = !1, a = "channelsLast") {
  let [c, l, u, h] = [-1, -1, -1, -1];
  if (a === "channelsLast")
    [c, l, u, h] = t;
  else if (a === "channelsFirst")
    [c, h, l, u] = t;
  else
    throw new Error(`Unknown dataFormat ${a}`);
  const [d, f, , p] = e, [y, g] = bf(n), [m, x] = bf(s), v = Yl(d, m), b = Yl(f, x), { padInfo: w, outHeight: S, outWidth: _ } = X4(i, l, u, y, g, v, b, r, a), E = o ? p * h : p;
  let I;
  return a === "channelsFirst" ? I = [c, E, S, _] : a === "channelsLast" && (I = [c, S, _, E]), {
    batchSize: c,
    dataFormat: a,
    inHeight: l,
    inWidth: u,
    inChannels: h,
    outHeight: S,
    outWidth: _,
    outChannels: E,
    padInfo: w,
    strideHeight: y,
    strideWidth: g,
    filterHeight: d,
    filterWidth: f,
    effectiveFilterHeight: v,
    effectiveFilterWidth: b,
    dilationHeight: m,
    dilationWidth: x,
    inShape: t,
    outShape: I,
    filterShape: e
  };
}
function Pa(t, e, n, s, i, r = !1, o = "channelsLast", a) {
  let [c, l, u, h, d] = [-1, -1, -1, -1, -1];
  if (o === "channelsLast")
    [c, l, u, h, d] = t;
  else if (o === "channelsFirst")
    [c, d, l, u, h] = t;
  else
    throw new Error(`Unknown dataFormat ${o}`);
  const [f, p, y, , g] = e, [m, x, v] = Xw(n), [b, w, S] = Xw(s), _ = Yl(f, b), E = Yl(p, w), I = Yl(y, S), { padInfo: k, outDepth: M, outHeight: L, outWidth: O } = K4(i, l, u, h, m, x, v, _, E, I, a), $ = r ? g * d : g;
  let D;
  return o === "channelsFirst" ? D = [c, $, M, L, O] : o === "channelsLast" && (D = [c, M, L, O, $]), {
    batchSize: c,
    dataFormat: o,
    inDepth: l,
    inHeight: u,
    inWidth: h,
    inChannels: d,
    outDepth: M,
    outHeight: L,
    outWidth: O,
    outChannels: $,
    padInfo: k,
    strideDepth: m,
    strideHeight: x,
    strideWidth: v,
    filterDepth: f,
    filterHeight: p,
    filterWidth: y,
    effectiveFilterDepth: _,
    effectiveFilterHeight: E,
    effectiveFilterWidth: I,
    dilationDepth: b,
    dilationHeight: w,
    dilationWidth: S,
    inShape: t,
    outShape: D,
    filterShape: e
  };
}
function j4(t, e, n, s, i) {
  s == null && (s = mS(t, e, n));
  const r = t[0], o = t[1], a = vf((r - e + 2 * s) / n + 1, i), c = vf((o - e + 2 * s) / n + 1, i);
  return [a, c];
}
function q4(t, e, n, s, i, r) {
  i == null && (i = mS(t, e[0], s[0]));
  const o = [0, 0, 0, n];
  for (let a = 0; a < 3; a++)
    t[a] + 2 * i >= e[a] && (o[a] = vf((t[a] - e[a] + 2 * i) / s[a] + 1, r));
  return o;
}
function mS(t, e, n, s = 1) {
  const i = Yl(e, s);
  return Math.floor((t[0] * (n - 1) - n + i) / 2);
}
function bf(t) {
  return typeof t == "number" ? [t, t, t] : t.length === 2 ? [t[0], t[1], 1] : t;
}
function Xw(t) {
  return typeof t == "number" ? [t, t, t] : t;
}
function Yl(t, e) {
  return e <= 1 ? t : t + (t - 1) * (e - 1);
}
function X4(t, e, n, s, i, r, o, a, c) {
  let l, u, h;
  if (typeof t == "number") {
    l = { top: t, bottom: t, left: t, right: t, type: t === 0 ? "VALID" : "NUMBER" };
    const f = j4([e, n], r, s, t, a);
    u = f[0], h = f[1];
  } else if (t === "same") {
    u = Math.ceil(e / s), h = Math.ceil(n / i);
    const d = Math.max(0, (u - 1) * s + r - e), f = Math.max(0, (h - 1) * i + o - n), p = Math.floor(d / 2), y = d - p, g = Math.floor(f / 2), m = f - g;
    l = { top: p, bottom: y, left: g, right: m, type: "SAME" };
  } else if (t === "valid")
    l = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }, u = Math.ceil((e - r + 1) / s), h = Math.ceil((n - o + 1) / i);
  else if (typeof t == "object") {
    const d = c === "channelsLast" ? t[1][0] : t[2][0], f = c === "channelsLast" ? t[1][1] : t[2][1], p = c === "channelsLast" ? t[2][0] : t[3][0], y = c === "channelsLast" ? t[2][1] : t[3][1];
    l = { top: d, bottom: f, left: p, right: y, type: d === 0 && f === 0 && p === 0 && y === 0 ? "VALID" : "EXPLICIT" }, u = vf((e - r + d + f) / s + 1, a), h = vf((n - o + p + y) / i + 1, a);
  } else
    throw Error(`Unknown padding parameter: ${t}`);
  return { padInfo: l, outHeight: u, outWidth: h };
}
function K4(t, e, n, s, i, r, o, a, c, l, u) {
  let h, d, f, p;
  if (t === "valid" && (t = 0), typeof t == "number") {
    h = {
      top: t,
      bottom: t,
      left: t,
      right: t,
      front: t,
      back: t,
      type: t === 0 ? "VALID" : "NUMBER"
    };
    const g = q4([e, n, s, 1], [a, c, l], 1, [i, r, o], t, u);
    d = g[0], f = g[1], p = g[2];
  } else if (t === "same") {
    d = Math.ceil(e / i), f = Math.ceil(n / r), p = Math.ceil(s / o);
    const y = (d - 1) * i + a - e, g = (f - 1) * r + c - n, m = (p - 1) * o + l - s, x = Math.floor(y / 2), v = y - x, b = Math.floor(g / 2), w = g - b, S = Math.floor(m / 2), _ = m - S;
    h = { top: b, bottom: w, left: S, right: _, front: x, back: v, type: "SAME" };
  } else
    throw Error(`Unknown padding parameter: ${t}`);
  return { padInfo: h, outDepth: d, outHeight: f, outWidth: p };
}
function vf(t, e) {
  if (!e)
    return Math.trunc(t);
  switch (e) {
    case "round":
      return Math.round(t);
    case "ceil":
      return Math.ceil(t);
    case "floor":
      return Math.floor(t);
    default:
      throw new Error(`Unknown roundingMode ${e}`);
  }
}
function Na(t) {
  const [e, n, s] = bf(t);
  return e === 1 && n === 1 && s === 1;
}
function Ss(t, e) {
  return Na(t) || Na(e);
}
function zc(t) {
  return bf(t).every((e) => e > 0);
}
function Go(t) {
  if (t === "NHWC")
    return "channelsLast";
  if (t === "NCHW")
    return "channelsFirst";
  throw new Error(`Unknown dataFormat ${t}`);
}
function Hs(t, e, n) {
  if (n != null) {
    if (typeof e == "string")
      throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);
    if (typeof e == "number")
      A(Lc(e), () => `Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);
    else if (typeof e == "object")
      e.forEach((s) => {
        s.forEach((i) => {
          A(Lc(i), () => `Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${i}.`);
        });
      });
    else
      throw Error(`Error in ${t}: Unknown padding parameter: ${e}`);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Y4(t, e) {
  const s = { x: R(t, "x", "reshape", "string_or_numeric") }, i = { shape: e };
  return G.runKernel(Ip, s, i);
}
const Y = /* @__PURE__ */ H({ reshape_: Y4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Z4(t, e, n, s, i) {
  const r = R(t, "x", "avgPool", "float32"), o = 1;
  A(Ss(n, o), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);
  let a = r, c = !1;
  r.rank === 3 && (c = !0, a = Y(r, [1, r.shape[0], r.shape[1], r.shape[2]])), A(a.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${a.rank}.`), Hs("avgPool", s, i);
  const l = { x: a }, u = { filterSize: e, strides: n, pad: s, dimRoundingMode: i };
  let h = G.runKernel(Vf, l, u);
  return h = Le(h, r.dtype), c ? Y(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
}
const Wp = /* @__PURE__ */ H({ avgPool_: Z4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function J4(t, e, n, s, i, r = "NDHWC") {
  const o = R(t, "x", "avgPool3d", "float32");
  let a = o, c = !1;
  o.rank === 4 && (c = !0, a = Y(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), A(a.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`), A(r === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`), A(typeof n == "number" && n > 0 || Array.isArray(n) && n[0] > 0 && n[1] > 0 && n[2] > 0, () => `Error in avgPool3d: Stride must be > 0, but got '${n}'`), Hs("avgPool3d", s, i);
  const l = { x: a }, u = { filterSize: e, strides: n, pad: s, dimRoundingMode: i, dataFormat: r };
  let h = G.runKernel(Uf, l, u);
  return h = Le(h, a.dtype), c ? Y(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h;
}
const gS = /* @__PURE__ */ H({ avgPool3d_: J4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Q4(t, e = 0) {
  A(t.length >= 1, () => "Pass at least one tensor to concat");
  const n = yf(t, "tensors", "concat", "string_or_numeric");
  if (n[0].dtype === "complex64" && n.forEach((r) => {
    if (r.dtype !== "complex64")
      throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${r.dtype}. `);
  }), n.length === 1)
    return qr(n[0]);
  const s = n, i = { axis: e };
  return G.runKernel(qf, s, i);
}
const Pn = /* @__PURE__ */ H({ concat_: Q4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eG(t, e, n = !1, s = !1) {
  let i = R(t, "a", "matMul"), r = R(e, "b", "matMul");
  [i, r] = kn(i, r);
  const o = { a: i, b: r }, a = { transposeA: n, transposeB: s };
  return G.runKernel(Gf, o, a);
}
const Tt = /* @__PURE__ */ H({ matMul_: eG });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tG(t) {
  const n = { x: R(t, "x", "sigmoid", "float32") };
  return G.runKernel(Sh, n);
}
const mi = /* @__PURE__ */ H({ sigmoid_: tG });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nG(t, e, n) {
  const s = R(t, "x", "slice", "string_or_numeric");
  if (s.rank === 0)
    throw new Error("Slicing scalar is not possible");
  const i = { x: s }, r = { begin: e, size: n };
  return G.runKernel(Mp, i, r);
}
const Pt = /* @__PURE__ */ H({ slice_: nG });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sG(t) {
  const n = { x: R(t, "x", "tanh", "float32") };
  return G.runKernel(Nh, n);
}
const ka = /* @__PURE__ */ H({ tanh_: sG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iG(t, e, n, s, i, r) {
  const o = R(t, "forgetBias", "basicLSTMCell"), a = R(e, "lstmKernel", "basicLSTMCell"), c = R(n, "lstmBias", "basicLSTMCell"), l = R(s, "data", "basicLSTMCell"), u = R(i, "c", "basicLSTMCell"), h = R(r, "h", "basicLSTMCell"), d = Pn([l, h], 1), f = Tt(d, a), p = Se(f, c), y = p.shape[0], g = p.shape[1] / 4, m = [y, g], x = Pt(p, [0, 0], m), v = Pt(p, [0, g], m), b = Pt(p, [0, g * 2], m), w = Pt(p, [0, g * 3], m), S = Se(q(mi(x), ka(v)), q(u, mi(Se(o, b)))), _ = q(ka(S), mi(w));
  return [S, _];
}
const fk = /* @__PURE__ */ H({ basicLSTMCell_: iG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rG(t, e, n) {
  const s = R(t, "x", "batchToSpaceND"), i = e.reduce((a, c) => a * c);
  A(s.rank >= 1 + e.length, () => `input rank is ${s.rank} but should be > than blockShape.length ${e.length}`), A(n.length === e.length, () => `crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`), A(s.shape[0] % i === 0, () => `input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);
  const r = { x: s }, o = { blockShape: e, crops: n };
  return G.runKernel(Wf, r, o);
}
const Hp = /* @__PURE__ */ H({ batchToSpaceND_: rG });
function oG(t) {
  let e;
  return t.rank === 0 || t.rank === 1 ? e = Y(t, [1, 1, 1, t.size]) : t.rank === 2 ? e = Y(t, [1, 1, t.shape[0], t.shape[1]]) : t.rank === 3 ? e = Y(t, [1, t.shape[0], t.shape[1], t.shape[2]]) : e = t, e;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aG(t, e, n, s, i, r) {
  r == null && (r = 1e-3);
  const o = R(t, "x", "batchNorm"), a = R(e, "mean", "batchNorm"), c = R(n, "variance", "batchNorm");
  let l;
  i != null && (l = R(i, "scale", "batchNorm"));
  let u;
  s != null && (u = R(s, "offset", "batchNorm")), A(a.rank === c.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks."), A(u == null || a.rank === u.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks."), A(l == null || a.rank === l.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
  const d = {
    x: oG(o),
    scale: l,
    offset: u,
    mean: a,
    variance: c
  }, f = { varianceEpsilon: r }, p = G.runKernel(np, d, f);
  return Y(p, o.shape);
}
const Mh = /* @__PURE__ */ H({ batchNorm_: aG });
function cG(t, e, n, s, i, r) {
  const o = R(t, "x", "batchNorm"), a = R(e, "mean", "batchNorm"), c = R(n, "variance", "batchNorm");
  let l;
  i != null && (l = R(i, "scale", "batchNorm"));
  let u;
  return s != null && (u = R(s, "offset", "batchNorm")), A(o.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`), A(a.rank === 2 || a.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`), A(c.rank === 2 || c.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`), l != null && A(l.rank === 2 || l.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`), u != null && A(u.rank === 2 || u.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`), Mh(o, a, c, u, l, r);
}
const yS = /* @__PURE__ */ H({ batchNorm2d_: cG });
function lG(t, e, n, s, i, r) {
  const o = R(t, "x", "batchNorm"), a = R(e, "mean", "batchNorm"), c = R(n, "variance", "batchNorm");
  let l;
  i != null && (l = R(i, "scale", "batchNorm"));
  let u;
  return s != null && (u = R(s, "offset", "batchNorm")), A(o.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`), A(a.rank === 3 || a.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`), A(c.rank === 3 || c.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`), l != null && A(l.rank === 3 || l.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`), u != null && A(u.rank === 3 || u.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`), Mh(o, a, c, u, l, r);
}
const xS = /* @__PURE__ */ H({ batchNorm3d_: lG });
function uG(t, e, n, s, i, r) {
  const o = R(t, "x", "batchNorm"), a = R(e, "mean", "batchNorm"), c = R(n, "variance", "batchNorm");
  let l;
  i != null && (l = R(i, "scale", "batchNorm"));
  let u;
  return s != null && (u = R(s, "offset", "batchNorm")), A(o.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`), A(a.rank === 4 || a.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`), A(c.rank === 4 || c.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`), l != null && A(l.rank === 4 || l.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`), u != null && A(u.rank === 4 || u.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`), Mh(o, a, c, u, l, r);
}
const bS = /* @__PURE__ */ H({ batchNorm4d_: uG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hG(t, e, n) {
  const s = R(t, "x", "bincount"), i = R(e, "weights", "bincount");
  A(s.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${s.dtype}`), A(n >= 0, () => `size must be non-negative, but got ${n}.`), A(i.size === s.size || i.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);
  const r = { x: s, weights: i }, o = { size: n };
  return G.runKernel(Sx, r, o);
}
const vS = /* @__PURE__ */ H({ bincount_: hG });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dG(t, e) {
  const n = R(t, "x", "bitwiseAnd"), s = R(e, "y", "bitwiseAnd");
  if (!Bt(n.shape, s.shape))
    throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${s.shape}`);
  if (n.dtype !== "int32" || s.dtype !== "int32")
    throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${s.dtype}`);
  const i = { a: n, b: s };
  return G.runKernel(Hf, i);
}
const pk = /* @__PURE__ */ H({ bitwiseAnd_: dG });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fG(t, e) {
  const n = R(t, "s0", "broadcastArgs", "int32"), s = R(e, "s1", "broadcastArgs", "int32");
  if (n.rank !== 1)
    throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);
  if (s.rank !== 1)
    throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);
  const i = { s0: n, s1: s };
  return G.runKernel(_x, i);
}
const mk = /* @__PURE__ */ H({ broadcastArgs_: fG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pG(t, e) {
  let n = R(t, "broadcastTo", "x");
  const s = n.shape;
  if (_i(e), e.length < n.rank)
    throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);
  if (e.length > n.rank) {
    const l = n.shape.slice();
    for (; l.length < e.length; )
      l.unshift(1);
    n = Y(n, l);
  }
  const i = n.shape, r = Array.from(e);
  for (let l = e.length - 1; l >= 0; l--)
    if (i[l] === e[l])
      r[l] = 1;
    else if (n.shape[l] !== 1)
      throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);
  if (r.map((l, u) => l > 1 ? u : -1).filter((l) => l >= 0).length === 0)
    return qr(n);
  const a = { x: n }, c = { reps: r };
  return G.runKernel(kh, a, c);
}
const Sc = /* @__PURE__ */ H({ broadcastTo_: pG });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mG(t) {
  const n = { x: R(t, "x", "ceil", "float32") };
  return G.runKernel(Wu, n);
}
const wS = /* @__PURE__ */ H({ ceil_: mG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nl(t, e, n) {
  _i(t), n = n || Zc(e);
  const s = { shape: t, value: e, dtype: n };
  return G.runKernel(Bx, {}, s);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gG(t, e, n) {
  const s = R(t, "x", "clipByValue");
  if (A(e <= n, () => `Error in clip: min (${e}) must be less than or equal to max (${n}).`), e === n)
    return nl(s.shape, e, s.dtype);
  const i = { x: s }, r = { clipValueMin: e, clipValueMax: n };
  return G.runKernel(Hu, i, r);
}
const Gs = /* @__PURE__ */ H({ clipByValue_: gG });
function yG(t) {
  return Pn(
    t,
    0
    /* axis */
  );
}
const SS = /* @__PURE__ */ H({ concat1d_: yG });
function xG(t, e) {
  return Pn(t, e);
}
const _S = /* @__PURE__ */ H({ concat2d_: xG });
function bG(t, e) {
  return Pn(t, e);
}
const TS = /* @__PURE__ */ H({ concat3d_: bG });
function vG(t, e) {
  return Pn(t, e);
}
const CS = /* @__PURE__ */ H({ concat4d_: vG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wG(t, e, n, s, i = "NHWC", r = [1, 1], o) {
  const a = R(t, "x", "conv2d", "float32"), c = R(e, "filter", "conv2d", "float32");
  let l = a, u = !1;
  a.rank === 3 && (u = !0, l = Y(a, [1, a.shape[0], a.shape[1], a.shape[2]])), A(l.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${l.rank}.`), A(c.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`), Hs("conv2d", s, o);
  const h = i === "NHWC" ? l.shape[3] : l.shape[1];
  A(h === c.shape[2], () => `Error in conv2d: depth of input (${h}) must match input depth for filter ${c.shape[2]}.`), A(Ss(n, r), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${r}'`), A(zc(r), () => "Error in conv2D: Dilated rates should be larger than 0."), A(zc(n), () => "Error in conv2D: Strides should be larger than 0.");
  const d = { x: l, filter: c }, f = { strides: n, pad: s, dataFormat: i, dilations: r, dimRoundingMode: o }, p = G.runKernel(Xf, d, f);
  return u ? Y(p, [p.shape[1], p.shape[2], p.shape[3]]) : p;
}
const $o = /* @__PURE__ */ H({ conv2d_: wG });
function SG(t, e, n, s, i = "NWC", r = 1, o) {
  const a = R(t, "x", "conv1d"), c = R(e, "filter", "conv1d");
  let l = a, u = !1;
  a.rank === 2 && (u = !0, l = Y(a, [1, a.shape[0], a.shape[1]])), A(l.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${l.rank}.`), A(c.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`), Hs("conv1d", s, o), A(l.shape[2] === c.shape[1], () => `Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${c.shape[1]}.`), A(Ss(n, r), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${r}'`), A(zc(r), () => "Error in conv1D: Dilated rates should be larger than 0."), A(zc(n), () => "Error in conv1D: Stride should be larger than 0."), A(i === "NWC", () => `Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);
  const h = Y(c, [1, c.shape[0], c.shape[1], c.shape[2]]), d = Y(l, [l.shape[0], 1, l.shape[1], l.shape[2]]), g = $o(d, h, [1, n], s, "NHWC", [1, r], o);
  return u ? Y(g, [g.shape[2], g.shape[3]]) : Y(g, [g.shape[0], g.shape[2], g.shape[3]]);
}
const N0 = /* @__PURE__ */ H({ conv1d_: SG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _G(t, e, n, s, i, r = "NHWC", o) {
  A(t.length === e.rank, () => `Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);
  let a = t, c = e, l = !1;
  e.rank === 3 && (l = !0, c = Y(e, [1, e.shape[0], e.shape[1], e.shape[2]]), a = [1, t[0], t[1], t[2]]), A(a.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`), A(c.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`), A(n.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);
  const u = r === "NHWC" ? a[3] : a[1], h = r === "NHWC" ? c.shape[3] : c.shape[1];
  A(u === n.shape[2], () => `Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`), A(h === n.shape[3], () => `Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`), Hs("conv2dDerInput", i, o);
  const d = { dy: c, filter: n }, f = { strides: s, pad: i, dataFormat: r, dimRoundingMode: o, inputShape: a }, p = G.runKernel(Kf, d, f);
  return l ? Y(p, [p.shape[1], p.shape[2], p.shape[3]]) : p;
}
const IS = /* @__PURE__ */ H({ conv2DBackpropInput_: _G });
function TG(t, e, n, s, i, r) {
  const o = R(t, "x", "conv2dTranspose"), a = R(e, "filter", "conv2dTranspose");
  return IS(n, o, a, s, i, "NHWC", r);
}
const k0 = /* @__PURE__ */ H({ conv2dTranspose_: TG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function CG(t, e, n, s, i = "NDHWC", r = [1, 1, 1]) {
  const o = R(t, "x", "conv3d"), a = R(e, "filter", "conv3d");
  let c = o, l = !1;
  o.rank === 4 && (l = !0, c = Y(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), A(c.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${c.rank}.`), A(a.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`), A(c.shape[4] === a.shape[3], () => `Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${a.shape[3]}.`), A(Ss(n, r), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${r}'`), A(i === "NDHWC", () => `Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`), A(zc(r), () => "Error in conv3D: Dilated rates should be larger than 0."), A(zc(n), () => "Error in conv3D: Strides should be larger than 0.");
  const u = { x: c, filter: a }, h = { strides: n, pad: s, dataFormat: i, dilations: r }, d = G.runKernel(Yf, u, h);
  return l ? Y(d, [d.shape[1], d.shape[2], d.shape[3], d.shape[4]]) : d;
}
const ES = /* @__PURE__ */ H({ conv3d_: CG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function IG(t, e, n, s, i) {
  A(t.length === e.rank, () => `Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);
  let r = t, o = e, a = !1;
  e.rank === 4 && (a = !0, o = Y(e, [1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]]), r = [1, t[0], t[1], t[2], t[3]]);
  const c = r[4], l = o.shape[4];
  A(r.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${r.length}.`), A(o.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`), A(n.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`), A(c === n.shape[3], () => `Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[3]}.`), A(l === n.shape[4], () => `Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`);
  const u = { dy: o, filter: n }, h = { pad: i, strides: s, inputShape: r }, d = G.runKernel(Ex, u, h);
  return a ? Y(d, [d.shape[1], d.shape[2], d.shape[3], d.shape[4]]) : d;
}
const gk = /* @__PURE__ */ H({ conv3DBackpropInput_: IG });
function EG(t, e, n, s, i) {
  const r = R(t, "x", "conv3dTranspose"), o = R(e, "filter", "conv3dTranspose");
  return gk(n, r, o, s, i);
}
const NS = /* @__PURE__ */ H({ conv3dTranspose_: EG });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NG(t) {
  const n = { x: R(t, "x", "cos", "float32") };
  return G.runKernel(ju, n);
}
const jp = /* @__PURE__ */ H({ cos_: NG });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kG(t) {
  const n = { x: R(t, "x", "cosh", "float32") };
  return G.runKernel(qu, n);
}
const A0 = /* @__PURE__ */ H({ cosh_: kG });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function AG(t, e = 0, n = !1, s = !1) {
  const r = { x: R(t, "x", "cumprod") }, o = { axis: e, exclusive: n, reverse: s };
  return G.runKernel(Nx, r, o);
}
const wf = /* @__PURE__ */ H({ cumprod_: AG });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function MG(t, e = 0, n = !1, s = !1) {
  const r = { x: R(t, "x", "cumsum") }, o = { axis: e, exclusive: n, reverse: s };
  return G.runKernel(Zf, r, o);
}
const M0 = /* @__PURE__ */ H({ cumsum_: MG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function RG(t, e, n, s = !1) {
  const i = R(t, "x", "denseBincount"), r = R(e, "weights", "denseBincount");
  A(i.dtype === "int32", () => `Error in denseBincount: input dtype must be int32, but got ${i.dtype}`), A(i.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`), A(n >= 0, () => `size must be non-negative, but got ${n}.`), A(r.size === i.size || r.size === 0, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${r.shape}.`);
  const o = { x: i, weights: r }, a = { size: n, binaryOutput: s };
  return G.runKernel(Ax, o, a);
}
const Fy = /* @__PURE__ */ H({ denseBincount_: RG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DG(t, e, n = "NHWC") {
  const s = R(t, "x", "depthToSpace", "float32"), i = n === "NHWC" ? s.shape[1] : s.shape[2], r = n === "NHWC" ? s.shape[2] : s.shape[3], o = n === "NHWC" ? s.shape[3] : s.shape[1];
  A(e > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${e}`), A(i * e >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${s.shape}`), A(r * e >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${r} and ${e} for depthToSpace with input shape
        ${s.shape}`), A(o % (e * e) === 0, () => `Dimension size must be evenly divisible by ${e * e} but is ${o} for depthToSpace with input shape ${s.shape}`);
  const a = { x: s }, c = { blockSize: e, dataFormat: n };
  return G.runKernel(Mx, a, c);
}
const kS = /* @__PURE__ */ H({ depthToSpace_: DG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $G(t, e, n, s, i = "NHWC", r = [1, 1], o) {
  const a = R(t, "x", "depthwiseConv2d", "float32"), c = R(e, "filter", "depthwiseConv2d", "float32");
  let l = a, u = !1;
  a.rank === 3 && (u = !0, l = Y(a, [1, a.shape[0], a.shape[1], a.shape[2]])), A(l.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`), A(c.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);
  const h = i === "NHWC" ? l.shape[3] : l.shape[1];
  A(h === c.shape[2], () => `Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${c.shape[2]}.`), Hs("depthwiseConv2d", s, o);
  const d = { x: l, filter: c }, f = { strides: n, pad: s, dataFormat: i, dilations: r, dimRoundingMode: o }, p = G.runKernel(Jf, d, f);
  return u ? Y(p, [p.shape[1], p.shape[2], p.shape[3]]) : p;
}
const Rh = /* @__PURE__ */ H({ depthwiseConv2d_: $G });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OG(t) {
  const n = { x: R(t, "x", "diag") };
  return G.runKernel($x, n);
}
const yk = /* @__PURE__ */ H({ diag_: OG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LG(t, e, n, s, i = [1, 1], r = "NHWC") {
  const o = R(t, "x", "dilation2d"), a = R(e, "filter", "dilation2d");
  A(o.rank === 3 || o.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`), A(a.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`), A(r === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${r}`);
  let c = o, l = !1;
  o.rank === 3 && (c = Y(o, [1, o.shape[0], o.shape[1], o.shape[2]]), l = !0), A(c.shape[3] === a.shape[2], () => `Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${a.shape[2]}`);
  const u = { x: c, filter: a }, h = { strides: n, pad: s, dilations: i }, d = G.runKernel(Qf, u, h);
  return l ? Y(d, [d.shape[1], d.shape[2], d.shape[3]]) : d;
}
const AS = /* @__PURE__ */ H({ dilation2d_: LG });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Vc(t, e) {
  const n = t.length, s = [];
  for (let i = 0; i < n; i++) {
    const r = n - 1 - i, o = t[r] || 1;
    (e[e.length - 1 - i] || 1) > 1 && o === 1 && s.unshift(r);
  }
  return s;
}
function Kn(t, e) {
  const n = [];
  for (let s = 0; s < e.length; s++) {
    const i = t[t.length - s - 1], r = e.length - s - 1, o = e[r];
    (i == null || i === 1 && o > 1) && n.unshift(r);
  }
  return n;
}
function bt(t, e) {
  const n = Math.max(t.length, e.length), s = new Array(n);
  for (let i = 0; i < n; i++) {
    let r = t[t.length - i - 1];
    r == null && (r = 1);
    let o = e[e.length - i - 1];
    if (o == null && (o = 1), r === 1)
      s[n - i - 1] = o;
    else if (o === 1)
      s[n - i - 1] = r;
    else if (r !== o) {
      const a = `Operands could not be broadcast together with shapes ${t} and ${e}.`;
      throw Error(a);
    } else
      s[n - i - 1] = r;
  }
  return s;
}
const FG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assertAndGetBroadcastShape: bt,
  getBroadcastDims: Vc,
  getReductionAxes: Kn
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PG(t, e) {
  let n = R(t, "a", "equal", "string_or_numeric"), s = R(e, "b", "equal", "string_or_numeric");
  [n, s] = kn(n, s), bt(n.shape, s.shape);
  const i = { a: n, b: s };
  return G.runKernel(ep, i);
}
const xi = /* @__PURE__ */ H({ equal_: PG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BG(t, e, n) {
  const s = R(e, "a", "where"), i = R(n, "b", "where"), r = R(t, "condition", "where", "bool"), o = bt(bt(r.shape, s.shape), i.shape), a = Sc(r, o), c = Sc(s, o), l = Sc(i, o), u = {
    condition: a,
    t: c,
    e: l
  };
  return G.runKernel(Ap, u);
}
const bs = /* @__PURE__ */ H({ where_: BG });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zG(t) {
  const n = { x: R(t, "x", "zerosLike") };
  return G.runKernel(Bp, n);
}
const Ut = /* @__PURE__ */ H({ zerosLike_: zG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VG(t, e) {
  let n = R(t, "a", "div"), s = R(e, "b", "div");
  [n, s] = kn(n, s);
  const i = it(n, s), r = Ut(i), o = xi(s, r);
  return bs(o, r, i);
}
const MS = /* @__PURE__ */ H({ divNoNan_: VG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UG(t, e) {
  const n = R(t, "t1", "dot"), s = R(e, "t2", "dot");
  A((n.rank === 1 || n.rank === 2) && (s.rank === 1 || s.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);
  const i = n.rank === 1 ? n.size : n.shape[1], r = s.rank === 1 ? s.size : s.shape[0];
  if (A(i === r, () => `Error in dot: inner dimensions of inputs must match, but got ${i} and ${r}.`), n.rank === 1 && s.rank === 1) {
    const o = Y(n, [1, -1]), a = Y(s, [-1, 1]), c = Tt(o, a);
    return Y(c, []);
  } else if (n.rank === 1 && s.rank === 2) {
    const o = Y(n, [1, -1]), a = Y(s, [s.shape[0], s.shape[1]]), c = Tt(o, a);
    return Y(c, [c.size]);
  } else if (n.rank === 2 && s.rank === 1) {
    const o = Y(s, [-1, 1]), a = Tt(n, o);
    return Y(a, [a.size]);
  } else {
    const o = Y(s, [s.shape[0], s.shape[1]]);
    return Tt(n, o);
  }
}
const RS = /* @__PURE__ */ H({ dot_: UG });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GG(t, ...e) {
  const n = e.map((i, r) => R(i, `tensors${r}`, "einsum")), s = { equation: t };
  return G.runKernel(Lx, n, s);
}
const hc = /* @__PURE__ */ H({ einsum_: GG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function WG(t) {
  const n = { x: R(t, "x", "elu", "float32") };
  return G.runKernel(Ku, n);
}
const Dh = /* @__PURE__ */ H({ elu_: WG });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HG(t, e) {
  const n = R(t, "x", "ensureShape", "string_or_numeric");
  if (!_N(n.shape, e))
    throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);
  return t;
}
const xk = /* @__PURE__ */ H({ ensureShape_: HG });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jG(t) {
  let e = R(t, "x", "erf");
  A(e.dtype === "int32" || e.dtype === "float32", () => "Input dtype must be `int32` or `float32`."), e.dtype === "int32" && (e = Le(e, "float32"));
  const n = { x: e };
  return G.runKernel(Yu, n);
}
const R0 = /* @__PURE__ */ H({ erf_: jG });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DS(t, e) {
  for (let n = 0; n < t.length; ++n)
    if (t[t.length - n - 1] !== e - 1 - n)
      return !1;
  return !0;
}
function bk(t, e, n) {
  const s = t.length + e.length, i = [];
  let r = 0, o = 0;
  for (let a = 0; a < s; a++)
    n.indexOf(a) === -1 ? i.push(t[r++]) : i.push(e[o++]);
  return i;
}
function ds(t, e) {
  const n = [], s = t.length;
  for (let r = 0; r < s; r++)
    e.indexOf(r) === -1 && n.push(t[r]);
  const i = e.map((r) => t[r]);
  return [n, i];
}
function zn(t, e) {
  const n = e.map((s) => 1);
  return bk(t, n, e);
}
function _s(t, e, n) {
  A(DS(e, n), () => `${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`);
}
function An(t, e) {
  if (DS(t, e))
    return null;
  const n = [];
  for (let s = 0; s < e; ++s)
    t.indexOf(s) === -1 && n.push(s);
  return t.forEach((s) => n.push(s)), n;
}
function Ba(t) {
  return t.map((e, n) => [n, e]).sort((e, n) => e[1] - n[1]).map((e) => e[0]);
}
function Vn(t, e) {
  const n = [];
  for (let s = e - t; s < e; ++s)
    n.push(s);
  return n;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qG(t, e = null, n = !1) {
  const i = { x: R(t, "x", "max") }, r = { reductionIndices: e, keepDims: n };
  return G.runKernel(dp, i, r);
}
const Ri = /* @__PURE__ */ H({ max_: qG });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XG(t, e = null, n = !1) {
  const i = { x: R(t, "x", "min") }, r = { axis: e, keepDims: n };
  return G.runKernel(gp, i, r);
}
const wu = /* @__PURE__ */ H({ min_: XG });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function KG(t, e) {
  let n = R(t, "base", "pow"), s = R(e, "exp", "pow");
  [n, s] = kn(n, s);
  const i = { a: n, b: s };
  return G.runKernel(dh, i);
}
const io = /* @__PURE__ */ H({ pow_: KG });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ot(t, e) {
  if ((os(t) && e !== "string" || Array.isArray(t)) && e !== "complex64")
    throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if (e === "string" && os(t) && !(t instanceof Uint8Array))
    throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return Fa(t, [], [], e);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YG(t) {
  const n = { x: R(t, "x", "sqrt", "float32") };
  return G.runKernel(Th, n);
}
const us = /* @__PURE__ */ H({ sqrt_: YG });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ZG(t) {
  const e = R(t, "x", "square"), n = {};
  return G.runKernel("Square", { x: e }, n);
}
const tn = /* @__PURE__ */ H({ square_: ZG });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JG(t, e = null, n = !1) {
  let s = R(t, "x", "sum");
  s.dtype === "bool" && (s = Le(s, "int32"));
  const i = { x: s }, r = { axis: e, keepDims: n };
  return G.runKernel(Rp, i, r);
}
const Qe = /* @__PURE__ */ H({ sum_: JG });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function QG(t, e = "euclidean", n = null, s = !1) {
  t = R(t, "x", "norm");
  const i = vk(t, e, n);
  let r = i.shape;
  if (s) {
    const o = Rt(n, t.shape);
    r = zn(i.shape, o);
  }
  return Y(i, r);
}
function vk(t, e, n = null) {
  if (t.rank === 0)
    return jn(t);
  if (t.rank !== 1 && n === null)
    return vk(Y(t, [-1]), e, n);
  if (t.rank === 1 || typeof n == "number" || Array.isArray(n) && n.length === 1) {
    if (e === 1)
      return Qe(jn(t), n);
    if (e === 1 / 0)
      return Ri(jn(t), n);
    if (e === -1 / 0)
      return wu(jn(t), n);
    if (e === "euclidean" || e === 2)
      return us(Qe(io(jn(t), ot(2, "int32")), n));
    throw new Error(`Error in norm: invalid ord value: ${e}`);
  }
  if (Array.isArray(n) && n.length === 2) {
    if (e === 1)
      return Ri(Qe(jn(t), n[0]), n[1] - 1);
    if (e === 1 / 0)
      return Ri(Qe(jn(t), n[1]), n[0]);
    if (e === -1 / 0)
      return wu(Qe(jn(t), n[1]), n[0]);
    if (e === "fro" || e === "euclidean")
      return us(Qe(tn(t), n));
    throw new Error(`Error in norm: invalid ord value: ${e}`);
  }
  throw new Error(`Error in norm: invalid axis: ${n}`);
}
const $h = /* @__PURE__ */ H({ norm_: QG });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eW(t, e = null, n = !1) {
  return $h(t, "euclidean", e, n);
}
const $S = /* @__PURE__ */ H({ euclideanNorm_: eW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tW(t) {
  const n = { x: R(t, "x", "exp") };
  return G.runKernel(Zu, n);
}
const ii = /* @__PURE__ */ H({ exp_: tW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nW(t, e = 0) {
  const n = R(t, "x", "expandDims", "string_or_numeric");
  A(e <= n.rank, () => "Axis must be <= rank of the tensor");
  const s = { input: n }, i = { dim: e };
  return G.runKernel(tp, s, i);
}
const vn = /* @__PURE__ */ H({ expandDims_: nW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sW(t) {
  const n = { x: R(t, "x", "expm1") };
  return G.runKernel(Ju, n);
}
const OS = /* @__PURE__ */ H({ expm1_: sW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iW(t, e) {
  const n = R(t, "x", "tile", "string_or_numeric");
  A(n.rank === e.length, () => `Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);
  const s = { x: n }, i = { reps: e };
  return G.runKernel(kh, s, i);
}
const pi = /* @__PURE__ */ H({ tile_: iW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rW(t, e, n, s = "float32") {
  e == null && (e = t);
  const i = It([t, e], s), r = t <= e ? t : e;
  for (let a = 0; a < r; ++a)
    i.set(1, a, a);
  const o = Y(i.toTensor(), [t, e]);
  if (n == null)
    return o;
  if (n.length === 1)
    return pi(vn(o, 0), [n[0], 1, 1]);
  if (n.length === 2)
    return pi(vn(vn(o, 0), 0), [n[0], n[1], 1, 1]);
  if (n.length === 3)
    return pi(vn(vn(vn(o, 0), 0), 0), [
      n[0],
      n[1],
      n[2],
      1,
      1
    ]);
  throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`);
}
const D0 = /* @__PURE__ */ H({ eye_: rW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oW(t) {
  const n = { x: R(t, "x", "floor", "float32") };
  return G.runKernel(Qu, n);
}
const Oh = /* @__PURE__ */ H({ floor_: oW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aW(t, e, n = 0, s = 0) {
  const i = R(t, "x", "gather"), r = R(e, "indices", "gather", "int32"), o = { x: i, indices: r }, a = { axis: n, batchDims: s };
  return G.runKernel(sp, o, a);
}
const Lh = /* @__PURE__ */ H({ gather_: aW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cW(t, e) {
  let n = R(t, "a", "greater", "string_or_numeric"), s = R(e, "b", "greater", "string_or_numeric");
  [n, s] = kn(n, s), bt(n.shape, s.shape);
  const i = { a: n, b: s };
  return G.runKernel(ip, i);
}
const js = /* @__PURE__ */ H({ greater_: cW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lW(t, e) {
  let n = R(t, "a", "greaterEqual", "string_or_numeric"), s = R(e, "b", "greaterEqual", "string_or_numeric");
  [n, s] = kn(n, s), bt(n.shape, s.shape);
  const i = { a: n, b: s };
  return G.runKernel(th, i);
}
const Wo = /* @__PURE__ */ H({ greaterEqual_: lW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uW(t) {
  const n = { input: R(t, "input", "imag") };
  return G.runKernel(Gx, n);
}
const qp = /* @__PURE__ */ H({ imag_: uW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hW(t) {
  const n = { x: R(t, "x", "isFinite") };
  return G.runKernel(sh, n);
}
const LS = /* @__PURE__ */ H({ isFinite_: hW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dW(t) {
  const n = { x: R(t, "x", "isInf") };
  return G.runKernel(ih, n);
}
const FS = /* @__PURE__ */ H({ isInf_: dW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fW(t) {
  const n = { x: R(t, "x", "isNaN") };
  return G.runKernel(rh, n);
}
const PS = /* @__PURE__ */ H({ isNaN_: fW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pW(t, e = 0.2) {
  const s = { x: R(t, "x", "leakyRelu") }, i = { alpha: e };
  return G.runKernel(rp, s, i);
}
const Xp = /* @__PURE__ */ H({ leakyRelu_: pW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mW(t, e) {
  let n = R(t, "a", "less", "string_or_numeric"), s = R(e, "b", "less", "string_or_numeric");
  [n, s] = kn(n, s), bt(n.shape, s.shape);
  const i = { a: n, b: s };
  return G.runKernel(op, i);
}
const Su = /* @__PURE__ */ H({ less_: mW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gW(t, e) {
  let n = R(t, "a", "lessEqual", "string_or_numeric"), s = R(e, "b", "lessEqual", "string_or_numeric");
  [n, s] = kn(n, s), bt(n.shape, s.shape);
  const i = { a: n, b: s };
  return G.runKernel(ap, i);
}
const za = /* @__PURE__ */ H({ lessEqual_: gW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wk(t, e, n) {
  if (n <= 0)
    throw new Error("The number of values should be positive.");
  const s = { start: t, stop: e, num: n };
  return G.runKernel(Wx, {}, s);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yW(t, e = 5, n = 1, s = 1, i = 0.5) {
  const r = R(t, "x", "localResponseNormalization");
  A(r.rank === 4 || r.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${r.rank}.`), A(Lc(e), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);
  let o = r, a = !1;
  r.rank === 3 && (a = !0, o = Y(r, [1, r.shape[0], r.shape[1], r.shape[2]]));
  const c = { x: o }, l = { depthRadius: e, bias: n, alpha: s, beta: i }, u = G.runKernel(hp, c, l);
  return a ? Y(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
}
const BS = /* @__PURE__ */ H({ localResponseNormalization_: yW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xW(t) {
  const n = { x: R(t, "x", "log", "float32") };
  return G.runKernel(oh, n);
}
const bi = /* @__PURE__ */ H({ log_: xW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bW(t) {
  const n = { x: R(t, "x", "log1p") };
  return G.runKernel(ah, n);
}
const Kp = /* @__PURE__ */ H({ log1p_: bW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vW(t) {
  return A(Ta(t), () => "The f passed in grad(f) must be a function"), (e, n) => {
    const s = R(e, "x", "tf.grad", "string_or_numeric"), i = n != null ? R(n, "dy", "tf.grad") : null;
    return G.tidy(() => {
      const { value: r, grads: o } = G.gradients(() => t(s), [s], i);
      return i != null && ws(r.shape, i.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), $0(o), o[0];
    });
  };
}
function wW(t) {
  return A(Ta(t), () => "The f passed in grads(f) must be a function"), (e, n) => {
    A(Array.isArray(e), () => "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");
    const s = yf(e, "args", "tf.grads", "string_or_numeric"), i = n != null ? R(n, "dy", "tf.grads") : null;
    return G.tidy(() => {
      const { value: r, grads: o } = G.gradients(() => t(...s), s, i);
      return i != null && ws(r.shape, i.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), $0(o), o;
    });
  };
}
function SW(t) {
  return A(Ta(t), () => "The f passed in valueAndGrad(f) must be a function"), (e, n) => {
    A(e instanceof Lt, () => "The x passed in valueAndGrad(f)(x) must be a tensor"), A(n == null || n instanceof Lt, () => "The dy passed in valueAndGrad(f)(x, dy) must be a tensor");
    const { grads: s, value: i } = G.gradients(() => t(e), [e], n);
    return $0(s), { grad: s[0], value: i };
  };
}
function _W(t) {
  return A(Ta(t), () => "The f passed in valueAndGrads(f) must be a function"), (e, n) => {
    A(Array.isArray(e) && e.every((i) => i instanceof Lt), () => "The args passed in valueAndGrads(f)(args) must be array of tensors"), A(n == null || n instanceof Lt, () => "The dy passed in valueAndGrads(f)(args, dy) must be a tensor");
    const s = G.gradients(() => t(...e), e, n);
    return n != null && ws(s.value.shape, n.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), $0(s.grads), s;
  };
}
function Sk(t, e) {
  A(Ta(t), () => "The f passed in variableGrads(f) must be a function"), A(e == null || Array.isArray(e) && e.every((l) => l instanceof gf), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
  const n = e != null;
  if (!n) {
    e = [];
    for (const l in G.registeredVariables)
      e.push(G.registeredVariables[l]);
  }
  const s = n ? e.filter((l) => !l.trainable) : null, i = e.length;
  e = e.filter((l) => l.trainable), A(e.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);
  const r = !0, { value: o, grads: a } = G.gradients(t, e, null, r);
  A(a.some((l) => l != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."), A(o.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);
  const c = {};
  return e.forEach((l, u) => {
    a[u] != null && (c[l.name] = a[u]);
  }), s != null && s.forEach((l) => c[l.name] = null), { value: o, grads: c };
}
function ro(t) {
  return G.customGrad(t);
}
function $0(t) {
  if (t.filter((n) => n == null).length > 0)
    throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TW(t) {
  const n = { x: R(t, "x", "neg") };
  return G.runKernel(xp, n);
}
const hn = /* @__PURE__ */ H({ neg_: TW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function CW(t) {
  const n = { x: R(t, "x", "softplus") };
  return G.runKernel(_h, n);
}
const sl = /* @__PURE__ */ H({ softplus_: CW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function IW(t) {
  const e = R(t, "x", "logSigmoid");
  return ro((s) => ({ value: hn(sl(hn(s))), gradFunc: (o) => q(o, mi(hn(s))) }))(e);
}
const zS = /* @__PURE__ */ H({ logSigmoid_: IW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function EW(t, e) {
  let n = R(t, "a", "sub"), s = R(e, "b", "sub");
  [n, s] = kn(n, s);
  const i = { a: n, b: s };
  return G.runKernel(Ih, i);
}
const je = /* @__PURE__ */ H({ sub_: EW });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NW(t, e = -1) {
  const n = R(t, "logits", "logSoftmax");
  if (e === -1 && (e = n.rank - 1), e !== n.rank - 1)
    throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);
  return ro((i, r) => {
    const a = Ri(i, e, !0), c = je(i, a), l = je(Le(c, "float32"), bi(Qe(ii(c), e, !0)));
    return r([l]), { value: l, gradFunc: (h, d) => {
      const [f] = d, p = !0, y = ii(f);
      return je(h, q(Qe(h, e, p), y));
    } };
  })(n);
}
const O0 = /* @__PURE__ */ H({ logSoftmax_: NW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kW(t, e = null, n = !1) {
  const s = R(t, "x", "logSumExp"), i = Rt(e, s.shape), r = Ri(
    s,
    i,
    !0
    /* keepDims */
  ), o = je(s, r), a = ii(o), c = Qe(a, i), l = bi(c), u = Se(Y(r, l.shape), l);
  if (n) {
    const h = zn(u.shape, i);
    return Y(u, h);
  }
  return u;
}
const Yp = /* @__PURE__ */ H({ logSumExp_: kW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function AW(t, e) {
  const n = R(t, "a", "logicalAnd", "bool"), s = R(e, "b", "logicalAnd", "bool");
  bt(n.shape, s.shape);
  const i = { a: n, b: s };
  return G.runKernel(cp, i);
}
const _r = /* @__PURE__ */ H({ logicalAnd_: AW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function MW(t) {
  const n = { x: R(t, "x", "logicalNot", "bool") };
  return G.runKernel(lp, n);
}
const Zp = /* @__PURE__ */ H({ logicalNot_: MW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function RW(t, e) {
  const n = R(t, "a", "logicalOr", "bool"), s = R(e, "b", "logicalOr", "bool");
  bt(n.shape, s.shape);
  const i = { a: n, b: s };
  return G.runKernel(up, i);
}
const L0 = /* @__PURE__ */ H({ logicalOr_: RW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DW(t, e) {
  const n = R(t, "a", "logicalXor", "bool"), s = R(e, "b", "logicalXor", "bool");
  return bt(n.shape, s.shape), _r(L0(t, e), Zp(_r(t, e)));
}
const VS = /* @__PURE__ */ H({ logicalXor_: DW });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const mg = 2147483648;
function $W(t, e, n = "left") {
  const s = R(t, "sortedSequence", "searchSorted"), i = R(e, "values", "searchSorted"), r = s.shape[s.shape.length - 1], o = i.shape[i.shape.length - 1], a = Y(s, [-1, r]), c = Y(i, [-1, o]);
  if (a.rank < 2)
    throw new Error("Sorted input argument must be at least 2-dimensional");
  if (a.shape[0] !== c.shape[0])
    throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");
  if (ue(c.shape) >= mg)
    throw new Error(`values tensor size must less than ${mg}`);
  if (a.shape[1] >= mg)
    throw new Error(`trailing dim_size must less than ${mg} for int32 output type, was ${a.shape[1]}`);
  const l = {
    sortedSequence: a,
    values: c
  }, u = { side: n };
  return G.runKernel(c0, l, u);
}
const F0 = /* @__PURE__ */ H({ searchSorted_: $W });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _k(t, e) {
  return F0(t, e, "left");
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OW(t, e, n, s, i) {
  const r = R(t, "x", "maxPool"), o = 1;
  let a = r, c = !1;
  r.rank === 3 && (c = !0, a = Y(r, [1, r.shape[0], r.shape[1], r.shape[2]])), A(a.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${a.rank}.`), A(Ss(n, o), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`), Hs("maxPool", s, i);
  const l = { x: a }, u = { filterSize: e, strides: n, pad: s, dimRoundingMode: i }, h = G.runKernel(fp, l, u);
  return c ? Y(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
}
const Jp = /* @__PURE__ */ H({ maxPool_: OW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LW(t, e = [1, 1, 1], n, s, i, r = "NDHWC") {
  const o = R(t, "x", "maxPool3d");
  let a = o, c = !1;
  o.rank === 4 && (c = !0, a = Y(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), A(a.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`), A(r === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`), Hs("maxPool3d", s, i);
  const l = { x: a }, u = { filterSize: e, strides: n, pad: s, dimRoundingMode: i, dataFormat: r }, h = G.runKernel(pp, l, u);
  return c ? Y(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h;
}
const US = /* @__PURE__ */ H({ maxPool3d_: LW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FW(t, e, n, s, i = !1) {
  const o = { x: R(t, "x", "maxPoolWithArgmax") }, a = { filterSize: e, strides: n, pad: s, includeBatchInIndex: i }, c = G.runKernel(Xx, o, a);
  return { result: c[0], indexes: c[1] };
}
const Tk = /* @__PURE__ */ H({ maxPoolWithArgmax_: FW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PW(t, e) {
  let n = R(t, "a", "maximum"), s = R(e, "b", "maximum");
  [n, s] = kn(n, s), n.dtype === "bool" && (n = Le(n, "int32"), s = Le(s, "int32")), bt(n.shape, s.shape);
  const i = { a: n, b: s };
  return G.runKernel(ch, i);
}
const lo = /* @__PURE__ */ H({ maximum_: PW });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BW(t, e = null, n = !1) {
  const i = { x: R(t, "x", "mean") }, r = { axis: e, keepDims: n };
  return G.runKernel(mp, i, r);
}
const En = /* @__PURE__ */ H({ mean_: BW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qn(t, e = "float32") {
  if (_i(t), e === "complex64") {
    const s = qn(t, "float32"), i = qn(t, "float32");
    return Do(s, i);
  }
  const n = vs(ue(t), e);
  return G.makeTensor(n, t, e);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qs(t, e = "float32") {
  if (_i(t), e === "complex64") {
    const s = Qs(t, "float32"), i = qn(t, "float32");
    return Do(s, i);
  }
  const n = yx(ue(t), e);
  return G.makeTensor(n, t, e);
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ck(t, e, { indexing: n = "xy" } = {}) {
  if (n !== "xy" && n !== "ij")
    throw new TypeError(`${n} is not a valid third argument to meshgrid`);
  if (t === void 0)
    return [];
  let s = R(t, "x", "meshgrid", t instanceof Lt ? t.dtype : "float32");
  if (e === void 0)
    return [s];
  let i = R(e, "y", "meshgrid", e instanceof Lt ? e.dtype : "float32");
  const r = ue(s.shape), o = ue(i.shape);
  return n === "xy" ? (s = Y(s, [1, -1]), i = Y(i, [-1, 1]), [
    Tt(Qs([o, 1], s.dtype), s),
    Tt(i, Qs([1, r], i.dtype))
  ]) : (s = Y(s, [-1, 1]), i = Y(i, [1, -1]), [
    Tt(s, Qs([1, o], s.dtype)),
    Tt(Qs([r, 1], i.dtype), i)
  ]);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zW(t, e) {
  let n = R(t, "a", "minimum"), s = R(e, "b", "minimum");
  [n, s] = kn(n, s), n.dtype === "bool" && (n = Le(n, "int32"), s = Le(s, "int32")), bt(n.shape, s.shape);
  const i = { a: n, b: s };
  return G.runKernel(lh, i);
}
const Aa = /* @__PURE__ */ H({ minimum_: zW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VW(t, e, n) {
  A(n === "reflect" || n === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);
  const s = R(t, "x", "mirrorPad");
  if (s.rank === 0)
    throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
  A(e.length === s.rank, () => `Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);
  const i = n === "reflect" ? 1 : 0;
  for (let a = 0; a < s.rank; a++)
    A(e[a].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), A(e[a][0] >= 0 && e[a][0] <= s.shape[a] - i && e[a][1] >= 0 && e[a][1] <= s.shape[a] - i, () => `Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a] - i} or less than 0 for input of shape ${s.shape}`);
  const r = { paddings: e, mode: n }, o = { x: s };
  return G.runKernel(yp, o, r);
}
const P0 = /* @__PURE__ */ H({ mirrorPad_: VW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UW(t, e) {
  let n = R(t, "a", "mod"), s = R(e, "b", "mod");
  [n, s] = kn(n, s);
  const i = { a: n, b: s };
  return G.runKernel(uh, i);
}
const GS = /* @__PURE__ */ H({ mod_: UW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GW(t, e = null, n = !1) {
  t = R(t, "x", "moments");
  const s = Rt(e, t.shape), i = En(t, s, n);
  let r = i.shape;
  n || (r = zn(i.shape, s));
  const o = tn(je(Le(t, "float32"), Y(i, r))), a = En(o, s, n);
  return { mean: i, variance: a };
}
const Qp = /* @__PURE__ */ H({ moments_: GW });
function WW(t, e, n, s) {
  const i = R(e, "data", "multiRNNCell"), r = yf(n, "c", "multiRNNCell"), o = yf(s, "h", "multiRNNCell");
  let a = i;
  const c = [];
  for (let h = 0; h < t.length; h++) {
    const d = t[h](a, r[h], o[h]);
    c.push(d[0]), c.push(d[1]), a = d[1];
  }
  const l = [], u = [];
  for (let h = 0; h < c.length; h += 2)
    l.push(c[h]), u.push(c[h + 1]);
  return [l, u];
}
const Ik = /* @__PURE__ */ H({ multiRNNCell_: WW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HW(t, e, n, s = !1) {
  const i = R(t, "logits", "multinomial"), r = i.size, o = i.rank;
  if (r < 2)
    throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${r}.`);
  if (o > 2)
    throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);
  n = n || Math.random();
  const c = { logits: o === 1 ? Y(i, [1, -1]) : i }, l = { numSamples: e, seed: n, normalized: s }, u = G.runKernel(Kx, c, l);
  return o === 1 ? Y(u, [u.size]) : u;
}
const Ek = /* @__PURE__ */ H({ multinomial_: HW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jW(t, e) {
  let n = R(t, "a", "notEqual", "string_or_numeric"), s = R(e, "b", "notEqual", "string_or_numeric");
  [n, s] = kn(n, s), bt(n.shape, s.shape);
  const i = { a: n, b: s };
  return G.runKernel(bp, i);
}
const Uc = /* @__PURE__ */ H({ notEqual_: jW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qW(t, e, n = 1, s = 0, i = "int32") {
  if (e < 2)
    throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);
  const o = { indices: R(t, "indices", "oneHot", "int32") }, a = { dtype: i, depth: e, onValue: n, offValue: s };
  return G.runKernel(wp, o, a);
}
const Gc = /* @__PURE__ */ H({ oneHot_: qW });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XW(t) {
  const n = { x: R(t, "x", "onesLike") };
  return G.runKernel(vp, n);
}
const vi = /* @__PURE__ */ H({ onesLike_: XW });
function KW(t, e) {
  const n = R(t, "v1", "outerProduct"), s = R(e, "v2", "outerProduct");
  A(n.rank === 1 && s.rank === 1, () => `Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${s.rank}.`);
  const i = Y(n, [-1, 1]), r = Y(s, [1, -1]);
  return Tt(i, r);
}
const Nk = /* @__PURE__ */ H({ outerProduct_: KW });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YW(t, e, n = 0) {
  const s = R(t, "x", "pad");
  if (s.rank === 0)
    throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
  const i = { paddings: e, constantValue: n }, r = { x: s };
  return G.runKernel(_p, r, i);
}
const uo = /* @__PURE__ */ H({ pad_: YW });
function ZW(t, e, n = 0) {
  return A(e.length === 2, () => "Invalid number of paddings. Must be length of 2."), uo(t, [e], n);
}
const kk = /* @__PURE__ */ H({ pad1d_: ZW });
function JW(t, e, n = 0) {
  return A(e.length === 2 && e[0].length === 2 && e[1].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), uo(t, e, n);
}
const Ak = /* @__PURE__ */ H({ pad2d_: JW });
function QW(t, e, n = 0) {
  return A(e.length === 3 && e[0].length === 2 && e[1].length === 2 && e[2].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), uo(t, e, n);
}
const WS = /* @__PURE__ */ H({ pad3d_: QW });
function eH(t, e, n = 0) {
  return A(e.length === 4 && e[0].length === 2 && e[1].length === 2 && e[2].length === 2 && e[3].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), uo(t, e, n);
}
const Mk = /* @__PURE__ */ H({ pad4d_: eH });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tH(t, e, n) {
  const s = R(t, "x", "spaceToBatchND");
  A(s.rank >= 1 + e.length, () => `input rank ${s.rank} should be > than [blockShape] ${e.length}`), A(n.length === e.length, () => `paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`), A(s.shape.reduce((o, a, c) => c > 0 && c <= e.length ? o && (a + n[c - 1][0] + n[c - 1][1]) % e[c - 1] === 0 : o, !0), () => `input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);
  const i = { x: s }, r = { blockShape: e, paddings: n };
  return G.runKernel(Dp, i, r);
}
const em = /* @__PURE__ */ H({ spaceToBatchND_: tH });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nH(t, e, n, s, i, r, o) {
  i == null && (i = [1, 1]), r == null && (r = 1), s === 0 && (s = "valid");
  const a = R(t, "x", "maxPool");
  let c = a, l = !1;
  a.rank === 3 && (l = !0, c = Y(a, [1, a.shape[0], a.shape[1], a.shape[2]])), A(Ss(r, i), () => `Error in pool: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`);
  const u = ir(c.shape, e, r, i, s), h = [u.dilationHeight, u.dilationWidth];
  let d;
  s === "same" ? d = iH([u.filterHeight, u.filterWidth], h) : d = [[0, 0], [0, 0]];
  const f = h[0] === 1 && h[1] === 1, [p, y] = sH([u.inHeight, u.inWidth], h, d), g = f ? s : "valid", m = f ? c : em(c, h, p), v = (n === "avg" ? () => Wp(m, e, r, g, o) : () => Jp(m, e, r, g, o))(), b = f ? v : Hp(v, h, y);
  return l ? Y(b, [b.shape[1], b.shape[2], b.shape[3]]) : b;
}
function sH(t, e, n) {
  const s = n.map((u) => u[0]), i = n.map((u) => u[1]), r = t.concat(s, i), o = e.map((u, h) => (u - r[h] % u) % u), a = i.map((u, h) => u + o[h]), c = e.map((u, h) => [s[h], a[h]]), l = e.map((u, h) => [0, o[h]]);
  return [c, l];
}
function iH(t, e) {
  const s = t.map((o, a) => o + (o - 1) * (e[a] - 1)).map((o) => o - 1), i = s.map((o) => Math.floor(o / 2)), r = s.map((o, a) => o - i[a]);
  return s.map((o, a) => [i[a], r[a]]);
}
const HS = /* @__PURE__ */ H({ pool_: nH });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rH(t, e) {
  const n = R(t, "x", "prelu"), s = R(e, "alpha", "prelu"), i = { x: n, alpha: s };
  return G.runKernel(Tp, i);
}
const tm = /* @__PURE__ */ H({ prelu_: rH });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oH(t, e = null, n = !1) {
  let s = R(t, "x", "prod");
  s.dtype === "bool" && (s = Le(s, "int32"));
  const i = { x: s }, r = { axis: e, keepDims: n };
  return G.runKernel(Cp, i, r);
}
const jS = /* @__PURE__ */ H({ prod_: oH });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aH(t, e, n, s) {
  const i = t.map((u, h) => R(u, `tensors${h}`, "raggedGather", "int32")), r = R(e, "paramsDenseValues", "raggedGather"), o = R(n, "indices", "raggedGather", "int32"), a = {
    paramsNestedSplits: i,
    paramsDenseValues: r,
    indices: o
  }, c = { outputRaggedRank: s }, l = G.runKernel(Qx, a, c);
  return {
    outputNestedSplits: l.slice(0, l.length - 1),
    outputDenseValues: l[l.length - 1]
  };
}
const Rk = /* @__PURE__ */ H({ raggedGather_: aH });
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cH(t, e, n) {
  const s = R(t, "starts", "raggedRange"), i = R(e, "limits", "raggedRange", s.dtype), r = R(n, "deltas", "raggedRange", s.dtype), o = {
    starts: s,
    limits: i,
    deltas: r
  }, a = G.runKernel(e0, o);
  return {
    rtNestedSplits: a[0],
    rtDenseValues: a[1]
  };
}
const Dk = /* @__PURE__ */ H({ raggedRange_: cH });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lH(t, e, n, s, i) {
  const r = R(t, "shape", "raggedTensorToTensor", "int32"), o = R(e, "values", "raggedTensorToTensor"), a = R(n, "defaultValue", "raggedTensorToTensor", o.dtype), c = s.map((h, d) => R(h, `tensors${d}`, "raggedTensorToTensor", "int32")), l = {
    shape: r,
    values: o,
    defaultValue: a,
    rowPartitionTensors: c
  }, u = { rowPartitionTypes: i };
  return G.runKernel(t0, l, u);
}
const $k = /* @__PURE__ */ H({ raggedTensorToTensor_: lH });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uH(t, e, n) {
  _i(t);
  const s = ue(t);
  let i = null;
  if (n == null || n === "float32")
    i = new Float32Array(s);
  else if (n === "int32")
    i = new Int32Array(s);
  else if (n === "bool")
    i = new Uint8Array(s);
  else
    throw new Error(`Unknown data type ${n}`);
  for (let r = 0; r < s; r++)
    i[r] = e();
  return G.makeTensor(i, t, n);
}
const Ok = /* @__PURE__ */ H({ rand_: uH });
var qS = { exports: {} };
qS.exports;
(function(t) {
  (function(e, n, s) {
    function i(c) {
      var l = this, u = a();
      l.next = function() {
        var h = 2091639 * l.s0 + l.c * 23283064365386963e-26;
        return l.s0 = l.s1, l.s1 = l.s2, l.s2 = h - (l.c = h | 0);
      }, l.c = 1, l.s0 = u(" "), l.s1 = u(" "), l.s2 = u(" "), l.s0 -= u(c), l.s0 < 0 && (l.s0 += 1), l.s1 -= u(c), l.s1 < 0 && (l.s1 += 1), l.s2 -= u(c), l.s2 < 0 && (l.s2 += 1), u = null;
    }
    function r(c, l) {
      return l.c = c.c, l.s0 = c.s0, l.s1 = c.s1, l.s2 = c.s2, l;
    }
    function o(c, l) {
      var u = new i(c), h = l && l.state, d = u.next;
      return d.int32 = function() {
        return u.next() * 4294967296 | 0;
      }, d.double = function() {
        return d() + (d() * 2097152 | 0) * 11102230246251565e-32;
      }, d.quick = d, h && (typeof h == "object" && r(h, u), d.state = function() {
        return r(u, {});
      }), d;
    }
    function a() {
      var c = 4022871197, l = function(u) {
        u = String(u);
        for (var h = 0; h < u.length; h++) {
          c += u.charCodeAt(h);
          var d = 0.02519603282416938 * c;
          c = d >>> 0, d -= c, d *= c, c = d >>> 0, d -= c, c += d * 4294967296;
        }
        return (c >>> 0) * 23283064365386963e-26;
      };
      return l;
    }
    n && n.exports ? n.exports = o : s && s.amd ? s(function() {
      return o;
    }) : this.alea = o;
  })(
    el,
    t,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(qS);
var hH = qS.exports, XS = { exports: {} };
XS.exports;
(function(t) {
  (function(e, n, s) {
    function i(a) {
      var c = this, l = "";
      c.x = 0, c.y = 0, c.z = 0, c.w = 0, c.next = function() {
        var h = c.x ^ c.x << 11;
        return c.x = c.y, c.y = c.z, c.z = c.w, c.w ^= c.w >>> 19 ^ h ^ h >>> 8;
      }, a === (a | 0) ? c.x = a : l += a;
      for (var u = 0; u < l.length + 64; u++)
        c.x ^= l.charCodeAt(u) | 0, c.next();
    }
    function r(a, c) {
      return c.x = a.x, c.y = a.y, c.z = a.z, c.w = a.w, c;
    }
    function o(a, c) {
      var l = new i(a), u = c && c.state, h = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return h.double = function() {
        do
          var d = l.next() >>> 11, f = (l.next() >>> 0) / 4294967296, p = (d + f) / (1 << 21);
        while (p === 0);
        return p;
      }, h.int32 = l.next, h.quick = h, u && (typeof u == "object" && r(u, l), h.state = function() {
        return r(l, {});
      }), h;
    }
    n && n.exports ? n.exports = o : s && s.amd ? s(function() {
      return o;
    }) : this.xor128 = o;
  })(
    el,
    t,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(XS);
var dH = XS.exports, KS = { exports: {} };
KS.exports;
(function(t) {
  (function(e, n, s) {
    function i(a) {
      var c = this, l = "";
      c.next = function() {
        var h = c.x ^ c.x >>> 2;
        return c.x = c.y, c.y = c.z, c.z = c.w, c.w = c.v, (c.d = c.d + 362437 | 0) + (c.v = c.v ^ c.v << 4 ^ (h ^ h << 1)) | 0;
      }, c.x = 0, c.y = 0, c.z = 0, c.w = 0, c.v = 0, a === (a | 0) ? c.x = a : l += a;
      for (var u = 0; u < l.length + 64; u++)
        c.x ^= l.charCodeAt(u) | 0, u == l.length && (c.d = c.x << 10 ^ c.x >>> 4), c.next();
    }
    function r(a, c) {
      return c.x = a.x, c.y = a.y, c.z = a.z, c.w = a.w, c.v = a.v, c.d = a.d, c;
    }
    function o(a, c) {
      var l = new i(a), u = c && c.state, h = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return h.double = function() {
        do
          var d = l.next() >>> 11, f = (l.next() >>> 0) / 4294967296, p = (d + f) / (1 << 21);
        while (p === 0);
        return p;
      }, h.int32 = l.next, h.quick = h, u && (typeof u == "object" && r(u, l), h.state = function() {
        return r(l, {});
      }), h;
    }
    n && n.exports ? n.exports = o : s && s.amd ? s(function() {
      return o;
    }) : this.xorwow = o;
  })(
    el,
    t,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(KS);
var fH = KS.exports, YS = { exports: {} };
YS.exports;
(function(t) {
  (function(e, n, s) {
    function i(a) {
      var c = this;
      c.next = function() {
        var u = c.x, h = c.i, d, f;
        return d = u[h], d ^= d >>> 7, f = d ^ d << 24, d = u[h + 1 & 7], f ^= d ^ d >>> 10, d = u[h + 3 & 7], f ^= d ^ d >>> 3, d = u[h + 4 & 7], f ^= d ^ d << 7, d = u[h + 7 & 7], d = d ^ d << 13, f ^= d ^ d << 9, u[h] = f, c.i = h + 1 & 7, f;
      };
      function l(u, h) {
        var d, f = [];
        if (h === (h | 0))
          f[0] = h;
        else
          for (h = "" + h, d = 0; d < h.length; ++d)
            f[d & 7] = f[d & 7] << 15 ^ h.charCodeAt(d) + f[d + 1 & 7] << 13;
        for (; f.length < 8; )
          f.push(0);
        for (d = 0; d < 8 && f[d] === 0; ++d)
          ;
        for (d == 8 ? f[7] = -1 : f[d], u.x = f, u.i = 0, d = 256; d > 0; --d)
          u.next();
      }
      l(c, a);
    }
    function r(a, c) {
      return c.x = a.x.slice(), c.i = a.i, c;
    }
    function o(a, c) {
      a == null && (a = +/* @__PURE__ */ new Date());
      var l = new i(a), u = c && c.state, h = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return h.double = function() {
        do
          var d = l.next() >>> 11, f = (l.next() >>> 0) / 4294967296, p = (d + f) / (1 << 21);
        while (p === 0);
        return p;
      }, h.int32 = l.next, h.quick = h, u && (u.x && r(u, l), h.state = function() {
        return r(l, {});
      }), h;
    }
    n && n.exports ? n.exports = o : s && s.amd ? s(function() {
      return o;
    }) : this.xorshift7 = o;
  })(
    el,
    t,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(YS);
var pH = YS.exports, ZS = { exports: {} };
ZS.exports;
(function(t) {
  (function(e, n, s) {
    function i(a) {
      var c = this;
      c.next = function() {
        var u = c.w, h = c.X, d = c.i, f, p;
        return c.w = u = u + 1640531527 | 0, p = h[d + 34 & 127], f = h[d = d + 1 & 127], p ^= p << 13, f ^= f << 17, p ^= p >>> 15, f ^= f >>> 12, p = h[d] = p ^ f, c.i = d, p + (u ^ u >>> 16) | 0;
      };
      function l(u, h) {
        var d, f, p, y, g, m = [], x = 128;
        for (h === (h | 0) ? (f = h, h = null) : (h = h + "\0", f = 0, x = Math.max(x, h.length)), p = 0, y = -32; y < x; ++y)
          h && (f ^= h.charCodeAt((y + 32) % h.length)), y === 0 && (g = f), f ^= f << 10, f ^= f >>> 15, f ^= f << 4, f ^= f >>> 13, y >= 0 && (g = g + 1640531527 | 0, d = m[y & 127] ^= f + g, p = d == 0 ? p + 1 : 0);
        for (p >= 128 && (m[(h && h.length || 0) & 127] = -1), p = 127, y = 4 * 128; y > 0; --y)
          f = m[p + 34 & 127], d = m[p = p + 1 & 127], f ^= f << 13, d ^= d << 17, f ^= f >>> 15, d ^= d >>> 12, m[p] = f ^ d;
        u.w = g, u.X = m, u.i = p;
      }
      l(c, a);
    }
    function r(a, c) {
      return c.i = a.i, c.w = a.w, c.X = a.X.slice(), c;
    }
    function o(a, c) {
      a == null && (a = +/* @__PURE__ */ new Date());
      var l = new i(a), u = c && c.state, h = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return h.double = function() {
        do
          var d = l.next() >>> 11, f = (l.next() >>> 0) / 4294967296, p = (d + f) / (1 << 21);
        while (p === 0);
        return p;
      }, h.int32 = l.next, h.quick = h, u && (u.X && r(u, l), h.state = function() {
        return r(l, {});
      }), h;
    }
    n && n.exports ? n.exports = o : s && s.amd ? s(function() {
      return o;
    }) : this.xor4096 = o;
  })(
    el,
    // window object or global
    t,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(ZS);
var mH = ZS.exports, JS = { exports: {} };
JS.exports;
(function(t) {
  (function(e, n, s) {
    function i(a) {
      var c = this, l = "";
      c.next = function() {
        var h = c.b, d = c.c, f = c.d, p = c.a;
        return h = h << 25 ^ h >>> 7 ^ d, d = d - f | 0, f = f << 24 ^ f >>> 8 ^ p, p = p - h | 0, c.b = h = h << 20 ^ h >>> 12 ^ d, c.c = d = d - f | 0, c.d = f << 16 ^ d >>> 16 ^ p, c.a = p - h | 0;
      }, c.a = 0, c.b = 0, c.c = -1640531527, c.d = 1367130551, a === Math.floor(a) ? (c.a = a / 4294967296 | 0, c.b = a | 0) : l += a;
      for (var u = 0; u < l.length + 20; u++)
        c.b ^= l.charCodeAt(u) | 0, c.next();
    }
    function r(a, c) {
      return c.a = a.a, c.b = a.b, c.c = a.c, c.d = a.d, c;
    }
    function o(a, c) {
      var l = new i(a), u = c && c.state, h = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return h.double = function() {
        do
          var d = l.next() >>> 11, f = (l.next() >>> 0) / 4294967296, p = (d + f) / (1 << 21);
        while (p === 0);
        return p;
      }, h.int32 = l.next, h.quick = h, u && (typeof u == "object" && r(u, l), h.state = function() {
        return r(l, {});
      }), h;
    }
    n && n.exports ? n.exports = o : s && s.amd ? s(function() {
      return o;
    }) : this.tychei = o;
  })(
    el,
    t,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(JS);
var gH = JS.exports, Lk = { exports: {} };
const yH = {}, xH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: yH
}, Symbol.toStringTag, { value: "Module" })), bH = /* @__PURE__ */ aU(xH);
(function(t) {
  (function(e, n, s) {
    var i = 256, r = 6, o = 52, a = "random", c = s.pow(i, r), l = s.pow(2, o), u = l * 2, h = i - 1, d;
    function f(b, w, S) {
      var _ = [];
      w = w == !0 ? { entropy: !0 } : w || {};
      var E = m(g(
        w.entropy ? [b, v(n)] : b ?? x(),
        3
      ), _), I = new p(_), k = function() {
        for (var M = I.g(r), L = c, O = 0; M < l; )
          M = (M + O) * i, L *= i, O = I.g(1);
        for (; M >= u; )
          M /= 2, L /= 2, O >>>= 1;
        return (M + O) / L;
      };
      return k.int32 = function() {
        return I.g(4) | 0;
      }, k.quick = function() {
        return I.g(4) / 4294967296;
      }, k.double = k, m(v(I.S), n), (w.pass || S || function(M, L, O, $) {
        return $ && ($.S && y($, I), M.state = function() {
          return y(I, {});
        }), O ? (s[a] = M, L) : M;
      })(
        k,
        E,
        "global" in w ? w.global : this == s,
        w.state
      );
    }
    function p(b) {
      var w, S = b.length, _ = this, E = 0, I = _.i = _.j = 0, k = _.S = [];
      for (S || (b = [S++]); E < i; )
        k[E] = E++;
      for (E = 0; E < i; E++)
        k[E] = k[I = h & I + b[E % S] + (w = k[E])], k[I] = w;
      (_.g = function(M) {
        for (var L, O = 0, $ = _.i, D = _.j, z = _.S; M--; )
          L = z[$ = h & $ + 1], O = O * i + z[h & (z[$] = z[D = h & D + L]) + (z[D] = L)];
        return _.i = $, _.j = D, O;
      })(i);
    }
    function y(b, w) {
      return w.i = b.i, w.j = b.j, w.S = b.S.slice(), w;
    }
    function g(b, w) {
      var S = [], _ = typeof b, E;
      if (w && _ == "object")
        for (E in b)
          try {
            S.push(g(b[E], w - 1));
          } catch {
          }
      return S.length ? S : _ == "string" ? b : b + "\0";
    }
    function m(b, w) {
      for (var S = b + "", _, E = 0; E < S.length; )
        w[h & E] = h & (_ ^= w[h & E] * 19) + S.charCodeAt(E++);
      return v(w);
    }
    function x() {
      try {
        var b;
        return d && (b = d.randomBytes) ? b = b(i) : (b = new Uint8Array(i), (e.crypto || e.msCrypto).getRandomValues(b)), v(b);
      } catch {
        var w = e.navigator, S = w && w.plugins;
        return [+/* @__PURE__ */ new Date(), e, S, e.screen, v(n)];
      }
    }
    function v(b) {
      return String.fromCharCode.apply(0, b);
    }
    if (m(s.random(), n), t.exports) {
      t.exports = f;
      try {
        d = bH;
      } catch {
      }
    } else
      s["seed" + a] = f;
  })(
    // global: `self` in browsers (including strict mode and web workers),
    // otherwise `this` in Node and other environments
    typeof self < "u" ? self : el,
    [],
    // pool: entropy pool starts empty
    Math
    // math: package containing random, pow, and seedrandom
  );
})(Lk);
var vH = Lk.exports, wH = hH, SH = dH, _H = fH, TH = pH, CH = mH, IH = gH, il = vH;
il.alea = wH;
il.xor128 = SH;
il.xorwow = _H;
il.xorshift7 = TH;
il.xor4096 = CH;
il.tychei = IH;
var B0 = il;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const EH = 1e-3, Fk = 0.1;
function NH(t, e, n) {
  return n == null && (n = QS()), Kw(t, e, (s, i) => e_(s, i, n));
}
function QS() {
  return G.backend.floatPrecision() === 32 ? EH : Fk;
}
function Kw(t, e, n) {
  let s = !0;
  if ((os(t) || os(e)) && (s = !1), os(t) && os(e) && (s = !0), s) {
    const o = t.constructor.name, a = e.constructor.name;
    if (o !== a)
      throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${a}`);
  }
  if (Array.isArray(t) && Array.isArray(e)) {
    const o = so(t), a = so(e);
    if (!Bt(o, a))
      throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${a}]`);
  }
  const i = os(t) ? t : no(t), r = os(e) ? e : no(e);
  if (i.length !== r.length)
    throw new Error(`Arrays have different lengths actual: ${i.length} vs expected: ${r.length}.
Actual:   ${i}.
Expected: ${r}.`);
  for (let o = 0; o < r.length; ++o) {
    const a = i[o], c = r[o];
    if (!n(a, c))
      throw new Error(`Arrays differ: actual[${o}] = ${a}, expected[${o}] = ${c}.
Actual:   ${i}.
Expected: ${r}.`);
  }
  typeof expect < "u" && expect().nothing();
}
function kH(t, e) {
  t().then(() => e.fail(), () => e()), typeof expect < "u" && expect().nothing();
}
function AH(t, e) {
  const n = typeof e == "string" || typeof e == "number" || typeof e == "boolean" ? [e] : e;
  return Wr(t) || Wr(t[0]) || Wr(e) || Wr(e[0]) ? Kw(t, n, (s, i) => s == i) : Kw(t, e, (s, i) => e_(s, i, 0));
}
function MH(t, e, n) {
  if (n == null && (n = QS()), !e_(t, e, n))
    throw new Error(`Numbers differ: actual === ${t}, expected === ${e}`);
  typeof expect < "u" && expect().nothing();
}
function e_(t, e, n) {
  return !isFinite(t) && !isFinite(e) ? !0 : !(isNaN(t) || isNaN(e) || Math.abs(t - e) > n);
}
function RH(t, e, n) {
  for (let s = 0; s < t.length; s++)
    if (t[s] < e || t[s] > n)
      throw new Error(`Value out of range:${t[s]} low: ${e}, high: ${n}`);
}
function DH(t, e) {
  const n = new Float32Array(t), s = new Float32Array(e);
  if (n.length !== s.length)
    throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${n.length}`);
  for (let i = 0; i < s.length; i++)
    if (n[i] !== s[i])
      throw new Error(`Expected ArrayBuffer value at ${i} to be ${s[i]} but got ${n[i]} instead`);
}
function Pk(t) {
  for (let e = 0; e < t.length; e++) {
    const n = t[e];
    Array.isArray(n) ? Pk(n) : t[e] = jr(n);
  }
  return t;
}
function $H(t) {
  const e = document.createElement("video");
  return "playsInline" in e && (e.playsInline = !0), e.muted = !0, e.loop = !0, e.style.position = "fixed", e.style.left = "0px", e.style.top = "0px", e.preload = "auto", e.appendChild(t), new Promise((n) => {
    e.addEventListener("loadeddata", (s) => n(e)), e.load();
  });
}
async function OH(t) {
  await t.play(), "requestVideoFrameCallback" in t && await new Promise((e) => {
    t.requestVideoFrameCallback(e);
  });
}
const LH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TEST_EPSILON_FLOAT16: Fk,
  createVideoElement: $H,
  encodeStrings: Pk,
  expectArrayBuffersEqual: DH,
  expectArraysClose: NH,
  expectArraysEqual: AH,
  expectNumbersClose: MH,
  expectPromiseToFail: kH,
  expectValuesInRange: RH,
  play: OH,
  testEpsilon: QS
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class t_ {
  constructor(e, n, s, i, r) {
    this.mean = e, this.stdDev = n, this.dtype = s, this.nextVal = NaN, this.truncated = i, this.truncated && (this.upper = this.mean + this.stdDev * 2, this.lower = this.mean - this.stdDev * 2);
    const o = r || Math.random();
    this.random = B0.alea(o.toString());
  }
  /** Returns next sample from a Gaussian distribution. */
  nextValue() {
    if (!isNaN(this.nextVal)) {
      const i = this.nextVal;
      return this.nextVal = NaN, i;
    }
    let e, n, s = !1;
    for (; !s; ) {
      let i, r, o;
      do
        i = 2 * this.random() - 1, r = 2 * this.random() - 1, o = i * i + r * r;
      while (o >= 1 || o === 0);
      const a = Math.sqrt(-2 * Math.log(o) / o);
      e = this.mean + this.stdDev * i * a, n = this.mean + this.stdDev * r * a, (!this.truncated || this.isValidTruncated(e)) && (s = !0);
    }
    return (!this.truncated || this.isValidTruncated(n)) && (this.nextVal = this.convertValue(n)), this.convertValue(e);
  }
  /** Handles proper rounding for non-floating-point numbers. */
  convertValue(e) {
    return this.dtype == null || this.dtype === "float32" ? e : Math.round(e);
  }
  /** Returns true if less than 2-standard-deviations from the mean. */
  isValidTruncated(e) {
    return e <= this.upper && e >= this.lower;
  }
}
class FH {
  constructor(e, n, s, i) {
    this.alpha = e, this.beta = 1 / n, this.dtype = s;
    const r = i || Math.random();
    this.randu = B0.alea(r.toString()), this.randn = new t_(0, 1, s, !1, this.randu()), e < 1 ? this.d = e + 2 / 3 : this.d = e - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
  }
  /** Returns next sample from a gamma distribution. */
  nextValue() {
    let e, n, s, i, r, o;
    for (; ; ) {
      do
        i = this.randn.nextValue(), o = 1 + this.c * i;
      while (o <= 0);
      if (o *= o * o, e = i * i, n = 1 - 0.331 * e * e, s = 0.5 * e + this.d * (1 - o + Math.log(o)), r = this.randu(), r < n || Math.log(r) < s)
        break;
    }
    return o = 1 / this.beta * this.d * o, this.alpha < 1 && (o *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(o);
  }
  /** Handles proper rounding for non-floating-point numbers. */
  convertValue(e) {
    return this.dtype === "float32" ? e : Math.round(e);
  }
}
class PH {
  constructor(e = 0, n = 1, s, i) {
    if (this.canReturnFloat = () => this.dtype == null || this.dtype === "float32", this.min = e, this.range = n - e, this.dtype = s, i == null && (i = Math.random()), typeof i == "number" && (i = i.toString()), !this.canReturnFloat() && this.range <= 1)
      throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);
    this.random = B0.alea(i);
  }
  convertValue(e) {
    return this.canReturnFloat() ? e : Math.round(e);
  }
  nextValue() {
    return this.convertValue(this.min + this.range * this.random());
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BH(t, e, n = 1, s = "float32", i) {
  if (_i(t), n == null && (n = 1), s == null && (s = "float32"), s !== "float32" && s !== "int32")
    throw new Error(`Unsupported data type ${s}`);
  const r = new FH(e, n, s, i), o = It(t, s);
  for (let a = 0; a < o.values.length; a++)
    o.values[a] = r.nextValue();
  return o.toTensor();
}
const Bk = /* @__PURE__ */ H({ randomGamma_: BH });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zH(t, e = 0, n = 1, s, i) {
  if (_i(t), s != null && s === "bool")
    throw new Error(`Unsupported data type ${s}`);
  const r = new t_(e, n, s, !1, i), o = It(t, s);
  for (let a = 0; a < o.values.length; a++)
    o.values[a] = r.nextValue();
  return o.toTensor();
}
const z0 = /* @__PURE__ */ H({ randomNormal_: zH });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VH(t, e, n) {
  if (e != null && e === "bool")
    throw new Error(`Unsupported data type ${e}`);
  return z0(t, 0, 1, e, n);
}
const zk = /* @__PURE__ */ H({ randomStandardNormal_: VH });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UH(t, e = 0, n = 1, s = "float32", i) {
  _i(t);
  const r = It(t, s), o = new PH(e, n, null, i);
  for (let a = 0; a < r.values.length; a++)
    r.values[a] = o.nextValue();
  return r.toTensor();
}
const Va = /* @__PURE__ */ H({ randomUniform_: UH });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GH(t, e, n, s) {
  return Va(t, e, n, "int32", s);
}
const Vk = /* @__PURE__ */ H({ randomUniformInt_: GH });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Oo(t, e, n = 1, s = "float32") {
  if (n === 0)
    throw new Error("Cannot have a step of zero");
  const i = { start: t, stop: e, step: n, dtype: s };
  return G.runKernel(n0, {}, i);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function WH(t) {
  const n = { input: R(t, "input", "real") };
  return G.runKernel(s0, n);
}
const _u = /* @__PURE__ */ H({ real_: WH });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HH(t) {
  const n = { x: R(t, "x", "reciprocal") };
  return G.runKernel(fh, n);
}
const n_ = /* @__PURE__ */ H({ reciprocal_: HH });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jH(t) {
  const n = { x: R(t, "x", "relu") };
  return G.runKernel(ph, n);
}
const kr = /* @__PURE__ */ H({ relu_: jH });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qH(t) {
  const n = { x: R(t, "x", "relu6") };
  return G.runKernel(mh, n);
}
const V0 = /* @__PURE__ */ H({ relu6_: qH });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XH(t, e) {
  const s = { x: R(t, "x", "reverse") }, i = { dims: e };
  return G.runKernel(kp, s, i);
}
const Fi = /* @__PURE__ */ H({ reverse_: XH });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function KH(t) {
  const e = R(t, "x", "reverse");
  return A(e.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`), Fi(e, 0);
}
const Uk = /* @__PURE__ */ H({ reverse1d_: KH });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YH(t, e) {
  const n = R(t, "x", "reverse");
  return A(n.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`), Fi(n, e);
}
const Gk = /* @__PURE__ */ H({ reverse2d_: YH });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ZH(t, e) {
  const n = R(t, "x", "reverse");
  return A(n.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`), Fi(n, e);
}
const Wk = /* @__PURE__ */ H({ reverse3d_: ZH });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JH(t, e) {
  const n = R(t, "x", "reverse");
  return A(n.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`), Fi(n, e);
}
const Hk = /* @__PURE__ */ H({ reverse4d_: JH });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function QH(t) {
  const n = { x: R(t, "x", "round") };
  return G.runKernel(gh, n);
}
const nm = /* @__PURE__ */ H({ round_: QH });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function e5(t) {
  const n = { x: R(t, "x", "rsqrt", "float32") };
  return G.runKernel(yh, n);
}
const U0 = /* @__PURE__ */ H({ rsqrt_: e5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function t5(t) {
  const n = { x: R(t, "x", "selu") };
  return G.runKernel(xh, n);
}
const G0 = /* @__PURE__ */ H({ selu_: t5 });
function n5(t, e, n, s, i, r = [1, 1], o = "NHWC") {
  const a = R(t, "x", "separableConv2d"), c = R(e, "depthwiseFilter", "separableConv2d"), l = R(n, "pointwiseFilter", "separableConv2d");
  let u = a, h = !1;
  if (a.rank === 3 && (h = !0, u = Y(a, [1, a.shape[0], a.shape[1], a.shape[2]])), o === "NCHW")
    throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
  A(u.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`), A(c.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`), A(l.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`), A(l.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`), A(l.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);
  const d = c.shape[2], f = c.shape[3];
  A(l.shape[2] === d * f, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${d * f}, but got ${l.shape[2]}.`);
  const p = Rh(u, c, s, i, o, r), g = $o(p, l, 1, "valid", o);
  return h ? Y(g, [g.shape[1], g.shape[2], g.shape[3]]) : g;
}
const W0 = /* @__PURE__ */ H({ separableConv2d_: n5 });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function s5(t, e) {
  const n = R(t, "x", "setdiff1d"), s = R(e, "y", "setdiff1d");
  A(n.dtype === s.dtype, () => `x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`), A(n.rank === 1, () => `x should be 1D tensor, but got x (${n.shape}).`), A(s.rank === 1, () => `y should be 1D tensor, but got y (${s.shape}).`);
  const i = await n.data(), r = await s.data(), o = new Set(r);
  let a = 0;
  for (let u = 0; u < i.length; u++)
    o.has(i[u]) || a++;
  const c = new Xn([a], n.dtype), l = new Xn([a], "int32");
  for (let u = 0, h = 0; u < i.length; u++)
    o.has(i[u]) || (c.values[h] = i[u], l.values[h] = u, h++);
  return [c.toTensor(), l.toTensor()];
}
const jk = s5;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i5(t) {
  const n = { x: R(t, "x", "sign") };
  return G.runKernel(wh, n);
}
const s_ = /* @__PURE__ */ H({ sign_: i5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r5(t) {
  const n = { x: R(t, "x", "sin", "float32") };
  return G.runKernel(bh, n);
}
const H0 = /* @__PURE__ */ H({ sin_: r5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o5(t) {
  const n = { x: R(t, "x", "sinh") };
  return G.runKernel(vh, n);
}
const j0 = /* @__PURE__ */ H({ sinh_: o5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function a5(t, e, n) {
  const s = R(t, "x", "slice1d");
  return A(s.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`), Pt(s, [e], [n]);
}
const sm = /* @__PURE__ */ H({ slice1d_: a5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c5(t, e, n) {
  const s = R(t, "x", "slice2d");
  return A(s.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`), Pt(s, e, n);
}
const q0 = /* @__PURE__ */ H({ slice2d_: c5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l5(t, e, n) {
  const s = R(t, "x", "slice3d");
  return A(s.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`), Pt(s, e, n);
}
const im = /* @__PURE__ */ H({ slice3d_: l5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u5(t, e, n) {
  const s = R(t, "x", "slice4d");
  return A(s.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`), Pt(s, e, n);
}
const Tu = /* @__PURE__ */ H({ slice4d_: u5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function h5(t, e = -1) {
  const n = R(t, "logits", "softmax", "float32");
  if (e === -1 && (e = n.rank - 1), e !== n.rank - 1)
    throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);
  const s = { logits: n }, i = { dim: e };
  return G.runKernel(Op, s, i);
}
const rm = /* @__PURE__ */ H({ softmax_: h5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function d5(t) {
  A(t.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);
  const e = { input: t };
  return G.runKernel(Px, e);
}
const om = /* @__PURE__ */ H({ fft_: d5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function f5(t) {
  A(t.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);
  const e = { input: t };
  return G.runKernel(Ux, e);
}
const Cu = /* @__PURE__ */ H({ ifft_: f5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function p5(t) {
  const e = t.shape[t.shape.length - 1], n = t.size / e;
  let s;
  if (e <= 2) {
    const i = Y(t, [n, e]);
    s = Cu(i);
  } else {
    const i = [n, 2 * (e - 1)], r = Y(_u(t), [n, e]), o = Y(qp(t), [n, e]), a = Fi(Pt(r, [0, 1], [n, e - 2]), 1), c = q(Fi(Pt(o, [0, 1], [n, e - 2]), 1), ot(-1)), l = Pn([r, a], 1), u = Pn([o, c], 1), h = Y(Do(l, u), [i[0], i[1]]);
    s = Cu(h);
  }
  if (s = _u(s), t.rank === 3 && t.shape[0] !== 0) {
    const i = s, r = t.shape[0];
    s = Y(s, [r, s.shape[0] / r, s.shape[1]]), i.dispose();
  }
  return s;
}
const X0 = /* @__PURE__ */ H({ irfft_: p5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function m5(t, e, n = 0) {
  const i = { x: R(t, "x", "split") }, r = { numOrSizeSplits: e, axis: n };
  return G.runKernel($p, i, r);
}
const ti = /* @__PURE__ */ H({ split_: m5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function g5(t, e) {
  A(t.dtype === "float32", () => `The dtype for rfft() must be real value but got ${t.dtype}`);
  let n = t.shape[t.shape.length - 1];
  const s = t.size / n;
  let i;
  if (e != null && e < n) {
    const p = t.shape.map((g) => 0), y = t.shape.map((g) => g);
    y[t.shape.length - 1] = e, i = Pt(t, p, y), n = e;
  } else if (e != null && e > n) {
    const p = t.shape.map((y) => y);
    p[t.shape.length - 1] = e - n, i = Pn([t, qn(p)], t.shape.length - 1), n = e;
  } else
    i = t;
  const r = Ut(i), o = Y(Do(i, r), [s, n]), a = om(o), c = Math.floor(n / 2) + 1, l = _u(a), u = qp(a), h = ti(l, [c, n - c], l.shape.length - 1), d = ti(u, [c, n - c], u.shape.length - 1), f = i.shape.slice();
  return f[i.shape.length - 1] = c, Y(Do(h[0], d[0]), f);
}
const am = /* @__PURE__ */ H({ rfft_: g5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function y5(t, e) {
  let n = R(t, "a", "squaredDifference"), s = R(e, "b", "squaredDifference");
  [n, s] = kn(n, s), bt(n.shape, s.shape);
  const i = { a: n, b: s }, r = {};
  return G.runKernel(Ch, i, r);
}
const K0 = /* @__PURE__ */ H({ squaredDifference_: y5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function x5(t, e) {
  const n = R(t, "x", "squeeze", "string_or_numeric");
  return Y(n, zo(n.shape, e).newShape);
}
const ys = /* @__PURE__ */ H({ squeeze_: x5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function b5(t, e = 0) {
  const n = yf(t, "tensors", "stack", "string_or_numeric");
  A(n.length >= 1, () => "Pass at least one tensor to tf.stack"), n.length > 0 && A(e <= n[0].rank, () => "Axis must be <= rank of the tensor");
  const s = n, i = { axis: e };
  return G.runKernel(Sp, s, i);
}
const ri = /* @__PURE__ */ H({ stack_: b5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function v5(t, e = 0) {
  const s = { x: R(t, "x", "step") }, i = { alpha: e };
  return G.runKernel(Ah, s, i);
}
const rl = /* @__PURE__ */ H({ step_: v5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function w5(t, e, n, s, i = 0, r = 0, o = 0, a = 0, c = 0) {
  const u = { x: R(t, "x", "stridedSlice", "string_or_numeric") }, h = {
    begin: e,
    end: n,
    strides: s,
    beginMask: i,
    endMask: r,
    ellipsisMask: o,
    newAxisMask: a,
    shrinkAxisMask: c
  };
  return G.runKernel(m0, u, h);
}
const i_ = /* @__PURE__ */ H({ stridedSlice_: w5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function S5(t) {
  const n = { x: R(t, "x", "tan", "float32") };
  return G.runKernel(Eh, n);
}
const r_ = /* @__PURE__ */ H({ tan_: S5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ns(t, e) {
  Yc(t);
  const n = so(t, e);
  if (n.length !== 1)
    throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return Fa(t, null, n, e);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _c(t, e, n) {
  if (Yc(t), e != null && e.length !== 2)
    throw new Error("tensor2d() requires shape to have two numbers");
  const s = so(t, n);
  if (s.length !== 2 && s.length !== 1)
    throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (s.length === 1 && e == null)
    throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return Fa(t, e, s, n);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o_(t, e, n) {
  if (Yc(t), e != null && e.length !== 3)
    throw new Error("tensor3d() requires shape to have three numbers");
  const s = so(t, n);
  if (s.length !== 3 && s.length !== 1)
    throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (s.length === 1 && e == null)
    throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return Fa(t, e, s, n);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qk(t, e, n) {
  if (Yc(t), e != null && e.length !== 4)
    throw new Error("tensor4d() requires shape to have four numbers");
  const s = so(t, n);
  if (s.length !== 4 && s.length !== 1)
    throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  if (s.length === 1 && e == null)
    throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  return Fa(t, e, s, n);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xk(t, e, n) {
  if (Yc(t), e != null && e.length !== 5)
    throw new Error("tensor5d() requires shape to have five numbers");
  const s = so(t, n);
  if (s.length !== 5 && s.length !== 1)
    throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  if (s.length === 1 && e == null)
    throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  return Fa(t, e, s, n);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Kk(t, e, n) {
  if (Yc(t), e != null && e.length !== 6)
    throw new Error("tensor6d() requires shape to have six numbers");
  const s = so(t, n);
  if (s.length !== 6 && s.length !== 1)
    throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  if (s.length === 1 && e == null)
    throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  return e = e || s, Fa(t, e, s, n);
}
function a_(t, e, n) {
  const s = e.rank > 1 ? e.shape[e.rank - 1] : 1, i = e.rank > 1 ? e.rank - 1 : 1, r = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${s}, and batchDim: ${i}.`;
  if (n.rank < i)
    throw new Error(r + ` update.rank < ${i}. `);
  if (t.length < s + (n.rank - i))
    throw new Error(r + ` Output shape length < ${s + (n.rank - i)}`);
  if (n.rank !== i + t.length - s)
    throw new Error(r + ` update.rank != ${i + t.length - s}`);
  for (let o = 0; o < i; ++o)
    if (n.shape[o] !== e.shape[o])
      throw new Error(r + ` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);
  for (let o = 0; o < n.rank - i; ++o)
    if (n.shape[o + i] !== t[o + s])
      throw new Error(r + ` updates.shape[${o + i}] (${n.shape[o + i]}) != shape[${o + i}] (${t[o + i]})`);
}
function Y0(t, e, n) {
  if (e.rank < 1)
    throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);
  if (t.rank < 1)
    throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);
  if (e.dtype !== "int32")
    throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);
  if (n.length < 1)
    throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);
  if (n.length === 0) {
    if (e.size === 0)
      throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);
    if (t.size === 0)
      throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`);
  }
  a_(n, e, t);
}
function Ua(t, e, n) {
  const s = e.shape.length, i = s > 1 ? e.shape[s - 1] : 1, r = n.length;
  let o = 1;
  for (let h = i; h < r; ++h)
    o *= n[h];
  const a = i < 1 ? 1 : i, c = ue(e.shape) / a, l = [...ct(n.slice(0, i)), 1], u = ue(n);
  return { sliceRank: i, numUpdates: c, sliceSize: o, strides: l, outputSize: u };
}
const _5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  calculateShapes: Ua,
  validateInput: Y0,
  validateUpdateShape: a_
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function T5(t, e, n) {
  const s = R(t, "tensor", "tensorScatterupdate"), i = R(e, "indices", "tensorScatterupdate", "int32"), r = R(n, "updates", "tensorScatterupdate");
  if (Y0(r, i, s.shape), s.dtype !== r.dtype)
    throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${r.dtype}.`);
  const o = {
    tensor: s,
    indices: i,
    updates: r
  }, a = {};
  return G.runKernel(a0, o, a);
}
const Yk = H({ tensorScatterUpdate_: T5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function C5(t, e = 1, n = !0) {
  const s = R(t, "x", "topk");
  if (s.rank === 0)
    throw new Error("topk() expects the input to be of rank 1 or higher");
  const i = s.shape[s.shape.length - 1];
  if (e < 0)
    throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);
  if (e > i)
    throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);
  const r = { x: s }, o = { k: e, sorted: n }, [a, c] = G.runKernel(b0, r, o);
  return { values: a, indices: c };
}
const c_ = /* @__PURE__ */ H({ topk_: C5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function I5(t, e = 0, n = 1, s, i) {
  if (_i(t), s != null && s === "bool")
    throw new Error("Unsupported data type $ { dtype }");
  const r = new t_(e, n, s, !0, i), o = It(t, s);
  for (let a = 0; a < o.values.length; a++)
    o.values[a] = r.nextValue();
  return o.toTensor();
}
const Z0 = /* @__PURE__ */ H({ truncatedNormal_: I5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function E5(t, e = 0) {
  const n = R(t, "x", "unique", "string_or_numeric");
  A(n.rank > 0, () => "The input tensor must be at least 1D");
  const s = { x: n }, i = { axis: e }, [r, o] = G.runKernel(w0, s, i);
  return { values: r, indices: o };
}
const l_ = /* @__PURE__ */ H({ unique_: E5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function N5(t, e, n) {
  const s = R(t, "x", "unsortedSegmentSum"), i = R(e, "segmentIds", "unsortedSegmentSum", "int32");
  A(Lc(n), () => "numSegments must be of dtype int");
  const r = { x: s, segmentIds: i }, o = { numSegments: n };
  return G.runKernel(Pp, r, o);
}
const J0 = /* @__PURE__ */ H({ unsortedSegmentSum_: N5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function k5(t, e = 0) {
  const n = R(t, "x", "unstack", "string_or_numeric");
  A(e >= -n.shape.length && e < n.shape.length, () => `Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);
  const s = { value: n }, i = { axis: e };
  return G.runKernel(Fp, s, i);
}
const Pi = /* @__PURE__ */ H({ unstack_: k5 });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zk(t, e) {
  return F0(t, e, "right");
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u_(t, e = !0, n, s) {
  return G.makeVariable(t, e, n, s);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Q0(t, e) {
  const n = [];
  for (let r = 0; r < e.length; r++)
    e[r] && n.push(r);
  const s = It(t, "int32"), i = It([n.length, t.length], "int32");
  for (let r = 0; r < n.length; r++) {
    const o = s.indexToLoc(n[r]), a = r * t.length;
    i.values.set(o, a);
  }
  return i.toTensor();
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function A5(t) {
  const e = R(t, "condition", "whereAsync", "bool"), n = await e.data(), s = Q0(e.shape, n);
  return t !== e && e.dispose(), s;
}
const h_ = A5;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function M5(t, e, n) {
  const s = R(t, "tensor", "boolMask"), i = R(e, "mask", "boolMask", "bool"), r = n ?? 0, o = i.rank, a = s.shape;
  A(o > 0, () => "mask cannot be scalar"), ws(a.slice(r, r + o), i.shape, "mask's shape must match the first K dimensions of tensor's shape,");
  let c = 1;
  for (let y = r; y < r + o; y++)
    c *= a[y];
  const l = a.slice(0, r).concat([c], a.slice(r + o)), u = Y(s, l), h = Y(i, [-1]), d = await h_(h), f = ys(d, [1]), p = Lh(u, f, r);
  return t !== s && s.dispose(), e !== i && i.dispose(), f.dispose(), u.dispose(), h.dispose(), d.dispose(), p;
}
const Jk = M5;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R5(t, e, n) {
  const s = R(t, "x", "transpose");
  if (e == null && (e = s.shape.map((o, a) => a).reverse()), A(s.rank === e.length, () => `Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`), e.forEach((o) => {
    A(o >= 0 && o < s.rank, () => `All entries in 'perm' must be between 0 and ${s.rank - 1} but got ${e}`);
  }), s.rank <= 1)
    return s.clone();
  const i = { x: s }, r = { perm: e };
  return s.dtype === "complex64" ? Q(() => {
    let o = _u(s), a = qp(s);
    return o = G.runKernel(wc, { x: o }, r), a = G.runKernel(wc, { x: a }, r), n && (a = hn(a)), Do(o, a);
  }) : G.runKernel(wc, i, r);
}
const zt = /* @__PURE__ */ H({ transpose_: R5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function D5(t, e, n, s, i = !0) {
  const r = R(t, "v", "movingAverage"), o = R(e, "x", "movingAverage"), a = R(n, "decay", "movingAverage");
  XN(r, o), A(Bt(r.shape, o.shape), () => "Shape mismatch in v and x");
  const c = ot(1), l = je(c, a);
  let u = q(je(o, r), l);
  if (i) {
    A(s != null, () => "When using zeroDebias: true, step is required.");
    const h = R(s, "step", "movingAverage");
    u = it(u, je(c, io(a, h)));
  }
  return Se(r, u);
}
const Qk = /* @__PURE__ */ H({ movingAverage_: D5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $5(t, e, n) {
  _i(n);
  const s = R(t, "indices", "scatterND", "int32"), i = R(e, "updates", "scatterND");
  Y0(i, s, n);
  const r = { indices: s, updates: i }, o = { shape: n };
  return G.runKernel(o0, r, o);
}
const eA = /* @__PURE__ */ H({ scatterND_: $5 });
function O5(t, e, n, s) {
  if (t.dtype !== "int32")
    throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);
  if (t.rank > 2)
    throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);
  const i = t.rank > 0 ? t.shape[0] : 1, r = t.rank > 1 ? t.shape[1] : 1;
  if (n.length !== r)
    throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${r}.`);
  const o = e.size;
  if (!(e.rank === 0 || e.rank === 1 && o === i))
    throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);
  if (e.dtype !== s.dtype)
    throw new Error("sparseValues.dtype must match defaultValues.dtype");
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function L5(t, e, n, s = 0) {
  _i(n);
  const i = R(t, "sparseIndices", "sparseToDense", "int32"), r = R(e, "sparseValues", "sparseToDense", "string_or_numeric"), o = R(s, "defaultValue", "sparseToDense", r.dtype);
  O5(i, r, n, o);
  const a = {
    sparseIndices: i,
    sparseValues: r,
    defaultValue: o
  }, c = { outputShape: n };
  return G.runKernel(f0, a, c);
}
const tA = /* @__PURE__ */ H({ sparseToDense_: L5 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function F5(t, e) {
  const n = R(e, "indices", "gatherND", "int32"), i = { params: R(t, "x", "gatherND", "string_or_numeric"), indices: n };
  return G.runKernel(Vx, i);
}
const nA = /* @__PURE__ */ H({ gatherND_: F5 });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function P5(t, e) {
  if (e == null)
    return t.shape.slice();
  if (Bt(t.shape, e))
    return e;
  if (t.shape.length === e.length) {
    const n = [];
    for (let s = 0; s < t.shape.length; s++)
      e[s] == null && t.shape[s] != null ? n.push(t.shape[s]) : n.push(e[s]);
    return n;
  }
  return e;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function B5(t, e, n, s) {
  const i = R(t, "x", "dropout");
  if (A(i.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`), A(e >= 0 && e < 1, () => `rate must be a float in the range [0, 1), but got ${e}.`), e === 0)
    return t instanceof Lt ? i.clone() : i;
  const r = P5(i, n), o = 1 - e, a = it(Oh(Se(Va(r, 0, 1, "float32", s), o)), o);
  return q(i, a);
}
const d_ = /* @__PURE__ */ H({ dropout_: B5 });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function f_(t) {
  return Math.floor(Math.pow(2, Math.ceil(Math.log(t) / Math.log(2))));
}
function eb(t, e, n) {
  const s = 1 - t % 2, i = new Float32Array(t);
  for (let r = 0; r < t; ++r) {
    const o = 2 * Math.PI * r / (t + s - 1);
    i[r] = e - n * Math.cos(o);
  }
  return Ns(i, "float32");
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function z5(t, e, n = 1) {
  const s = R(t, "predictions", "inTopK"), i = R(e, "targets", "inTopK");
  A(s.rank > 1, () => `inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`), A(s.rank - 1 === i.rank, () => `predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${i.rank}`), ws(s.shape.slice(0, s.shape.length - 1), i.shape, "predictions's shape should be align with the targets' shape, except the last dimension.");
  const r = s.shape[s.shape.length - 1];
  A(n > 0 && n <= r, () => `'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${r}), but got ${n}`);
  const o = await s.data(), a = await i.data(), [c, l] = [o.length / r, r], u = ls("bool", c);
  for (let h = 0; h < c; h++) {
    const d = h * l, f = o.subarray(d, d + l), p = [];
    for (let y = 0; y < f.length; y++)
      p.push({ value: f[y], index: y });
    p.sort((y, g) => g.value - y.value), u[h] = 0;
    for (let y = 0; y < n; y++)
      if (p[y].index === a[h]) {
        u[h] = 1;
        break;
      }
  }
  return t !== s && s.dispose(), e !== i && i.dispose(), Mi(u, i.shape, "bool");
}
const sA = z5;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function V5(t, e, n, s, i, r = "NHWC", o) {
  let a = t;
  t.rank === 3 && (a = Y(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
  let c = e;
  c.rank === 3 && (c = Y(e, [1, e.shape[0], e.shape[1], e.shape[2]])), A(a.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`), A(c.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`), A(n.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);
  const l = r === "NHWC" ? a.shape[3] : a.shape[1], u = r === "NHWC" ? c.shape[3] : c.shape[1];
  A(l === n[2], () => `Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`), A(u === n[3], () => `Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`), Hs("conv2dDerFilter", i, o);
  const h = { x: a, dy: c }, d = { strides: s, pad: i, dataFormat: r, dimRoundingMode: o, filterShape: n };
  return G.runKernel(Cx, h, d);
}
const p_ = /* @__PURE__ */ H({ conv2DBackpropFilter_: V5 });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tb(t, e, n) {
  if (n == null || n === "linear")
    return t;
  if (n === "relu")
    return q(t, rl(e));
  throw new Error(`Cannot compute gradient for fused activation ${n}.`);
}
function nb(t, e) {
  let n = e;
  const s = Kn(t.shape, e.shape);
  return s.length > 0 && (n = Qe(n, s)), Y(n, t.shape);
}
function sb(t, e, n, s) {
  if (e === "linear")
    return t;
  if (e === "relu")
    return kr(t);
  if (e === "elu")
    return Dh(t);
  if (e === "relu6")
    return V0(t);
  if (e === "prelu")
    return tm(t, n);
  if (e === "leakyrelu")
    return Xp(t, s);
  if (e === "sigmoid")
    return mi(t);
  throw new Error(`Unknown fused activation ${e}.`);
}
const ib = (t, e) => !(t > 0) || e === "linear";
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function U5({ x: t, filter: e, strides: n, pad: s, dataFormat: i = "NHWC", dilations: r = [1, 1], dimRoundingMode: o, bias: a, activation: c = "linear", preluActivationWeights: l, leakyreluAlpha: u }) {
  if (c = c || "linear", ib(G.state.gradientDepth, c) === !1) {
    A(i === "NHWC", () => `Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);
    let S = $o(t, e, n, s, i, r, o);
    return a != null && (S = Se(S, a)), sb(S, c, l, u);
  }
  const h = R(t, "x", "conv2d", "float32"), d = R(e, "filter", "conv2d", "float32");
  let f = h, p = !1;
  h.rank === 3 && (p = !0, f = Y(h, [1, h.shape[0], h.shape[1], h.shape[2]])), A(f.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`), A(d.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`), Hs("fused conv2d", s, o);
  const y = i === "NHWC" ? f.shape[3] : f.shape[1];
  A(d.shape[2] === y, () => `Error in conv2d: depth of input (${y}) must match input depth for filter ${d.shape[2]}.`), A(Ss(n, r), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${r}'`);
  const g = hs(f.shape, d.shape, n, r, s, o);
  let m;
  a != null && (m = R(a, "bias", "fused conv2d"), [m] = kn(m, h), i === "NHWC" ? bt(g.outShape, m.shape) : (A(m.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${m.shape.length}.`), A(m.shape.length === 0 || m.shape[0] === g.outChannels || m.shape[0] === 1, () => `Error in fused conv2d: bias shape (${m.shape}) is not compatible with the number of output channels (${g.outChannels})`)));
  let x;
  if (l != null) {
    const S = l.shape;
    if (A(S.length <= 1 || S.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${S.length}.`), S.length === 1)
      A(S[0] === 1 || S[0] === g.outChannels, () => `Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the number of output channels (${g.outChannels}).`);
    else if (S.length === 3)
      try {
        bt(S, g.outShape);
      } catch {
        const E = `Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the output shape of the conv2d (${g.outShape}).`;
        throw Error(E);
      }
    x = R(l, "prelu weights", "fused conv2d");
  }
  const v = (S, _) => {
    A(i === "NHWC", () => `Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);
    const [E, I, k, M] = _, L = tb(S, k, c);
    A(Na(r), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);
    const O = IS(I.shape, L, E, n, s), $ = p_(I, L, E.shape, n, s), D = [O, $];
    if (M != null) {
      const z = nb(M, L);
      D.push(z);
    }
    return D;
  }, b = {
    x: f,
    filter: d,
    bias: m,
    preluActivationWeights: x
  }, w = {
    strides: n,
    pad: s,
    dataFormat: i,
    dilations: r,
    dimRoundingMode: o,
    activation: c,
    leakyreluAlpha: u
  };
  return a == null ? ro((_, E, I) => {
    let k = (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      G.runKernel(df, b, w)
    );
    return I([E, _, k]), p && (k = Y(k, [k.shape[1], k.shape[2], k.shape[3]])), { value: k, gradFunc: v };
  })(f, d) : ro((_, E, I, k) => {
    let M = G.runKernel(df, b, w);
    return k([E, _, M, I]), p && (M = Y(M, [M.shape[1], M.shape[2], M.shape[3]])), { value: M, gradFunc: v };
  })(f, d, m);
}
const iA = /* @__PURE__ */ H({ fusedConv2d_: U5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function G5(t, e, n, s, i, r = [1, 1], o) {
  let a = t;
  t.rank === 3 && (a = Y(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
  let c = e;
  c.rank === 3 && (c = Y(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
  const l = { x: a, dy: c }, u = { strides: s, pad: i, dimRoundingMode: o, dilations: r, filterShape: n };
  return G.runKernel(Rx, l, u);
}
const rA = H({ depthwiseConv2dNativeBackpropFilter_: G5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function W5(t, e, n, s, i, r = [1, 1], o) {
  let a = e, c = !1;
  e.rank === 3 && (c = !0, a = Y(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
  const l = { dy: a, filter: n }, u = { strides: s, pad: i, dimRoundingMode: o, dilations: r, inputShape: t }, h = (
    // tslint:disable-next-line: no-unnecessary-type-assertion
    G.runKernel(Dx, l, u)
  );
  return c ? Y(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
}
const oA = H({ depthwiseConv2dNativeBackpropInput_: W5 });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function H5({ x: t, filter: e, strides: n, pad: s, dataFormat: i = "NHWC", dilations: r = [1, 1], dimRoundingMode: o, bias: a, activation: c = "linear", preluActivationWeights: l, leakyreluAlpha: u }) {
  if (ib(G.state.gradientDepth, c) === !1) {
    let w = Rh(t, e, n, s, i, r, o);
    return a != null && (w = Se(w, a)), sb(w, c, l, u);
  }
  const h = R(t, "x", "depthwiseConv2d", "float32"), d = R(e, "filter", "depthwiseConv2d", "float32");
  let f = h, p = !1;
  h.rank === 3 && (p = !0, f = Y(h, [1, h.shape[0], h.shape[1], h.shape[2]])), A(f.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`), A(d.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`), A(f.shape[3] === d.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`), r == null && (r = [1, 1]), A(Ss(n, r), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${r}'`), Hs("fused depthwiseConv2d", s, o);
  const y = hs(
    f.shape,
    d.shape,
    n,
    r,
    s,
    o,
    !0
    /* depthwise */
  );
  let g;
  a != null && (g = R(a, "bias", "fused conv2d"), [g] = kn(g, h), bt(y.outShape, g.shape));
  let m;
  l != null && (m = R(l, "prelu weights", "fused depthwiseConv2d"));
  const x = (w, S) => {
    A(Na(r), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${r}'`);
    const [_, E, I, k] = S, M = tb(w, I, c), L = oA(E.shape, M, _, n, s, r, o), O = rA(E, M, _.shape, n, s, r, o);
    if (k != null) {
      const $ = nb(g, M);
      return [L, O, $];
    }
    return [L, O];
  }, v = {
    x: f,
    filter: d,
    bias: g,
    preluActivationWeights: m
  }, b = {
    strides: n,
    pad: s,
    dataFormat: i,
    dilations: r,
    dimRoundingMode: o,
    activation: c,
    leakyreluAlpha: u
  };
  return a == null ? ro((S, _, E) => {
    let I = G.runKernel(ff, v, b);
    return E([_, S, I]), p && (I = Y(I, [I.shape[1], I.shape[2], I.shape[3]])), { value: I, gradFunc: x };
  })(f, d) : ro((S, _, E, I) => {
    let k = G.runKernel(ff, v, b);
    return I([_, S, k, E]), p && (k = Y(k, [k.shape[1], k.shape[2], k.shape[3]])), { value: k, gradFunc: x };
  })(f, d, g);
}
const j5 = /* @__PURE__ */ H({ fusedDepthwiseConv2d_: H5 });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function q5({ a: t, b: e, transposeA: n = !1, transposeB: s = !1, bias: i, activation: r = "linear", preluActivationWeights: o, leakyreluAlpha: a = 0.2 }) {
  if (ib(G.state.gradientDepth, r) === !1) {
    let M = Tt(t, e, n, s);
    return i != null && (M = Se(M, i)), sb(M, r, o, a);
  }
  let c = R(t, "a", "fused matMul"), l = R(e, "b", "fused matMul");
  [c, l] = kn(c, l);
  const u = n ? c.shape[c.rank - 2] : c.shape[c.rank - 1], h = s ? l.shape[l.rank - 1] : l.shape[l.rank - 2], d = n ? c.shape[c.rank - 1] : c.shape[c.rank - 2], f = s ? l.shape[l.rank - 2] : l.shape[l.rank - 1], p = c.shape.slice(0, -2), y = l.shape.slice(0, -2), g = ue(p), m = ue(y);
  A(u === h, () => `Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${c.shape} and ${l.shape} and transposeA=${n} and transposeB=${s} must match.`);
  const v = bt(c.shape.slice(0, -2), l.shape.slice(0, -2)).concat([d, f]), b = n ? Y(c, [g, u, d]) : Y(c, [g, d, u]), w = s ? Y(l, [m, f, h]) : Y(l, [m, h, f]);
  let S;
  i != null && (S = R(i, "bias", "fused matMul"), [S] = kn(S, c), bt(v, S.shape));
  let _;
  o != null && (_ = R(o, "prelu weights", "fused matMul"));
  const E = (M, L) => {
    const [O, $, D, z] = L, W = tb(Y(M, D.shape), D, r);
    let j, J;
    if (!n && !s ? (j = Tt(W, $, !1, !0), J = Tt(O, W, !0, !1)) : !n && s ? (j = Tt(W, $, !1, !1), J = Tt(W, O, !0, !1)) : n && !s ? (j = Tt($, W, !1, !0), J = Tt(O, W, !1, !1)) : (j = Tt($, W, !0, !0), J = Tt(W, O, !0, !0)), i != null) {
      const ne = nb(z, W);
      return [j, J, ne];
    } else
      return [j, J];
  }, I = {
    a: b,
    b: w,
    bias: S,
    preluActivationWeights: _
  }, k = { transposeA: n, transposeB: s, activation: r, leakyreluAlpha: a };
  return i == null ? ro((L, O, $) => {
    const D = (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      G.runKernel(hf, I, k)
    );
    return $([L, O, D]), { value: Y(D, v), gradFunc: E };
  })(b, w) : ro((L, O, $, D) => {
    const z = (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      G.runKernel(hf, I, k)
    );
    return D([L, O, z, $]), { value: Y(z, v), gradFunc: E };
  })(b, w, S);
}
const Yw = /* @__PURE__ */ H({ fusedMatMul_: q5 });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const aA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  conv2d: iA,
  depthwiseConv2d: j5,
  matMul: Yw
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function X5(t) {
  return eb(t, 0.54, 0.46);
}
const K5 = /* @__PURE__ */ H({ hammingWindow_: X5 });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Y5(t) {
  return eb(t, 0.5, 0.5);
}
const cA = /* @__PURE__ */ H({ hannWindow_: Y5 });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Z5(t, e, n, s = !1, i = 0) {
  let r = 0;
  const o = [];
  for (; r + e <= t.size; )
    o.push(Pt(t, r, e)), r += n;
  if (s)
    for (; r < t.size; ) {
      const a = r + e - t.size, c = Pn([
        Pt(t, r, e - a),
        nl([a], i)
      ]);
      o.push(c), r += n;
    }
  return o.length === 0 ? _c([], [0, e]) : Y(Pn(o), [o.length, e]);
}
const lA = /* @__PURE__ */ H({ frame_: Z5 });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function J5(t, e, n, s, i = cA) {
  s == null && (s = f_(e));
  const r = lA(t, e, n), o = q(r, i(e));
  return am(o, s);
}
const Q5 = /* @__PURE__ */ H({ stft_: J5 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ej(t, e, n, s, i = "bilinear", r = 0) {
  const o = R(t, "image", "cropAndResize"), a = R(e, "boxes", "cropAndResize", "float32"), c = R(n, "boxInd", "cropAndResize", "int32"), l = a.shape[0];
  A(o.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`), A(a.rank === 2 && a.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`), A(c.rank === 1 && c.shape[0] === l, () => `Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`), A(s.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`), A(s[0] >= 1 && s[1] >= 1, () => `cropSize must be atleast [1,1], but was ${s}`), A(i === "bilinear" || i === "nearest", () => `method must be bilinear or nearest, but was ${i}`);
  const u = { image: o, boxes: a, boxInd: c }, h = { method: i, extrapolationValue: r, cropSize: s };
  return G.runKernel(kx, u, h);
}
const tj = /* @__PURE__ */ H({ cropAndResize_: ej });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nj(t) {
  const e = R(t, "image", "flipLeftRight", "float32");
  A(e.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);
  const n = { image: e };
  return G.runKernel(zx, n, {});
}
const sj = /* @__PURE__ */ H({ flipLeftRight_: nj });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ij(t) {
  const e = R(t, "image", "grayscaleToRGB"), n = e.rank - 1, s = e.shape[n];
  A(e.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`), A(s === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);
  const i = new Array(e.rank);
  return i.fill(1, 0, n), i[n] = 3, pi(e, i);
}
const rj = /* @__PURE__ */ H({ grayscaleToRGB_: ij });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oj(t) {
  const e = R(t, "image", "RGBToGrayscale"), n = e.rank - 1, s = e.shape[n];
  A(e.rank >= 2, () => `Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`), A(s === 3, () => `Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);
  const i = e.dtype, r = Le(e, "float32"), o = Ns([0.2989, 0.587, 0.114]);
  let a;
  switch (e.rank) {
    case 2:
      a = hc("ij,j->i", r, o);
      break;
    case 3:
      a = hc("ijk,k->ij", r, o);
      break;
    case 4:
      a = hc("ijkl,l->ijk", r, o);
      break;
    case 5:
      a = hc("ijklm,m->ijkl", r, o);
      break;
    case 6:
      a = hc("ijklmn,n->ijklm", r, o);
      break;
    default:
      throw new Error("Not a valid tensor rank.");
  }
  return a = vn(a, -1), Le(a, i);
}
const aj = /* @__PURE__ */ H({ rgbToGrayscale_: oj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cj(t, e, n = 0, s = 0.5) {
  const i = R(t, "image", "rotateWithOffset", "float32");
  A(i.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);
  const r = { image: i }, o = { radians: e, fillValue: n, center: s };
  return G.runKernel(S0, r, o);
}
const lj = /* @__PURE__ */ H({ rotateWithOffset_: cj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fh(t, e, n, s, i, r) {
  s == null && (s = 0.5), i == null && (i = Number.NEGATIVE_INFINITY), r == null && (r = 0);
  const o = t.shape[0];
  return n = Math.min(n, o), A(0 <= s && s <= 1, () => `iouThreshold must be in [0, 1], but was '${s}'`), A(t.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${t.rank}'`), A(t.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`), A(e.rank === 1, () => "scores must be a 1D tensor"), A(e.shape[0] === o, () => `scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`), A(0 <= r && r <= 1, () => `softNmsSigma must be in [0, 1], but was '${r}'`), { maxOutputSize: n, iouThreshold: s, scoreThreshold: i, softNmsSigma: r };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uj(t, e, n, s = 0.5, i = Number.NEGATIVE_INFINITY) {
  const r = R(t, "boxes", "nonMaxSuppression", "float32"), o = R(e, "scores", "nonMaxSuppression", "float32"), a = Fh(r, o, n, s, i);
  n = a.maxOutputSize, s = a.iouThreshold, i = a.scoreThreshold;
  const c = { maxOutputSize: n, iouThreshold: s, scoreThreshold: i };
  return G.runKernel(Yx, { boxes: r, scores: o }, c);
}
const hj = /* @__PURE__ */ H({ nonMaxSuppression_: uj });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dj(t, e, n) {
  const s = fj(t, e, n), i = s < 0 ? -(s + 1) : s;
  t.splice(i, 0, e);
}
function fj(t, e, n) {
  return mj(t, e, n || pj);
}
function pj(t, e) {
  return t > e ? 1 : t < e ? -1 : 0;
}
function mj(t, e, n) {
  let s = 0, i = t.length, r = 0, o = !1;
  for (; s < i; ) {
    r = s + (i - s >>> 1);
    const a = n(e, t[r]);
    a > 0 ? s = r + 1 : (i = r, o = !a);
  }
  return o ? s : -s - 1;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rb(t, e, n, s, i) {
  return m_(
    t,
    e,
    n,
    s,
    i,
    0
    /* softNmsSigma */
  );
}
function ob(t, e, n, s, i, r) {
  return m_(
    t,
    e,
    n,
    s,
    i,
    0,
    !1,
    r,
    !0
    /* returnValidOutputs */
  );
}
function ab(t, e, n, s, i, r) {
  return m_(
    t,
    e,
    n,
    s,
    i,
    r,
    !0
    /* returnScoresTensor */
  );
}
function m_(t, e, n, s, i, r, o = !1, a = !1, c = !1) {
  const l = [];
  for (let g = 0; g < e.length; g++)
    e[g] > i && l.push({ score: e[g], boxIndex: g, suppressBeginIndex: 0 });
  l.sort(L2);
  const u = r > 0 ? -0.5 / r : 0, h = [], d = [];
  for (; h.length < n && l.length > 0; ) {
    const g = l.pop(), { score: m, boxIndex: x, suppressBeginIndex: v } = g;
    if (m < i)
      break;
    let b = !1;
    for (let w = h.length - 1; w >= v; --w) {
      const S = gj(t, x, h[w]);
      if (S >= s) {
        b = !0;
        break;
      }
      if (g.score = g.score * yj(s, u, S), g.score <= i)
        break;
    }
    g.suppressBeginIndex = h.length, b || (g.score === m ? (h.push(x), d.push(g.score)) : g.score > i && dj(l, g, L2));
  }
  const f = h.length, p = n - f;
  a && p > 0 && (h.push(...new Array(p).fill(0)), d.push(...new Array(p).fill(0)));
  const y = { selectedIndices: h };
  return o && (y.selectedScores = d), c && (y.validOutputs = f), y;
}
function gj(t, e, n) {
  const s = t.subarray(e * 4, e * 4 + 4), i = t.subarray(n * 4, n * 4 + 4), r = Math.min(s[0], s[2]), o = Math.min(s[1], s[3]), a = Math.max(s[0], s[2]), c = Math.max(s[1], s[3]), l = Math.min(i[0], i[2]), u = Math.min(i[1], i[3]), h = Math.max(i[0], i[2]), d = Math.max(i[1], i[3]), f = (a - r) * (c - o), p = (h - l) * (d - u);
  if (f <= 0 || p <= 0)
    return 0;
  const y = Math.max(r, l), g = Math.max(o, u), m = Math.min(a, h), x = Math.min(c, d), v = Math.max(m - y, 0) * Math.max(x - g, 0);
  return v / (f + p - v);
}
function yj(t, e, n) {
  const s = Math.exp(e * n * n);
  return n <= t ? s : 0;
}
function L2(t, e) {
  return t.score - e.score || t.score === e.score && e.boxIndex - t.boxIndex;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function xj(t, e, n, s = 0.5, i = Number.NEGATIVE_INFINITY) {
  const r = R(t, "boxes", "nonMaxSuppressionAsync"), o = R(e, "scores", "nonMaxSuppressionAsync"), a = Fh(r, o, n, s, i);
  n = a.maxOutputSize, s = a.iouThreshold, i = a.scoreThreshold;
  const c = await Promise.all([r.data(), o.data()]), l = c[0], u = c[1], { selectedIndices: h } = rb(l, u, n, s, i);
  return r !== t && r.dispose(), o !== e && o.dispose(), Ns(h, "int32");
}
const bj = xj;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vj(t, e, n, s = 0.5, i = Number.NEGATIVE_INFINITY, r = 0) {
  const o = R(t, "boxes", "nonMaxSuppression"), a = R(e, "scores", "nonMaxSuppression"), c = Fh(o, a, n, s, i, r);
  n = c.maxOutputSize, s = c.iouThreshold, i = c.scoreThreshold, r = c.softNmsSigma;
  const l = { boxes: o, scores: a }, u = { maxOutputSize: n, iouThreshold: s, scoreThreshold: i, softNmsSigma: r }, h = G.runKernel(Jx, l, u);
  return { selectedIndices: h[0], selectedScores: h[1] };
}
const wj = /* @__PURE__ */ H({ nonMaxSuppressionWithScore_: vj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function Sj(t, e, n, s = 0.5, i = Number.NEGATIVE_INFINITY, r = 0) {
  const o = R(t, "boxes", "nonMaxSuppressionAsync"), a = R(e, "scores", "nonMaxSuppressionAsync"), c = Fh(o, a, n, s, i, r);
  n = c.maxOutputSize, s = c.iouThreshold, i = c.scoreThreshold, r = c.softNmsSigma;
  const l = await Promise.all([o.data(), a.data()]), u = l[0], h = l[1], { selectedIndices: d, selectedScores: f } = ab(u, h, n, s, i, r);
  return o !== t && o.dispose(), a !== e && a.dispose(), {
    selectedIndices: Ns(d, "int32"),
    selectedScores: Ns(f)
  };
}
const _j = Sj;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Tj(t, e, n, s = 0.5, i = Number.NEGATIVE_INFINITY, r = !1) {
  const o = R(t, "boxes", "nonMaxSuppression"), a = R(e, "scores", "nonMaxSuppression"), c = Fh(
    o,
    a,
    n,
    s,
    i,
    null
    /* softNmsSigma */
  ), l = c.maxOutputSize, u = c.iouThreshold, h = c.scoreThreshold, d = { boxes: o, scores: a }, f = {
    maxOutputSize: l,
    iouThreshold: u,
    scoreThreshold: h,
    padToMaxOutputSize: r
  }, p = G.runKernel(Zx, d, f);
  return { selectedIndices: p[0], validOutputs: p[1] };
}
const Cj = /* @__PURE__ */ H({ nonMaxSuppressionPadded_: Tj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function Ij(t, e, n, s = 0.5, i = Number.NEGATIVE_INFINITY, r = !1) {
  const o = R(t, "boxes", "nonMaxSuppressionAsync"), a = R(e, "scores", "nonMaxSuppressionAsync"), c = Fh(
    o,
    a,
    n,
    s,
    i,
    null
    /* softNmsSigma */
  ), l = c.maxOutputSize, u = c.iouThreshold, h = c.scoreThreshold, [d, f] = await Promise.all([o.data(), a.data()]), { selectedIndices: p, validOutputs: y } = ob(d, f, l, u, h, r);
  return o !== t && o.dispose(), a !== e && a.dispose(), {
    selectedIndices: Ns(p, "int32"),
    validOutputs: ot(y, "int32")
  };
}
const Ej = Ij;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nj(t, e, n = !1, s = !1) {
  const i = R(t, "images", "resizeBilinear");
  A(i.rank === 3 || i.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`), A(e.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${e}.`), A(s === !1 || n === !1, () => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");
  let r = i, o = !1;
  i.rank === 3 && (o = !0, r = Y(i, [1, i.shape[0], i.shape[1], i.shape[2]]));
  const a = { images: r }, c = { alignCorners: n, halfPixelCenters: s, size: e }, l = G.runKernel(Np, a, c);
  return o ? Y(l, [l.shape[1], l.shape[2], l.shape[3]]) : l;
}
const uA = /* @__PURE__ */ H({ resizeBilinear_: Nj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kj(t, e, n = !1, s = !1) {
  const i = R(t, "images", "resizeNearestNeighbor");
  A(i.rank === 3 || i.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`), A(e.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`), A(i.dtype === "float32" || i.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype"), A(s === !1 || n === !1, () => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");
  let r = i, o = !1;
  i.rank === 3 && (o = !0, r = Y(i, [1, i.shape[0], i.shape[1], i.shape[2]]));
  const a = { images: r }, c = { alignCorners: n, halfPixelCenters: s, size: e }, l = G.runKernel(Ep, a, c);
  return o ? Y(l, [l.shape[1], l.shape[2], l.shape[3]]) : l;
}
const hA = /* @__PURE__ */ H({ resizeNearestNeighbor_: kj });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Aj(t, e = "binary", n = !1, s = 0.5) {
  const i = R(t, "image", "threshold"), r = 0.2989, o = 0.587, a = 0.114, c = i.shape[0] * i.shape[1];
  let l = q(Ns([s]), 255), u, h, d, f;
  if (A(i.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${i.rank}.`), A(i.shape[2] === 3 || i.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`), A(i.dtype === "int32" || i.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`), A(e === "otsu" || e === "binary", () => `Method must be binary or otsu, but was ${e}`), i.shape[2] === 3) {
    [u, h, d] = ti(i, [1, 1, 1], -1);
    const g = q(u, r), m = q(h, o), x = q(d, a);
    f = Se(Se(g, m), x);
  } else
    f = t;
  if (e === "otsu") {
    const g = vS(Le(nm(f), "int32"), Mi([]), 256);
    l = Mj(g, c);
  }
  const p = n ? za(f, l) : js(f, l);
  return Le(q(p, 255), "int32");
}
function Mj(t, e) {
  let n = Ns([-1]), s = Ns([0]), i = Ns([0]), r, o, a, c, l, u;
  for (let h = 0; h < t.size - 1; h++) {
    r = Pt(t, 0, h + 1), o = Pt(t, h + 1), l = it(Qe(r), e), u = it(Qe(o), e);
    const d = Qe(q(r, Oo(0, r.size)));
    a = it(d, Qe(r));
    const f = nl(o.shape, r.size), p = Se(Oo(0, o.size), f), y = q(o, p);
    c = it(Qe(y), Qe(o));
    const g = je(a, c), m = je(a, c), x = q(l, u);
    i = q(q(x, g), m);
    const v = js(i, s);
    s = bs(v, i, s), n = bs(v, Ns([h]), n);
  }
  return n;
}
const Rj = /* @__PURE__ */ H({ threshold_: Aj });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dj(t, e, n = "nearest", s = "constant", i = 0, r) {
  const o = R(t, "image", "transform", "float32"), a = R(e, "transforms", "transform", "float32");
  A(o.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${o.rank}.`), A(a.rank === 2 && (a.shape[0] === o.shape[0] || a.shape[0] === 1) && a.shape[1] === 8, () => "Error in transform: Input transform should be batch x 8 or 1 x 8"), A(r == null || r.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${r}.`);
  const c = { image: o, transforms: a }, l = { interpolation: n, fillMode: s, fillValue: i, outputShape: r };
  return G.runKernel(v0, c, l);
}
const $j = /* @__PURE__ */ H({ transform_: Dj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Oj(t, e, n) {
  const s = R(t, "a", "bandPart");
  A(s.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${s.rank}.`);
  const i = s.shape, [r, o] = s.shape.slice(-2);
  let a, c;
  typeof e == "number" ? (A(e % 1 === 0, () => `bandPart(): numLower must be an integer, got ${e}.`), A(e <= r, () => `bandPart(): numLower (${e}) must not be greater than the number of rows (${r}).`), a = R(e < 0 ? r : e, "numLower", "bandPart")) : (A(e.dtype === "int32", () => "bandPart(): numLower's dtype must be an int32."), a = bs(Su(e, 0), r, Aa(e, r))), typeof n == "number" ? (A(n % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${n}.`), A(n <= o, () => `bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`), c = R(n < 0 ? o : n, "numUpper", "bandPart")) : (A(n.dtype === "int32", () => "bandPart(): numUpper's dtype must be an int32."), c = bs(Su(n, 0), o, Aa(n, o)));
  const l = Y(Oo(0, r, 1, "int32"), [-1, 1]), u = Oo(0, o, 1, "int32"), h = je(l, u), d = _r(za(h, a), Wo(h, hn(c))), f = qn([r, o], s.dtype);
  return Y(ri(Pi(Y(s, [-1, r, o])).map((p) => bs(d, p, f))), i);
}
const Lj = /* @__PURE__ */ H({ bandPart_: Oj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fj(t) {
  let e;
  if (Array.isArray(t)) {
    e = !1, A(t != null && t.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
    const i = t[0].shape[0];
    for (let r = 1; r < t.length; ++r)
      A(t[r].shape[0] === i, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[r].shape[0]} vs. ${i})`);
  } else
    e = !0, t = ti(t, t.shape[0], 0).map((i) => ys(i, [0]));
  A(t.length <= t[0].shape[0], () => `Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);
  const n = [], s = t;
  for (let i = 0; i < t.length; ++i)
    n.push(G.tidy(() => {
      let r = s[i];
      if (i > 0)
        for (let o = 0; o < i; ++o) {
          const a = q(Qe(q(n[o], r)), n[o]);
          r = je(r, a);
        }
      return it(r, $h(r, "euclidean"));
    }));
  return e ? ri(n, 0) : n;
}
const Pj = /* @__PURE__ */ H({ gramSchmidt_: Fj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Bj(t, e = !1) {
  if (A(t.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`), t.rank === 2)
    return F2(t, e);
  {
    const n = t.shape.slice(0, t.shape.length - 2).reduce((c, l) => c * l), s = Pi(Y(t, [
      n,
      t.shape[t.shape.length - 2],
      t.shape[t.shape.length - 1]
    ]), 0), i = [], r = [];
    s.forEach((c) => {
      const [l, u] = F2(c, e);
      i.push(l), r.push(u);
    });
    const o = Y(ri(i, 0), t.shape), a = Y(ri(r, 0), t.shape);
    return [o, a];
  }
}
function F2(t, e = !1) {
  return G.tidy(() => {
    A(t.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);
    const n = t.shape[0], s = t.shape[1];
    let i = D0(n), r = qr(t);
    const o = _c([[1]], [1, 1]);
    let a = qr(o);
    const c = n >= s ? s : n;
    for (let l = 0; l < c; ++l) {
      const u = r, h = a, d = i;
      [a, r, i] = G.tidy(() => {
        const f = Pt(r, [l, l], [n - l, 1]), p = $h(f), y = Pt(r, [l, l], [1, 1]), g = bs(js(y, 0), _c([[-1]]), _c([[1]])), m = je(y, q(g, p)), x = it(f, m);
        x.shape[0] === 1 ? a = qr(o) : a = Pn([
          o,
          Pt(x, [1, 0], [x.shape[0] - 1, x.shape[1]])
        ], 0);
        const v = hn(it(Tt(g, m), p)), b = Pt(r, [l, 0], [n - l, s]), w = q(v, a), S = zt(a);
        if (l === 0)
          r = je(b, Tt(w, Tt(S, b)));
        else {
          const I = je(b, Tt(w, Tt(S, b)));
          r = Pn([Pt(r, [0, 0], [l, s]), I], 0);
        }
        const _ = zt(w), E = Pt(i, [0, l], [n, i.shape[1] - l]);
        if (l === 0)
          i = je(E, Tt(Tt(E, a), _));
        else {
          const I = je(E, Tt(Tt(E, a), _));
          i = Pn([Pt(i, [0, 0], [n, l]), I], 1);
        }
        return [a, r, i];
      }), At([u, h, d]);
    }
    return !e && n > s && (i = Pt(i, [0, 0], [n, s]), r = Pt(r, [0, 0], [s, s])), [i, r];
  });
}
const zj = /* @__PURE__ */ H({ qr_: Bj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Bs;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.MEAN = 1] = "MEAN", t[t.SUM = 2] = "SUM", t[t.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(Bs || (Bs = {}));
function Vj(t, e, n = Bs.SUM_BY_NONZERO_WEIGHTS) {
  const s = R(t, "losses", "computeWeightedLoss");
  let i = null;
  e != null && (i = R(e, "weights", "computeWeightedLoss"));
  const r = i == null ? s : q(s, i);
  if (n === Bs.NONE)
    return r;
  if (n === Bs.SUM)
    return Qe(r);
  if (n === Bs.MEAN) {
    if (i == null)
      return En(r);
    {
      const o = s.size / i.size, a = it(Qe(r), Qe(i));
      return o > 1 ? it(a, ot(o)) : a;
    }
  }
  if (n === Bs.SUM_BY_NONZERO_WEIGHTS) {
    if (i == null)
      return it(Qe(r), ot(s.size));
    {
      const o = q(i, Qs(s.shape)), a = Le(Qe(Uc(o, ot(0))), "float32");
      return it(Qe(r), a);
    }
  }
  throw Error(`Unknown reduction: ${n}`);
}
const Ho = /* @__PURE__ */ H({ computeWeightedLoss_: Vj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Uj(t, e, n, s = Bs.SUM_BY_NONZERO_WEIGHTS) {
  const i = R(t, "labels", "absoluteDifference"), r = R(e, "predictions", "absoluteDifference");
  let o = null;
  n != null && (o = R(n, "weights", "absoluteDifference")), ws(i.shape, r.shape, "Error in absoluteDifference: ");
  const a = jn(je(i, r));
  return Ho(a, o, s);
}
const Gj = /* @__PURE__ */ H({ absoluteDifference_: Uj });
function Wj(t, e, n, s, i = Bs.SUM_BY_NONZERO_WEIGHTS) {
  const r = R(t, "labels", "cosineDistance"), o = R(e, "predictions", "cosineDistance");
  let a = null;
  s != null && (a = R(s, "weights", "cosineDistance")), ws(r.shape, o.shape, "Error in cosineDistance: ");
  const c = ot(1), l = je(c, Qe(q(r, o), n, !0));
  return Ho(l, a, i);
}
const Hj = /* @__PURE__ */ H({ cosineDistance_: Wj });
function jj(t, e, n, s = Bs.SUM_BY_NONZERO_WEIGHTS) {
  let i = R(t, "labels", "hingeLoss");
  const r = R(e, "predictions", "hingeLoss");
  let o = null;
  n != null && (o = R(n, "weights", "hingeLoss")), ws(i.shape, r.shape, "Error in hingeLoss: ");
  const a = ot(1);
  i = je(q(ot(2), i), a);
  const c = kr(je(a, q(i, r)));
  return Ho(c, o, s);
}
const qj = /* @__PURE__ */ H({ hingeLoss_: jj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xj(t, e, n, s = 1, i = Bs.SUM_BY_NONZERO_WEIGHTS) {
  const r = R(t, "labels", "huberLoss"), o = R(e, "predictions", "huberLoss");
  let a = null;
  n != null && (a = R(n, "weights", "huberLoss")), ws(r.shape, o.shape, "Error in huberLoss: ");
  const c = ot(s), l = jn(je(o, r)), u = Aa(l, c), h = je(l, u), d = Se(q(ot(0.5), tn(u)), q(c, h));
  return Ho(d, a, i);
}
const Kj = /* @__PURE__ */ H({ huberLoss_: Xj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yj(t, e, n, s = 1e-7, i = Bs.SUM_BY_NONZERO_WEIGHTS) {
  const r = R(t, "labels", "logLoss"), o = R(e, "predictions", "logLoss");
  let a = null;
  n != null && (a = R(n, "weights", "logLoss")), ws(r.shape, o.shape, "Error in logLoss: ");
  const c = ot(1), l = ot(s), u = hn(q(r, bi(Se(o, l)))), h = q(je(c, r), bi(Se(je(c, o), l))), d = je(u, h);
  return Ho(d, a, i);
}
const Zj = /* @__PURE__ */ H({ logLoss_: Yj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jj(t, e, n, s = Bs.SUM_BY_NONZERO_WEIGHTS) {
  const i = R(t, "labels", "meanSquaredError"), r = R(e, "predictions", "meanSquaredError");
  let o = null;
  n != null && (o = R(n, "weights", "meanSquaredError")), ws(i.shape, r.shape, "Error in meanSquaredError: ");
  const a = K0(i, r);
  return Ho(a, o, s);
}
const Qj = /* @__PURE__ */ H({ meanSquaredError_: Jj });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function e6(t, e) {
  const n = R(t, "labels", "sigmoidCrossEntropyWithLogits"), s = R(e, "logits", "sigmoidCrossEntropyWithLogits");
  ws(n.shape, s.shape, "Error in sigmoidCrossEntropyWithLogits: ");
  const i = kr(s), r = q(s, n), o = Kp(ii(hn(jn(s))));
  return Se(je(i, r), o);
}
function t6(t, e, n, s = 0, i = Bs.SUM_BY_NONZERO_WEIGHTS) {
  let r = R(t, "multiClassLabels", "sigmoidCrossEntropy");
  const o = R(e, "logits", "sigmoidCrossEntropy");
  let a = null;
  if (n != null && (a = R(n, "weights", "sigmoidCrossEntropy")), ws(r.shape, o.shape, "Error in sigmoidCrossEntropy: "), s > 0) {
    const l = ot(s), u = ot(1), h = ot(0.5);
    r = Se(q(r, je(u, l)), q(h, l));
  }
  const c = e6(r, o);
  return Ho(c, a, i);
}
const n6 = /* @__PURE__ */ H({ sigmoidCrossEntropy_: t6 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s6(t, e, n = -1) {
  if (n === -1 && (n = e.rank - 1), n !== e.rank - 1)
    throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);
  return ro((i, r, o) => {
    const c = Yp(r, [n], !0), l = je(Le(r, "float32"), c);
    o([i, l]);
    const u = hn(q(l, i));
    return { value: Qe(u, [n]), gradFunc: (f, p) => {
      const [y, g] = p, m = zn(f.shape, [n]);
      return [
        q(Y(f, m), je(Le(y, "float32"), ii(g))),
        q(Y(f, m), je(ii(g), Le(y, "float32")))
      ];
    } };
  })(t, e);
}
function i6(t, e, n, s = 0, i = Bs.SUM_BY_NONZERO_WEIGHTS) {
  let r = R(t, "onehotLabels", "softmaxCrossEntropy");
  const o = R(e, "logits", "softmaxCrossEntropy");
  let a = null;
  if (n != null && (a = R(n, "weights", "softmaxCrossEntropy")), ws(r.shape, o.shape, "Error in softmaxCrossEntropy: "), s > 0) {
    const l = ot(s), u = ot(1), h = ot(r.shape[1]);
    r = Se(q(r, je(u, l)), it(l, h));
  }
  const c = s6(r, o);
  return Ho(c, a, i);
}
const r6 = /* @__PURE__ */ H({ softmaxCrossEntropy_: i6 });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o6(t, e, n, s) {
  const i = R(t, "indices", "sparseFillEmptyRows", "int32"), r = R(e, "values", "sparseFillEmptyRows"), o = R(n, "denseShape", "sparseFillEmptyRows", "int32"), a = R(s, "defaultValue", "sparseFillEmptyRows", r.dtype);
  if (i.rank !== 2)
    throw new Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);
  if (r.rank !== 1)
    throw new Error(`Values should be Tensor1D but received shape ${r.shape}`);
  if (o.rank !== 1)
    throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);
  if (a.rank !== 0)
    throw new Error(`Default value should be a scalar but received shape ${a.shape}`);
  const c = {
    indices: i,
    values: r,
    denseShape: o,
    defaultValue: a
  }, l = G.runKernel(l0, c);
  return {
    outputIndices: l[0],
    outputValues: l[1],
    emptyRowIndicator: l[2],
    reverseIndexMap: l[3]
  };
}
const a6 = /* @__PURE__ */ H({ sparseFillEmptyRows_: o6 });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c6(t, e, n) {
  const s = R(t, "inputIndices", "sparseReshape", "int32"), i = R(e, "inputShape", "sparseReshape", "int32"), r = R(n, "newShape", "sparseReshape", "int32");
  if (s.rank !== 2)
    throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);
  if (i.rank !== 1)
    throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);
  if (r.rank !== 1)
    throw new Error(`New shape should be Tensor1D but received shape ${r.shape}`);
  const o = {
    inputIndices: s,
    inputShape: i,
    newShape: r
  }, a = G.runKernel(u0, o);
  return { outputIndices: a[0], outputShape: a[1] };
}
const l6 = /* @__PURE__ */ H({ sparseReshape_: c6 });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u6(t, e, n) {
  const s = R(t, "data", "sparseSegmentMean"), i = R(e, "indices", "sparseSegmentMean", "int32"), r = R(n, "segmentIds", "sparseSegmentMean", "int32");
  if (s.rank < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (i.rank !== 1)
    throw new Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);
  if (r.rank !== 1)
    throw new Error(`Segment ids should be Tensor1D but received shape
          ${r.shape}`);
  const o = {
    data: s,
    indices: i,
    segmentIds: r
  };
  return G.runKernel(h0, o);
}
const h6 = /* @__PURE__ */ H({ sparseSegmentMean_: u6 });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function d6(t, e, n) {
  const s = R(t, "data", "sparseSegmentSum"), i = R(e, "indices", "sparseSegmentSum", "int32"), r = R(n, "segmentIds", "sparseSegmentSum", "int32");
  if (s.rank < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (i.rank !== 1)
    throw new Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);
  if (r.rank !== 1)
    throw new Error(`Segment ids should be Tensor1D but received shape
         ${r.shape}`);
  const o = {
    data: s,
    indices: i,
    segmentIds: r
  };
  return G.runKernel(d0, o);
}
const f6 = /* @__PURE__ */ H({ sparseSegmentSum_: d6 });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function p6(t, e, n, s, i, r, o, a) {
  const c = R(t, "data", "stringNGrams", "string");
  if (c.dtype !== "string")
    throw new Error("Data must be of datatype string");
  if (c.shape.length !== 1)
    throw new Error(`Data must be a vector, saw: ${c.shape}`);
  const l = R(e, "dataSplits", "stringNGrams");
  if (l.dtype !== "int32")
    throw new Error("Data splits must be of datatype int32");
  const u = {
    separator: n,
    nGramWidths: s,
    leftPad: i,
    rightPad: r,
    padWidth: o,
    preserveShortSequences: a
  }, h = { data: c, dataSplits: l }, d = G.runKernel(g0, h, u);
  return { nGrams: d[0], nGramsSplits: d[1] };
}
const m6 = /* @__PURE__ */ H({ stringNGrams_: p6 });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function g6(t, e, n = !0) {
  const s = R(t, "input", "stringSplit", "string"), i = R(e, "delimiter", "stringSplit", "string");
  if (s.rank !== 1)
    throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);
  if (i.rank !== 0)
    throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);
  const r = { skipEmpty: n }, o = { input: s, delimiter: i }, a = G.runKernel(y0, o, r);
  return { indices: a[0], values: a[1], shape: a[2] };
}
const y6 = /* @__PURE__ */ H({ stringSplit_: g6 });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function x6(t, e) {
  const n = R(t, "input", "stringToHashBucketFast", "string"), s = { numBuckets: e };
  if (e <= 0)
    throw new Error("Number of buckets must be at least 1");
  const i = { input: n };
  return G.runKernel(x0, i, s);
}
const b6 = /* @__PURE__ */ H({ stringToHashBucketFast_: x6 });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function v6(t, e, n, s = !0) {
  const i = R(t, "input", "staticRegexReplace", "string"), r = { pattern: e, rewrite: n, replaceGlobal: s };
  return G.runKernel(Lp, { x: i }, r);
}
const w6 = /* @__PURE__ */ H({ staticRegexReplace_: v6 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dA = {
  fft: om,
  ifft: Cu,
  rfft: am,
  irfft: X0
}, fA = {
  hammingWindow: K5,
  hannWindow: cA,
  frame: lA,
  stft: Q5
}, as = {
  flipLeftRight: sj,
  grayscaleToRGB: rj,
  resizeNearestNeighbor: hA,
  resizeBilinear: uA,
  rgbToGrayscale: aj,
  rotateWithOffset: lj,
  cropAndResize: tj,
  nonMaxSuppression: hj,
  nonMaxSuppressionAsync: bj,
  nonMaxSuppressionWithScore: wj,
  nonMaxSuppressionWithScoreAsync: _j,
  nonMaxSuppressionPadded: Cj,
  nonMaxSuppressionPaddedAsync: Ej,
  threshold: Rj,
  transform: $j
}, g_ = {
  bandPart: Lj,
  gramSchmidt: Pj,
  qr: zj
}, pA = {
  absoluteDifference: Gj,
  computeWeightedLoss: Ho,
  cosineDistance: Hj,
  hingeLoss: qj,
  huberLoss: Kj,
  logLoss: Zj,
  meanSquaredError: Qj,
  sigmoidCrossEntropy: n6,
  softmaxCrossEntropy: r6
}, mA = {
  sparseFillEmptyRows: a6,
  sparseReshape: l6,
  sparseSegmentMean: h6,
  sparseSegmentSum: f6
}, gA = {
  stringNGrams: m6,
  stringSplit: y6,
  stringToHashBucketFast: b6,
  staticRegexReplace: w6
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const S6 = /* @__PURE__ */ new Map(), Zw = /* @__PURE__ */ new Map();
class ol {
  /**
   * Return the class name for this class to use in serialization contexts.
   *
   * Generally speaking this will be the same thing that constructor.name
   * would have returned.  However, the class name needs to be robust
   * against minification for serialization/deserialization to work properly.
   *
   * There's also places such as initializers.VarianceScaling, where
   * implementation details between different languages led to different
   * class hierarchies and a non-leaf node is used for serialization purposes.
   */
  getClassName() {
    return this.constructor.className;
  }
  /**
   * Creates an instance of T from a ConfigDict.
   *
   * This works for most descendants of serializable.  A few need to
   * provide special handling.
   * @param cls A Constructor for the class to instantiate.
   * @param config The Configuration for the object.
   */
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n);
  }
}
class Ni {
  constructor() {
    this.classNameMap = {};
  }
  /**
   * Returns the singleton instance of the map.
   */
  static getMap() {
    return Ni.instance == null && (Ni.instance = new Ni()), Ni.instance;
  }
  /**
   * Registers the class as serializable.
   */
  static register(e) {
    Ni.getMap().classNameMap[e.className] = [e, e.fromConfig];
  }
}
function Ee(t, e, n) {
  A(t.className != null, () => "Class being registered does not have the static className property defined."), A(typeof t.className == "string", () => "className is required to be a string, but got type " + typeof t.className), A(t.className.length > 0, () => "Class being registered has an empty-string as its className, which is disallowed."), typeof e > "u" && (e = "Custom"), typeof n > "u" && (n = t.className);
  const s = n, i = e + ">" + s;
  return Ni.register(t), S6.set(i, t), Zw.set(t, i), t;
}
function _6(t) {
  return Zw.has(t) ? Zw.get(t) : t.className;
}
const T6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Serializable: ol,
  SerializationMap: Ni,
  getRegisteredName: _6,
  registerClass: Ee
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class jo extends ol {
  /**
   * Executes `f()` and minimizes the scalar output of `f()` by computing
   * gradients of y with respect to the list of trainable variables provided by
   * `varList`. If no list is provided, it defaults to all trainable variables.
   *
   * @param f The function to execute and whose output to minimize.
   * @param returnCost Whether to return the scalar cost value produced by
   * executing `f()`.
   * @param varList An optional list of variables to update. If specified, only
   * the trainable variables in varList will be updated by minimize. Defaults to
   * all trainable variables.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers'}
   */
  minimize(e, n = !1, s) {
    const { value: i, grads: r } = this.computeGradients(e, s);
    if (s != null) {
      const o = s.map((a) => ({ name: a.name, tensor: r[a.name] }));
      this.applyGradients(o);
    } else
      this.applyGradients(r);
    return At(r), n ? i : (i.dispose(), null);
  }
  /**
   * The number of iterations that this optimizer instance has been invoked for.
   */
  get iterations() {
    return this.iterations_ == null && (this.iterations_ = 0), this.iterations_;
  }
  incrementIterations() {
    this.iterations_ = this.iterations + 1;
  }
  /**
   * Executes f() and computes the gradient of the scalar output of f() with
   * respect to the list of trainable variables provided by `varList`. If no
   * list is provided, it defaults to all trainable variables.
   *
   * @param f The function to execute and whose output to use for computing
   * gradients with respect to variables.
   * @param varList An optional list of variables to compute gradients with
   * respect to. If specified, only the trainable variables in varList will have
   * gradients computed with respect to. Defaults to all trainable variables.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers'}
   */
  computeGradients(e, n) {
    return Sk(e, n);
  }
  /**
   * Dispose the variables (if any) owned by this optimizer instance.
   */
  dispose() {
    this.iterations_ != null && At(this.iterations_);
  }
  async saveIterations() {
    return this.iterations_ == null && (this.iterations_ = 0), {
      name: "iter",
      // TODO(cais): Use 'int64' type when available.
      tensor: ot(this.iterations_, "int32")
    };
  }
  async getWeights() {
    throw new Error("getWeights() is not implemented for this optimizer yet.");
  }
  async setWeights(e) {
    throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
  }
  /**
   * Extract the first element of the weight values and set it
   * as the iterations counter variable of this instance of optimizer.
   *
   * @param weightValues
   * @returns Weight values with the first element consumed and excluded.
   */
  async extractIterations(e) {
    return this.iterations_ = (await e[0].tensor.data())[0], e.slice(1);
  }
}
Object.defineProperty(jo, Symbol.hasInstance, {
  value: (t) => t.minimize != null && t.computeGradients != null && t.applyGradients != null
});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class y_ extends jo {
  /** @nocollapse */
  static get className() {
    return "Adadelta";
  }
  constructor(e, n, s = null) {
    super(), this.learningRate = e, this.rho = n, this.epsilon = s, this.accumulatedGrads = [], this.accumulatedUpdates = [], s == null && (this.epsilon = G.backend.epsilon());
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((s) => s.name) : Object.keys(e)).forEach((s, i) => {
      const r = G.registeredVariables[s], o = !1;
      this.accumulatedGrads[i] == null && (this.accumulatedGrads[i] = {
        originalName: `${s}/accum_grad`,
        variable: Q(() => Ut(r).variable(o))
      }), this.accumulatedUpdates[i] == null && (this.accumulatedUpdates[i] = {
        originalName: `${s}/accum_var`,
        variable: Q(() => Ut(r).variable(o))
      });
      const a = Array.isArray(e) ? e[i].tensor : e[s];
      if (a == null)
        return;
      const c = this.accumulatedGrads[i].variable, l = this.accumulatedUpdates[i].variable;
      Q(() => {
        const u = Se(q(c, this.rho), q(tn(a), 1 - this.rho)), h = q(it(us(Se(l, this.epsilon)), us(Se(c, this.epsilon))), a), d = Se(q(l, this.rho), q(tn(h), 1 - this.rho));
        c.assign(u), l.assign(d);
        const f = Se(q(h, -this.learningRate), r);
        r.assign(f);
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.accumulatedUpdates != null && (At(this.accumulatedGrads.map((e) => e.variable)), At(this.accumulatedUpdates.map((e) => e.variable)));
  }
  async getWeights() {
    const e = [...this.accumulatedGrads, ...this.accumulatedUpdates];
    return [await this.saveIterations()].concat(e.map((n) => ({ name: n.originalName, tensor: n.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e);
    const n = e.length / 2, s = !1;
    this.accumulatedGrads = e.slice(0, n).map((i) => ({
      originalName: i.name,
      variable: i.tensor.variable(s)
    })), this.accumulatedUpdates = e.slice(n, n * 2).map((i) => ({
      originalName: i.name,
      variable: i.tensor.variable(s)
    }));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      rho: this.rho,
      epsilon: this.epsilon
    };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate, n.rho, n.epsilon);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class x_ extends jo {
  /** @nocollapse */
  static get className() {
    return "Adagrad";
  }
  constructor(e, n = 0.1) {
    super(), this.learningRate = e, this.initialAccumulatorValue = n, this.accumulatedGrads = [];
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((s) => s.name) : Object.keys(e)).forEach((s, i) => {
      const r = G.registeredVariables[s];
      this.accumulatedGrads[i] == null && (this.accumulatedGrads[i] = {
        originalName: `${s}/accumulator`,
        variable: Q(() => nl(r.shape, this.initialAccumulatorValue).variable(!1))
      });
      const o = Array.isArray(e) ? e[i].tensor : e[s];
      if (o == null)
        return;
      const a = this.accumulatedGrads[i].variable;
      Q(() => {
        const c = Se(a, tn(o));
        a.assign(c);
        const l = Se(q(it(o, us(Se(c, G.backend.epsilon()))), -this.learningRate), r);
        r.assign(l);
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.accumulatedGrads != null && At(this.accumulatedGrads.map((e) => e.variable));
  }
  async getWeights() {
    return [await this.saveIterations()].concat(this.accumulatedGrads.map((e) => ({ name: e.originalName, tensor: e.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e);
    const n = !1;
    this.accumulatedGrads = e.map((s) => ({ originalName: s.name, variable: s.tensor.variable(n) }));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      initialAccumulatorValue: this.initialAccumulatorValue
    };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate, n.initialAccumulatorValue);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class b_ extends jo {
  /** @nocollapse */
  static get className() {
    return "Adam";
  }
  constructor(e, n, s, i = null) {
    super(), this.learningRate = e, this.beta1 = n, this.beta2 = s, this.epsilon = i, this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], Q(() => {
      this.accBeta1 = ot(n).variable(), this.accBeta2 = ot(s).variable();
    }), i == null && (this.epsilon = G.backend.epsilon());
  }
  applyGradients(e) {
    const n = Array.isArray(e) ? e.map((s) => s.name) : Object.keys(e);
    Q(() => {
      const s = je(1, this.accBeta1), i = je(1, this.accBeta2);
      n.forEach((r, o) => {
        const a = G.registeredVariables[r], c = !1;
        this.accumulatedFirstMoment[o] == null && (this.accumulatedFirstMoment[o] = {
          originalName: `${r}/m`,
          variable: Q(() => Ut(a).variable(c))
        }), this.accumulatedSecondMoment[o] == null && (this.accumulatedSecondMoment[o] = {
          originalName: `${r}/v`,
          variable: Q(() => Ut(a).variable(c))
        });
        const l = Array.isArray(e) ? e[o].tensor : e[r];
        if (l == null)
          return;
        const u = this.accumulatedFirstMoment[o].variable, h = this.accumulatedSecondMoment[o].variable, d = Se(q(u, this.beta1), q(l, 1 - this.beta1)), f = Se(q(h, this.beta2), q(tn(l), 1 - this.beta2)), p = it(d, s), y = it(f, i);
        u.assign(d), h.assign(f);
        const g = Se(q(it(p, Se(us(y), this.epsilon)), -this.learningRate), a);
        a.assign(g);
      }), this.accBeta1.assign(q(this.accBeta1, this.beta1)), this.accBeta2.assign(q(this.accBeta2, this.beta2));
    }), this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose(), this.accBeta2.dispose(), this.accumulatedFirstMoment != null && At(this.accumulatedFirstMoment.map((e) => e.variable)), this.accumulatedSecondMoment != null && At(this.accumulatedSecondMoment.map((e) => e.variable));
  }
  async getWeights() {
    const e = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
    return [await this.saveIterations()].concat(e.map((n) => ({ name: n.originalName, tensor: n.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e), Q(() => {
      this.accBeta1.assign(io(this.beta1, this.iterations_ + 1)), this.accBeta2.assign(io(this.beta2, this.iterations_ + 1));
    });
    const n = e.length / 2, s = !1;
    this.accumulatedFirstMoment = e.slice(0, n).map((i) => ({
      originalName: i.name,
      variable: i.tensor.variable(s)
    })), this.accumulatedSecondMoment = e.slice(n, n * 2).map((i) => ({
      originalName: i.name,
      variable: i.tensor.variable(s)
    }));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon
    };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate, n.beta1, n.beta2, n.epsilon);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class v_ extends jo {
  /** @nocollapse */
  static get className() {
    return "Adamax";
  }
  constructor(e, n, s, i = null, r = 0) {
    super(), this.learningRate = e, this.beta1 = n, this.beta2 = s, this.epsilon = i, this.decay = r, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], Q(() => {
      this.iteration = ot(0).variable(), this.accBeta1 = ot(n).variable();
    }), i == null && (this.epsilon = G.backend.epsilon());
  }
  applyGradients(e) {
    const n = Array.isArray(e) ? e.map((s) => s.name) : Object.keys(e);
    Q(() => {
      const s = je(1, this.accBeta1), i = it(-this.learningRate, Se(q(this.iteration, this.decay), 1));
      n.forEach((r, o) => {
        const a = G.registeredVariables[r], c = !1;
        this.accumulatedFirstMoment[o] == null && (this.accumulatedFirstMoment[o] = {
          originalName: `${r}/m`,
          variable: Ut(a).variable(c)
        }), this.accumulatedWeightedInfNorm[o] == null && (this.accumulatedWeightedInfNorm[o] = {
          originalName: `${r}/v`,
          variable: Ut(a).variable(c)
        });
        const l = Array.isArray(e) ? e[o].tensor : e[r];
        if (l == null)
          return;
        const u = this.accumulatedFirstMoment[o].variable, h = this.accumulatedWeightedInfNorm[o].variable, d = Se(q(u, this.beta1), q(l, 1 - this.beta1)), f = q(h, this.beta2), p = jn(l), y = lo(f, p);
        u.assign(d), h.assign(y);
        const g = Se(q(it(i, s), it(d, Se(y, this.epsilon))), a);
        a.assign(g);
      }), this.iteration.assign(Se(this.iteration, 1)), this.accBeta1.assign(q(this.accBeta1, this.beta1));
    }), this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose(), this.iteration.dispose(), this.accumulatedFirstMoment != null && At(this.accumulatedFirstMoment.map((e) => e.variable)), this.accumulatedWeightedInfNorm != null && At(this.accumulatedWeightedInfNorm.map((e) => e.variable));
  }
  async getWeights() {
    throw new Error("getWeights() is not implemented for Adamax yet.");
  }
  async setWeights(e) {
    throw new Error("setWeights() is not implemented for Adamax yet.");
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon,
      decay: this.decay
    };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate, n.beta1, n.beta2, n.epsilon, n.decay);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class cb extends jo {
  /** @nocollapse */
  static get className() {
    return "SGD";
  }
  constructor(e) {
    super(), this.learningRate = e, this.setLearningRate(e);
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((s) => s.name) : Object.keys(e)).forEach((s, i) => {
      const r = Array.isArray(e) ? e[i].tensor : e[s];
      if (r == null)
        return;
      const o = G.registeredVariables[s];
      Q(() => {
        const a = Se(q(this.c, r), o);
        o.assign(a);
      });
    }), this.incrementIterations();
  }
  /**
   * Sets the learning rate of the optimizer.
   */
  setLearningRate(e) {
    this.learningRate = e, this.c != null && this.c.dispose(), this.c = Zn(ot(-e));
  }
  dispose() {
    this.c.dispose();
  }
  async getWeights() {
    return [await this.saveIterations()];
  }
  async setWeights(e) {
    if (e = await this.extractIterations(e), e.length !== 0)
      throw new Error("SGD optimizer does not have settable weights.");
  }
  getConfig() {
    return { learningRate: this.learningRate };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class w_ extends cb {
  /** @nocollapse */
  // Name matters for Python compatibility.
  static get className() {
    return "Momentum";
  }
  constructor(e, n, s = !1) {
    super(e), this.learningRate = e, this.momentum = n, this.useNesterov = s, this.accumulations = [], this.m = ot(this.momentum);
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((s) => s.name) : Object.keys(e)).forEach((s, i) => {
      const r = G.registeredVariables[s];
      this.accumulations[i] == null && (this.accumulations[i] = {
        originalName: `${s}/momentum`,
        variable: Q(() => Ut(r).variable(!1))
      });
      const o = this.accumulations[i].variable, a = Array.isArray(e) ? e[i].tensor : e[s];
      a != null && Q(() => {
        let c;
        const l = Se(q(this.m, o), a);
        this.useNesterov ? c = Se(q(this.c, Se(a, q(l, this.m))), r) : c = Se(q(this.c, l), r), o.assign(l), r.assign(c);
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.m.dispose(), this.accumulations != null && At(this.accumulations.map((e) => e.variable));
  }
  /**
   * Sets the momentum of the optimizer.
   *
   * @param momentum
   */
  setMomentum(e) {
    this.momentum = e;
  }
  async getWeights() {
    return [await this.saveIterations()].concat(this.accumulations.map((e) => ({ name: e.originalName, tensor: e.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e);
    const n = !1;
    this.accumulations = e.map((s) => ({ originalName: s.name, variable: s.tensor.variable(n) }));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      momentum: this.momentum,
      useNesterov: this.useNesterov
    };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate, n.momentum, n.useNesterov);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class S_ extends jo {
  /** @nocollapse */
  static get className() {
    return "RMSProp";
  }
  constructor(e, n = 0.9, s = 0, i = null, r = !1) {
    if (super(), this.learningRate = e, this.decay = n, this.momentum = s, this.epsilon = i, this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], this.centered = r, i == null && (this.epsilon = G.backend.epsilon()), e == null)
      throw new Error("learningRate for RMSPropOptimizer must be defined.");
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((s) => s.name) : Object.keys(e)).forEach((s, i) => {
      const r = G.registeredVariables[s], o = !1;
      this.accumulatedMeanSquares[i] == null && (this.accumulatedMeanSquares[i] = {
        originalName: `${s}/rms`,
        variable: Q(() => Ut(r).variable(o))
      }), this.accumulatedMoments[i] == null && (this.accumulatedMoments[i] = {
        originalName: `${s}/momentum`,
        variable: Q(() => Ut(r).variable(o))
      }), this.accumulatedMeanGrads[i] == null && this.centered && (this.accumulatedMeanGrads[i] = {
        originalName: `${s}/mg`,
        variable: Q(() => Ut(r).variable(o))
      });
      const a = Array.isArray(e) ? e[i].tensor : e[s];
      if (a == null)
        return;
      const c = this.accumulatedMeanSquares[i].variable, l = this.accumulatedMoments[i].variable;
      Q(() => {
        const u = Se(q(c, this.decay), q(tn(a), 1 - this.decay));
        if (this.centered) {
          const h = this.accumulatedMeanGrads[i].variable, d = Se(q(h, this.decay), q(a, 1 - this.decay)), f = it(q(a, this.learningRate), us(je(u, Se(tn(d), this.epsilon)))), p = Se(q(l, this.momentum), f);
          c.assign(u), h.assign(d), l.assign(p);
          const y = je(r, p);
          r.assign(y);
        } else {
          const h = Se(q(c, this.decay), q(tn(a), 1 - this.decay)), d = Se(q(l, this.momentum), it(q(a, this.learningRate), us(Se(h, this.epsilon))));
          c.assign(h), l.assign(d);
          const f = je(r, d);
          r.assign(f);
        }
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.accumulatedMeanSquares != null && At(this.accumulatedMeanSquares.map((e) => e.variable)), this.accumulatedMeanGrads != null && this.centered && At(this.accumulatedMeanGrads.map((e) => e.variable)), this.accumulatedMoments != null && At(this.accumulatedMoments.map((e) => e.variable));
  }
  async getWeights() {
    const e = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
    return this.centered && e.push(...this.accumulatedMeanGrads), [await this.saveIterations()].concat(e.map((n) => ({ name: n.originalName, tensor: n.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e);
    const n = this.centered ? e.length / 3 : e.length / 2, s = !1;
    this.accumulatedMeanSquares = e.slice(0, n).map((i) => ({
      originalName: i.name,
      variable: i.tensor.variable(s)
    })), this.accumulatedMoments = e.slice(n, n * 2).map((i) => ({
      originalName: i.name,
      variable: i.tensor.variable(s)
    })), this.centered && (this.accumulatedMeanGrads = e.slice(n * 2, n * 3).map((i) => ({
      originalName: i.name,
      variable: i.tensor.variable(s)
    })));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      decay: this.decay,
      momentum: this.momentum,
      epsilon: this.epsilon,
      centered: this.centered
    };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate, n.decay, n.momentum, n.epsilon, n.centered);
  }
}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const C6 = [
  y_,
  x_,
  b_,
  v_,
  w_,
  S_,
  cb
];
function I6() {
  for (const t of C6)
    Ee(t);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const E6 = "model", N6 = ".json", k6 = ".weights.bin";
function P2(t) {
  return new Promise((e) => setTimeout(e)).then(t);
}
class Wc {
  constructor(e) {
    if (!ie().getBool("IS_BROWSER"))
      throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    e.startsWith(Wc.URL_SCHEME) && (e = e.slice(Wc.URL_SCHEME.length)), (e == null || e.length === 0) && (e = E6), this.modelJsonFileName = e + N6, this.weightDataFileName = e + k6;
  }
  async save(e) {
    if (typeof document > "u")
      throw new Error("Browser downloads are not supported in this environment since `document` is not present");
    const n = Nr.join(e.weightData), s = window.URL.createObjectURL(new Blob([n], { type: "application/octet-stream" }));
    if (e.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
    {
      const i = [{
        paths: ["./" + this.weightDataFileName],
        weights: e.weightSpecs
      }], r = nk(e, i), o = window.URL.createObjectURL(new Blob([JSON.stringify(r)], { type: "application/json" })), a = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor;
      if (a.download = this.modelJsonFileName, a.href = o, await P2(() => a.dispatchEvent(new MouseEvent("click"))), e.weightData != null) {
        const c = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
        c.download = this.weightDataFileName, c.href = s, await P2(() => c.dispatchEvent(new MouseEvent("click")));
      }
      return { modelArtifactsInfo: Up(e) };
    }
  }
}
Wc.URL_SCHEME = "downloads://";
class A6 {
  constructor(e) {
    if (e == null || e.length < 1)
      throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);
    this.jsonFile = e[0], this.weightsFiles = e.slice(1);
  }
  async load() {
    return new Promise((e, n) => {
      const s = new FileReader();
      s.onload = (i) => {
        const r = JSON.parse(i.target.result), o = r.modelTopology;
        if (o == null) {
          n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
          return;
        }
        if (r.weightsManifest == null) {
          n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
          return;
        }
        if (this.weightsFiles.length === 0) {
          e({ modelTopology: o });
          return;
        }
        const c = rS(r, (l) => this.loadWeights(l));
        e(c);
      }, s.onerror = (i) => n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`), s.readAsText(this.jsonFile);
    });
  }
  loadWeights(e) {
    const n = [], s = [];
    for (const o of e)
      n.push(...o.weights), s.push(...o.paths);
    const i = this.checkManifestAndWeightFiles(e), r = s.map((o) => this.loadWeightsFile(o, i[o]));
    return Promise.all(r).then((o) => [n, o]);
  }
  loadWeightsFile(e, n) {
    return new Promise((s, i) => {
      const r = new FileReader();
      r.onload = (o) => {
        const a = o.target.result;
        s(a);
      }, r.onerror = (o) => i(`Failed to weights data from file of path '${e}'.`), r.readAsArrayBuffer(n);
    });
  }
  /**
   * Check the compatibility between weights manifest and weight files.
   */
  checkManifestAndWeightFiles(e) {
    const n = [], s = this.weightsFiles.map((r) => O2(r.name)), i = {};
    for (const r of e)
      r.paths.forEach((o) => {
        const a = O2(o);
        if (n.indexOf(a) !== -1)
          throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);
        if (n.push(a), s.indexOf(a) === -1)
          throw new Error(`Weight file with basename '${a}' is not provided.`);
        i[o] = this.weightsFiles[s.indexOf(a)];
      });
    if (n.length !== this.weightsFiles.length)
      throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
    return i;
  }
}
const M6 = (t) => ie().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(Wc.URL_SCHEME) ? R6(t.slice(Wc.URL_SCHEME.length)) : null;
In.registerSaveRouter(M6);
function R6(t = "model") {
  return new Wc(t);
}
function D6(t) {
  return new A6(t);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function B2(t, e, n, s) {
  o(t), n = n ?? 0, s = s ?? 1, a(n, s);
  let i = 0;
  const r = (c) => (c.then((l) => {
    const u = n + ++i / t.length * (s - n);
    return e(u), l;
  }), c);
  function o(c) {
    A(c != null && Array.isArray(c) && c.length > 0, () => "promises must be a none empty array");
  }
  function a(c, l) {
    A(c >= 0 && c <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${c}`), A(l >= 0 && l <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${l}`), A(l >= c, () => `startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${l}`);
  }
  return Promise.all(t.map(r));
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function yA(t, e) {
  e == null && (e = {});
  const n = e.fetchFunc == null ? ie().platform.fetch : e.fetchFunc, s = t.map((h) => n(h, e.requestInit, { isBinary: !0 })), i = 0, r = 0.5, a = (e.onProgress == null ? await Promise.all(s) : await B2(s, e.onProgress, i, r)).map((h) => h.arrayBuffer()), c = 0.5, l = 1;
  return e.onProgress == null ? await Promise.all(a) : await B2(a, e.onProgress, c, l);
}
function $6(t, e) {
  var n;
  const s = e.fetchFunc == null ? ie().platform.fetch : e.fetchFunc;
  let i = 0, r;
  return (n = e.onProgress) === null || n === void 0 || n.call(e, 0), new ReadableStream({
    pull: async (o) => {
      for (var a; i < t.length; ) {
        r || (r = (await s(t[i], e.requestInit, { isBinary: !0 })).body.getReader());
        const { done: c, value: l } = await r.read();
        if (c) {
          i++, r = void 0, (a = e.onProgress) === null || a === void 0 || a.call(e, i / t.length);
          continue;
        }
        o.enqueue(l);
        return;
      }
      o.close();
    }
  });
}
async function O6(t, e = "", n, s) {
  return xA((o) => yA(o, { requestInit: s }))(t, e, n);
}
function xA(t) {
  return async (e, n = "", s) => {
    const i = e.map(() => !1), r = {}, o = s != null ? s.map(() => !1) : [], a = [];
    if (e.forEach((f, p) => {
      let y = 0;
      f.weights.forEach((g) => {
        const m = "quantization" in g ? g.quantization.dtype : g.dtype, x = Fc[m] * ue(g.shape), v = () => {
          i[p] = !0, r[p] == null && (r[p] = []), r[p].push({
            manifestEntry: g,
            groupOffset: y,
            sizeBytes: x
          });
        };
        s != null ? s.forEach((b, w) => {
          b === g.name && (v(), o[w] = !0);
        }) : v(), a.push(g.name), y += x;
      });
    }), !o.every((f) => f)) {
      const f = s.filter((p, y) => !o[y]);
      throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`);
    }
    const c = i.reduce((f, p, y) => (p && f.push(y), f), []), l = [];
    c.forEach((f) => {
      e[f].paths.forEach((p) => {
        const y = n + (n.endsWith("/") ? "" : "/") + p;
        l.push(y);
      });
    });
    const u = await t(l), h = {};
    let d = 0;
    return c.forEach((f) => {
      const p = e[f].paths.length, y = new Nr(u.slice(d, d + p));
      r[f].forEach((m) => {
        const x = y.slice(m.groupOffset, m.groupOffset + m.sizeBytes), v = JN(x, [m.manifestEntry]);
        for (const b in v)
          h[b] = v[b];
      }), d += p;
    }), h;
  };
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const L6 = "application/octet-stream", F6 = "application/json";
class __ {
  constructor(e, n) {
    if (this.DEFAULT_METHOD = "POST", n == null && (n = {}), this.weightPathPrefix = n.weightPathPrefix, this.weightUrlConverter = n.weightUrlConverter, n.fetchFunc != null ? (A(typeof n.fetchFunc == "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"), this.fetch = n.fetchFunc) : this.fetch = ie().platform.fetch, A(e != null && e.length > 0, () => "URL path for http must not be null, undefined or empty."), Array.isArray(e) && A(e.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${e.length}).`), this.path = e, n.requestInit != null && n.requestInit.body != null)
      throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = n.requestInit || {}, this.loadOptions = n;
  }
  async save(e) {
    if (e.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
    const n = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
    n.body = new FormData();
    const s = [{
      paths: ["./model.weights.bin"],
      weights: e.weightSpecs
    }], i = nk(e, s);
    if (n.body.append("model.json", new Blob([JSON.stringify(i)], { type: F6 }), "model.json"), e.weightData != null) {
      const o = Nr.join(e.weightData);
      n.body.append("model.weights.bin", new Blob([o], { type: L6 }), "model.weights.bin");
    }
    const r = await this.fetch(this.path, n);
    if (r.ok)
      return {
        modelArtifactsInfo: Up(e),
        responses: [r]
      };
    throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`);
  }
  async loadModelJSON() {
    const e = await this.fetch(this.path, this.requestInit);
    if (!e.ok)
      throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);
    let n;
    try {
      n = await e.json();
    } catch {
      let o = `Failed to parse model JSON of response from ${this.path}.`;
      throw this.path.endsWith(".pb") ? o += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : o += " Please make sure the server is serving valid JSON for this request.", new Error(o);
    }
    const s = n.modelTopology, i = n.weightsManifest;
    if (s == null && i == null)
      throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
    return n;
  }
  /**
   * Load model artifacts via HTTP request(s).
   *
   * See the documentation to `tf.io.http` for details on the saved
   * artifacts.
   *
   * @returns The loaded model artifacts (if loading succeeds).
   */
  async load() {
    if (this.loadOptions.streamWeights)
      return this.loadStream();
    const e = await this.loadModelJSON();
    return rS(e, (n) => this.loadWeights(n));
  }
  async loadStream() {
    const e = await this.loadModelJSON(), n = await this.getWeightUrls(e.weightsManifest), s = Ww(e.weightsManifest), i = () => $6(n, this.loadOptions);
    return Object.assign(Object.assign({}, e), { weightSpecs: s, getWeightStream: i });
  }
  async getWeightUrls(e) {
    const n = Array.isArray(this.path) ? this.path[1] : this.path, [s, i] = P6(n), r = this.weightPathPrefix || s, o = [], a = [];
    for (const c of e)
      for (const l of c.paths)
        this.weightUrlConverter != null ? a.push(this.weightUrlConverter(l)) : o.push(r + l + i);
    return this.weightUrlConverter && o.push(...await Promise.all(a)), o;
  }
  async loadWeights(e) {
    const n = await this.getWeightUrls(e), s = Ww(e), i = await yA(n, this.loadOptions);
    return [s, i];
  }
}
__.URL_SCHEME_REGEX = /^https?:\/\//;
function P6(t) {
  const e = t.lastIndexOf("/"), n = t.lastIndexOf("?"), s = t.substring(0, e), i = n > e ? t.substring(n) : "";
  return [s + "/", i];
}
function Jw(t) {
  return t.match(__.URL_SCHEME_REGEX) != null;
}
const bA = (t, e) => {
  if (typeof fetch > "u" && (e == null || e.fetchFunc == null))
    return null;
  {
    let n = !0;
    if (Array.isArray(t) ? n = t.every((s) => Jw(s)) : n = Jw(t), n)
      return T_(t, e);
  }
  return null;
};
In.registerSaveRouter(bA);
In.registerLoadRouter(bA);
function T_(t, e) {
  return new __(t, e);
}
function B6(t, e) {
  return T_(t, e);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class bv {
  constructor(e) {
    this.modelArtifacts = e;
  }
  load() {
    return this.modelArtifacts;
  }
}
class vA {
  constructor(e) {
    this.saveHandler = e;
  }
  save(e) {
    return this.saveHandler(e);
  }
}
class z6 {
  constructor(e) {
    e.load && (this.load = () => Promise.resolve(e.load())), e.save && (this.save = (n) => Promise.resolve(e.save(n)));
  }
}
function V6(t, e, n, s) {
  const i = arguments;
  return new z6(wA(...i));
}
function wA(t, e, n, s) {
  return arguments.length === 1 ? t.modelTopology != null || t.weightSpecs != null ? new bv(t) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new bv({ modelTopology: t })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new bv({
    modelTopology: t,
    weightSpecs: e,
    weightData: n,
    trainingConfig: s
  }));
}
function U6(t) {
  return new vA(t);
}
function G6(t) {
  return new vA(t);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const C_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CompositeArrayBuffer: Nr,
  browserFiles: D6,
  browserHTTPRequest: B6,
  concatenateArrayBuffers: tk,
  copyModel: w4,
  decodeWeights: JN,
  decodeWeightsStream: ek,
  encodeWeights: Gw,
  fromMemory: V6,
  fromMemorySync: wA,
  getLoadHandlers: a4,
  getModelArtifactsForJSON: rS,
  getModelArtifactsForJSONSync: sk,
  getModelArtifactsInfoForJSON: Up,
  getSaveHandlers: ik,
  getWeightSpecs: Ww,
  http: T_,
  isHTTPScheme: Jw,
  listModels: b4,
  loadWeights: O6,
  moveModel: S4,
  registerLoadRouter: o4,
  registerSaveRouter: r4,
  removeModel: v4,
  weightsLoaderFactory: xA,
  withSaveHandler: U6,
  withSaveHandlerSync: G6
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function W6(t, e, n) {
  const s = R(t, "labels", "confusionMatrix"), i = R(e, "predictions", "confusionMatrix");
  A(n == null || n > 0 && Number.isInteger(n), () => `If provided, numClasses must be a positive integer, but got ${n}`), A(s.rank === 1, () => `Expected the rank of labels to be 1, but got ${s.rank}`), A(i.rank === 1, () => `Expected the rank of predictions to be 1, but got ${i.rank}`), A(s.shape[0] === i.shape[0], () => `Mismatch in the number of examples: ${s.shape[0]} vs. ${i.shape[0]}. Labels and predictions should have the same number of elements.`), A(n > 0 && Number.isInteger(n), () => `numClasses is required to be a positive integer, but got ${n}`);
  const r = Gc(Le(s, "int32"), n), o = Gc(Le(i, "int32"), n), a = zt(r), c = Tt(a, o);
  return Le(c, "int32");
}
const H6 = /* @__PURE__ */ H({ confusionMatrix_: W6 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const j6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  confusionMatrix: H6
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let ic, z2 = !1;
function SA(t, e = 3) {
  if (e > 4)
    throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
  if (t == null)
    throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
  let n = !1, s = !1, i = !1, r = !1, o = !1, a = !1;
  if (t.data instanceof Uint8Array)
    n = !0;
  else if (typeof ImageData < "u" && t instanceof ImageData)
    s = !0;
  else if (typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement)
    i = !0;
  else if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement)
    r = !0;
  else if (t.getContext != null)
    o = !0;
  else if (typeof ImageBitmap < "u" && t instanceof ImageBitmap)
    a = !0;
  else
    throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);
  if (mf(Dy, G.backendName) != null) {
    const p = { pixels: t }, y = { numChannels: e };
    return G.runKernel(Dy, p, y);
  }
  const [l, u] = i ? [
    t.videoWidth,
    t.videoHeight
  ] : [t.width, t.height];
  let h;
  if (o)
    h = // tslint:disable-next-line:no-any
    t.getContext("2d").getImageData(0, 0, l, u).data;
  else if (s || n)
    h = t.data;
  else if (r || i || a) {
    if (ic == null)
      if (typeof document > "u")
        if (typeof OffscreenCanvas < "u" && typeof OffscreenCanvasRenderingContext2D < "u")
          ic = new OffscreenCanvas(1, 1).getContext("2d");
        else
          throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
      else
        ic = document.createElement("canvas").getContext("2d", { willReadFrequently: !0 });
    ic.canvas.width = l, ic.canvas.height = u, ic.drawImage(t, 0, 0, l, u), h = ic.getImageData(0, 0, l, u).data;
  }
  let d;
  if (e === 4)
    d = new Int32Array(h);
  else {
    const p = l * u;
    d = new Int32Array(p * e);
    for (let y = 0; y < p; y++)
      for (let g = 0; g < e; ++g)
        d[y * e + g] = h[y * 4 + g];
  }
  return o_(d, [u, l, e], "int32");
}
function q6(t) {
  return t != null && t.data instanceof Uint8Array;
}
function X6() {
  return typeof window < "u" && typeof ImageBitmap < "u" && window.hasOwnProperty("createImageBitmap");
}
function K6(t) {
  return t != null && t.width !== 0 && t.height !== 0;
}
function Y6(t) {
  return X6() && !(t instanceof ImageBitmap) && K6(t) && !q6(t);
}
async function Z6(t, e = 3) {
  let n = null;
  if (ie().getBool("WRAP_TO_IMAGEBITMAP") && Y6(t)) {
    let s;
    try {
      s = await createImageBitmap(t, { premultiplyAlpha: "none" });
    } catch {
      s = null;
    }
    s != null && s.width === t.width && s.height === t.height ? n = s : n = t;
  } else
    n = t;
  return SA(n, e);
}
function _A(t) {
  if (t.rank !== 2 && t.rank !== 3)
    throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);
  const e = t.rank === 2 ? 1 : t.shape[2];
  if (e > 4 || e === 2)
    throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);
  if (t.dtype !== "float32" && t.dtype !== "int32")
    throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);
}
function J6(t) {
  const e = (t == null ? void 0 : t.alpha) || 1;
  if (e > 1 || e < 0)
    throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`);
}
async function cm(t, e) {
  let n = R(t, "img", "toPixels");
  if (!(t instanceof Lt)) {
    const l = n;
    n = Le(l, "int32"), l.dispose();
  }
  _A(n);
  const [s, i] = n.shape.slice(0, 2), r = n.rank === 2 ? 1 : n.shape[2], o = await n.data(), a = n.dtype === "float32" ? 255 : 1, c = new Uint8ClampedArray(i * s * 4);
  for (let l = 0; l < s * i; ++l) {
    const u = [0, 0, 0, 255];
    for (let d = 0; d < r; d++) {
      const f = o[l * r + d];
      if (n.dtype === "float32") {
        if (f < 0 || f > 1)
          throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`);
      } else if (n.dtype === "int32" && (f < 0 || f > 255))
        throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);
      r === 1 ? (u[0] = f * a, u[1] = f * a, u[2] = f * a) : u[d] = f * a;
    }
    const h = l * 4;
    c[h + 0] = Math.round(u[0]), c[h + 1] = Math.round(u[1]), c[h + 2] = Math.round(u[2]), c[h + 3] = Math.round(u[3]);
  }
  if (e != null) {
    z2 || mf(Ox, G.backendName) != null && (console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."), z2 = !0), e.width = i, e.height = s;
    const l = e.getContext("2d"), u = new ImageData(c, i, s);
    l.putImageData(u, 0, 0);
  }
  return n !== t && n.dispose(), c;
}
function Q6(t, e, n) {
  let s = R(t, "img", "draw");
  if (!(t instanceof Lt)) {
    const o = s;
    s = Le(o, "int32"), o.dispose();
  }
  _A(s), J6(n == null ? void 0 : n.imageOptions);
  const i = { image: s }, r = { canvas: e, options: n };
  G.runKernel(Ox, i, r);
}
const lm = /* @__PURE__ */ H({ fromPixels_: SA }), e8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  draw: Q6,
  fromPixels: lm,
  fromPixelsAsync: Z6,
  toPixels: cm
}, Symbol.toStringTag, { value: "Module" }));
function lb(t, e) {
  const n = t.shape.length, s = e.shape.length;
  if (n < 1)
    throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);
  if (s < 1)
    throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);
  if (e.dtype !== "int32")
    throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);
  if (e.shape[s - 1] > n)
    throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s - 1]} vs. ${n}`);
  if (ue(t.shape) === 0)
    throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);
  const i = e.shape, r = i[i.length - 1];
  let o = 1;
  for (let h = 0; h < i.length - 1; ++h)
    o *= i[h];
  const a = t.shape, c = i.slice();
  c.pop();
  let l = 1;
  for (let h = r; h < n; ++h)
    l *= a[h], c.push(a[h]);
  const u = [
    ...ct(t.shape).map((h) => h / l),
    1
  ].slice(0, r);
  return [c, o, l, u];
}
const t8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  prepareAndValidate: lb
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Qw = -2, n8 = -1;
function I_(t, e, n) {
  const s = t.shape.length;
  A(s === e.length, () => `Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`), A(s === n.length, () => `Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);
  for (let i = 0; i < s; ++i)
    A(e[i] + n[i] <= t.shape[i], () => `Error in slice${s}D: begin[${i}] + size[${i}] (${e[i] + n[i]}) would overflow input.shape[${i}] (${t.shape[i]})`);
}
function s8(t) {
  const e = [];
  let n = 0;
  for (; t > 0; )
    t & 1 && e.push(n), t /= 2, n++;
  return e;
}
function E_(t, e, n) {
  const s = [];
  for (let i = 0; i < t.length; i++)
    s[i] = Math.ceil((e[i] - t[i]) / n[i]);
  return s;
}
function TA(t, e, n, s) {
  const i = [...t];
  for (let r = i.length; r < s.length; r++)
    i.push(1);
  for (let r = 0; r < n; r++)
    r === 0 ? i[e] = 1 : (i.splice(
      e,
      0,
      1
      /* element to add */
    ), i.pop());
  return i;
}
function CA(t, e, n) {
  return n <= t ? n : n - (e - 1);
}
function IA(t, e) {
  const n = [];
  for (let s = 0; s < t; s++)
    n.push(e + s);
  return n;
}
function i8(t, e, n, s, i, r, o, a, c) {
  const l = t.length;
  let u = new Array(l), h = new Array(l), d = new Array(l);
  if (e.length && n > 0) {
    const f = e[0], p = n + 1;
    u = EA(o, f, p, s, t), h = NA(a, f, p, i, t), d = TA(r, f, p, t);
  } else
    for (let f = 0; f < l; f++)
      u[f] = AA(o, s, r, t, f, c), h[f] = MA(a, i, r, t, f, c), d[f] = kA(r, f, c);
  return {
    begin: u,
    end: h,
    strides: d
  };
}
function EA(t, e, n, s, i) {
  const r = [...i], o = IA(n, e);
  for (let a = 0; a < r.length; a++)
    if (o.indexOf(a) > -1)
      r[a] = 0;
    else {
      const c = CA(e, n, a);
      let l = s[c];
      t & 1 << c && (l = 0), r[a] = l;
    }
  return r;
}
function NA(t, e, n, s, i) {
  const r = [...i], o = IA(n, e);
  for (let a = 0; a < r.length; a++)
    if (o.indexOf(a) > -1)
      r[a] = Number.MAX_SAFE_INTEGER;
    else {
      const c = CA(e, n, a);
      let l = s[c];
      t & 1 << c && (l = Number.MAX_SAFE_INTEGER), r[a] = l;
    }
  for (let a = 0; a < r.length; a++) {
    const c = i[a];
    r[a] < 0 && (r[a] += c), r[a] = _a(0, r[a], i[a]);
  }
  return r;
}
function kA(t, e, n) {
  let s = t[e];
  return (n & 1 << e || s == null) && (s = 1), s;
}
function AA(t, e, n, s, i, r) {
  let o = e[i];
  const a = n[i] || 1;
  (t & 1 << i || r & 1 << i || o == null) && (a > 0 ? o = Number.MIN_SAFE_INTEGER : o = Number.MAX_SAFE_INTEGER);
  const c = s[i];
  return o < 0 && (o += c), o = _a(0, o, c - 1), o;
}
function MA(t, e, n, s, i, r) {
  let o = e[i];
  const a = n[i] || 1;
  (t & 1 << i || r & 1 << i || o == null) && (a > 0 ? o = Number.MAX_SAFE_INTEGER : o = Number.MIN_SAFE_INTEGER);
  const c = s[i];
  return o < 0 && (o += c), a > 0 ? o = _a(0, o, c) : o = _a(-1, o, c - 1), o;
}
function N_(t, e, n) {
  let s = n.length;
  for (let i = 0; i < n.length; i++)
    if (n[i] > 1) {
      s = i;
      break;
    }
  for (let i = s + 1; i < n.length; i++)
    if (e[i] > 0 || n[i] !== t[i])
      return !1;
  return !0;
}
function k_(t, e) {
  let n = t.length > 0 ? t[t.length - 1] : 1;
  for (let s = 0; s < t.length - 1; s++)
    n += t[s] * e[s];
  return n;
}
function ub(t, e, n) {
  let s;
  const i = t.shape.length;
  typeof e == "number" ? s = [e, ...new Array(i - 1).fill(0)] : e.length < i ? s = e.concat(new Array(i - e.length).fill(0)) : s = e.slice(), s.forEach((o) => {
    A(o !== -1, () => "slice() does not support negative begin indexing.");
  });
  let r;
  return n == null ? r = new Array(i).fill(-1) : typeof n == "number" ? r = [n, ...new Array(i - 1).fill(-1)] : n.length < i ? r = n.concat(new Array(i - n.length).fill(-1)) : r = n, r = r.map((o, a) => o >= 0 ? o : (A(o === -1, () => `Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`), t.shape[a] - s[a])), [s, r];
}
function A_(t, e, n, s, i, r, o, a, c) {
  let l;
  if (s == null ? (l = new Array(e.length), l.fill(1)) : l = s, o != null && o & o - 1)
    throw new Error("Multiple ellipses in slice is not allowed.");
  let u = !1;
  const h = {
    dims: l.length,
    numAddAxisAfterEllipsis: 0,
    begin: e.slice(),
    end: n.slice(),
    strides: l.slice(),
    beginMask: i,
    endMask: r,
    ellipsisMask: o,
    newAxisMask: a,
    shrinkAxisMask: c
  };
  for (let v = 0; v < h.dims; v++)
    u && 1 << v & a && h.numAddAxisAfterEllipsis++, 1 << v & o && (u = !0);
  u || (h.ellipsisMask |= 1 << h.dims, h.dims++);
  const d = {
    dims: t.length,
    beginMask: 0,
    endMask: 0,
    beginValid: !1,
    endValid: !1
  };
  r8(h, d);
  let f = !0, p = !0, y = !0;
  const g = [], m = [];
  for (let v = 0; v < t.length; ++v) {
    if (d.strides[v] === 0)
      throw Error(`strides[${v}] must be non-zero`);
    const b = !!(d.shrinkAxisMask & 1 << v), w = t[v];
    if (w === -1) {
      g.push(b ? 1 : -1);
      continue;
    }
    const S = [d.beginMask & 1 << v, d.endMask & 1 << v], _ = [
      d.strides[v] > 0 ? 0 : -1,
      d.strides[v] > 0 ? w : w - 1
    ];
    if (b && d.strides[v] <= 0)
      throw Error("only stride 1 allowed on non-range indexing.");
    y = y && d.strides[v] === 1;
    const E = !!(d.beginMask & 1 << v && d.endMask & 1 << v);
    if (d.beginValid && d.endValid) {
      if (b) {
        const L = d.begin[v] < 0 ? w + d.begin[v] : d.begin[v];
        if (d.begin[v] = L, d.end[v] = d.begin[v] + 1, L < 0 || L >= w)
          throw Error(`slice index ${d.begin[v]} of dimension ${v} out of bounds.`);
      } else
        d.begin[v] = V2(d.begin[v], 0, d.strides[v], w, S, _), d.end[v] = V2(d.end[v], 1, d.strides[v], w, S, _);
      const M = d.strides[v] === 1 && d.begin[v] === 0 && d.end[v] === w;
      f = f && M, p = p && (v === 0 && d.strides[v] === 1 || M);
    } else
      f = f && d.strides[v] === 1 && E, p = p && (v === 0 && d.strides[v] === 1 || E);
    let I, k = !1;
    if (d.beginValid && d.endValid ? (I = d.end[v] - d.begin[v], k = !0) : b ? (I = 1, k = !0) : E && w >= 0 && (d.strides[v] < 0 ? I = -w : I = w, k = !0), k) {
      let M;
      I === 0 || I < 0 != d.strides[v] < 0 ? M = 0 : M = Math.trunc(I / d.strides[v]) + (I % d.strides[v] !== 0 ? 1 : 0), g.push(M);
    } else
      g.push(-1);
  }
  for (let v = 0; v < d.finalShapeGatherIndices.length; ++v) {
    const b = d.finalShapeGatherIndices[v];
    b >= 0 ? m.push(g[b]) : b === Qw && m.push(1);
  }
  return {
    finalShapeSparse: m.filter((v, b) => d.finalShapeGatherIndices[b] !== Qw),
    finalShape: m,
    isIdentity: f,
    sliceDim0: p,
    isSimpleSlice: y,
    begin: d.begin,
    end: d.end,
    strides: d.strides
  };
}
function r8(t, e) {
  e.beginMask = 0, e.endMask = 0, e.shrinkAxisMask = 0;
  let n = 0;
  e.beginValid = t.begin != null, e.endValid = t.end != null, e.begin = new Array(e.dims), e.end = new Array(e.dims), e.strides = new Array(e.dims), e.finalShapeGatherIndices = [], e.finalShapeGatherIndicesSparse = [], e.inputShapeGatherIndicesSparse = new Array(e.dims);
  for (let s = 0; s < t.dims; s++)
    if (1 << s & t.ellipsisMask) {
      const i = Math.min(e.dims - (t.dims - s) + 1 + t.numAddAxisAfterEllipsis, e.dims);
      for (; n < i; n++)
        e.begin[n] = 0, e.end[n] = 0, e.strides[n] = 1, e.beginMask |= 1 << n, e.endMask |= 1 << n, e.finalShapeGatherIndices.push(n), e.finalShapeGatherIndicesSparse.push(-1), e.inputShapeGatherIndicesSparse[n] = s;
    } else if (1 << s & t.newAxisMask)
      e.finalShapeGatherIndices.push(Qw), e.finalShapeGatherIndicesSparse.push(-1);
    else {
      if (n === e.begin.length)
        throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);
      t.begin != null && (e.begin[n] = t.begin[s]), t.end != null && (e.end[n] = t.end[s]), e.strides[n] = t.strides[s], t.beginMask & 1 << s && (e.beginMask |= 1 << n), t.endMask & 1 << s && (e.endMask |= 1 << n), t.shrinkAxisMask & 1 << s ? (e.finalShapeGatherIndices.push(n8), e.finalShapeGatherIndicesSparse.push(-1), e.shrinkAxisMask |= 1 << n) : (e.finalShapeGatherIndices.push(n), e.finalShapeGatherIndicesSparse.push(s)), e.inputShapeGatherIndicesSparse[n] = s, n++;
    }
}
function V2(t, e, n, s, i, r) {
  if (i[e])
    return n > 0 ? r[e] : r[e + 1 & 1];
  {
    const o = t < 0 ? s + t : t;
    return o < r[0] ? r[0] : o > r[1] ? r[1] : o;
  }
}
const RA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assertParamsValid: I_,
  computeFlatOffset: k_,
  computeOutShape: E_,
  getNormalizedAxes: i8,
  isSliceContinous: N_,
  maskToAxes: s8,
  parseSliceParams: ub,
  sliceInfo: A_,
  startForAxis: AA,
  startIndicesWithElidedDims: EA,
  stopForAxis: MA,
  stopIndicesWithElidedDims: NA,
  stridesForAxis: kA,
  stridesWithElidedDims: TA
}, Symbol.toStringTag, { value: "Module" }));
/** @license See the LICENSE file. */
const o8 = "4.22.0";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class DA {
  /**
   * Constructs a `tf.SGDOptimizer` that uses stochastic gradient descent.
   *
   * ```js
   * // Fit a quadratic function by learning the coefficients a, b, c.
   * const xs = tf.tensor1d([0, 1, 2, 3]);
   * const ys = tf.tensor1d([1.1, 5.9, 16.8, 33.9]);
   *
   * const a = tf.scalar(Math.random()).variable();
   * const b = tf.scalar(Math.random()).variable();
   * const c = tf.scalar(Math.random()).variable();
   *
   * // y = a * x^2 + b * x + c.
   * const f = x => a.mul(x.square()).add(b.mul(x)).add(c);
   * const loss = (pred, label) => pred.sub(label).square().mean();
   *
   * const learningRate = 0.01;
   * const optimizer = tf.train.sgd(learningRate);
   *
   * // Train the model.
   * for (let i = 0; i < 10; i++) {
   *   optimizer.minimize(() => loss(f(xs), ys));
   * }
   *
   * // Make predictions.
   * console.log(
   *     `a: ${a.dataSync()}, b: ${b.dataSync()}, c: ${c.dataSync()}`);
   * const preds = f(xs).dataSync();
   * preds.forEach((pred, i) => {
   *   console.log(`x: ${i}, pred: ${pred}`);
   * });
   * ```
   *
   * @param learningRate The learning rate to use for the SGD algorithm.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static sgd(e) {
    return new cb(e);
  }
  /**
   * Constructs a `tf.MomentumOptimizer` that uses momentum gradient
   * descent.
   *
   * See
   * [http://proceedings.mlr.press/v28/sutskever13.pdf](
   * http://proceedings.mlr.press/v28/sutskever13.pdf)
   *
   * @param learningRate The learning rate to use for the Momentum gradient
   * descent algorithm.
   * @param momentum The momentum to use for the momentum gradient descent
   * algorithm.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static momentum(e, n, s = !1) {
    return new w_(e, n, s);
  }
  /**
   * Constructs a `tf.RMSPropOptimizer` that uses RMSProp gradient
   * descent. This implementation uses plain momentum and is not centered
   * version of RMSProp.
   *
   * See
   * [http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf](
   * http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf)
   *
   * @param learningRate The learning rate to use for the RMSProp gradient
   * descent algorithm.
   * @param decay The discounting factor for the history/coming gradient.
   * @param momentum The momentum to use for the RMSProp gradient descent
   * algorithm.
   * @param epsilon Small value to avoid zero denominator.
   * @param centered If true, gradients are normalized by the estimated
   * variance of the gradient.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static rmsprop(e, n = 0.9, s = 0, i = null, r = !1) {
    return new S_(e, n, s, i, r);
  }
  /**
   * Constructs a `tf.AdamOptimizer` that uses the Adam algorithm.
   * See [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)
   *
   * @param learningRate The learning rate to use for the Adam gradient
   * descent algorithm.
   * @param beta1 The exponential decay rate for the 1st moment estimates.
   * @param beta2 The exponential decay rate for the 2nd moment estimates.
   * @param epsilon A small constant for numerical stability.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static adam(e = 1e-3, n = 0.9, s = 0.999, i = null) {
    return new b_(e, n, s, i);
  }
  /**
   * Constructs a `tf.AdadeltaOptimizer` that uses the Adadelta algorithm.
   * See [https://arxiv.org/abs/1212.5701](https://arxiv.org/abs/1212.5701)
   *
   * @param learningRate The learning rate to use for the Adadelta gradient
   * descent algorithm.
   * @param rho The learning rate decay over each update.
   * @param epsilon A constant epsilon used to better condition the grad
   * update.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static adadelta(e = 1e-3, n = 0.95, s = null) {
    return new y_(e, n, s);
  }
  /**
   * Constructs a `tf.AdamaxOptimizer` that uses the Adamax algorithm.
   * See [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)
   *
   * @param learningRate The learning rate to use for the Adamax gradient
   * descent algorithm.
   * @param beta1 The exponential decay rate for the 1st moment estimates.
   * @param beta2 The exponential decay rate for the 2nd moment estimates.
   * @param epsilon A small constant for numerical stability.
   * @param decay The learning rate decay over each update.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static adamax(e = 2e-3, n = 0.9, s = 0.999, i = null, r = 0) {
    return new v_(e, n, s, i, r);
  }
  /**
   * Constructs a `tf.AdagradOptimizer` that uses the Adagrad algorithm.
   * See
   * [http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf](
   * http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf)
   * or
   * [http://ruder.io/optimizing-gradient-descent/index.html#adagrad](
   * http://ruder.io/optimizing-gradient-descent/index.html#adagrad)
   *
   * @param learningRate The learning rate to use for the Adagrad gradient
   * descent algorithm.
   * @param initialAccumulatorValue Starting value for the accumulators, must be
   * positive.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static adagrad(e, n = 0.1) {
    return new x_(e, n);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const lc = DA;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const a8 = (() => typeof requestAnimationFrame < "u" ? requestAnimationFrame : typeof setImmediate < "u" ? setImmediate : (t) => t())();
function M_() {
  return new Promise((t) => a8(() => t()));
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R_(t, e) {
  const n = t[0].length;
  t.forEach((i, r) => {
    A(i.length === n, () => `Error in concat${n}D: rank of tensors[${r}] must be the same as the rank of the rest (${n})`);
  }), A(e >= 0 && e < n, () => `Error in concat${n}D: axis must be between 0 and ${n - 1}.`);
  const s = t[0];
  t.forEach((i, r) => {
    for (let o = 0; o < n; o++)
      A(o === e || i[o] === s[o], () => `Error in concat${n}D: Shape of tensors[${r}] (${i}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`);
  });
}
function Xr(t, e) {
  const n = t[0].slice();
  for (let s = 1; s < t.length; s++)
    n[e] += t[s][e];
  return n;
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var mr;
(function(t) {
  t[t.FIRST_DIM_SIZE = 0] = "FIRST_DIM_SIZE", t[t.VALUE_ROWIDS = 1] = "VALUE_ROWIDS", t[t.ROW_LENGTHS = 2] = "ROW_LENGTHS", t[t.ROW_SPLITS = 3] = "ROW_SPLITS", t[t.ROW_LIMITS = 4] = "ROW_LIMITS", t[t.ROW_STARTS = 5] = "ROW_STARTS";
})(mr || (mr = {}));
function $A(t, e, n) {
  let s = new Array();
  if (n == null && e == null)
    return s;
  if (e == null)
    for (; s.length < t + n.length; )
      s.push(-1);
  else
    s = e.slice();
  if (n == null)
    return s;
  if (t + n.length !== s.length)
    throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t + n.length}, but shape.rank = ${s.length}`);
  for (let i = 1; i < n.length; ++i) {
    const r = n[i], o = s[s.length - n.length + i], a = s[o];
    if (r >= 0)
      if (a >= 0) {
        if (a !== r)
          throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i + t}] = ${r} but shape[${i + t}] = ${a}`);
      } else
        s[o] = r;
  }
  return s;
}
function OA(t) {
  const e = {
    FIRST_DIM_SIZE: mr.FIRST_DIM_SIZE,
    VALUE_ROWIDS: mr.VALUE_ROWIDS,
    ROW_LENGTHS: mr.ROW_LENGTHS,
    ROW_SPLITS: mr.ROW_SPLITS,
    ROW_LIMITS: mr.ROW_LIMITS,
    ROW_STARTS: mr.ROW_STARTS
  }, n = [];
  for (const s of t)
    if (s in e)
      n.push(e[s]);
    else
      break;
  return n;
}
function LA(t) {
  return t.length === 0 ? 0 : t[0] === mr.FIRST_DIM_SIZE ? t.length - 1 : t.length;
}
function FA(t, e) {
  if (t == null || e == null)
    return;
  const n = t.length, s = e.length;
  if (n >= s)
    throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`);
  for (let i = 0; i < Math.min(n, s - 1); ++i) {
    const r = t[i], o = e[i + 1];
    if (r >= 0 && o >= 0 && r !== 1 && r !== o)
      throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i - t.length}] = ${r} but ragged tensor input.flatValues.shape[${i - t.length}] = ${o}`);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const D_ = 30;
function hb(t) {
  return t <= D_ ? t : Ay(t, Math.floor(Math.sqrt(t)));
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $_(t, e, n) {
  const s = n * (typeof t == "number" ? t : t[0]), i = e * (typeof t == "number" ? t : t[1]);
  return [s, i];
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function um(t, e, n, s = !0) {
  let i = [];
  if (s)
    i = i.concat(e.slice(0)), i.push(t[0] / n), i = i.concat(t.slice(1));
  else {
    i = i.concat(t[0]);
    const r = e.length;
    for (let o = 0; o < r; ++o)
      i = i.concat([t[o + 1] / e[o], e[o]]);
    i = i.concat(t.slice(r + 1));
  }
  return i;
}
function hm(t, e, n = !0) {
  const s = [];
  if (n) {
    s.push(e);
    for (let i = e + 1; i < t; ++i)
      i <= 2 * e ? (s.push(i), s.push(i - (e + 1))) : s.push(i);
  } else {
    const i = [], r = [];
    for (let o = 1; o < t; ++o)
      o >= e * 2 + 1 || o % 2 === 1 ? r.push(o) : i.push(o);
    s.push(...i), s.push(0), s.push(...r);
  }
  return s;
}
function dm(t, e, n, s = !0) {
  const i = [];
  s ? i.push(t[0] / n) : i.push(t[0] * n);
  for (let r = 1; r < t.length; ++r)
    r <= e.length ? s ? i.push(e[r - 1] * t[r]) : i.push(t[r] / e[r - 1]) : i.push(t[r]);
  return i;
}
function O_(t, e) {
  const n = [0];
  for (let s = 0; s < e; ++s)
    n.push(t[s][0]);
  return n;
}
function L_(t, e, n) {
  const s = t.slice(0, 1);
  for (let i = 0; i < n; ++i)
    s.push(t[i + 1] - e[i][0] - e[i][1]);
  return s;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const db = 1.7580993408473768, fb = 1.0507009873554805;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const F_ = 0.3275911, P_ = 0.254829592, B_ = -0.284496736, z_ = 1.421413741, V_ = -1.453152027, U_ = 1.061405429;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Lo(t, e) {
  if (t.length !== e.length)
    throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);
  const n = new Float32Array(t.length * 2);
  for (let s = 0; s < n.length; s += 2)
    n[s] = t[s / 2], n[s + 1] = e[s / 2];
  return n;
}
function PA(t) {
  const e = new Float32Array(t.length / 2), n = new Float32Array(t.length / 2);
  for (let s = 0; s < t.length; s += 2)
    e[s / 2] = t[s], n[s / 2] = t[s + 1];
  return { real: e, imag: n };
}
function BA(t) {
  const e = Math.ceil(t.length / 4), n = new Float32Array(e), s = new Float32Array(e);
  for (let i = 0; i < t.length; i += 4)
    n[Math.floor(i / 4)] = t[i], s[Math.floor(i / 4)] = t[i + 1];
  return { real: n, imag: s };
}
function zA(t) {
  const e = Math.floor(t.length / 4), n = new Float32Array(e), s = new Float32Array(e);
  for (let i = 2; i < t.length; i += 4)
    n[Math.floor(i / 4)] = t[i], s[Math.floor(i / 4)] = t[i + 1];
  return { real: n, imag: s };
}
function G_(t, e) {
  const n = t[e * 2], s = t[e * 2 + 1];
  return { real: n, imag: s };
}
function VA(t, e, n, s) {
  t[s * 2] = e, t[s * 2 + 1] = n;
}
function UA(t, e) {
  const n = new Float32Array(t / 2), s = new Float32Array(t / 2);
  for (let i = 0; i < Math.ceil(t / 2); i++) {
    const r = (e ? 2 : -2) * Math.PI * (i / t);
    n[i] = Math.cos(r), s[i] = Math.sin(r);
  }
  return { real: n, imag: s };
}
function GA(t, e, n) {
  const s = (n ? 2 : -2) * Math.PI * (t / e), i = Math.cos(s), r = Math.sin(s);
  return { real: i, imag: r };
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const vv = "->", c8 = /->/g, U2 = ",", G2 = "...";
function W_(t, e) {
  t = t.replace(/\s/g, "");
  const n = (t.length - t.replace(c8, "").length) / vv.length;
  if (n < 1)
    throw new Error("Equations without an arrow are not supported.");
  if (n > 1)
    throw new Error(`Equation must contain exactly one arrow ("${vv}").`);
  const [s, i] = t.split(vv);
  A(s.indexOf(G2) === -1, () => `The ellipsis notation ("${G2}") is not supported yet.`);
  const r = s.split(U2), o = r.length;
  if (e !== o)
    throw new Error(`Expected ${o} input tensors, received ${e}`);
  if (o > 2)
    throw new Error("Support for more than 2 input tensors is not implemented yet.");
  const a = [];
  for (let d = 0; d < i.length; ++d) {
    const f = i[d];
    if (!r.some((p) => p.indexOf(f) !== -1))
      throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);
    a.indexOf(f) === -1 && a.push(f);
  }
  for (let d = 0; d < s.length; ++d) {
    const f = s[d];
    a.indexOf(f) === -1 && f !== U2 && a.push(f);
  }
  const c = new Array(r.length);
  for (let d = 0; d < o; ++d) {
    if (new Set(r[d].split("")).size !== r[d].length)
      throw new Error(`Found duplicate axes in input component ${r[d]}. Support for duplicate axes in input is not implemented yet.`);
    c[d] = [];
    for (let f = 0; f < r[d].length; ++f)
      c[d].push(a.indexOf(r[d][f]));
  }
  const l = a.length, u = i.length, h = [];
  for (let d = u; d < l; ++d)
    h.push(d);
  return { allDims: a, summedDims: h, idDims: c };
}
function H_(t, e) {
  let n = new Array(t);
  n.fill(-1);
  for (let i = 0; i < e.length; ++i)
    n[e[i]] = i;
  const s = [];
  for (let i = 0; i < t; ++i)
    n[i] === -1 && s.push(i);
  return n = n.filter((i) => i !== -1), { permutationIndices: n, expandDims: s };
}
function j_(t, e, n) {
  const s = new Array(t);
  for (let i = 0; i < n.length; ++i) {
    const r = n[i].shape;
    for (let o = 0; o < e[i].length; ++o)
      s[e[i][o]] === void 0 ? s[e[i][o]] = r[o] : A(s[e[i][o]] === r[o], () => `Expected dimension ${s[e[i][o]]} at axis ${o} of input shaped ${JSON.stringify(r)}, but got dimension ${r[o]}`);
  }
}
function q_(t, e) {
  const n = t, s = [];
  let i = 0;
  t.length === 0 && n.push(-1), i = t.length + 1;
  for (let o = 0; o < i; ++o)
    s.push([]);
  const r = [];
  for (let o = 0; o < n.length; ++o) {
    const a = n[o], c = l8(e, a);
    for (const l of c)
      r.indexOf(l) === -1 && (s[o].push(l), r.push(l));
  }
  return { path: n, steps: s };
}
function X_(t) {
  return t.every((e, n) => e === n);
}
function l8(t, e) {
  const n = [];
  for (let s = 0; s < t.length; ++s)
    (t[s].length === 0 || t[s].indexOf(e) !== -1 || e === -1) && n.push(s);
  return n;
}
function K_(t, e, n = 0) {
  let s = [];
  if (typeof e == "number")
    A(t.shape[n] % e === 0, () => "Number of splits must evenly divide the axis."), s = new Array(e).fill(t.shape[n] / e);
  else {
    const i = e.reduce((o, a) => (a === -1 && (o += 1), o), 0);
    A(i <= 1, () => "There should be only one negative value in split array.");
    const r = e.indexOf(-1);
    if (r !== -1) {
      const o = e.reduce((a, c) => c > 0 ? a + c : a);
      e[r] = t.shape[n] - o;
    }
    A(t.shape[n] === e.reduce((o, a) => o + a), () => "The sum of sizes must match the size of the axis dimension."), s = e;
  }
  return s;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function WA(t) {
  return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`;
}
function HA(t, e) {
  return `indices(${t}, 0) is invalid: ${e} < 0`;
}
function jA(t, e, n) {
  return `indices(${t}, 0) is invalid: ${e} >= ${n}`;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qA(t, e) {
  return `only one output dimension may be -1, not both ${t} and ${e}`;
}
function XA(t, e) {
  return `size ${t} must be non-negative, not ${e}`;
}
function KA() {
  return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
}
function YA(t, e) {
  const n = ue(t), s = ue(e);
  return `Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${t} outputShape= ${e}`;
}
function ZA(t, e) {
  const n = ue(t), s = ue(e);
  return `Input to reshape is a tensor with ${n} dense values, but the requested shape has ${s}. inputShape=${t} outputShape=${e}`;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function e1() {
  return "segment ids must be >= 0";
}
function JA() {
  return "segment ids are not increasing";
}
function QA(t, e) {
  return `Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`;
}
function eM(t, e, n) {
  return `Bad: indices[${t}] == ${e} out of range [0, ${n})`;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tM(t, e) {
  let n = !1, s;
  for (t <= D_ ? (s = t, n = !0) : s = Ay(t, Math.floor(Math.sqrt(t))); !n; )
    s > e || s === t ? n = !0 : s = Ay(t, s + 1);
  return s;
}
function nM(t, e, n) {
  const s = [], i = t.length;
  for (let r = 0; r < i; r++)
    r !== e ? s.push(t[r]) : s.push(n);
  return s;
}
function Y_(t, e, n, s) {
  const i = e.shape.length, r = t.shape.length;
  if (s !== 0 && (s < -i || s > i))
    throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${s}`);
  if (s < 0 && (s += i), s > r)
    throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${r}).`);
  if (n < s)
    throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);
  for (let h = 0; h < s; ++h)
    if (t.shape[h] !== e.shape[h])
      throw new Error(`x.shape[${h}]: ${t.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);
  const o = t.shape[n], a = [];
  let c = 1, l = 1, u = 1;
  for (let h = 0; h < s; ++h)
    a.push(t.shape[h]), c *= t.shape[h];
  for (let h = s; h < n; h++)
    a.push(t.shape[h]), l *= t.shape[h];
  for (let h = s; h < i; h++)
    a.push(e.shape[h]);
  for (let h = n + 1; h < r; h++)
    a.push(t.shape[h]), u *= t.shape[h];
  return { batchSize: c, sliceSize: u, outerSize: l, dimSize: o, outputShape: a };
}
const u8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  collectGatherOpShapeInfo: Y_,
  computeOutShape: nM,
  segOpComputeOptimalWindowSize: tM
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fo(t) {
  try {
    return t.map((e) => Ro(e));
  } catch (e) {
    throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`);
  }
}
function sM(t) {
  return t.map((e) => jr(e));
}
const iM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ERF_A1: P_,
  ERF_A2: B_,
  ERF_A3: z_,
  ERF_A4: V_,
  ERF_A5: U_,
  ERF_P: F_,
  PARALLELIZE_THRESHOLD: D_,
  get RowPartitionType() {
    return mr;
  },
  SELU_SCALE: fb,
  SELU_SCALEALPHA: db,
  applyActivation: sb,
  assertAndGetBroadcastShape: bt,
  assertAxesAreInnerMostDims: _s,
  assertParamsConsistent: R_,
  assignToTypedArray: VA,
  axesAreInnerMostDims: DS,
  calculateShapes: Ua,
  checkEinsumDimSizes: j_,
  checkPadOnDimRoundingMode: Hs,
  combineLocations: bk,
  combineRaggedTensorToTensorShapes: $A,
  complexWithEvenIndex: BA,
  complexWithOddIndex: zA,
  computeConv2DInfo: hs,
  computeConv3DInfo: Pa,
  computeDefaultPad: mS,
  computeDilation2DInfo: Gp,
  computeOptimalWindowSize: hb,
  computeOutAndReduceShapes: ds,
  computeOutShape: Xr,
  computePool2DInfo: ir,
  computePool3DInfo: Uo,
  convertConv2DDataFormat: Go,
  decodeEinsumEquation: W_,
  eitherStridesOrDilationsAreOne: Ss,
  expandShapeToKeepDim: zn,
  exponent: GA,
  exponents: UA,
  fromStringArrayToUint8: sM,
  fromUint8ToStringArray: Fo,
  getAxesPermutation: An,
  getBroadcastDims: Vc,
  getComplexWithIndex: G_,
  getEinsumComputePath: q_,
  getEinsumPermutation: H_,
  getFusedBiasGradient: nb,
  getFusedDyActivation: tb,
  getImageCenter: $_,
  getInnerMostAxes: Vn,
  getPermuted: hm,
  getRaggedRank: LA,
  getReductionAxes: Kn,
  getReshaped: um,
  getReshapedPermuted: dm,
  getRowPartitionTypesHelper: OA,
  getSliceBeginCoords: O_,
  getSliceSize: L_,
  getSparseFillEmptyRowsIndicesDenseShapeMismatch: WA,
  getSparseFillEmptyRowsNegativeIndexErrorMessage: HA,
  getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: jA,
  getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: KA,
  getSparseReshapeInputOutputMismatchErrorMessage: ZA,
  getSparseReshapeInputOutputMultipleErrorMessage: YA,
  getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: qA,
  getSparseReshapeNegativeOutputDimErrorMessage: XA,
  getSparseSegmentReductionIndicesOutOfRangeErrorMessage: eM,
  getSparseSegmentReductionNegativeSegmentIdsErrorMessage: e1,
  getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: JA,
  getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: QA,
  getUndoAxesPermutation: Ba,
  isIdentityPermutation: X_,
  log: nU,
  mergeRealAndImagArrays: Lo,
  prepareAndValidate: lb,
  prepareSplitSize: K_,
  segment_util: u8,
  shouldFuse: ib,
  slice_util: RA,
  splitRealAndImagArrays: PA,
  stridesOrDilationsArePositive: zc,
  tupleValuesAreOne: Na,
  upcastType: ni,
  validateDefaultValueShape: FA,
  validateInput: Y0,
  validateUpdateShape: a_,
  warn: Ei
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const h8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  nonMaxSuppressionV3Impl: rb,
  nonMaxSuppressionV4Impl: ob,
  nonMaxSuppressionV5Impl: ab,
  whereImpl: Q0
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
I6();
const rM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Abs: Ff,
  Acos: Lu,
  Acosh: Fu,
  AdadeltaOptimizer: y_,
  AdagradOptimizer: x_,
  AdamOptimizer: b_,
  AdamaxOptimizer: v_,
  Add: Qc,
  AddN: Pf,
  All: xx,
  Any: bx,
  ArgMax: Bf,
  ArgMin: zf,
  Asin: Pu,
  Asinh: Bu,
  Atan: zu,
  Atan2: Uu,
  Atanh: Vu,
  AvgPool: Vf,
  AvgPool3D: Uf,
  AvgPool3DGrad: wx,
  AvgPoolGrad: vx,
  BatchMatMul: Gf,
  BatchToSpaceND: Wf,
  Bincount: Sx,
  BitwiseAnd: Hf,
  BroadcastArgs: _x,
  BroadcastTo: RN,
  Cast: Gu,
  Ceil: Wu,
  ClipByValue: Hu,
  Complex: Tx,
  ComplexAbs: jf,
  Concat: qf,
  Conv2D: Xf,
  Conv2DBackpropFilter: Cx,
  Conv2DBackpropInput: Kf,
  Conv3D: Yf,
  Conv3DBackpropFilterV2: Ix,
  Conv3DBackpropInputV2: Ex,
  Cos: ju,
  Cosh: qu,
  CropAndResize: kx,
  Cumprod: Nx,
  Cumsum: Zf,
  DataStorage: W1,
  DenseBincount: Ax,
  DepthToSpace: Mx,
  DepthwiseConv2dNative: Jf,
  DepthwiseConv2dNativeBackpropFilter: Rx,
  DepthwiseConv2dNativeBackpropInput: Dx,
  Diag: $x,
  Dilation2D: Qf,
  Dilation2DBackpropFilter: Ry,
  Dilation2DBackpropInput: My,
  Draw: Ox,
  get ENV() {
    return K1;
  },
  Einsum: Lx,
  Elu: Ku,
  EluGrad: Fx,
  Environment: AN,
  Equal: ep,
  Erf: Yu,
  Exp: Zu,
  ExpandDims: tp,
  Expm1: Ju,
  FFT: Px,
  Fill: Bx,
  FlipLeftRight: zx,
  Floor: Qu,
  FloorDiv: eh,
  FromPixels: Dy,
  FusedBatchNorm: np,
  FusedConv2D: df,
  FusedDepthwiseConv2D: ff,
  GatherNd: Vx,
  GatherV2: sp,
  Greater: ip,
  GreaterEqual: th,
  IFFT: Ux,
  Identity: nh,
  Imag: Gx,
  IsFinite: sh,
  IsInf: ih,
  IsNan: rh,
  KernelBackend: mx,
  LRN: hp,
  LRNGrad: Hx,
  LeakyRelu: rp,
  Less: op,
  LessEqual: ap,
  LinSpace: Wx,
  Log: oh,
  Log1p: ah,
  LogSoftmax: DN,
  LogicalAnd: cp,
  LogicalNot: lp,
  LogicalOr: up,
  LogicalXor: ZV,
  LowerBound: JV,
  MatrixBandPart: QV,
  Max: dp,
  MaxPool: fp,
  MaxPool3D: pp,
  MaxPool3DGrad: qx,
  MaxPoolGrad: jx,
  MaxPoolWithArgmax: Xx,
  Maximum: ch,
  Mean: mp,
  Min: gp,
  Minimum: lh,
  MirrorPad: yp,
  Mod: uh,
  MomentumOptimizer: w_,
  Multinomial: Kx,
  Multiply: hh,
  Neg: xp,
  NonMaxSuppressionV3: Yx,
  NonMaxSuppressionV4: Zx,
  NonMaxSuppressionV5: Jx,
  NotEqual: bp,
  OP_SCOPE_SUFFIX: nS,
  OneHot: wp,
  OnesLike: vp,
  Optimizer: jo,
  OptimizerConstructors: DA,
  Pack: Sp,
  PadV2: _p,
  Pool: eU,
  Pow: dh,
  Prelu: Tp,
  Prod: Cp,
  RMSPropOptimizer: S_,
  RaggedGather: Qx,
  RaggedRange: e0,
  RaggedTensorToTensor: t0,
  Range: n0,
  get Rank() {
    return Fw;
  },
  Real: s0,
  RealDiv: Xu,
  Reciprocal: fh,
  get Reduction() {
    return Bs;
  },
  Relu: ph,
  Relu6: mh,
  Reshape: Ip,
  ResizeBilinear: Np,
  ResizeBilinearGrad: r0,
  ResizeNearestNeighbor: Ep,
  ResizeNearestNeighborGrad: i0,
  Reverse: kp,
  RotateWithOffset: S0,
  Round: gh,
  Rsqrt: yh,
  SGDOptimizer: cb,
  ScatterNd: o0,
  SearchSorted: c0,
  Select: Ap,
  Selu: xh,
  Sigmoid: Sh,
  Sign: wh,
  Sin: bh,
  Sinh: vh,
  Slice: Mp,
  Softmax: Op,
  Softplus: _h,
  SpaceToBatchND: Dp,
  SparseFillEmptyRows: l0,
  SparseReshape: u0,
  SparseSegmentMean: h0,
  SparseSegmentSum: d0,
  SparseToDense: f0,
  SplitV: $p,
  Sqrt: Th,
  Square: p0,
  SquaredDifference: Ch,
  StaticRegexReplace: Lp,
  Step: Ah,
  StridedSlice: m0,
  StringNGrams: g0,
  StringSplit: y0,
  StringToHashBucketFast: x0,
  Sub: Ih,
  Sum: Rp,
  Tan: Eh,
  Tanh: Nh,
  Tensor: Lt,
  TensorBuffer: Xn,
  TensorScatterUpdate: a0,
  Tile: kh,
  TopK: b0,
  Transform: v0,
  Transpose: wc,
  Unique: w0,
  Unpack: Fp,
  UnsortedSegmentSum: Pp,
  UpperBound: tU,
  Variable: gf,
  ZerosLike: Bp,
  _FusedMatMul: hf,
  abs: jn,
  acos: aS,
  acosh: cS,
  add: Se,
  addN: dk,
  all: E0,
  any: xf,
  argMax: Ea,
  argMin: lS,
  asin: uS,
  asinh: hS,
  atan: dS,
  atan2: fS,
  atanh: pS,
  avgPool: Wp,
  avgPool3d: gS,
  backend: Vp,
  backend_util: iM,
  basicLSTMCell: fk,
  batchNorm: Mh,
  batchNorm2d: yS,
  batchNorm3d: xS,
  batchNorm4d: bS,
  batchToSpaceND: Hp,
  bincount: vS,
  bitwiseAnd: pk,
  booleanMaskAsync: Jk,
  broadcastArgs: mk,
  broadcastTo: Sc,
  broadcast_util: FG,
  browser: e8,
  buffer: It,
  cast: Le,
  ceil: wS,
  clipByValue: Gs,
  clone: qr,
  complex: Do,
  concat: Pn,
  concat1d: SS,
  concat2d: _S,
  concat3d: TS,
  concat4d: CS,
  conv1d: N0,
  conv2d: $o,
  conv2dTranspose: k0,
  conv3d: ES,
  conv3dTranspose: NS,
  copyRegisteredKernels: rU,
  cos: jp,
  cosh: A0,
  cosineWindow: eb,
  cumprod: wf,
  cumsum: M0,
  customGrad: ro,
  denseBincount: Fy,
  deprecationWarn: zU,
  depthToSpace: kS,
  depthwiseConv2d: Rh,
  device_util: $U,
  diag: yk,
  dilation2d: AS,
  disableDeprecationWarnings: BU,
  dispose: At,
  disposeVariables: VU,
  div: it,
  divNoNan: MS,
  dot: RS,
  dropout: d_,
  einsum: hc,
  elu: Dh,
  enableDebugMode: PU,
  enableProdMode: FU,
  enclosingPowerOfTwo: f_,
  engine: ui,
  ensureShape: xk,
  env: ie,
  equal: xi,
  erf: R0,
  euclideanNorm: $S,
  exp: ii,
  expandDims: vn,
  expm1: OS,
  eye: D0,
  fft: om,
  fill: nl,
  findBackend: qU,
  findBackendFactory: XU,
  floor: Oh,
  floorDiv: I0,
  fused: aA,
  gather: Lh,
  gatherND: nA,
  gather_util: t8,
  getBackend: C0,
  getGradient: $w,
  getKernel: mf,
  getKernelsForBackend: $y,
  grad: vW,
  grads: wW,
  greater: js,
  greaterEqual: Wo,
  ifft: Cu,
  imag: qp,
  image: as,
  inTopKAsync: sA,
  io: C_,
  irfft: X0,
  isFinite: LS,
  isInf: FS,
  isNaN: PS,
  keep: Zn,
  kernel_impls: h8,
  leakyRelu: Xp,
  less: Su,
  lessEqual: za,
  linalg: g_,
  linspace: wk,
  localResponseNormalization: BS,
  log: bi,
  log1p: Kp,
  logSigmoid: zS,
  logSoftmax: O0,
  logSumExp: Yp,
  logicalAnd: _r,
  logicalNot: Zp,
  logicalOr: L0,
  logicalXor: VS,
  losses: pA,
  lowerBound: _k,
  matMul: Tt,
  math: j6,
  max: Ri,
  maxPool: Jp,
  maxPool3d: US,
  maxPoolWithArgmax: Tk,
  maximum: lo,
  mean: En,
  memory: Ly,
  meshgrid: Ck,
  min: wu,
  minimum: Aa,
  mirrorPad: P0,
  mod: GS,
  moments: Qp,
  movingAverage: Qk,
  mul: q,
  multiRNNCell: Ik,
  multinomial: Ek,
  neg: hn,
  nextFrame: M_,
  norm: $h,
  notEqual: Uc,
  oneHot: Gc,
  ones: Qs,
  onesLike: vi,
  op: H,
  outerProduct: Nk,
  pad: uo,
  pad1d: kk,
  pad2d: Ak,
  pad3d: WS,
  pad4d: Mk,
  pool: HS,
  pow: io,
  prelu: tm,
  print: oS,
  prod: jS,
  profile: UU,
  raggedGather: Rk,
  raggedRange: Dk,
  raggedTensorToTensor: $k,
  rand: Ok,
  randomGamma: Bk,
  randomNormal: z0,
  randomStandardNormal: zk,
  randomUniform: Va,
  randomUniformInt: Vk,
  range: Oo,
  ready: HU,
  real: _u,
  reciprocal: n_,
  registerBackend: sS,
  registerGradient: $N,
  registerKernel: _0,
  relu: kr,
  relu6: V0,
  removeBackend: jU,
  reshape: Y,
  reverse: Fi,
  reverse1d: Uk,
  reverse2d: Gk,
  reverse3d: Wk,
  reverse4d: Hk,
  rfft: am,
  round: nm,
  rsqrt: U0,
  scalar: ot,
  scatterND: eA,
  scatter_util: _5,
  searchSorted: F0,
  selu: G0,
  separableConv2d: W0,
  serialization: T6,
  setBackend: WU,
  setPlatform: KU,
  setdiff1dAsync: jk,
  sigmoid: mi,
  sign: s_,
  signal: fA,
  sin: H0,
  sinh: j0,
  slice: Pt,
  slice1d: sm,
  slice2d: q0,
  slice3d: im,
  slice4d: Tu,
  slice_util: RA,
  softmax: rm,
  softplus: sl,
  spaceToBatchND: em,
  sparse: mA,
  sparseToDense: tA,
  spectral: dA,
  split: ti,
  sqrt: us,
  square: tn,
  squaredDifference: K0,
  squeeze: ys,
  stack: ri,
  step: rl,
  stridedSlice: i_,
  string: gA,
  sub: je,
  sum: Qe,
  sumOutType: T0,
  tan: r_,
  tanh: ka,
  tensor: Mi,
  tensor1d: Ns,
  tensor2d: _c,
  tensor3d: o_,
  tensor4d: qk,
  tensor5d: Xk,
  tensor6d: Kk,
  tensorScatterUpdate: Yk,
  tensor_util: kU,
  test_util: LH,
  tidy: Q,
  tile: pi,
  time: GU,
  topk: c_,
  train: lc,
  transpose: zt,
  truncatedNormal: Z0,
  unique: l_,
  unregisterGradient: iU,
  unregisterKernel: sU,
  unsortedSegmentSum: J0,
  unstack: Pi,
  upcastType: ni,
  upperBound: Zk,
  util: gU,
  valueAndGrad: SW,
  valueAndGrads: _W,
  variable: u_,
  variableGrads: Sk,
  version_core: o8,
  where: bs,
  whereAsync: h_,
  zeros: qn,
  zerosLike: Ut
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const oM = {
  kernelName: Ff,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => q(t, rl(Le(n, "float32"), -1)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const d8 = {
  kernelName: Lu,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return {
      x: () => {
        const s = tn(Le(n, "float32")), i = us(je(ot(1), s));
        return hn(it(t, i));
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const f8 = {
  kernelName: Fu,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return {
      x: () => {
        const s = us(je(tn(Le(n, "float32")), 1));
        return it(t, s);
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const p8 = {
  kernelName: Qc,
  inputsToSave: ["a", "b"],
  gradFunc: (t, e) => {
    const [n, s] = e, i = bt(n.shape, s.shape);
    return { a: () => {
      let a = t;
      const c = Kn(n.shape, i);
      return c.length > 0 && (a = Qe(a, c)), Y(a, n.shape);
    }, b: () => {
      let a = t;
      const c = Kn(s.shape, i);
      return c.length > 0 && (a = Qe(a, c)), Y(a, s.shape);
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const m8 = {
  kernelName: Pf,
  saveAllInputs: !0,
  gradFunc: (t, e) => {
    const n = {};
    return e.forEach((s, i) => {
      n[i] = () => t.clone();
    }), n;
  }
};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const g8 = {
  kernelName: Bf,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => Ut(n) };
  }
};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const y8 = {
  kernelName: zf,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => Ut(n) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const x8 = {
  kernelName: Pu,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => it(t, us(je(ot(1), tn(Le(n, "float32"))))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const b8 = {
  kernelName: Bu,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return {
      x: () => {
        const s = us(Se(ot(1), tn(Le(n, "float32"))));
        return it(t, s);
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const v8 = {
  kernelName: Uu,
  inputsToSave: ["a", "b"],
  gradFunc: (t, e) => {
    const [n, s] = e, i = bt(n.shape, s.shape);
    return { a: () => {
      const a = Se(tn(n), tn(s));
      let c = q(t, it(s, a));
      const l = Kn(n.shape, i);
      return l.length > 0 && (c = Qe(c, l)), Y(c, n.shape);
    }, b: () => {
      const a = Se(tn(n), tn(s));
      let c = hn(q(t, it(n, a)));
      const l = Kn(s.shape, i);
      return l.length > 0 && (c = Qe(c, l)), Y(c, s.shape);
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const w8 = {
  kernelName: zu,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => it(t, Se(tn(Le(n, "float32")), 1)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const S8 = {
  kernelName: Vu,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => it(t, je(ot(1), tn(Le(n, "float32")))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _8(t, e, n, s, i, r) {
  const o = R(t, "dy", "avgPool3dGrad"), a = R(e, "input", "avgPool3dGrad");
  let c = o, l = a, u = !1;
  a.rank === 4 && (u = !0, c = Y(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]), l = Y(a, [
    1,
    a.shape[0],
    a.shape[1],
    a.shape[2],
    a.shape[3]
  ])), A(c.rank === 5, () => `Error in avgPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`), A(l.rank === 5, () => `Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`), Hs("avgPool3dGrad", i, r);
  const h = { dy: c, input: l }, d = { filterSize: n, strides: s, pad: i, dimRoundingMode: r }, f = G.runKernel(wx, h, d);
  return u ? Y(f, [f.shape[1], f.shape[2], f.shape[3], f.shape[4]]) : f;
}
const T8 = /* @__PURE__ */ H({ avgPool3dGrad_: _8 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const C8 = {
  kernelName: Uf,
  inputsToSave: ["x"],
  gradFunc: (t, e, n) => {
    const [s] = e, { filterSize: i, strides: r, pad: o, dimRoundingMode: a } = n;
    return {
      x: () => T8(t, s, i, r, o, a)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function I8(t, e, n, s, i) {
  const r = R(t, "dy", "avgPoolGrad"), o = R(e, "input", "avgPoolGrad");
  A(o.rank === r.rank, () => `Rank of input (${o.rank}) does not match rank of dy (${r.rank})`);
  let a = o, c = r, l = !1;
  o.rank === 3 && (l = !0, a = Y(o, [1, o.shape[0], o.shape[1], o.shape[2]]), c = Y(r, [1, r.shape[0], r.shape[1], r.shape[2]])), A(c.rank === 4, () => `Error in avgPoolGrad: dy must be rank 4 but got rank ${c.rank}.`), A(a.rank === 4, () => `Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);
  const u = { dy: c, input: a }, h = { filterSize: n, strides: s, pad: i }, d = G.runKernel(vx, u, h);
  return l ? Y(d, [d.shape[1], d.shape[2], d.shape[3]]) : d;
}
const E8 = /* @__PURE__ */ H({ avgPoolGrad_: I8 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const N8 = {
  kernelName: Vf,
  inputsToSave: ["x"],
  gradFunc: (t, e, n) => {
    const [s] = e, { filterSize: i, strides: r, pad: o } = n;
    return { x: () => E8(t, s, i, r, o) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const k8 = {
  kernelName: Gf,
  inputsToSave: ["a", "b"],
  gradFunc: (t, e, n) => {
    const [s, i] = e, { transposeA: r, transposeB: o } = n;
    return !r && !o ? {
      a: () => Tt(t, i, !1, !0),
      b: () => Tt(s, t, !0, !1)
    } : !r && o ? {
      a: () => Tt(t, i, !1, !1),
      b: () => Tt(t, s, !0, !1)
    } : r && !o ? {
      a: () => Tt(i, t, !1, !0),
      b: () => Tt(s, t, !1, !1)
    } : {
      a: () => Tt(i, t, !0, !0),
      b: () => Tt(t, s, !0, !0)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const A8 = {
  kernelName: Wf,
  gradFunc: (t, e, n) => {
    const { blockShape: s, crops: i } = n;
    return { x: () => em(t, s, i) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const M8 = {
  kernelName: RN,
  gradFunc: (t, e, n) => {
    const s = n, i = s.inputShape, r = s.shape, o = Array.from(r);
    for (let c = i.length - 1; c >= 0; c--)
      if (i[c] === r[c])
        o[c] = 1;
      else if (i[c] !== 1)
        throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${r}].`);
    const a = [];
    for (let c = 0; c < o.length; c++)
      o[c] > 1 && a.push(c);
    return { x: () => Qe(
      t,
      a,
      !0
      /* keepDims */
    ) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const R8 = {
  kernelName: Gu,
  gradFunc: (t) => ({ x: () => t.clone() })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const D8 = {
  kernelName: Wu,
  gradFunc: (t) => ({ x: () => Ut(t) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $8 = {
  kernelName: Hu,
  inputsToSave: ["x"],
  gradFunc: (t, e, n) => {
    const [s] = e, { clipValueMin: i, clipValueMax: r } = n;
    return {
      x: () => bs(_r(Wo(s, i), za(s, r)), t, Ut(t))
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const O8 = {
  kernelName: jf,
  inputsToSave: ["x"],
  gradFunc: oM.gradFunc
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const L8 = {
  kernelName: qf,
  saveAllInputs: !0,
  gradFunc: (t, e, n) => {
    const s = e.map((c) => c.shape), { axis: i } = n, r = Rt(i, e[0].shape)[0], o = s.map((c) => c[r]);
    return ti(t, o, r).map((c) => () => c);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const F8 = {
  kernelName: Xf,
  inputsToSave: ["x", "filter"],
  gradFunc: (t, e, n) => {
    const [s, i] = e, { dilations: r, strides: o, pad: a, dataFormat: c } = n;
    return A(Na(r), () => `Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`), {
      x: () => IS(s.shape, t, i, o, a, c),
      filter: () => p_(s, t, i.shape, o, a, c)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const P8 = {
  kernelName: Kf,
  inputsToSave: ["dy", "filter"],
  gradFunc: (t, e, n) => {
    const [s, i] = e, { strides: r, pad: o, dataFormat: a, dimRoundingMode: c } = n;
    return {
      dy: () => $o(t, i, r, o, a, 1, c),
      filter: () => p_(t, s, i.shape, r, o, a, c)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function B8(t, e, n, s, i) {
  let r = t;
  t.rank === 4 && (r = Y(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]]));
  let o = e;
  o.rank === 4 && (o = Y(e, [1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]])), A(r.rank === 5, () => `Error in conv3dDerFilter: input must be rank 5, but got shape ${r.shape}.`), A(o.rank === 5, () => `Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`), A(n.length === 5, () => `Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`), A(r.shape[4] === n[3], () => `Error in conv3dDerFilter: depth of input ${r.shape[4]}) must match input depth in filter (${n[3]}.`), A(o.shape[4] === n[4], () => `Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`);
  const a = { x: r, dy: o }, c = { strides: s, pad: i, filterShape: n };
  return G.runKernel(Ix, a, c);
}
const z8 = /* @__PURE__ */ H({ conv3DBackpropFilter_: B8 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const V8 = {
  kernelName: Yf,
  inputsToSave: ["x", "filter"],
  gradFunc: (t, e, n) => {
    const { dilations: s, strides: i, pad: r } = n;
    A(Na(s), () => `Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);
    const [o, a] = e;
    return {
      x: () => gk(o.shape, t, a, i, r),
      filter: () => z8(o, t, a.shape, i, r)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const U8 = {
  kernelName: ju,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => q(hn(H0(Le(n, "float32"))), t) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const G8 = {
  kernelName: qu,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => q(j0(Le(n, "float32")), t) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const W8 = {
  kernelName: Zf,
  inputsToSave: ["x"],
  gradFunc: (t, e, n) => {
    const [s] = e, { axis: i, exclusive: r, reverse: o } = n;
    return {
      x: () => {
        const a = An([i], s.rank);
        let c = M0(t, i, r, !o);
        return a != null && (c = zt(c, a)), c;
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const H8 = {
  kernelName: Jf,
  inputsToSave: ["x", "filter"],
  gradFunc: (t, e, n) => {
    const { dilations: s, strides: i, pad: r, dimRoundingMode: o } = n, a = s ?? [1, 1];
    A(Na(a), () => `Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);
    const [c, l] = e;
    return A(c.rank === 4, () => `Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${c.rank}.`), A(l.rank === 4, () => `Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`), A(c.shape[3] === l.shape[2], () => `Error in gradient of depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`), A(Ss(i, a), () => `Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${a}'.`), Hs("depthwiseConv2d", r, o), {
      x: () => oA(c.shape, t, l, i, r, a, o),
      filter: () => rA(c, t, l.shape, i, r, a, o)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const j8 = {
  kernelName: Qf,
  inputsToSave: ["x", "filter"],
  gradFunc: (t, e, n) => {
    const [s, i] = e, r = { x: s, filter: i, dy: t }, o = { x: s, filter: i, dy: t };
    return {
      x: () => G.runKernel(My, r, n),
      filter: () => G.runKernel(Ry, o, n)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const q8 = {
  kernelName: Ku,
  outputsToSave: [!0],
  gradFunc: (t, e) => {
    const [n] = e, s = { dy: t, y: n };
    return { x: () => G.runKernel(Fx, s) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const X8 = {
  kernelName: Yu,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e, s = q(ii(hn(tn(n))), 2 / Math.sqrt(Math.PI));
    return { x: () => q(t, s) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const K8 = {
  kernelName: Zu,
  outputsToSave: [!0],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => q(t, n) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Y8 = {
  kernelName: tp,
  inputsToSave: ["input"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { input: () => Y(t, n.shape) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Z8 = {
  kernelName: Ju,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => q(t, ii(n)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const J8 = {
  kernelName: Qu,
  gradFunc: (t) => ({ x: () => Ut(t) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Q8 = {
  kernelName: eh,
  inputsToSave: ["a", "b"],
  gradFunc: (t, e) => {
    const [n, s] = e, i = bt(n.shape, s.shape);
    return { a: () => {
      const a = it(t, Le(s, "float32")), c = Kn(n.shape, i);
      return c.length > 0 ? Y(Qe(a, c), n.shape) : a;
    }, b: () => {
      let a = q(t, Le(n, "float32"));
      const c = Kn(s.shape, i);
      c.length > 0 && (a = Y(Qe(a, c), s.shape));
      const l = tn(s);
      return hn(it(a, Le(l, "float32")));
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const eq = {
  kernelName: np,
  inputsToSave: ["x", "mean", "variance", "scale"],
  gradFunc: (t, e, n) => {
    const { varianceEpsilon: s } = n, [i, r, o, a] = e, c = a ?? ot(1), l = Kn(r.shape, i.shape), u = [];
    if (r.rank === 1) {
      for (let b = 0; b < i.shape.length - 1; ++b)
        u.push(i.shape[b]);
      u.push(1);
    }
    const h = je(i, r), d = q(t, c), f = U0(Se(o, ot(s))), p = q(q(q(f, f), f), ot(-0.5));
    return {
      x: () => r.rank === 1 ? Y(q(q(t, pi(Y(f, [1, 1, 1, r.shape[0]]), u)), c), i.shape) : Y(q(q(t, f), c), i.shape),
      mean: () => {
        let b = q(q(f, ot(-1)), d);
        return r.rank === 1 && (b = Qe(b, l)), Y(b, r.shape);
      },
      variance: () => {
        let b = q(q(p, h), d);
        return r.rank === 1 && (b = Qe(b, l)), Y(b, r.shape);
      },
      scale: () => {
        const b = q(h, f);
        let w = q(t, b);
        return r.rank === 1 && (w = Qe(w, l)), Y(w, r.shape);
      },
      offset: () => {
        let b = t;
        return r.rank === 1 && (b = Qe(b, l)), Y(b, r.shape);
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const tq = {
  kernelName: sp,
  inputsToSave: ["x", "indices"],
  gradFunc: (t, e, n) => {
    const [s, i] = e, { axis: r, batchDims: o } = n, a = Rt(r, s.shape)[0], c = (l, u, h) => () => {
      const d = l.shape, f = u.size, p = d.slice(0, a), y = p.length, g = d.slice(r, d.length).slice(1), m = g.length, x = W2(0, y), v = W2(y + 1, y + 1 + m), b = H2([
        p,
        [f],
        g
      ]), w = Y(h, b), S = Y(u, [f]), _ = H2([[y], x, v]), E = zt(w, _);
      let I = J0(E, S, l.shape[a]);
      const k = Ba(_);
      return I = zt(I, k), I;
    };
    if (o === 1) {
      const l = s.shape[0], u = s.split(l, 0);
      return { x: () => ri(u.map((f, p) => c(f, i.slice(p, 1), t.slice(p, 1))())).reshape(s.shape), indices: () => i };
    } else
      return { x: c(s, i, t), indices: () => i };
  }
};
function W2(t, e) {
  const n = [];
  for (let s = t; s < e; ++s)
    n.push(s);
  return n;
}
function H2(t) {
  const e = [];
  for (let n = 0; n < t.length; ++n)
    for (let s = 0; s < t[n].length; ++s)
      e.push(t[n][s]);
  return e;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nq = {
  kernelName: th,
  inputsToSave: ["a", "b"],
  gradFunc: (t, e) => {
    const [n, s] = e;
    return { a: () => Ut(n), b: () => Ut(s) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sq = {
  kernelName: nh,
  gradFunc: (t) => ({ x: () => Le(t, "float32") })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const iq = {
  kernelName: sh,
  gradFunc: (t) => ({ x: () => Ut(t) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const rq = {
  kernelName: ih,
  gradFunc: (t) => ({ x: () => Ut(t) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const oq = {
  kernelName: rh,
  gradFunc: (t) => ({ x: () => Ut(t) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const aq = {
  kernelName: rp,
  inputsToSave: ["x"],
  gradFunc: (t, e, n) => {
    const [s] = e, { alpha: i } = n, r = js(s, 0);
    return { x: () => bs(r, t, q(t, i)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cq = {
  kernelName: ah,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => it(t, Se(n, 1)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const lq = {
  kernelName: oh,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => it(t, Le(n, "float32")) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uq = {
  kernelName: DN,
  inputsToSave: [],
  outputsToSave: [!0],
  gradFunc: (t, e, n) => {
    const [s] = e, { axis: i } = n;
    return {
      logits: () => {
        const o = ii(s);
        return je(t, q(Qe(t, i, !0), o));
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hq(t, e, n, s = 5, i = 1, r = 1, o = 0.5) {
  const a = { x: t, y: e, dy: n }, c = { depthRadius: s, bias: i, alpha: r, beta: o };
  return G.runKernel(Hx, a, c);
}
const dq = H({ localResponseNormalizationBackprop_: hq });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const fq = {
  kernelName: hp,
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (t, e, n) => {
    const [s, i] = e, { depthRadius: r, bias: o, alpha: a, beta: c } = n;
    return {
      x: () => dq(s, i, t, r, o, a, c)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aM(t, e, n, s) {
  return e.rank < n.rank && (e = Y(e, zn(e.shape, s))), t.rank < n.rank && (t = Y(t, zn(t.shape, s))), {
    x: () => q(t, Le(xi(n, e), t.dtype))
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const j2 = {
  kernelName: dp,
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (t, e, n) => {
    const s = n, { reductionIndices: i } = s, r = e[0], o = e[1], a = Rt(i, r.shape), c = aM(t, o, r, a);
    return {
      x: () => c.x()
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pq = {
  kernelName: ch,
  inputsToSave: ["a", "b"],
  gradFunc: (t, e) => {
    const [n, s] = e;
    return { a: () => q(t, Le(Wo(n, s), "float32")), b: () => q(t, Le(Su(n, s), "float32")) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mq(t, e, n, s, i, r, o) {
  const a = R(t, "dy", "maxPool3dGrad"), c = R(e, "input", "maxPool3dGrad"), l = R(n, "output", "maxPool3dGrad");
  let u = a, h = c, d = l, f = !1;
  c.rank === 4 && (f = !0, u = Y(a, [1, a.shape[0], a.shape[1], a.shape[2], a.shape[3]]), h = Y(c, [
    1,
    c.shape[0],
    c.shape[1],
    c.shape[2],
    c.shape[3]
  ]), d = Y(l, [
    1,
    l.shape[0],
    l.shape[1],
    l.shape[2],
    l.shape[3]
  ])), A(u.rank === 5, () => `Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`), A(h.rank === 5, () => `Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`), A(d.rank === 5, () => `Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`), Hs("maxPool3dGrad", r, o);
  const p = { dy: u, input: h, output: d }, y = { filterSize: s, strides: i, pad: r, dimRoundingMode: o }, g = G.runKernel(qx, p, y);
  return f ? Y(g, [g.shape[1], g.shape[2], g.shape[3], g.shape[4]]) : g;
}
const gq = /* @__PURE__ */ H({ maxPool3dGrad_: mq });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const yq = {
  kernelName: pp,
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (t, e, n) => {
    const [s, i] = e, { filterSize: r, strides: o, pad: a, dimRoundingMode: c } = n;
    return {
      x: () => gq(t, s, i, r, o, a, c)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xq(t, e, n, s, i, r, o) {
  const a = R(t, "dy", "maxPoolGrad"), c = R(e, "input", "maxPoolGrad"), l = R(n, "output", "maxPoolGrad");
  A(c.rank === a.rank, () => `Rank of input (${c.rank}) does not match rank of dy (${a.rank})`), A(a.rank === 4, () => `Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`), A(c.rank === 4, () => `Error in maxPoolGrad: input must be rank 4 but got rank ${c.rank}.`), Hs("maxPoolGrad", r, o);
  const u = { dy: a, input: c, output: l }, h = { filterSize: s, strides: i, pad: r, dimRoundingMode: o };
  return G.runKernel(jx, u, h);
}
const bq = /* @__PURE__ */ H({ maxPoolGrad_: xq });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const vq = {
  kernelName: fp,
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (t, e, n) => {
    const [s, i] = e, { filterSize: r, strides: o, pad: a } = n;
    return {
      x: () => bq(t, s, i, r, o, a)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const wq = {
  kernelName: mp,
  inputsToSave: ["x"],
  gradFunc: (t, e, n) => {
    const [s] = e, { axis: i } = n, r = Rt(i, s.shape), a = ds(s.shape, r)[1], c = ue(a);
    return { x: () => {
      const u = s.shape.slice();
      r.forEach((f) => {
        u[f] = 1;
      });
      const h = Y(t, u);
      return it(q(h, Qs(s.shape, "float32")), c);
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Sq = {
  kernelName: gp,
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (t, e, n) => {
    const s = n, { axis: i } = s, [r, o] = e, a = Rt(i, r.shape), c = aM(t, o, r, a);
    return {
      x: () => c.x()
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _q = {
  kernelName: lh,
  inputsToSave: ["a", "b"],
  gradFunc: (t, e) => {
    const [n, s] = e;
    return { a: () => q(t, Le(za(n, s), "float32")), b: () => q(t, Le(js(n, s), "float32")) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Tq = {
  kernelName: yp,
  inputsToSave: ["x"],
  gradFunc: (t, e, n) => {
    const s = e[0], { paddings: i } = n, r = i.map((o) => o[0]);
    return { x: () => Pt(t, r, s.shape) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Cq = {
  kernelName: uh,
  inputsToSave: ["a", "b"],
  gradFunc: (t, e) => {
    const [n, s] = e, i = bt(n.shape, s.shape);
    return { a: () => {
      const a = Kn(n.shape, i);
      return a.length > 0 ? Y(Qe(t, a), n.shape) : t;
    }, b: () => {
      const a = q(t, hn(Oh(it(n, s)))), c = Kn(s.shape, i);
      return c.length > 0 ? Y(Qe(a, c), s.shape) : a;
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Iq = {
  kernelName: hh,
  inputsToSave: ["a", "b"],
  gradFunc: (t, e) => {
    const [n, s] = e, i = bt(n.shape, s.shape);
    return { a: () => {
      const a = q(t, Le(s, "float32")), c = Kn(n.shape, i);
      return c.length > 0 ? Y(Qe(a, c), n.shape) : a;
    }, b: () => {
      const a = q(t, Le(n, "float32")), c = Kn(s.shape, i);
      return c.length > 0 ? Y(Qe(a, c), s.shape) : a;
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Eq = {
  kernelName: xp,
  gradFunc: (t) => ({ x: () => hn(t) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Nq = {
  kernelName: wp,
  inputsToSave: ["indices"],
  gradFunc: (t, e) => {
    const n = e[0];
    return { indices: () => qn(n.shape, "float32") };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kq = {
  kernelName: vp,
  gradFunc: (t) => ({ x: () => Ut(t) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Aq = {
  kernelName: Sp,
  saveAllInputs: !0,
  gradFunc: (t, e, n) => {
    const { axis: s } = n;
    return Pi(t, s).map((r) => () => r);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const q2 = {
  kernelName: _p,
  inputsToSave: ["x"],
  gradFunc: (t, e, n) => {
    const s = e[0], { paddings: i } = n, r = i.map((o) => o[0]);
    return { x: () => Pt(t, r, s.shape) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Mq = {
  kernelName: dh,
  inputsToSave: ["a", "b"],
  outputsToSave: [!0],
  gradFunc: (t, e) => {
    const [n, s, i] = e, r = n, o = s, a = bt(r.shape, o.shape);
    return { a: () => {
      const u = Le(o, "float32");
      let h = q(t, q(u, io(r, je(u, ot(1)))));
      const d = Kn(r.shape, a);
      return d.length > 0 && (h = Qe(h, d)), Y(h, r.shape);
    }, b: () => {
      const u = js(r, 0), h = bs(u, bi(r), Ut(r));
      let d = q(t, q(i, h));
      const f = Kn(o.shape, a);
      return f.length > 0 && (d = Qe(d, f)), Y(d, o.shape);
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Rq = {
  kernelName: Tp,
  inputsToSave: ["x", "alpha"],
  gradFunc: (t, e) => {
    const [n, s] = e, i = js(n, 0);
    return {
      x: () => bs(i, t, q(t, s)),
      alpha: () => {
        let r = bs(i, Ut(t), q(t, n));
        const o = Kn(s.shape, t.shape);
        return o.length > 0 && (r = Qe(r, o)), Y(r, s.shape);
      }
    };
  }
};
/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dq(t, e, n) {
  const s = t.shape.slice();
  s[n] = 1;
  const i = Y(e, s), r = wf(t, n, !0, !1), o = wf(t, n, !0, !0), a = q(r, o);
  return q(i, a);
}
function $q(t, e, n) {
  const s = t.shape.length, i = s - n.length, r = An(n, s);
  let o = t;
  r != null && (o = zt(t, r));
  const a = o.shape.slice(), l = a.splice(s - n.length, n.length).reduce((d, f) => d * f, 1);
  a.push(l);
  const u = o.reshape(a);
  let h = Dq(u, e, i);
  if (h = h.reshape(o.shape), r != null) {
    const d = Ba(r);
    h = zt(h, d);
  }
  return h;
}
const Oq = {
  kernelName: Cp,
  inputsToSave: ["x"],
  gradFunc: (t, e, n) => {
    const [s] = e, { axis: i } = n;
    let r = [];
    return i == null ? r = s.shape.map((o, a) => a) : typeof i == "number" ? r = [i] : r = i, { x: () => $q(s, t, r) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Lq = {
  kernelName: Xu,
  inputsToSave: ["a", "b"],
  gradFunc: (t, e) => {
    const [n, s] = e, i = bt(n.shape, s.shape);
    return { a: () => {
      const a = it(t, Le(s, "float32")), c = Kn(n.shape, i);
      return c.length > 0 ? Y(Qe(a, c), n.shape) : a;
    }, b: () => {
      let a = q(t, Le(n, "float32"));
      const c = Kn(s.shape, i);
      c.length > 0 && (a = Y(Qe(a, c), s.shape));
      const l = tn(s);
      return hn(it(a, Le(l, "float32")));
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Fq = {
  kernelName: fh,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => it(t, hn(tn(n))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Pq = {
  kernelName: mh,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e, s = q(za(n, 6), rl(n));
    return { x: () => q(t, Le(s, "float32")) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Bq = {
  kernelName: ph,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => q(t, Le(rl(n), "float32")) };
  }
};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const zq = {
  kernelName: Ip,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => Y(t, n.shape) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Vq = {
  kernelName: Np,
  inputsToSave: ["images"],
  gradFunc: (t, e, n) => {
    const [s] = e, i = { dy: t, images: s };
    return { images: () => (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      G.runKernel(r0, i, n)
    ) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Uq = {
  kernelName: Ep,
  inputsToSave: ["images"],
  gradFunc: (t, e, n) => {
    const [s] = e, i = { dy: t, images: s };
    return { images: () => (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      G.runKernel(i0, i, n)
    ) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Gq = {
  kernelName: kp,
  gradFunc: (t, e, n) => {
    const { dims: s } = n, i = Rt(s, t.shape);
    return { x: () => Fi(t, i) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Wq = {
  kernelName: gh,
  gradFunc: (t) => ({ x: () => Ut(t) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Hq = {
  kernelName: yh,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => hn(it(t, q(io(n, 1.5), 2))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jq = {
  kernelName: Ap,
  inputsToSave: ["condition"],
  gradFunc: (t, e) => {
    const [n] = e;
    return {
      // TODO(julianoks): Return null for condition gradient
      // when backprop supports it.
      condition: () => Le(Ut(n), "float32"),
      t: () => q(t, Le(n, t.dtype)),
      e: () => q(t, Le(Zp(n), t.dtype))
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qq = {
  kernelName: xh,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return {
      x: () => {
        const s = js(n, ot(0)), i = ot(db), r = ot(fb), o = q(t, r), a = q(q(t, i), ii(Le(n, "float32")));
        return bs(s, o, a);
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Xq = {
  kernelName: Sh,
  outputsToSave: [!0],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => q(t, q(n, je(ot(1), n))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Kq = {
  kernelName: wh,
  gradFunc: (t) => ({ x: () => Ut(t) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Yq = {
  kernelName: bh,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => q(jp(Le(n, "float32")), t) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Zq = {
  kernelName: vh,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => q(A0(Le(n, "float32")), t) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Jq = {
  kernelName: Mp,
  inputsToSave: ["x"],
  gradFunc: (t, e, n) => {
    const [s] = e, { begin: i, size: r } = n, o = s.shape, [a, c] = ub(s, i, r), l = [];
    for (let u = 0; u < t.rank; u++)
      l.push([a[u], o[u] - a[u] - c[u]]);
    return { x: () => uo(t, l) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Qq = {
  kernelName: Op,
  outputsToSave: [!0],
  gradFunc: (t, e, n) => {
    const [s] = e, { dim: i } = n, r = !0, o = q(t, s);
    return {
      logits: () => je(o, q(Qe(o, [i], r), s))
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const eX = {
  kernelName: _h,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => q(t, mi(n)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const X2 = {
  kernelName: Dp,
  gradFunc: (t, e, n) => {
    const { blockShape: s, paddings: i } = n;
    return { x: () => Hp(t, s, i) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const K2 = {
  kernelName: $p,
  gradFunc: (t, e, n) => {
    const { axis: s } = n;
    return { x: () => Pn(t, s) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const tX = {
  kernelName: Th,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => it(t, q(us(Le(n, "float32")), 2)) };
  }
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nX = {
  kernelName: p0,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => q(t, q(Le(n, "float32"), 2)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sX = {
  kernelName: Ch,
  inputsToSave: ["a", "b"],
  gradFunc: (t, e) => {
    const [n, s] = e, i = ot(2);
    return { a: () => q(t, q(i, je(n, s))), b: () => q(t, q(i, je(s, n))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const iX = {
  kernelName: Ah,
  gradFunc: (t) => ({ x: () => Ut(t) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const rX = {
  kernelName: Ih,
  inputsToSave: ["a", "b"],
  gradFunc: (t, e) => {
    const [n, s] = e, i = bt(n.shape, s.shape);
    return { a: () => {
      let a = t;
      const c = Kn(n.shape, i);
      return c.length > 0 && (a = Qe(a, c)), Y(a, n.shape);
    }, b: () => {
      let a = t;
      const c = Kn(s.shape, i);
      return c.length > 0 && (a = Qe(a, c)), Y(hn(a), s.shape);
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const oX = {
  kernelName: Rp,
  inputsToSave: ["x"],
  gradFunc: (t, e, n) => {
    const [s] = e, i = s.shape.slice(), { axis: r } = n;
    Rt(r, s.shape).forEach((l) => {
      i[l] = 1;
    });
    const a = Y(t, i), c = q(a, Qs(s.shape, "float32"));
    return { x: () => c };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const aX = {
  kernelName: Eh,
  inputsToSave: ["x"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => it(t, tn(jp(n))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cX = {
  kernelName: Nh,
  outputsToSave: [!0],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => q(je(ot(1), tn(n)), t) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const lX = {
  kernelName: kh,
  inputsToSave: ["x"],
  gradFunc: (t, e, n) => {
    const [s] = e, { reps: i } = n;
    return { x: () => {
      let o = Ut(s);
      if (s.rank === 1)
        for (let a = 0; a < i[0]; ++a)
          o = Se(o, Pt(t, [a * s.shape[0]], [s.shape[0]]));
      else if (s.rank === 2)
        for (let a = 0; a < i[0]; ++a)
          for (let c = 0; c < i[1]; ++c)
            o = Se(o, Pt(t, [a * s.shape[0], c * s.shape[1]], [
              s.shape[0],
              s.shape[1]
            ]));
      else if (s.rank === 3)
        for (let a = 0; a < i[0]; ++a)
          for (let c = 0; c < i[1]; ++c)
            for (let l = 0; l < i[2]; ++l)
              o = Se(o, Pt(t, [a * s.shape[0], c * s.shape[1], l * s.shape[2]], [s.shape[0], s.shape[1], s.shape[2]]));
      else if (s.rank === 4)
        for (let a = 0; a < i[0]; ++a)
          for (let c = 0; c < i[1]; ++c)
            for (let l = 0; l < i[2]; ++l)
              for (let u = 0; u < i[3]; ++u)
                o = Se(o, Pt(t, [
                  a * s.shape[0],
                  c * s.shape[1],
                  l * s.shape[2],
                  u * s.shape[3]
                ], [s.shape[0], s.shape[1], s.shape[2], s.shape[3]]));
      else
        throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);
      return o;
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uX = {
  kernelName: wc,
  gradFunc: (t, e, n) => {
    const s = n, { perm: i } = s, r = Ba(i);
    return { x: () => zt(t, r) };
  }
};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const hX = {
  kernelName: Fp,
  gradFunc: (t, e, n) => {
    const s = n, { axis: i } = s;
    return { value: () => ri(t, i) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dX = {
  kernelName: Pp,
  inputsToSave: ["segmentIds"],
  gradFunc: (t, e) => {
    const [n] = e;
    return { x: () => fX(t, n) };
  }
};
function fX(t, e) {
  const n = lo(e, Ut(e)), s = Lh(t, n);
  let i = Wo(e, ot(0, "int32"));
  const r = s.rank - i.rank;
  for (let a = 0; a < r; ++a)
    i = vn(i, a + 1);
  i = _r(i, Qs(s.shape, "bool"));
  const o = Ut(s);
  return bs(i, s, o);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pX = {
  kernelName: Bp,
  gradFunc: (t) => ({ x: () => Ut(t) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const mX = [
  oM,
  d8,
  f8,
  p8,
  m8,
  g8,
  y8,
  x8,
  b8,
  v8,
  w8,
  S8,
  C8,
  N8,
  k8,
  A8,
  M8,
  R8,
  D8,
  $8,
  O8,
  L8,
  P8,
  F8,
  V8,
  U8,
  G8,
  W8,
  H8,
  j8,
  Lq,
  q8,
  X8,
  K8,
  Y8,
  Z8,
  Q8,
  J8,
  eq,
  tq,
  nq,
  sq,
  iq,
  rq,
  oq,
  aq,
  cq,
  lq,
  uq,
  fq,
  j2,
  j2,
  pq,
  yq,
  vq,
  wq,
  Sq,
  _q,
  Tq,
  Cq,
  Iq,
  Eq,
  Nq,
  kq,
  Aq,
  q2,
  q2,
  Mq,
  Rq,
  Oq,
  Fq,
  Pq,
  Bq,
  zq,
  Vq,
  Uq,
  Gq,
  Wq,
  Hq,
  jq,
  qq,
  Xq,
  Kq,
  Yq,
  Zq,
  Jq,
  Qq,
  eX,
  X2,
  X2,
  K2,
  K2,
  tX,
  sX,
  nX,
  iX,
  rX,
  oX,
  aX,
  cX,
  lX,
  uX,
  hX,
  dX,
  pX
];
for (const t of mX)
  $N(t);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.abs = function() {
  return this.throwIfDisposed(), jn(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.acos = function() {
  return this.throwIfDisposed(), aS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.acosh = function() {
  return this.throwIfDisposed(), cS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.add = function(t) {
  return this.throwIfDisposed(), Se(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.all = function(t, e) {
  return this.throwIfDisposed(), E0(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.any = function(t, e) {
  return this.throwIfDisposed(), xf(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.argMax = function(t) {
  return this.throwIfDisposed(), Ea(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.argMin = function(t) {
  return this.throwIfDisposed(), lS(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.asScalar = function() {
  return this.throwIfDisposed(), A(this.size === 1, () => "The array must have only 1 element."), Y(this, []);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.asType = function(t) {
  return this.throwIfDisposed(), Le(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.as1D = function() {
  return this.throwIfDisposed(), Y(this, [this.size]);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.as2D = function(t, e) {
  return this.throwIfDisposed(), Y(this, [t, e]);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.as3D = function(t, e, n) {
  return this.throwIfDisposed(), Y(this, [t, e, n]);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.as4D = function(t, e, n, s) {
  return this.throwIfDisposed(), Y(this, [t, e, n, s]);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.as5D = function(t, e, n, s, i) {
  return this.throwIfDisposed(), Y(this, [t, e, n, s, i]);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.asin = function() {
  return this.throwIfDisposed(), uS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.asinh = function() {
  return this.throwIfDisposed(), hS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.atan = function() {
  return this.throwIfDisposed(), dS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.atan2 = function(t) {
  return this.throwIfDisposed(), fS(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.atanh = function() {
  return this.throwIfDisposed(), pS(this);
};
de().prototype.avgPool = function(t, e, n, s) {
  return this.throwIfDisposed(), Wp(this, t, e, n, s);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.batchToSpaceND = function(t, e) {
  return this.throwIfDisposed(), Hp(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.batchNorm = function(t, e, n, s, i) {
  return this.throwIfDisposed(), Mh(this, t, e, n, s, i);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.broadcastTo = function(t) {
  return this.throwIfDisposed(), Sc(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.cast = function(t) {
  return this.throwIfDisposed(), Le(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.ceil = function() {
  return this.throwIfDisposed(), wS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.clipByValue = function(t, e) {
  return this.throwIfDisposed(), Gs(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.concat = function(t, e) {
  return this.throwIfDisposed(), t instanceof Lt && (t = [t]), Pn([this, ...t], e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.conv1d = function(t, e, n, s, i, r) {
  return this.throwIfDisposed(), N0(this, t, e, n, s, i, r);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.conv2dTranspose = function(t, e, n, s, i) {
  return this.throwIfDisposed(), k0(this, t, e, n, s, i);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.conv2d = function(t, e, n, s, i, r) {
  return this.throwIfDisposed(), $o(this, t, e, n, s, i, r);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.cos = function() {
  return this.throwIfDisposed(), jp(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.cosh = function() {
  return this.throwIfDisposed(), A0(this);
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.cumprod = function(t, e, n) {
  return this.throwIfDisposed(), wf(this, t, e, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.cumsum = function(t, e, n) {
  return this.throwIfDisposed(), M0(this, t, e, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.depthToSpace = function(t, e) {
  return this.throwIfDisposed(), kS(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.depthwiseConv2d = function(t, e, n, s, i, r) {
  return this.throwIfDisposed(), Rh(this, t, e, n, s, i, r);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.dilation2d = function(t, e, n, s, i) {
  return this.throwIfDisposed(), AS(this, t, e, n, s, i);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.divNoNan = function(t) {
  return this.throwIfDisposed(), MS(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.div = function(t) {
  return this.throwIfDisposed(), it(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.dot = function(t) {
  return this.throwIfDisposed(), RS(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.elu = function() {
  return this.throwIfDisposed(), Dh(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.equal = function(t) {
  return this.throwIfDisposed(), xi(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.erf = function() {
  return this.throwIfDisposed(), R0(this);
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.euclideanNorm = function(t, e) {
  return this.throwIfDisposed(), $S(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.exp = function() {
  return this.throwIfDisposed(), ii(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.expandDims = function(t) {
  return this.throwIfDisposed(), vn(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.expm1 = function() {
  return this.throwIfDisposed(), OS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.fft = function() {
  return this.throwIfDisposed(), om(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.flatten = function() {
  return this.throwIfDisposed(), Y(this, [this.size]);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.floor = function() {
  return this.throwIfDisposed(), Oh(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.floorDiv = function(t) {
  return this.throwIfDisposed(), I0(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.gather = function(t, e, n) {
  return this.throwIfDisposed(), Lh(this, t, e, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.greaterEqual = function(t) {
  return this.throwIfDisposed(), Wo(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.greater = function(t) {
  return this.throwIfDisposed(), js(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.ifft = function() {
  return this.throwIfDisposed(), Cu(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.irfft = function() {
  return this.throwIfDisposed(), X0(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.isFinite = function() {
  return this.throwIfDisposed(), LS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.isInf = function() {
  return this.throwIfDisposed(), FS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.isNaN = function() {
  return this.throwIfDisposed(), PS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.leakyRelu = function(t) {
  return this.throwIfDisposed(), Xp(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.lessEqual = function(t) {
  return this.throwIfDisposed(), za(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.less = function(t) {
  return this.throwIfDisposed(), Su(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.localResponseNormalization = function(t, e, n, s) {
  return this.throwIfDisposed(), BS(this, t, e, n, s);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.logSigmoid = function() {
  return this.throwIfDisposed(), zS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.logSoftmax = function(t) {
  return this.throwIfDisposed(), O0(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.logSumExp = function(t, e) {
  return this.throwIfDisposed(), Yp(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.log = function() {
  return this.throwIfDisposed(), bi(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.log1p = function() {
  return this.throwIfDisposed(), Kp(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.logicalAnd = function(t) {
  return this.throwIfDisposed(), _r(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.logicalNot = function() {
  return this.throwIfDisposed(), Zp(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.logicalOr = function(t) {
  return this.throwIfDisposed(), L0(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.logicalXor = function(t) {
  return this.throwIfDisposed(), VS(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.matMul = function(t, e, n) {
  return this.throwIfDisposed(), Tt(this, t, e, n);
};
de().prototype.maxPool = function(t, e, n, s) {
  return this.throwIfDisposed(), Jp(this, t, e, n, s);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.max = function(t, e) {
  return this.throwIfDisposed(), Ri(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.maximum = function(t) {
  return this.throwIfDisposed(), lo(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.mean = function(t, e) {
  return this.throwIfDisposed(), En(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.min = function(t, e) {
  return this.throwIfDisposed(), wu(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.minimum = function(t) {
  return this.throwIfDisposed(), Aa(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.mirrorPad = function(t, e) {
  return this.throwIfDisposed(), P0(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.mod = function(t) {
  return this.throwIfDisposed(), GS(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.mul = function(t) {
  return this.throwIfDisposed(), q(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.neg = function() {
  return this.throwIfDisposed(), hn(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.norm = function(t, e, n) {
  return this.throwIfDisposed(), $h(this, t, e, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.notEqual = function(t) {
  return this.throwIfDisposed(), Uc(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.oneHot = function(t, e = 1, n = 0) {
  return this.throwIfDisposed(), Gc(this, t, e, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.onesLike = function() {
  return this.throwIfDisposed(), vi(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.pad = function(t, e) {
  return this.throwIfDisposed(), uo(this, t, e);
};
de().prototype.pool = function(t, e, n, s, i, r) {
  return this.throwIfDisposed(), HS(this, t, e, n, s, i, r);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.pow = function(t) {
  return this.throwIfDisposed(), io(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.prelu = function(t) {
  return this.throwIfDisposed(), tm(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.prod = function(t, e) {
  return this.throwIfDisposed(), jS(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.reciprocal = function() {
  return this.throwIfDisposed(), n_(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.relu = function() {
  return this.throwIfDisposed(), kr(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.relu6 = function() {
  return this.throwIfDisposed(), V0(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.reshapeAs = function(t) {
  return this.throwIfDisposed(), Y(this, t.shape);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.reshape = function(t) {
  return this.throwIfDisposed(), Y(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.resizeBilinear = function(t, e, n) {
  return this.throwIfDisposed(), uA(this, t, e, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.resizeNearestNeighbor = function(t, e, n) {
  return this.throwIfDisposed(), hA(this, t, e, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.reverse = function(t) {
  return this.throwIfDisposed(), Fi(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.rfft = function() {
  return this.throwIfDisposed(), am(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.round = function() {
  return this.throwIfDisposed(), nm(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.rsqrt = function() {
  return this.throwIfDisposed(), U0(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.selu = function() {
  return this.throwIfDisposed(), G0(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.separableConv2d = function(t, e, n, s, i, r) {
  return this.throwIfDisposed(), W0(this, t, e, n, s, i, r);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.sigmoid = function() {
  return this.throwIfDisposed(), mi(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.sign = function() {
  return this.throwIfDisposed(), s_(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.sin = function() {
  return this.throwIfDisposed(), H0(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.sinh = function() {
  return this.throwIfDisposed(), j0(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.slice = function(t, e) {
  return this.throwIfDisposed(), Pt(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.softmax = function(t) {
  return this.throwIfDisposed(), rm(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.softplus = function() {
  return this.throwIfDisposed(), sl(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.spaceToBatchND = function(t, e) {
  return this.throwIfDisposed(), em(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.split = function(t, e) {
  return this.throwIfDisposed(), ti(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.sqrt = function() {
  return this.throwIfDisposed(), us(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.square = function() {
  return this.throwIfDisposed(), tn(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.squaredDifference = function(t) {
  return this.throwIfDisposed(), K0(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.squeeze = function(t) {
  return this.throwIfDisposed(), ys(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.stack = function(t, e) {
  this.throwIfDisposed();
  const n = t instanceof Lt ? [this, t] : [this, ...t];
  return ri(n, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.step = function(t) {
  return this.throwIfDisposed(), rl(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.stridedSlice = function(t, e, n, s, i, r, o, a) {
  return this.throwIfDisposed(), i_(this, t, e, n, s, i, r, o, a);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.sub = function(t) {
  return this.throwIfDisposed(), je(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.sum = function(t, e) {
  return this.throwIfDisposed(), Qe(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.tan = function() {
  return this.throwIfDisposed(), r_(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.tanh = function() {
  return this.throwIfDisposed(), ka(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.tile = function(t) {
  return this.throwIfDisposed(), pi(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.toBool = function() {
  return this.throwIfDisposed(), Le(this, "bool");
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.toFloat = function() {
  return this.throwIfDisposed(), Le(this, "float32");
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.toInt = function() {
  return this.throwIfDisposed(), Le(this, "int32");
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.topk = function(t, e) {
  return this.throwIfDisposed(), c_(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.transpose = function(t) {
  return this.throwIfDisposed(), zt(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.unique = function(t) {
  return this.throwIfDisposed(), l_(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.unsortedSegmentSum = function(t, e) {
  return this.throwIfDisposed(), J0(this, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.unstack = function(t) {
  return this.throwIfDisposed(), Pi(this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.where = function(t, e) {
  return this.throwIfDisposed(), bs(t, this, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
de().prototype.zerosLike = function() {
  return this.throwIfDisposed(), Ut(this);
};
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Br extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, Br.prototype);
  }
}
class Ki extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, Ki.prototype);
  }
}
class Z extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, Z.prototype);
  }
}
class Ct extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, Ct.prototype);
  }
}
class Z_ extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, Z_.prototype);
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class cM {
  constructor(e) {
    this.maxEntries = e || 100, this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * Get the entry for the key and mark it as used recently.
   */
  get(e) {
    let n;
    return this.cache.has(e) && (n = this.cache.get(e), this.cache.delete(e), this.cache.set(e, n)), n;
  }
  /**
   * Put the entry into the cache. If the key already existed, mark the key as
   * used recently.
   */
  put(e, n) {
    if (this.cache.has(e))
      this.cache.delete(e);
    else if (this.cache.size >= this.maxEntries) {
      const s = this.cache.keys().next().value;
      this.cache.delete(s);
    }
    this.cache.set(e, n);
  }
  /**
   * Get the MaxEntries of the cache.
   */
  getMaxEntries() {
    return this.maxEntries;
  }
  /**
   * Set the MaxEntries of the cache. If the maxEntries is decreased, reduce
   * entries in the cache.
   */
  setMaxEntries(e) {
    if (e < 0)
      throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);
    if (this.maxEntries > e)
      for (let n = 0; n < this.maxEntries - e; n++) {
        const s = this.cache.keys().next().value;
        this.cache.delete(s);
      }
    this.maxEntries = e;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Hc(t, e) {
  if (Array.isArray(t)) {
    let n = [];
    for (let s = 0; s < e; s++)
      n = n.concat(t);
    return n;
  } else {
    const n = new Array(e);
    return n.fill(t), n;
  }
}
function zr(t, e) {
  if (!t)
    throw new Z_(e);
}
function Y2(t, e) {
  let n = 0;
  for (const s of t)
    s === e && n++;
  return n;
}
function Zs(t) {
  return t.length === 1 ? t[0] : t;
}
function Zt(t) {
  return Array.isArray(t) ? t : [t];
}
function wo(t) {
  const n = t.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  return n[0] !== "_" ? n : "private" + n;
}
function dc(t) {
  return t.length <= 1 || t.indexOf("_") === -1 ? t : t.replace(/[_]+(\w|$)/g, (e, n) => n.toUpperCase());
}
let Vi = {};
function J_(t) {
  if (t == null)
    return null;
  const e = {};
  return e.className = t.getClassName(), e.config = t.getConfig(), e;
}
function t1(t) {
  if (!(t == null || typeof t != "object"))
    if (Array.isArray(t))
      t.forEach((e) => t1(e));
    else {
      const e = Object.keys(t);
      for (const n of e) {
        const s = t[n];
        s != null && typeof s == "object" && (!Array.isArray(s) && s.type === "ndarray" && typeof s.value == "number" ? t[n] = s.value : t1(s));
      }
    }
}
function fm(t, e = {}, n = {}, s = "object", i = !1) {
  if (typeof t == "string") {
    const r = t;
    let o;
    if (r in n)
      o = n[r];
    else if (r in Vi)
      o = Vi[r];
    else if (o = e[r], o == null)
      throw new Z(`Unknown ${s}: ${t}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
    return o;
  } else {
    const r = t;
    if (r.className == null || r.config == null)
      throw new Z(`${s}: Improper config format: ${JSON.stringify(r)}.
'className' and 'config' must set.`);
    const o = r.className;
    let a, c;
    if (o in n ? [a, c] = n[o] : o in Vi ? [a, c] = Vi.className : o in e && ([a, c] = e[o]), a == null)
      throw new Z(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
    if (c != null) {
      const l = {};
      for (const f of Object.keys(Vi))
        l[f] = Vi[f];
      for (const f of Object.keys(n))
        l[f] = n[f];
      const u = r.config;
      u.customObjects = l;
      const h = Object.assign({}, Vi);
      for (const f of Object.keys(n))
        Vi[f] = n[f];
      t1(r.config);
      const d = c(a, r.config, n, i);
      return Vi = Object.assign({}, h), d;
    } else {
      const l = Object.assign({}, Vi);
      for (const h of Object.keys(n))
        Vi[h] = n[h];
      const u = new a(r.config);
      return Vi = Object.assign({}, l), u;
    }
  }
}
function gX(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function gg(t, e) {
  return -1 * gX(t, e);
}
function ga(t) {
  if (t == null)
    return t;
  const e = [];
  for (const n of t)
    e.indexOf(n) === -1 && e.push(n);
  return e;
}
function yX(t) {
  if (t == null)
    throw new Z(`Invalid value in obj: ${JSON.stringify(t)}`);
  for (const e in t)
    if (t.hasOwnProperty(e))
      return !1;
  return !0;
}
function al(t, e, n) {
  if (n != null && t.indexOf(n) < 0)
    throw new Z(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`);
}
function Q_(t, e, n = 0, s = 1 / 0) {
  return zr(n >= 0), zr(s >= n), Array.isArray(t) && t.length >= n && t.length <= s && t.every((i) => typeof i === e);
}
function cs(t, e) {
  Array.isArray(t) ? (A(t.length > 0, () => `${e} is unexpectedly an empty array.`), t.forEach((n, s) => cs(n, `element ${s + 1} of ${e}`))) : A(Number.isInteger(t) && t > 0, () => `Expected ${e} to be a positive integer, but got ${lM(t)}.`);
}
function lM(t) {
  return t === null ? "null" : Array.isArray(t) ? "[" + t.map((e) => lM(e)).join(",") + "]" : typeof t == "string" ? `"${t}"` : `${t}`;
}
function xX(t, e, n) {
  let s = n != null ? n() : Ls(), i;
  return (...o) => {
    const a = n != null ? n() : Ls();
    return a - s < e || (s = a, i = t(...o)), i;
  };
}
function uM(t) {
  return t === "relu" ? "relu" : t === "linear" ? "linear" : t === "elu" ? "elu" : null;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let bX = 0;
function hM() {
  return bX++;
}
const yg = {};
function pb(t = "") {
  return t in yg || (yg[t] = 0), yg[t] += 1, t + yg[t].toString();
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const vX = ["channelsFirst", "channelsLast"], wX = ["nearest", "bilinear"], SX = ["valid", "same", "causal"], _X = ["max", "avg"], TX = ["sum", "mul", "concat", "ave"];
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const Dl = /* @__PURE__ */ new Map();
function Un(t) {
  al(vX, "DataFormat", t);
}
function CX(t) {
  al(wX, "InterpolationFormat", t);
}
function Bi(t) {
  al(SX, "PaddingMode", t);
}
function dM(t) {
  al(_X, "PoolMode", t);
}
const Id = [], Z2 = "/";
function Tc(t, e) {
  Id.push(t);
  try {
    const n = e();
    return Id.pop(), n;
  } catch (n) {
    throw Id.pop(), n;
  }
}
function IX() {
  return Id.length === 0 ? "" : Id.join(Z2) + Z2;
}
function fM(t) {
  if (!mM(t))
    throw new Error("Not a valid tensor name: '" + t + "'");
  return IX() + t;
}
function pM(t) {
  if (!mM(t))
    throw new Error("Not a valid tensor name: '" + t + "'");
  Dl.has(t) || Dl.set(t, 0);
  const e = Dl.get(t);
  if (Dl.set(t, Dl.get(t) + 1), e > 0) {
    const n = `${t}_${e}`;
    return Dl.set(n, 1), n;
  } else
    return t;
}
const EX = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
function mM(t) {
  return !!t.match(EX);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function NX(t) {
  return t === parseInt(t.toString(), 10);
}
function ya(t, e, n) {
  e == null && (e = 0), n == null && (n = t.length);
  let s = 1;
  for (let i = e; i < n; ++i)
    s *= t[i];
  return s;
}
function Iu(t) {
  if (t.length === 0)
    return Number.NaN;
  let e = Number.POSITIVE_INFINITY;
  for (let n = 0; n < t.length; n++) {
    const s = t[n];
    s < e && (e = s);
  }
  return e;
}
function Ma(t) {
  if (t.length === 0)
    return Number.NaN;
  let e = Number.NEGATIVE_INFINITY;
  for (let n = 0; n < t.length; n++) {
    const s = t[n];
    s > e && (e = s);
  }
  return e;
}
function Tr(t, e) {
  if (e < t)
    throw new Z(`end (${e}) < begin (${t}) is forbidden.`);
  const n = [];
  for (let s = t; s < e; ++s)
    n.push(s);
  return n;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let wv;
function Jn() {
  return wv == null && (wv = Vp().epsilon()), wv;
}
function Cr() {
  return "channelsLast";
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Kr(t, e) {
  return Le(t, e);
}
function pm(t, e = -1) {
  const n = t.shape.slice();
  return e < 0 && (e = n.length + e + 1), n.splice(e, 0, 1), Y(t, n);
}
function kX(t, e) {
  return Q(() => {
    if (t.shape.length !== 2)
      throw new Z(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);
    const n = pm(t, 1);
    return n1(n, [1, e, 1]);
  });
}
function AX(t) {
  const e = [ya(t.shape)];
  return Y(t, e);
}
function MX(t) {
  if (t.rank <= 1)
    throw new Z(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);
  const e = [t.shape[0], ya(t.shape, 1)];
  return Y(t, e);
}
function Cc(t, e, n) {
  return Q(() => {
    switch (t.rank) {
      case 1:
        return sm(t, e, n);
      case 2:
        return q0(t, [e, 0], [n, t.shape[1]]);
      case 3:
        return im(t, [e, 0, 0], [n, t.shape[1], t.shape[2]]);
      case 4:
        return Tu(t, [e, 0, 0, 0], [n, t.shape[1], t.shape[2], t.shape[3]]);
      case 5:
        return Pt(t, [e, 0, 0, 0, 0], [
          n,
          t.shape[1],
          t.shape[2],
          t.shape[3],
          t.shape[4]
        ]);
      case 6:
        return Pt(t, [e, 0, 0, 0, 0, 0], [
          n,
          t.shape[1],
          t.shape[2],
          t.shape[3],
          t.shape[4],
          t.shape[5]
        ]);
      default:
        throw new Z(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`);
    }
  });
}
function Sv(t, e, n) {
  return Q(() => {
    switch (t.rank) {
      case 1:
        return sm(t, e, n);
      case 2:
        return q0(t, [0, e], [t.shape[0], n]);
      case 3:
        return im(t, [0, 0, e], [t.shape[0], t.shape[1], n]);
      case 4:
        return Tu(t, [0, 0, 0, e], [t.shape[0], t.shape[1], t.shape[2], n]);
      default:
        throw new Z(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`);
    }
  });
}
function xg(t, e, n, s) {
  return Q(() => {
    switch (t.rank) {
      case 1:
        return sm(t, e, n);
      case 2:
        switch (s) {
          case 1:
            return Cc(t, e, n);
          case 2:
            return Sv(t, e, n);
          default:
            throw new Z(`The axis is not within the rank of the tensor ${s}`);
        }
      case 3:
        switch (s) {
          case 1:
            return Cc(t, e, n);
          case 2:
            return im(t, [0, e, 0], [t.shape[0], n, t.shape[2]]);
          case 3:
            return Sv(t, e, n);
          default:
            throw new Z(`The axis is not within the rank of the tensor ${s}`);
        }
      case 4:
        switch (s) {
          case 1:
            return Cc(t, e, n);
          case 2:
            return Tu(t, [0, e, 0, 0], [t.shape[0], n, t.shape[2], t.shape[3]]);
          case 3:
            return Tu(t, [0, 0, e, 0], [t.shape[0], t.shape[1], n, t.shape[3]]);
          case 4:
            return Sv(t, e, n);
          default:
            throw new Z(`The axis is not within the rank of the tensor ${s}`);
        }
      default:
        throw new Z(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`);
    }
  });
}
function eT(t, e = -1) {
  let n;
  return e < 0 && (n = t[0].rank, n !== 0 ? e = n : e = 0), e === t[0].rank && (e = -1), Pn(t, e);
}
function J2(t, e) {
  switch (t.rank) {
    case 1:
      return SS([t, e]);
    case 2:
      return _S([t, e], 0);
    case 3:
      return TS([t, e], 0);
    case 4:
      return CS([t, e], 0);
    default:
      throw new Z(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`);
  }
}
function n1(t, e) {
  if (Array.isArray(e) || (e = [e]), t.rank !== e.length)
    throw new Z(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);
  return pi(t, e);
}
function mb(t, e = 0, n = 1, s, i) {
  return z0(t, e, n, s, i);
}
function Yr(t, e, n, s) {
  if (t.rank < 2 || e.rank < 2)
    throw new Ct(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);
  if (e.rank >= 3) {
    const i = t.shape.slice(-1)[0], r = e.shape.slice(-2)[0];
    if (i !== r)
      throw new Ct(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`);
  }
  if (t.rank === 2 && e.rank === 2)
    return Yw({
      a: t,
      b: e,
      transposeA: !1,
      transposeB: !1,
      bias: s ? s1(t.rank, s, Cr()) : null,
      activation: n
    });
  {
    const i = t.shape.slice(), r = i.pop();
    t = Y(t, [-1, r]);
    const o = e.shape.slice(), a = o.pop(), c = o.pop(), l = [...o, a], u = Array.from({ length: e.rank }, (p, y) => y === 0 ? e.rank - 2 : y <= e.rank - 2 ? y - 1 : y);
    e = Y(zt(e, u), [c, -1]);
    const h = [...i, ...l];
    return Y(Yw({
      a: t,
      b: e,
      transposeA: !1,
      transposeB: !1,
      bias: s ? s1(t.rank, s, Cr()) : null,
      activation: n
    }), h);
  }
}
function gM(t, e, n) {
  return Q(() => (Array.isArray(e) ? e = Ns(e, "int32") : e = Le(e, "int32"), Lh(t, e, n)));
}
function mm(t) {
  return q(t, t);
}
function s1(t, e, n) {
  const s = e.shape;
  if (e.rank !== 1 && e.rank !== t)
    throw new Z(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);
  if (t === 5) {
    if (n === "channelsFirst")
      return s.length === 1 ? Y(e, [1, s[0], 1, 1, 1]) : Y(e, [1, s[3], s[0], s[1], s[2]]);
    if (n === "channelsLast")
      return s.length === 1 ? Y(e, [1, 1, 1, 1, s[0]]) : Y(e, [1].concat(s));
  } else if (t === 4) {
    if (n === "channelsFirst")
      return s.length === 1 ? Y(e, [1, s[0], 1, 1]) : Y(e, [1, s[2], s[0], s[1]]);
    if (n === "channelsLast")
      return s.length === 1 ? Y(e, [1, 1, 1, s[0]]) : Y(e, [1].concat(s));
  } else if (t === 3) {
    if (n === "channelsFirst")
      return s.length === 1 ? Y(e, [1, s[0], 1]) : Y(e, [1, s[1], s[0]]);
    if (n === "channelsLast")
      return s.length === 1 ? Y(e, [1, 1, s[0]]) : Y(e, [1].concat(s));
  } else if (t < 3)
    return e;
  throw new Z(`Unsupported input rank by biasAdd: ${e.rank}`);
}
function Ar(t, e, n) {
  return Q(() => (n == null && (n = Cr()), Un(n), Se(t, s1(t.rank, e, n))));
}
function RX(t, e = 1) {
  if (e !== 1)
    throw new Ct(`Support for alpha values other than 1 (${e}) is not implemented yet.`);
  return Dh(t);
}
function DX(t) {
  return Q(() => it(t, Se(jn(t), 1)));
}
function yM(t, e, n, s) {
  return Q(() => d_(t, e, n, s));
}
function $X(t) {
  return Q(() => {
    const e = Se(0.5, q(0.2, t));
    return Gs(e, 0, 1);
  });
}
function gm(t, e, n = !1) {
  return n ? t() : e();
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const OX = ["fanIn", "fanOut", "fanAvg"], LX = ["normal", "uniform", "truncatedNormal"];
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function FX(t) {
  al(OX, "FanMode", t);
}
function PX(t) {
  al(LX, "Distribution", t);
}
class rr extends ol {
  fromConfigUsesCustomObjects() {
    return !1;
  }
  getConfig() {
    return {};
  }
}
class xM extends rr {
  apply(e, n) {
    return qn(e, n);
  }
}
xM.className = "Zeros";
Ee(xM);
class tT extends rr {
  apply(e, n) {
    return Qs(e, n);
  }
}
tT.className = "Ones";
Ee(tT);
class bM extends rr {
  constructor(e) {
    if (super(), typeof e != "object")
      throw new Z(`Expected argument of type ConstantConfig but got ${e}`);
    if (e.value === void 0)
      throw new Z(`config must have value set but got ${e}`);
    this.value = e.value;
  }
  apply(e, n) {
    return Q(() => q(ot(this.value), Qs(e, n)));
  }
  getConfig() {
    return {
      value: this.value
    };
  }
}
bM.className = "Constant";
Ee(bM);
class vM extends rr {
  constructor(e) {
    super(), this.DEFAULT_MINVAL = -0.05, this.DEFAULT_MAXVAL = 0.05, this.minval = e.minval || this.DEFAULT_MINVAL, this.maxval = e.maxval || this.DEFAULT_MAXVAL, this.seed = e.seed;
  }
  apply(e, n) {
    return Va(e, this.minval, this.maxval, n, this.seed);
  }
  getConfig() {
    return { minval: this.minval, maxval: this.maxval, seed: this.seed };
  }
}
vM.className = "RandomUniform";
Ee(vM);
class wM extends rr {
  constructor(e) {
    super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = 0.05, this.mean = e.mean || this.DEFAULT_MEAN, this.stddev = e.stddev || this.DEFAULT_STDDEV, this.seed = e.seed;
  }
  apply(e, n) {
    if (n = n || "float32", n !== "float32" && n !== "int32")
      throw new Ct(`randomNormal does not support dType ${n}.`);
    return mb(e, this.mean, this.stddev, n, this.seed);
  }
  getConfig() {
    return { mean: this.mean, stddev: this.stddev, seed: this.seed };
  }
}
wM.className = "RandomNormal";
Ee(wM);
class SM extends rr {
  constructor(e) {
    super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = 0.05, this.mean = e.mean || this.DEFAULT_MEAN, this.stddev = e.stddev || this.DEFAULT_STDDEV, this.seed = e.seed;
  }
  apply(e, n) {
    if (n = n || "float32", n !== "float32" && n !== "int32")
      throw new Ct(`truncatedNormal does not support dType ${n}.`);
    return Z0(e, this.mean, this.stddev, n, this.seed);
  }
  getConfig() {
    return { mean: this.mean, stddev: this.stddev, seed: this.seed };
  }
}
SM.className = "TruncatedNormal";
Ee(SM);
class _M extends rr {
  constructor(e) {
    super(), this.gain = e.gain != null ? e.gain : 1;
  }
  apply(e, n) {
    return Q(() => {
      if (e.length !== 2 || e[0] !== e[1])
        throw new Z("Identity matrix initializer can only be used for 2D square matrices.");
      return q(this.gain, D0(e[0]));
    });
  }
  getConfig() {
    return { gain: this.gain };
  }
}
_M.className = "Identity";
Ee(_M);
function BX(t, e = "channelsLast") {
  let n, s;
  if (Un(e), t.length === 2)
    n = t[0], s = t[1];
  else if ([3, 4, 5].indexOf(t.length) !== -1) {
    if (e === "channelsFirst") {
      const i = ya(t, 2);
      n = t[1] * i, s = t[0] * i;
    } else if (e === "channelsLast") {
      const i = ya(t, 0, t.length - 2);
      n = t[t.length - 2] * i, s = t[t.length - 1] * i;
    }
  } else {
    const i = ya(t);
    n = Math.sqrt(i), s = Math.sqrt(i);
  }
  return [n, s];
}
class wi extends rr {
  /**
   * Constructor of VarianceScaling.
   * @throws ValueError for invalid value in scale.
   */
  constructor(e) {
    if (super(), e.scale < 0)
      throw new Z(`scale must be a positive float. Got: ${e.scale}`);
    this.scale = e.scale == null ? 1 : e.scale, this.mode = e.mode == null ? "fanIn" : e.mode, FX(this.mode), this.distribution = e.distribution == null ? "normal" : e.distribution, PX(this.distribution), this.seed = e.seed;
  }
  apply(e, n) {
    const s = BX(e), i = s[0], r = s[1];
    let o = this.scale;
    if (this.mode === "fanIn" ? o /= Math.max(1, i) : this.mode === "fanOut" ? o /= Math.max(1, r) : o /= Math.max(1, (i + r) / 2), this.distribution === "normal") {
      const a = Math.sqrt(o);
      if (n = n || "float32", n !== "float32" && n !== "int32")
        throw new Ct(`${this.getClassName()} does not support dType ${n}.`);
      return Z0(e, 0, a, n, this.seed);
    } else {
      const a = Math.sqrt(3 * o);
      return Va(e, -a, a, n, this.seed);
    }
  }
  getConfig() {
    return {
      scale: this.scale,
      mode: this.mode,
      distribution: this.distribution,
      seed: this.seed
    };
  }
}
wi.className = "VarianceScaling";
Ee(wi);
class nT extends wi {
  /**
   * Constructor of GlorotUniform
   * @param scale
   * @param mode
   * @param distribution
   * @param seed
   */
  constructor(e) {
    super({
      scale: 1,
      mode: "fanAvg",
      distribution: "uniform",
      seed: e == null ? null : e.seed
    });
  }
  getClassName() {
    return wi.className;
  }
}
nT.className = "GlorotUniform";
Ee(nT);
class sT extends wi {
  /**
   * Constructor of GlorotNormal.
   * @param scale
   * @param mode
   * @param distribution
   * @param seed
   */
  constructor(e) {
    super({
      scale: 1,
      mode: "fanAvg",
      distribution: "normal",
      seed: e == null ? null : e.seed
    });
  }
  getClassName() {
    return wi.className;
  }
}
sT.className = "GlorotNormal";
Ee(sT);
class iT extends wi {
  constructor(e) {
    super({
      scale: 2,
      mode: "fanIn",
      distribution: "normal",
      seed: e == null ? null : e.seed
    });
  }
  getClassName() {
    return wi.className;
  }
}
iT.className = "HeNormal";
Ee(iT);
class rT extends wi {
  constructor(e) {
    super({
      scale: 2,
      mode: "fanIn",
      distribution: "uniform",
      seed: e == null ? null : e.seed
    });
  }
  getClassName() {
    return wi.className;
  }
}
rT.className = "HeUniform";
Ee(rT);
class oT extends wi {
  constructor(e) {
    super({
      scale: 1,
      mode: "fanIn",
      distribution: "normal",
      seed: e == null ? null : e.seed
    });
  }
  getClassName() {
    return wi.className;
  }
}
oT.className = "LeCunNormal";
Ee(oT);
class aT extends wi {
  constructor(e) {
    super({
      scale: 1,
      mode: "fanIn",
      distribution: "uniform",
      seed: e == null ? null : e.seed
    });
  }
  getClassName() {
    return wi.className;
  }
}
aT.className = "LeCunUniform";
Ee(aT);
class TM extends rr {
  constructor(e) {
    super(), this.DEFAULT_GAIN = 1, this.ELEMENTS_WARN_SLOW = 2e3, this.gain = e.gain == null ? this.DEFAULT_GAIN : e.gain, this.seed = e.seed;
  }
  apply(e, n) {
    return Q(() => {
      if (e.length < 2)
        throw new Ct("Shape must be at least 2D.");
      if (n !== "int32" && n !== "float32" && n !== void 0)
        throw new TypeError(`Unsupported data type ${n}.`);
      n = n;
      const s = ue(e.slice(0, -1)), i = e[e.length - 1], r = s * i;
      r > this.ELEMENTS_WARN_SLOW && console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);
      const o = [Math.max(i, s), Math.min(i, s)], a = mb(o, 0, 1, n, this.seed), c = g_.qr(a, !1);
      let l = c[0];
      const h = c[1].flatten().stridedSlice([0], [Math.min(i, s) * Math.min(i, s)], [Math.min(i, s) + 1]);
      return l = q(l, h.sign()), s < i && (l = l.transpose()), q(ot(this.gain), l.reshape(e));
    });
  }
  getConfig() {
    return {
      gain: this.gain,
      seed: this.seed
    };
  }
}
TM.className = "Orthogonal";
Ee(TM);
const Q2 = {
  constant: "Constant",
  glorotNormal: "GlorotNormal",
  glorotUniform: "GlorotUniform",
  heNormal: "HeNormal",
  heUniform: "HeUniform",
  identity: "Identity",
  leCunNormal: "LeCunNormal",
  leCunUniform: "LeCunUniform",
  ones: "Ones",
  orthogonal: "Orthogonal",
  randomNormal: "RandomNormal",
  randomUniform: "RandomUniform",
  truncatedNormal: "TruncatedNormal",
  varianceScaling: "VarianceScaling",
  zeros: "Zeros"
};
function eI(t, e = {}) {
  return fm(t, Ni.getMap().classNameMap, e, "initializer");
}
function Nn(t) {
  return J_(t);
}
function wn(t) {
  if (typeof t == "string") {
    const e = t in Q2 ? Q2[t] : t;
    if (e === "GlorotNormal")
      return new sT();
    if (e === "GlorotUniform")
      return new nT();
    if (e === "HeNormal")
      return new iT();
    if (e === "HeUniform")
      return new rT();
    if (e === "LeCunNormal")
      return new oT();
    if (e === "LeCunUniform")
      return new aT();
    {
      const n = {};
      return n.className = e, n.config = {}, eI(n);
    }
  } else
    return t instanceof rr ? t : eI(t);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function i1(t) {
  return Array.isArray(t) && Array.isArray(t[0]);
}
function Py(t) {
  return t.length === 0 ? [] : Array.isArray(t[0]) ? t : [t];
}
function gt(t) {
  let e;
  if (Array.isArray(t)) {
    if (t.length !== 1)
      throw new Z(`Expected Tensor length to be 1; got ${t.length}`);
    e = t[0];
  } else
    e = t;
  return e;
}
function Ht(t) {
  if (Array.isArray(t) && Array.isArray(t[0])) {
    if (t.length === 1)
      return t = t, t[0];
    throw new Z(`Expected exactly 1 Shape; got ${t.length}`);
  } else
    return t;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function By(t) {
  let e = 0;
  for (const n of t)
    n.shape.length === 0 ? e += 1 : e += n.shape.reduce((s, i) => s * i);
  return e;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const tI = "Variable";
class zX {
  /**
   * Construct Variable from a `tf.Tensor`.
   *
   * If not explicitly named, the Variable will be given a name with the
   * prefix 'Variable'. Variable names are unique. In the case of name
   * collision, suffixies '_<num>' will be added to the name.
   *
   * @param val Initial value of the Variable.
   * @param name Name of the variable. If `null` or `undefined` is provided, it
   *   will default a name with the prefix 'Variable'.
   * @param constraint Optional, projection function to be applied to the
   * variable after optimize updates
   * @throws ValueError if `name` is `null` or `undefined`.
   */
  constructor(e, n = "float32", s = tI, i = !0, r = null) {
    this.dtype = n ?? "float32", this.shape = e.shape, this.id = hM(), s = s ?? tI, this.originalName = fM(s), this.name = pM(this.originalName), this.trainable_ = i, this.constraint = r, this.val = u_(e, this.trainable_, this.name, this.dtype);
  }
  /**
   * Get a snapshot of the Variable's value.
   *
   * The returned value is a snapshot of the Variable's value at the time of
   * the invocation. Future mutations in the value of the tensor will only
   * be reflected by future calls to this method.
   */
  read() {
    return this.assertNotDisposed(), this.val;
  }
  /**
   * Update the value of the Variable.
   *
   * @param newVal: The new value to update to. Must be consistent with the
   *   dtype and shape of the Variable.
   * @return This Variable.
   */
  write(e) {
    return this.assertNotDisposed(), VX(this.val, e), this.val.id !== e.id && (this.val.assign(e), this.constraint != null && this.val.assign(this.constraint.apply(this.val))), this;
  }
  /**
   * Dispose this LayersVariable instance from memory.
   */
  dispose() {
    this.assertNotDisposed(), this.val.dispose();
  }
  assertNotDisposed() {
    if (this.val.isDisposed)
      throw new Error(`LayersVariable ${this.name} is already disposed.`);
  }
  get trainable() {
    return this.trainable_;
  }
  set trainable(e) {
    this.trainable_ = e, this.val.trainable = e;
  }
}
function VX(t, e) {
  if (t.shape.toString() !== e.shape.toString())
    throw new Error("Shape mismatch: " + JSON.stringify(t.shape) + " vs. " + JSON.stringify(e.shape));
}
function r1(t) {
  return t.map((e) => e.read());
}
function cT(t) {
  t.forEach((e) => {
    e[0].write(e[1]);
  });
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Qn {
  constructor(e) {
    this.dtype = e.dtype, this.shape = e.shape, e.shape != null ? this.ndim = e.shape.length : this.ndim = e.ndim, this.maxNDim = e.maxNDim, this.minNDim = e.minNDim, this.axes = e.axes || {};
  }
}
class oo {
  /**
   *
   * @param dtype
   * @param shape
   * @param sourceLayer The Layer that produced this symbolic tensor.
   * @param inputs The inputs passed to sourceLayer's __call__() method.
   * @param nodeIndex
   * @param tensorIndex
   * @param callArgs The keyword arguments passed to the __call__() method.
   * @param name
   * @param outputTensorIndex The index of this tensor in the list of outputs
   *   returned by apply().
   */
  constructor(e, n, s, i, r, o, a) {
    this.dtype = e, this.shape = n, this.sourceLayer = s, this.inputs = i, this.callArgs = r, this.outputTensorIndex = a, this.id = hM(), o != null && (this.originalName = fM(o), this.name = pM(this.originalName)), this.rank = n.length;
  }
}
let UX = 0;
class gb {
  constructor(e, n) {
    this.callArgs = n, this.id = UX++, this.outboundLayer = e.outboundLayer, this.inboundLayers = e.inboundLayers, this.nodeIndices = e.nodeIndices, this.tensorIndices = e.tensorIndices, this.inputTensors = e.inputTensors, this.outputTensors = e.outputTensors, this.inputMasks = e.inputMasks, this.outputMasks = e.outputMasks, this.inputShapes = e.inputShapes, this.outputShapes = e.outputShapes;
    for (const s of e.inboundLayers)
      s != null && s.outboundNodes.push(this);
    e.outboundLayer.inboundNodes.push(this);
  }
  getConfig() {
    const e = [];
    for (const n of this.inboundLayers)
      n != null ? e.push(n.name) : e.push(null);
    return {
      outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
      inboundLayers: e,
      nodeIndices: this.nodeIndices,
      tensorIndices: this.tensorIndices
    };
  }
}
let GX = 0;
class Ft extends ol {
  constructor(e = {}) {
    super(), this._callHook = null, this._addedWeightNames = [], this._stateful = !1, this.id = GX++, this.activityRegularizer = null, this.inputSpec = null, this.supportsMasking = !1, this._trainableWeights = [], this._nonTrainableWeights = [], this._losses = [], this._updates = [], this._built = !1, this.inboundNodes = [], this.outboundNodes = [];
    let n = e.name;
    if (!n) {
      const s = this.getClassName();
      n = wo(s) + "_" + pb(s);
    }
    if (this.name = n, this.trainable_ = e.trainable == null ? !0 : e.trainable, e.inputShape != null || e.batchInputShape != null) {
      let s;
      if (e.batchInputShape != null)
        s = e.batchInputShape;
      else if (e.inputShape != null) {
        let r = null;
        e.batchSize != null && (r = e.batchSize), s = [r].concat(e.inputShape);
      }
      this.batchInputShape = s;
      let i = e.dtype;
      i == null && (i = e.inputDType), i == null && (i = "float32"), this.dtype = i;
    }
    e.weights != null ? this.initialWeights = e.weights : this.initialWeights = null, this._refCount = null, this.fastWeightInitDuringBuild = !1;
  }
  /**
   * Converts a layer and its index to a unique (immutable type) name.
   * This function is used internally with `this.containerNodes`.
   * @param layer The layer.
   * @param nodeIndex The layer's position (e.g. via enumerate) in a list of
   *   nodes.
   *
   * @returns The unique name.
   */
  static nodeKey(e, n) {
    return e.name + "_ib-" + n.toString();
  }
  /**
   * Returns this.inboundNode at index nodeIndex.
   *
   * Porting note: This is a replacement for _get_node_attribute_at_index()
   * @param nodeIndex
   * @param attrName The name of the attribute related to request for this node.
   */
  getNodeAtIndex(e, n) {
    if (this.inboundNodes.length === 0)
      throw new Ki(`The layer has never been called and thus has no defined ${n}.`);
    if (this.inboundNodes.length <= e)
      throw new Z(`Asked to get ${n} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);
    return this.inboundNodes[e];
  }
  /**
   * Retrieves the input tensor(s) of a layer at a given node.
   *
   * @param nodeIndex Integer, index of the node from which to retrieve the
   *   attribute. E.g. `nodeIndex=0` will correspond to the first time the layer
   *   was called.
   *
   * @return A tensor (or list of tensors if the layer has multiple inputs).
   */
  getInputAt(e) {
    return Zs(this.getNodeAtIndex(e, "input").inputTensors);
  }
  /**
   * Retrieves the output tensor(s) of a layer at a given node.
   *
   * @param nodeIndex Integer, index of the node from which to retrieve the
   *   attribute. E.g. `nodeIndex=0` will correspond to the first time the layer
   *   was called.
   *
   * @return A tensor (or list of tensors if the layer has multiple outputs).
   */
  getOutputAt(e) {
    return Zs(this.getNodeAtIndex(e, "output").outputTensors);
  }
  // Properties
  /**
   * Retrieves the input tensor(s) of a layer.
   *
   * Only applicable if the layer has exactly one inbound node,
   * i.e. if it is connected to one incoming layer.
   *
   * @return Input tensor or list of input tensors.
   *
   * @exception AttributeError if the layer is connected to more than one
   *   incoming layers.
   */
  get input() {
    if (this.inboundNodes.length > 1)
      throw new Br(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);
    if (this.inboundNodes.length === 0)
      throw new Br(`Layer ${this.name} is not connected, no input to return.`);
    return Zs(this.getNodeAtIndex(0, "input").inputTensors);
  }
  /**
   * Retrieves the output tensor(s) of a layer.
   *
   * Only applicable if the layer has exactly one inbound node,
   * i.e. if it is connected to one incoming layer.
   *
   * @return Output tensor or list of output tensors.
   *
   * @exception AttributeError if the layer is connected to more than one
   *   incoming layers.
   */
  get output() {
    if (this.inboundNodes.length === 0)
      throw new Br(`Layer ${this.name} has no inbound nodes.`);
    if (this.inboundNodes.length > 1)
      throw new Br(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);
    return Zs(this.getNodeAtIndex(0, "output").outputTensors);
  }
  get losses() {
    return this._losses;
  }
  /**
   * Retrieves the Layer's current loss values.
   *
   * Used for regularizers during training.
   */
  calculateLosses() {
    return this.losses.map((e) => e());
  }
  get updates() {
    return this._updates;
  }
  get built() {
    return this._built;
  }
  set built(e) {
    this._built = e;
  }
  get trainable() {
    return this.trainable_;
  }
  set trainable(e) {
    this._trainableWeights.forEach((n) => n.trainable = e), this.trainable_ = e;
  }
  get trainableWeights() {
    return this.trainable_ ? this._trainableWeights.filter((e) => e.trainable) : [];
  }
  set trainableWeights(e) {
    this._trainableWeights = e;
  }
  get nonTrainableWeights() {
    return this.trainable ? this._trainableWeights.filter((e) => !e.trainable).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
  }
  set nonTrainableWeights(e) {
    this._nonTrainableWeights = e;
  }
  /**
   * The concatenation of the lists trainableWeights and nonTrainableWeights
   * (in this order).
   */
  get weights() {
    return this.trainableWeights.concat(this.nonTrainableWeights);
  }
  get stateful() {
    return this._stateful;
  }
  /**
   * Reset the states of the layer.
   *
   * This method of the base Layer class is essentially a no-op.
   * Subclasses that are stateful (e.g., stateful RNNs) should override this
   * method.
   */
  resetStates() {
    if (!this.stateful)
      throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
  }
  /**
   * Checks compatibility between the layer and provided inputs.
   *
   * This checks that the tensor(s) `input`
   * verify the input assumptions of the layer
   * (if any). If not, exceptions are raised.
   *
   * @param inputs Input tensor or list of input tensors.
   *
   * @exception ValueError in case of mismatch between
   *   the provided inputs and the expectations of the layer.
   */
  assertInputCompatibility(e) {
    const n = Zt(e);
    if (this.inputSpec == null || this.inputSpec.length === 0)
      return;
    const s = Zt(this.inputSpec);
    if (n.length !== s.length)
      throw new Z(`Layer ${this.name} expects ${s.length} inputs, but it received ${n.length} input tensors. Input received: ${e}`);
    for (let i = 0; i < n.length; i++) {
      const r = n[i], o = s[i];
      if (o == null)
        continue;
      const a = r.rank;
      if (o.ndim != null && a !== o.ndim)
        throw new Z(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);
      if (o.maxNDim != null && a > o.maxNDim)
        throw new Z(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);
      if (o.minNDim != null && a < o.minNDim)
        throw new Z(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);
      if (o.dtype != null && r.dtype !== o.dtype)
        throw new Z(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${r.dtype}.`);
      if (o.axes) {
        const c = r.shape;
        for (const l in o.axes) {
          const u = Number(l), h = o.axes[l], d = u >= 0 ? c[u] : c[c.length + u];
          if (h != null && [h, null].indexOf(d) === -1)
            throw new Z(`Input ${i} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${h} but got shape ${c}.`);
        }
      }
      if (o.shape != null)
        for (let c = 0; c < o.shape.length; ++c) {
          const l = o.shape[c], u = r.shape[c];
          if (l != null && u != null && l !== u)
            throw new Z(`Input ${i} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${r.shape}.`);
        }
    }
  }
  /**
   * This is where the layer's logic lives.
   *
   * @param inputs Input tensor, or list/tuple of input tensors.
   * @param kwargs Additional keyword arguments.
   *
   * @return A tensor or list/tuple of tensors.
   */
  call(e, n) {
    return e;
  }
  invokeCallHook(e, n) {
    this._callHook != null && this._callHook(e, n);
  }
  /**
   * Set call hook.
   * This is currently used for testing only.
   * @param callHook
   */
  setCallHook(e) {
    this._callHook = e;
  }
  /**
   * Clear call hook.
   * This is currently used for testing only.
   */
  clearCallHook() {
    this._callHook = null;
  }
  /**
   * Builds or executes a `Layer`'s logic.
   *
   * When called with `tf.Tensor`(s), execute the `Layer`'s computation and
   * return Tensor(s). For example:
   *
   * ```js
   * const denseLayer = tf.layers.dense({
   *   units: 1,
   *   kernelInitializer: 'zeros',
   *   useBias: false
   * });
   *
   * // Invoke the layer's apply() method with a `tf.Tensor` (with concrete
   * // numeric values).
   * const input = tf.ones([2, 2]);
   * const output = denseLayer.apply(input);
   *
   * // The output's value is expected to be [[0], [0]], due to the fact that
   * // the dense layer has a kernel initialized to all-zeros and does not have
   * // a bias.
   * output.print();
   * ```
   *
   * When called with `tf.SymbolicTensor`(s), this will prepare the layer for
   * future execution.  This entails internal book-keeping on shapes of
   * expected Tensors, wiring layers together, and initializing weights.
   *
   * Calling `apply` with `tf.SymbolicTensor`s are typically used during the
   * building of non-`tf.Sequential` models. For example:
   *
   * ```js
   * const flattenLayer = tf.layers.flatten();
   * const denseLayer = tf.layers.dense({units: 1});
   *
   * // Use tf.layers.input() to obtain a SymbolicTensor as input to apply().
   * const input = tf.input({shape: [2, 2]});
   * const output1 = flattenLayer.apply(input);
   *
   * // output1.shape is [null, 4]. The first dimension is the undetermined
   * // batch size. The second dimension comes from flattening the [2, 2]
   * // shape.
   * console.log(JSON.stringify(output1.shape));
   *
   * // The output SymbolicTensor of the flatten layer can be used to call
   * // the apply() of the dense layer:
   * const output2 = denseLayer.apply(output1);
   *
   * // output2.shape is [null, 1]. The first dimension is the undetermined
   * // batch size. The second dimension matches the number of units of the
   * // dense layer.
   * console.log(JSON.stringify(output2.shape));
   *
   * // The input and output can be used to construct a model that consists
   * // of the flatten and dense layers.
   * const model = tf.model({inputs: input, outputs: output2});
   * ```
   *
   * @param inputs a `tf.Tensor` or `tf.SymbolicTensor` or an Array of them.
   * @param kwargs Additional keyword arguments to be passed to `call()`.
   *
   * @return Output of the layer's `call` method.
   *
   * @exception ValueError error in case the layer is missing shape information
   *   for its `build` call.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  // Porting Note: This is a replacement for __call__() in Python.
  apply(e, n) {
    n = n || {}, this.assertNotDisposed();
    const s = Zt(e), i = jX(e), r = qX(e);
    if (i === r)
      throw new Z("Arguments to apply() must be all SymbolicTensors or all Tensors");
    return Tc(this.name, () => {
      if (!this.built) {
        this.assertInputCompatibility(e);
        const o = [];
        for (const a of Zt(e))
          o.push(a.shape);
        this.build(Zs(o)), this.built = !0, this.initialWeights && this.setWeights(this.initialWeights), this._refCount === null && r && (this._refCount = 1);
      }
      if (this.assertInputCompatibility(e), r) {
        let o = this.call(e, n);
        this.supportsMasking && this.setMaskMetadata(e, o);
        const a = Zt(o), c = [];
        for (let l of a)
          s.indexOf(l) !== -1 && (l = l.clone()), c.push(l);
        if (o = Zs(c), this.activityRegularizer != null)
          throw new Ct("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return o;
      } else {
        const o = WX(e), a = this.computeOutputShape(o);
        let c;
        const l = HX(e);
        if (this.warnOnIncompatibleInputShape(Array.isArray(e) ? o[0] : o), a != null && a.length > 0 && Array.isArray(a[0]) ? c = a.map((u, h) => new oo(l, u, this, Zt(e), n, this.name, h)) : c = new oo(l, a, this, Zt(e), n, this.name), this.addInboundNode(e, c, null, null, o, a, n), this._refCount++, this.activityRegularizer != null)
          throw new Ct("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return c;
      }
    });
  }
  /**
   * Check compatibility between input shape and this layer's batchInputShape.
   *
   * Print warning if any incompatibility is found.
   *
   * @param inputShape Input shape to be checked.
   */
  warnOnIncompatibleInputShape(e) {
    if (this.batchInputShape != null)
      if (e.length !== this.batchInputShape.length)
        console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);
      else {
        let n = !1;
        this.batchInputShape.forEach((s, i) => {
          s != null && e[i] != null && e[i] !== s && (n = !0);
        }), n && console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`);
      }
  }
  /**
   * Retrieves the output shape(s) of a layer.
   *
   * Only applicable if the layer has only one inbound node, or if all inbound
   * nodes have the same output shape.
   *
   * @returns Output shape or shapes.
   * @throws AttributeError: if the layer is connected to more than one incoming
   *   nodes.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  get outputShape() {
    if (this.inboundNodes == null || this.inboundNodes.length === 0)
      throw new Br(`The layer ${this.name} has never been called and thus has no defined output shape.`);
    const e = [];
    for (const n of this.inboundNodes) {
      const s = JSON.stringify(n.outputShapes);
      e.indexOf(s) === -1 && e.push(s);
    }
    if (e.length === 1) {
      const n = this.inboundNodes[0].outputShapes;
      return Array.isArray(n) && Array.isArray(n[0]) && n.length === 1 ? n[0] : n;
    } else
      throw new Br(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`);
  }
  /**
   * Counts the total number of numbers (e.g., float32, int32) in the
   * weights.
   *
   * @returns An integer count.
   * @throws RuntimeError: If the layer is not built yet (in which case its
   *   weights are not defined yet.)
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  countParams() {
    if (!this.built)
      throw new Ki(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);
    return By(this.weights);
  }
  /**
   * Creates the layer weights.
   *
   * Must be implemented on all layers that have weights.
   *
   * Called when apply() is called to construct the weights.
   *
   * @param inputShape A `Shape` or array of `Shape` (unused).
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  build(e) {
    this.built = !0;
  }
  /**
   * Returns the current values of the weights of the layer.
   *
   * @param trainableOnly Whether to get the values of only trainable weights.
   * @returns Weight values as an `Array` of `tf.Tensor`s.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  getWeights(e = !1) {
    return r1(e ? this.trainableWeights : this.weights);
  }
  /**
   * Sets the weights of the layer, from Tensors.
   *
   * @param weights a list of Tensors. The number of arrays and their shape
   *   must match number of the dimensions of the weights of the layer (i.e.
   *   it should match the output of `getWeights`).
   *
   * @exception ValueError If the provided weights list does not match the
   *   layer's specifications.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  setWeights(e) {
    Q(() => {
      const n = this.weights;
      if (n.length !== e.length)
        throw new Z(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${n.length} weights. Provided weights: ${e}...`);
      if (n.length === 0)
        return;
      const s = [], i = r1(n);
      for (let r = 0; r < i.length; ++r) {
        const o = i[r], a = n[r], c = e[r];
        if (!Bt(o.shape, c.shape))
          throw new Z(`Layer weight shape ${o.shape} not compatible with provided weight shape ${c.shape}`);
        s.push([a, c]);
      }
      cT(s);
    });
  }
  /**
   * Adds a weight variable to the layer.
   *
   * @param name Name of the new weight variable.
   * @param shape The shape of the weight.
   * @param dtype The dtype of the weight.
   * @param initializer An initializer instance.
   * @param regularizer A regularizer instance.
   * @param trainable Whether the weight should be trained via backprop or not
   *   (assuming that the layer itself is also trainable).
   * @param constraint An optional trainable.
   * @return The created weight variable.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  addWeight(e, n, s, i, r, o, a, c) {
    if (this._addedWeightNames.indexOf(e) !== -1)
      throw new Z(`Duplicate weight name ${e} for layer ${this.name}`);
    this._addedWeightNames.push(e), s == null && (s = "float32"), this.fastWeightInitDuringBuild && (i = c != null ? c() : wn("zeros"));
    const l = i.apply(n, s), u = new zX(l, s, e, o, a);
    return l.dispose(), r != null && this.addLoss(() => r.apply(u.read())), o == null && (o = !0), o ? this._trainableWeights.push(u) : this._nonTrainableWeights.push(u), u;
  }
  /**
   * Set the fast-weight-initialization flag.
   *
   * In cases where the initialized weight values will be immediately
   * overwritten by loaded weight values during model loading, setting
   * the flag to `true` saves unnecessary calls to potentially expensive
   * initializers and speeds up the loading process.
   *
   * @param value Target value of the flag.
   */
  setFastWeightInitDuringBuild(e) {
    this.fastWeightInitDuringBuild = e;
  }
  /**
   * Add losses to the layer.
   *
   * The loss may potentially be conditional on some inputs tensors,
   * for instance activity losses are conditional on the layer's inputs.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  addLoss(e) {
    e == null || Array.isArray(e) && e.length === 0 || (e = Zt(e), this._losses !== void 0 && this._losses !== null && this.losses.push(...e));
  }
  /**
   * Computes the output shape of the layer.
   *
   * Assumes that the layer will be built to match that input shape provided.
   *
   * @param inputShape A shape (tuple of integers) or a list of shape tuples
   *   (one per output tensor of the layer). Shape tuples can include null for
   *   free dimensions, instead of an integer.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  computeOutputShape(e) {
    return e;
  }
  /**
   * Computes an output mask tensor.
   *
   * @param inputs Tensor or list of tensors.
   * @param mask Tensor or list of tensors.
   *
   * @return null or a tensor (or list of tensors, one per output tensor of the
   * layer).
   */
  computeMask(e, n) {
    if (!this.supportsMasking) {
      if (n != null)
        if (Array.isArray(n))
          n.forEach((s) => {
            if (s != null)
              throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
          });
        else
          throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
      return null;
    }
    return n;
  }
  setMaskMetadata(e, n, s) {
    if (!this.supportsMasking)
      return;
    const i = this.computeMask(e, s), r = Zt(n), o = Zt(i);
    if (r.length !== o.length)
      throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);
    for (let a = 0; a < r.length; a++)
      r[a].kerasMask = o[a];
  }
  /**
   * Internal method to create an inbound node for the layer.
   *
   * @param inputTensors List of input tensors.
   * @param outputTensors List of output tensors.
   * @param inputMasks List of input masks (a mask can be a tensor, or null).
   * @param outputMasks List of output masks (a mask can be a tensor, or null).
   * @param inputShapes List of input shape tuples.
   * @param outputShapes List of output shape tuples.
   * @param kwargs Dictionary of keyword arguments that were passed to the
   *   `call` method of the layer at the call that created the node.
   */
  addInboundNode(e, n, s, i, r, o, a = null) {
    const c = Zt(e);
    n = Zt(n), s = Zt(s), i = Zt(i), r = Py(r), o = Py(o);
    const l = [], u = [], h = [];
    for (const d of c)
      l.push(d.sourceLayer), u.push(d.nodeIndex), h.push(d.tensorIndex);
    new gb({
      outboundLayer: this,
      inboundLayers: l,
      nodeIndices: u,
      tensorIndices: h,
      inputTensors: c,
      outputTensors: n,
      inputMasks: s,
      outputMasks: i,
      inputShapes: r,
      outputShapes: o
    }, a);
    for (let d = 0; d < n.length; d++)
      n[d].sourceLayer = this, n[d].nodeIndex = this.inboundNodes.length - 1, n[d].tensorIndex = d;
  }
  /**
   * Returns the config of the layer.
   *
   * A layer config is a TS dictionary (serializable)
   * containing the configuration of a layer.
   * The same layer can be reinstantiated later
   * (without its trained weights) from this configuration.
   *
   * The config of a layer does not include connectivity
   * information, nor the layer class name.  These are handled
   * by 'Container' (one layer of abstraction above).
   *
   * Porting Note: The TS dictionary follows TS naming standards for
   * keys, and uses tfjs-layers type-safe Enums.  Serialization methods
   * should use a helper function to convert to the pythonic storage
   * standard. (see serialization_utils.convertTsToPythonic)
   *
   * @returns TS dictionary of configuration.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  getConfig() {
    const e = { name: this.name, trainable: this.trainable };
    return this.batchInputShape != null && (e.batchInputShape = this.batchInputShape), this.dtype != null && (e.dtype = this.dtype), e;
  }
  /**
   * Dispose the weight variables that this Layer instance holds.
   *
   * @returns {number} Number of disposed variables.
   */
  disposeWeights() {
    return this.weights.forEach((e) => e.dispose()), this.weights.length;
  }
  assertNotDisposed() {
    if (this._refCount === 0)
      throw new Error(`Layer '${this.name}' is already disposed.`);
  }
  /**
   * Attempt to dispose layer's weights.
   *
   * This method decreases the reference count of the Layer object by 1.
   *
   * A Layer is reference-counted. Its reference count is incremented by 1
   * the first item its `apply()` method is called and when it becomes a part
   * of a new `Node` (through calling the `apply()` method on a
   * `tf.SymbolicTensor`).
   *
   * If the reference count of a Layer becomes 0, all the weights will be
   * disposed and the underlying memory (e.g., the textures allocated in WebGL)
   * will be freed.
   *
   * Note: If the reference count is greater than 0 after the decrement, the
   * weights of the Layer will *not* be disposed.
   *
   * After a Layer is disposed, it cannot be used in calls such as `apply()`,
   * `getWeights()` or `setWeights()` anymore.
   *
   * @returns A DisposeResult Object with the following fields:
   *   - refCountAfterDispose: The reference count of the Container after this
   *     `dispose()` call.
   *   - numDisposedVariables: Number of `tf.Variable`s (i.e., weights) disposed
   *     during this `dispose()` call.
   * @throws {Error} If the layer is not built yet, or if the layer has already
   *   been disposed.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  dispose() {
    if (!this.built)
      throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);
    if (this._refCount === null)
      throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);
    this.assertNotDisposed();
    let e = 0;
    return --this._refCount === 0 && (e = this.disposeWeights()), { refCountAfterDispose: this._refCount, numDisposedVariables: e };
  }
}
function WX(t) {
  t = Zt(t);
  const e = [];
  for (const n of t)
    e.push(n.shape);
  return Zs(e);
}
function HX(t) {
  return "float32";
}
function CM(t, e, n) {
  if ((e == null || n != null && n > 0) && (e = t.sourceLayer, n = t.nodeIndex), e.inboundNodes.length === 0)
    return [t];
  {
    const s = e.inboundNodes[n];
    if (s.inboundLayers.length === 0)
      return s.inputTensors;
    {
      const i = [];
      for (let r = 0; r < s.inboundLayers.length; r++) {
        const o = s.inputTensors[r], a = s.inboundLayers[r], c = s.nodeIndices[r], l = CM(o, a, c);
        for (const u of l)
          i.indexOf(u) === -1 && i.push(u);
      }
      return i;
    }
  }
}
function jX(t) {
  let e = !0;
  for (const n of Zt(t))
    if (!(n instanceof oo)) {
      e = !1;
      break;
    }
  return e;
}
function qX(t) {
  let e = !0;
  for (const n of Zt(t))
    if (n instanceof oo) {
      e = !1;
      break;
    }
  return e;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class ym extends Ft {
  constructor(e) {
    if (super({
      dtype: e.dtype,
      name: e.name != null ? e.name : pb("input").toString()
    }), e.batchSize == null && (e.batchSize = null), e.sparse == null && (e.sparse = !1), this.trainable = !1, this.built = !0, this.sparse = e.sparse, e.inputShape != null && e.batchInputShape != null)
      throw new Z("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
    let n = e.batchInputShape;
    if (n == null) {
      if (e.inputShape == null)
        throw new Z("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
      n = [e.batchSize].concat(e.inputShape);
    } else if (e.batchSize != null)
      throw new Z("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
    const s = e.dtype || "float32";
    this.batchInputShape = n, this.dtype = s, this.inputSpec = [{ shape: n }];
    const i = new oo(this.dtype, this.batchInputShape, this, [], {}, this.name);
    i.nodeIndex = 0, i.tensorIndex = 0, new gb({
      outboundLayer: this,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: [i],
      outputTensors: [i],
      inputMasks: [null],
      outputMasks: [null],
      inputShapes: [n],
      outputShapes: [n]
    });
  }
  apply(e, n) {
    throw new Z(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`);
  }
  dispose() {
    return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };
  }
  getConfig() {
    return {
      batchInputShape: this.batchInputShape,
      dtype: this.dtype,
      sparse: this.sparse,
      name: this.name
    };
  }
}
ym.className = "InputLayer";
Ee(ym);
function XX(t) {
  if (t.batchShape == null && t.shape == null)
    throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
  if (t.batchShape != null && t.shape != null)
    throw new Z("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
  let e = t.batchShape;
  t.shape != null && e == null && (e = [null].concat(t.shape));
  let n = t.dtype;
  return n == null && (n = "float32"), new ym({
    batchInputShape: e,
    name: t.name,
    dtype: n,
    sparse: t.sparse
  }).inboundNodes[0].outputTensors[0];
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function KX(t, e) {
  if (t.dtype == null || t.dtype === e.dtype)
    return e;
  try {
    return Le(e, t.dtype);
  } catch {
    throw new Z(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`);
  }
}
class la {
  /**
   * Constructor, optionally does copy-construction.
   * @param feeds An Array of `Feed`s, or another `FeedDict`, in which case
   *   copy-construction will be performed.
   */
  constructor(e) {
    if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, e instanceof la)
      for (const n in e.id2Value)
        this.id2Value[n] = e.id2Value[n], n in e.id2Mask && (this.id2Mask[n] = e.id2Mask[n]);
    else {
      if (e == null)
        return;
      for (const n of e)
        this.add(n.key, n.value);
    }
  }
  /**
   * Add a key-value pair to the FeedDict.
   *
   * @param key The key of the feed.
   * @param value The value of the tensor feed.
   * @param mask The value of the mask feed (optional).
   * @returns This `FeedDict`.
   * @throws ValueError: If the key `SymbolicTensor` already exists in the
   *   `FeedDict`.
   */
  add(e, n, s) {
    if (this.id2Value[e.id] == null)
      this.id2Value[e.id] = KX(e, n), this.name2Id[e.name] = e.id, s != null && (this.id2Mask[e.id] = s);
    else
      throw new Z(`Duplicate key: name=${e.name}, id=${e.id}`);
    return this;
  }
  /**
   * Add a Feed to the FeedDict.
   * @param feed The new `Feed` to add.
   * @returns This `FeedDict`.
   */
  addFeed(e) {
    this.add(e.key, e.value);
  }
  /**
   * Probe whether a key already exists in the FeedDict.
   * @param key
   */
  hasKey(e) {
    return this.id2Value[e.id] != null;
  }
  /**
   * Get all the SymbolicTensor available in this FeedDict.
   */
  names() {
    return Object.keys(this.name2Id);
  }
  /**
   * Get the feed value for given key.
   * @param key The SymbolicTensor, or its name (as a string), of which the
   *     value is sought.
   * @returns If `key` exists, the corresponding feed value.
   * @throws ValueError: If `key` does not exist in this `FeedDict`.
   */
  getValue(e) {
    if (e instanceof oo) {
      if (this.id2Value[e.id] == null)
        throw new Z(`Nonexistent key: ${e.name}`);
      return this.id2Value[e.id];
    } else {
      const n = this.name2Id[e];
      if (n == null)
        throw new Z(`Feed dict has no SymbolicTensor name: ${e}`);
      return this.id2Value[n];
    }
  }
  /**
   * Get the feed mask for given key.
   * @param key The SymbolicTensor, or its name (as a string), of which the
   *     value is sought.
   * @returns If `key` exists, the corresponding feed mask.
   * @throws ValueError: If `key` does not exist in this `FeedDict`.
   */
  getMask(e) {
    if (e instanceof oo) {
      if (this.id2Value[e.id] == null)
        throw new Z(`Nonexistent key: ${e.name}`);
      return this.id2Mask[e.id];
    } else {
      const n = this.name2Id[e];
      if (n == null)
        throw new Z(`Feed dict has no SymbolicTensor name: ${e}`);
      return this.id2Mask[n];
    }
  }
  /** Dispose all mask Tensors held by this object. */
  disposeMasks() {
    this.id2Mask != null && At(this.id2Mask);
  }
}
const zy = new cM(), Vy = new cM();
function YX(t) {
  zy != null && zy.setMaxEntries(t), Vy != null && Vy.setMaxEntries(t);
}
function pd(t, e, n, s) {
  const i = n == null ? !1 : n.training, r = Array.isArray(t), o = r ? t : [t], a = o.map((p) => p.name), c = [], l = e.names();
  for (const p of a)
    l.indexOf(p) !== -1 ? c.push(e.getValue(p)) : c.push(null);
  s != null && (s.maxNumTensors = -1 / 0, s.minNumTensors = 1 / 0);
  const u = a.join(",") + "|" + e.names().sort().join(",");
  let h = zy.get(u), d;
  if (h == null) {
    const p = ZX(o, e);
    h = p.sorted, d = p.recipientCounts, zy.put(u, h), Vy.put(u, d);
  }
  d = {}, i || Object.assign(d, Vy.get(u));
  const f = new la(e);
  for (let p = 0; p < h.length; ++p) {
    if (s != null) {
      const I = Ly().numTensors;
      I > s.maxNumTensors && (s.maxNumTensors = I), I < s.minNumTensors && (s.minNumTensors = I);
    }
    const y = h[p], g = y.sourceLayer;
    if (g instanceof ym)
      continue;
    const m = [], x = [], v = [];
    let b = !1;
    for (const I of y.inputs) {
      const k = f.getValue(I), M = f.getMask(I);
      m.push(k), x.push(M), M != null && (b = !0), i || (d[I.name]--, d[I.name] === 0 && !e.hasKey(I) && a.indexOf(I.name) === -1 && !k.isDisposed && I.sourceLayer.stateful !== !0 && v.push(k));
    }
    b && (n = n || {}, n.mask = x[0]);
    const w = Zt(g.apply(m, n));
    let S = null;
    g.supportsMasking && (S = g.computeMask(m, x));
    const _ = QX(y), E = Array.isArray(_) ? _ : [_];
    for (let I = 0; I < E.length; ++I) {
      f.hasKey(E[I]) || f.add(E[I], w[I], Array.isArray(S) ? S[0] : S);
      const k = a.indexOf(E[I].name);
      k !== -1 && (c[k] = w[I]);
    }
    i || At(v);
  }
  return f.disposeMasks(), r ? c : c[0];
}
function ZX(t, e) {
  A(t != null && t.length > 0, () => "Expected at least one fetch, got none");
  let n = [], s = {};
  if (t.length === 1) {
    const i = nI(t[0], e);
    n = i.sorted, s = i.recipientMap;
  } else {
    const i = /* @__PURE__ */ new Set();
    for (const r of t) {
      const { sorted: o, recipientMap: a } = nI(r, e);
      for (const c of o)
        i.has(c.name) || (n.push(c), i.add(c.name));
      for (const c in a)
        s[c] == null && (s[c] = /* @__PURE__ */ new Set()), a[c].forEach((l) => s[c].add(l));
    }
  }
  return {
    sorted: n,
    recipientCounts: JX(s)
  };
}
function JX(t) {
  const e = {};
  for (const n in t)
    e[n] = t[n].size;
  return e;
}
function nI(t, e) {
  const n = /* @__PURE__ */ new Set(), s = [], i = {};
  for (const a of e.names())
    n.add(a);
  const r = [], o = [];
  for (r.push(t); r.length > 0; ) {
    const a = r[r.length - 1];
    if (n.has(a.name)) {
      r.pop();
      continue;
    }
    const c = o[o.length - 1] === r.length - 1;
    if (a.inputs.length === 0 || c)
      r.pop(), s.push(a), n.add(a.name), c && o.pop();
    else {
      o.push(r.length - 1);
      for (const l of a.inputs)
        i[l.name] == null && (i[l.name] = /* @__PURE__ */ new Set()), i[l.name].add(a.name), !n.has(l.name) && r.push(l);
    }
  }
  return { sorted: s, recipientMap: i };
}
function QX(t) {
  let e;
  if (t.sourceLayer.inboundNodes.length === 1)
    e = t.sourceLayer.output;
  else {
    let n = null;
    for (let s = 0; s < t.sourceLayer.inboundNodes.length; ++s)
      for (const i of t.sourceLayer.inboundNodes[s].outputTensors)
        if (i.id === t.id) {
          n = s;
          break;
        }
    e = t.sourceLayer.getOutputAt(n);
  }
  return e;
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const e7 = ie();
e7.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES", () => 100, YX);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function lT(t, e) {
  return Q(() => us(Qe(q(t, t), e, !0)));
}
class xm extends ol {
  getConfig() {
    return {};
  }
}
class IM extends xm {
  constructor(e) {
    super(), this.defaultMaxValue = 2, this.defaultAxis = 0, this.maxValue = e.maxValue != null ? e.maxValue : this.defaultMaxValue, this.axis = e.axis != null ? e.axis : this.defaultAxis;
  }
  apply(e) {
    return Q(() => {
      const n = lT(e, this.axis), s = Gs(n, 0, this.maxValue);
      return q(e, it(s, Se(Jn(), n)));
    });
  }
  getConfig() {
    return { maxValue: this.maxValue, axis: this.axis };
  }
}
IM.className = "MaxNorm";
Ee(IM);
class EM extends xm {
  constructor(e) {
    super(), this.defaultAxis = 0, this.axis = e.axis != null ? e.axis : this.defaultAxis;
  }
  apply(e) {
    return Q(() => it(e, Se(Jn(), lT(e, this.axis))));
  }
  getConfig() {
    return { axis: this.axis };
  }
}
EM.className = "UnitNorm";
Ee(EM);
class NM extends xm {
  apply(e) {
    return kr(e);
  }
}
NM.className = "NonNeg";
Ee(NM);
class kM extends xm {
  constructor(e) {
    super(), this.defaultMinValue = 0, this.defaultMaxValue = 1, this.defaultRate = 1, this.defaultAxis = 0, this.minValue = e.minValue != null ? e.minValue : this.defaultMinValue, this.maxValue = e.maxValue != null ? e.maxValue : this.defaultMaxValue, this.rate = e.rate != null ? e.rate : this.defaultRate, this.axis = e.axis != null ? e.axis : this.defaultAxis;
  }
  apply(e) {
    return Q(() => {
      const n = lT(e, this.axis), s = Se(q(this.rate, Gs(n, this.minValue, this.maxValue)), q(1 - this.rate, n));
      return q(e, it(s, Se(Jn(), n)));
    });
  }
  getConfig() {
    return {
      minValue: this.minValue,
      maxValue: this.maxValue,
      rate: this.rate,
      axis: this.axis
    };
  }
}
kM.className = "MinMaxNorm";
Ee(kM);
const sI = {
  maxNorm: "MaxNorm",
  minMaxNorm: "MinMaxNorm",
  nonNeg: "NonNeg",
  unitNorm: "UnitNorm"
};
function es(t) {
  return J_(t);
}
function iI(t, e = {}) {
  return fm(t, Ni.getMap().classNameMap, e, "constraint");
}
function ts(t) {
  if (t == null)
    return null;
  if (typeof t == "string") {
    const n = { className: t in sI ? sI[t] : t, config: {} };
    return iI(n);
  } else
    return t instanceof xm ? t : iI(t);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
async function rc(t) {
  if (t == null)
    return;
  const e = [], n = [], s = [];
  for (const i in t) {
    const r = t[i];
    if (typeof r != "number") {
      const o = r;
      e.push(o.data()), n.push(i), s.push(o);
    }
  }
  if (e.length > 0) {
    const i = await Promise.all(e);
    for (let r = 0; r < i.length; ++r)
      t[n[r]] = i[r][0];
    At(s);
  }
}
function AM(t) {
  if (t != null)
    for (const e in t) {
      const n = t[e];
      typeof n != "number" && n.dispose();
    }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
var rI;
(function(t) {
  t[t.SILENT = 0] = "SILENT", t[t.VERBOSE = 1] = "VERBOSE";
})(rI || (rI = {}));
const t7 = 125;
class Sf {
  constructor() {
    this.validationData = null;
  }
  setParams(e) {
    this.params = e;
  }
  async onEpochBegin(e, n) {
  }
  async onEpochEnd(e, n) {
  }
  async onBatchBegin(e, n) {
  }
  async onBatchEnd(e, n) {
  }
  async onTrainBegin(e) {
  }
  async onTrainEnd(e) {
  }
  // LayersModel needs to call Callback.setModel(), but cannot actually depend
  // on Callback because that creates a cyclic dependency.  Providing this no-op
  // method on BaseCallback breaks the cycle: this way LayersModel can depend on
  // BaseCallback but not on Callback.  The argument is typed as `Container`
  // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback
  // overrides this method and enforces that the argument is really a
  // LayersModel.
  setModel(e) {
  }
}
class n7 {
  // TODO(cais): When the need arises, uncomment the following lines and
  // implement the queue for time values.
  // private deltaTBatch: number;
  // private deltaTsBatchBegin: Array<number>;
  // private deltaTsBatchEnd: Array<number>;
  /**
   * Constructor of CallbackList.
   * @param callbacks Array of `Callback` instances.
   * @param queueLength Queue length for keeping running statistics over
   *   callback execution time.
   */
  constructor(e, n = 10) {
    e == null && (e = []), this.callbacks = e, this.queueLength = n;
  }
  append(e) {
    this.callbacks.push(e);
  }
  setParams(e) {
    for (const n of this.callbacks)
      n.setParams(e);
  }
  setModel(e) {
    for (const n of this.callbacks)
      n.setModel(e);
  }
  /**
   * Called at the start of an epoch.
   * @param epoch Index of epoch.
   * @param logs Dictionary of logs.
   */
  async onEpochBegin(e, n) {
    n == null && (n = {});
    for (const s of this.callbacks)
      await s.onEpochBegin(e, n);
  }
  /**
   * Called at the end of an epoch.
   * @param epoch Index of epoch.
   * @param logs Dictionary of logs.
   */
  async onEpochEnd(e, n) {
    n == null && (n = {});
    for (const s of this.callbacks)
      await s.onEpochEnd(e, n);
  }
  /**
   * Called  right before processing a batch.
   * @param batch Index of batch within the current epoch.
   * @param logs Dictionary of logs.
   */
  async onBatchBegin(e, n) {
    n == null && (n = {});
    for (const s of this.callbacks)
      await s.onBatchBegin(e, n);
  }
  /**
   * Called at the end of a batch.
   * @param batch Index of batch within the current epoch.
   * @param logs Dictionary of logs.
   */
  async onBatchEnd(e, n) {
    n == null && (n = {});
    for (const s of this.callbacks)
      await s.onBatchEnd(e, n);
  }
  /**
   * Called at the beginning of training.
   * @param logs Dictionary of logs.
   */
  async onTrainBegin(e) {
    e == null && (e = {});
    for (const n of this.callbacks)
      await n.onTrainBegin(e);
  }
  /**
   * Called at the end of training.
   * @param logs Dictionary of logs.
   */
  async onTrainEnd(e) {
    e == null && (e = {});
    for (const n of this.callbacks)
      await n.onTrainEnd(e);
  }
}
class s7 extends Sf {
  constructor() {
    super();
  }
  async onEpochBegin(e) {
    this.seen = 0, this.totals = {};
  }
  async onBatchEnd(e, n) {
    n == null && (n = {});
    const s = n.size == null ? 0 : n.size;
    this.seen += s;
    for (const i in n) {
      const r = n[i];
      if (typeof r == "number")
        this.totals.hasOwnProperty(i) || (this.totals[i] = 0), this.totals[i] = this.totals[i] + r * s;
      else {
        let o;
        i in this.totals ? o = this.totals[i] : this.totals[i] = 0;
        const a = Q(() => Se(this.totals[i], q(r, s)));
        this.totals[i] = a, o != null && o.dispose();
      }
    }
  }
  async onEpochEnd(e, n) {
    if (n != null)
      for (const s of this.params.metrics)
        this.totals[s] != null && (typeof this.totals[s] == "number" ? n[s] = this.totals[s] / this.seen : Q(() => {
          const i = q(it(1, this.seen), this.totals[s]);
          n[s] = i, this.totals[s].dispose(), Zn(n[s]);
        }));
  }
}
class i7 extends Sf {
  async onTrainBegin(e) {
    this.epoch = [], this.history = {};
  }
  async onEpochEnd(e, n) {
    n == null && (n = {}), this.epoch.push(e);
    for (const s in n)
      this.history[s] == null && (this.history[s] = []), this.history[s].push(n[s]);
  }
  /**
   * Await the values of all losses and metrics.
   */
  async syncData() {
    const e = [], n = [], s = [];
    for (const r in this.history) {
      const o = this.history[r];
      for (let a = 0; a < o.length; ++a)
        if (typeof o[a] != "number") {
          const c = o[a];
          e.push(c.data()), n.push(r), s.push(a);
        }
    }
    const i = await Promise.all(e);
    for (let r = 0; r < i.length; ++r)
      this.history[n[r]][s[r]].dispose(), this.history[n[r]][s[r]] = i[r][0];
  }
}
class r7 extends Sf {
  constructor(e, n) {
    if (super(), this.currentEpoch = 0, this.nowFunc = e.nowFunc, this.nextFrameFunc = e.nextFrameFunc || M_, this.yieldEvery = n || "auto", this.yieldEvery === "auto" && (this.yieldEvery = t7), this.yieldEvery === "never" && e.onYield != null)
      throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
    ky(this.yieldEvery) && (this.maybeWait = xX(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc)), this.trainBegin = e.onTrainBegin, this.trainEnd = e.onTrainEnd, this.epochBegin = e.onEpochBegin, this.epochEnd = e.onEpochEnd, this.batchBegin = e.onBatchBegin, this.batchEnd = e.onBatchEnd, this.yield = e.onYield;
  }
  async maybeWait(e, n, s) {
    const i = [];
    this.yield != null && (await rc(s), i.push(this.yield(e, n, s))), i.push(this.nextFrameFunc()), await Promise.all(i);
  }
  async onEpochBegin(e, n) {
    this.currentEpoch = e, this.epochBegin != null && (await rc(n), await this.epochBegin(e, n));
  }
  async onEpochEnd(e, n) {
    const s = [];
    this.epochEnd != null && (await rc(n), s.push(this.epochEnd(e, n))), this.yieldEvery === "epoch" && s.push(this.nextFrameFunc()), await Promise.all(s);
  }
  async onBatchBegin(e, n) {
    this.batchBegin != null && (await rc(n), await this.batchBegin(e, n));
  }
  async onBatchEnd(e, n) {
    const s = [];
    this.batchEnd != null && (await rc(n), s.push(this.batchEnd(e, n))), this.yieldEvery === "batch" ? s.push(this.nextFrameFunc()) : ky(this.yieldEvery) && s.push(this.maybeWait(this.currentEpoch, e, n)), await Promise.all(s);
  }
  async onTrainBegin(e) {
    this.trainBegin != null && (await rc(e), await this.trainBegin(e));
  }
  async onTrainEnd(e) {
    this.trainEnd != null && (await rc(e), await this.trainEnd(e));
  }
}
function MM(t, e) {
  return t == null && (t = {}), t instanceof Sf ? [t] : Array.isArray(t) && t[0] instanceof Sf ? t : Zt(t).map((s) => new r7(s, e));
}
class Gi {
  /**
   * Blocks public access to constructor.
   */
  constructor() {
  }
  /**
   * Register a tf.LayersModel.fit() callback constructor.
   *
   * The registered callback constructor will be used to instantiate
   * callbacks for every tf.LayersModel.fit() call afterwards.
   *
   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`
   *   is to be reigstered.
   * @param callbackConstructor A no-arg constructor for `tf.Callback`.
   * @throws Error, if the same callbackConstructor has been registered before,
   *   either at the same or a different `verbosityLevel`.
   */
  static registerCallbackConstructor(e, n) {
    A(e >= 0 && Number.isInteger(e), () => `Verbosity level is expected to be an integer >= 0, but got ${e}`), Gi.checkForDuplicate(n), Gi.constructors[e] == null && (Gi.constructors[e] = []), Gi.constructors[e].push(n);
  }
  static checkForDuplicate(e) {
    for (const n in Gi.constructors)
      Gi.constructors[+n].forEach((i) => {
        if (i === e)
          throw new Z("Duplicate callback constructor.");
      });
  }
  /**
   * Clear all registered callback constructors.
   */
  static clear() {
    Gi.constructors = {};
  }
  /**
   * Create callbacks using the registered callback constructors.
   *
   * Given `verbosityLevel`, all constructors registered at that level or above
   * will be called and the instantiated callbacks will be used.
   *
   * @param verbosityLevel: Level of verbosity.
   */
  static createCallbacks(e) {
    const n = [];
    for (const s in Gi.constructors) {
      const i = +s;
      e >= i && n.push(...Gi.constructors[i]);
    }
    return n.map((s) => new s());
  }
}
Gi.constructors = {};
function RM(t, e, n, s, i, r, o, a, c) {
  const l = new i7(), u = [
    new s7(),
    ...Gi.createCallbacks(e)
  ];
  t != null && u.push(...t), u.push(l);
  const h = new n7(u);
  return h.setParams({
    epochs: n,
    initialEpoch: s,
    samples: i,
    steps: r,
    batchSize: o,
    verbose: e,
    doValidation: a,
    metrics: c
  }), { callbackList: h, history: l };
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Io(t, e = {}, n = !1) {
  return fm(t, Ni.getMap().classNameMap, e, "layer", n);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Uy(t, e) {
  return Q(() => {
    t.dtype !== "float32" && (t = Le(t, "float32"));
    const n = Qe(mm(t), e, !0), s = nl(n.shape, Jn()), i = us(lo(n, s));
    return it(t, i);
  });
}
function yb(t, e) {
  return Q(() => En(mm(je(e, t)), -1));
}
function uT(t, e) {
  return Q(() => En(jn(je(e, t)), -1));
}
function hT(t, e) {
  return Q(() => {
    const n = je(t, e), s = Gs(jn(t), Jn(), Number.MAX_VALUE), i = jn(it(n, s));
    return q(100, En(i, -1));
  });
}
function o7(t, e) {
  return Q(() => {
    const n = Gs(e, Jn(), Number.MAX_VALUE), s = bi(Se(1, n)), i = Gs(t, Jn(), Number.MAX_VALUE), r = bi(Se(1, i));
    return En(mm(je(s, r)), -1);
  });
}
function a7(t, e) {
  return Q(() => {
    const n = lo(0, je(1, q(t, e)));
    return En(mm(n), -1);
  });
}
function c7(t, e) {
  return Q(() => {
    const n = lo(0, je(1, q(t, e)));
    return En(n, -1);
  });
}
function l7(t, e) {
  return Q(() => {
    const n = Qe(q(t, e), -1), s = Ri(q(je(1, t), e), -1);
    return lo(0, Se(1, je(s, n)));
  });
}
function u7(t, e) {
  return Q(() => {
    const n = Math.log(2), s = je(e, t), i = je(Se(s, sl(q(-2, s))), n);
    return En(i, -1);
  });
}
function _f(t, e, n = !1) {
  return Q(() => {
    if (n)
      e = rm(e);
    else {
      const s = Qe(e, e.shape.length - 1, !0);
      e = it(e, s);
    }
    return e = Gs(e, Jn(), 1 - Jn()), hn(Qe(q(Le(t, "float32"), bi(e)), e.shape.length - 1));
  });
}
function Gy(t, e, n = !1) {
  return Q(() => {
    const s = Le(Oh(AX(t)), "int32");
    e = Gs(e, Jn(), 1 - Jn());
    const i = e.shape, r = Y(Gc(s, i[i.length - 1]), i);
    return _f(r, e, n);
  });
}
function h7(t, e) {
  if (!Bt(t.shape, e.shape))
    throw new Z(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);
  return Q(() => {
    const n = kr(e), s = hn(jn(e));
    return Se(je(n, q(e, t)), Kp(ii(s)));
  });
}
function xb(t, e) {
  return Q(() => {
    let n;
    return n = Gs(e, Jn(), 1 - Jn()), n = bi(it(n, je(1, n))), En(h7(t, n), -1);
  });
}
function d7(t, e) {
  return Q(() => {
    const n = Gs(t, Jn(), 1), s = Gs(e, Jn(), 1);
    return Qe(q(t, bi(it(n, s))), -1);
  });
}
function f7(t, e) {
  return Q(() => {
    const n = bi(Se(Jn(), e));
    return En(je(e, q(t, n)), -1);
  });
}
function DM(t, e) {
  return Q(() => {
    const n = Uy(t, -1), s = Uy(e, -1), i = q(n, s);
    return hn(Qe(i, -1));
  });
}
const Wy = {
  meanSquaredError: yb,
  meanAbsoluteError: uT,
  meanAbsolutePercentageError: hT,
  meanSquaredLogarithmicError: o7,
  squaredHinge: a7,
  hinge: c7,
  categoricalHinge: l7,
  logcosh: u7,
  categoricalCrossentropy: _f,
  sparseCategoricalCrossentropy: Gy,
  binaryCrossentropy: xb,
  kullbackLeiblerDivergence: d7,
  poisson: f7,
  cosineProximity: DM
};
function _v(t) {
  if (typeof t == "string") {
    if (t in Wy)
      return Wy[t];
    let e = `Unknown loss ${t}`;
    throw t.toLowerCase().includes("softmaxcrossentropy") && (e = `Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`), new Z(e);
  } else
    return t;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function $M(t, e) {
  return Q(() => {
    const n = q(0.5, vi(e)), s = Kr(js(e, n), t.dtype);
    return En(xi(t, s), -1);
  });
}
function OM(t, e) {
  return Q(() => Kr(xi(Ea(t, -1), Ea(e, -1)), "float32"));
}
function p7(t, e) {
  return Q(() => Le(Qe(_r(xi(t, 1), xi(e, 1))), "float32"));
}
function m7(t, e) {
  return Q(() => Le(Qe(_r(xi(t, 0), xi(e, 1))), "float32"));
}
function g7(t, e) {
  return Q(() => {
    const n = p7(t, e), s = m7(t, e), i = Se(n, s);
    return Le(bs(js(i, 0), it(n, i), 0), "float32");
  });
}
function y7(t, e) {
  return xb(t, e);
}
function x7(t, e) {
  return t.rank === e.rank && (t = ys(t, [t.rank - 1])), e = Ea(e, -1), e.dtype !== t.dtype && (e = Le(e, t.dtype)), Le(xi(t, e), "float32");
}
const b7 = yb, v7 = yb, w7 = uT, S7 = uT, _7 = hT, T7 = hT, LM = _f, C7 = DM, FM = Gy, Hy = {
  binaryAccuracy: $M,
  categoricalAccuracy: OM,
  precision: g7,
  categoricalCrossentropy: LM,
  sparseCategoricalCrossentropy: FM,
  mse: b7,
  MSE: v7,
  mae: w7,
  MAE: S7,
  mape: _7,
  MAPE: T7,
  cosine: C7
};
function I7(t) {
  if (typeof t == "string" && t in Hy)
    return Hy[t];
  if (typeof t != "string" && t != null)
    return t;
  throw new Z(`Unknown metric ${t}`);
}
function bg(t) {
  if (zr(t !== null, `Unknown LossOrMetricFn ${t}`), typeof t == "string")
    return t;
  {
    let e;
    for (const n of Object.keys(Wy))
      if (Wy[n] === t) {
        e = n;
        break;
      }
    if (e !== void 0)
      return e;
    for (const n of Object.keys(Hy))
      if (Hy[n] === t) {
        e = n;
        break;
      }
    return e !== void 0 ? e : t.name;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function E7(t) {
  const e = {
    Adagrad: () => lc.adagrad(0.01),
    Adadelta: () => lc.adadelta(1, 0.95, Jn()),
    Adam: () => lc.adam(1e-3, 0.9, 0.999, Jn()),
    Adamax: () => lc.adamax(2e-3, 0.9, 0.999, Jn(), 0),
    RMSProp: () => lc.rmsprop(1e-3, 0.9, 0, Jn()),
    SGD: () => lc.sgd(0.01)
  };
  if (e.adagrad = e.Adagrad, e.adadelta = e.Adadelta, e.adam = e.Adam, e.adamax = e.Adamax, e.rmsprop = e.RMSProp, e.sgd = e.SGD, t in e)
    return e[t]();
  throw new Z(`Unknown Optimizer ${t}`);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const oI = 1 * 1024 * 1024;
function aI(t, e, n = !1) {
  if (t == null || typeof t != "object" || Object.getPrototypeOf(t) !== Object.prototype || !o1(t))
    throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
  if (n) {
    const s = JSON.stringify(t);
    s.length > oI && console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${oI}.`);
  }
}
function o1(t) {
  if (t === null)
    return !0;
  if (typeof t == "object")
    if (Object.getPrototypeOf(t) === Object.prototype) {
      const e = Object.keys(t);
      for (const n of e)
        if (typeof n != "string" || !o1(t[n]))
          return !1;
      return !0;
    } else if (Array.isArray(t)) {
      for (const e of t)
        if (!o1(e))
          return !1;
      return !0;
    } else
      return !1;
  else {
    const e = typeof t;
    return e === "string" || e === "number" || e === "boolean";
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function N7(t, e, n, s = console.log) {
  const i = A7(t), r = ["Layer (type)", "Input Shape", "Output shape", "Param #"];
  i ? (e = e || 90, n = n || [0.32, 0.61, 0.89, 1]) : (e = e || 115, n = n || [0.24, 0.48, 0.7, 0.8, 1]), n[n.length - 1] <= 1 && (n = n.map((u) => Math.floor(e * u)));
  let o;
  if (!i) {
    r.push("Receives inputs"), o = [];
    for (const u in t.nodesByDepth)
      o.push(...t.nodesByDepth[u]);
  }
  s("_".repeat(e)), jy(r, n, s), s("=".repeat(e));
  const a = t.layers;
  for (let u = 0; u < a.length; ++u)
    i ? M7(a[u], n, s) : R7(a[u], n, o, s), s((u === a.length - 1 ? "=" : "_").repeat(e));
  t.checkTrainableWeightsConsistency();
  const c = k7(t), l = By(t.nonTrainableWeights);
  s(`Total params: ${c + l}`), s(`Trainable params: ${c}`), s(`Non-trainable params: ${l}`), s("_".repeat(e));
}
function k7(t) {
  let e;
  return t.collectedTrainableWeights != null ? e = By(t.collectedTrainableWeights) : e = By(t.trainableWeights), e;
}
function A7(t) {
  let e = !0;
  const n = [], s = [];
  for (const i in t.nodesByDepth)
    n.push(t.nodesByDepth[i]);
  for (const i of n) {
    if (i.length > 1 || i.length === 1 && i[0].inboundLayers.length > 1) {
      e = !1;
      break;
    }
    s.push(...i);
  }
  if (e)
    for (const i of t.layers) {
      let r = !1;
      for (const o of i.inboundNodes)
        if (s.indexOf(o) !== -1)
          if (r) {
            e = !1;
            break;
          } else
            r = !0;
      if (!e)
        break;
    }
  return e;
}
function jy(t, e, n = console.log) {
  let s = "";
  for (let i = 0; i < t.length; ++i)
    i > 0 && (s = s.slice(0, s.length - 1) + " "), s += t[i], s = s.slice(0, e[i]), s += " ".repeat(e[i] - s.length);
  n(s);
}
function M7(t, e, n) {
  let s, i;
  try {
    i = t.inboundNodes.map((c) => JSON.stringify(c.inputShapes)).join(",");
  } catch {
    i = "multiple";
  }
  try {
    s = JSON.stringify(t.outputShape);
  } catch {
    s = "multiple";
  }
  const r = t.name, o = t.getClassName(), a = [
    `${r} (${o})`,
    i,
    s,
    t.countParams().toString()
  ];
  jy(a, e, n);
}
function R7(t, e, n, s) {
  let i, r;
  try {
    r = t.inboundNodes.map((h) => JSON.stringify(h.inputShapes)).join(",");
  } catch {
    r = "multiple";
  }
  try {
    i = JSON.stringify(t.outputShape);
  } catch {
    i = "multiple";
  }
  const o = [];
  for (const h of t.inboundNodes)
    if (!(n != null && n.length > 0 && n.indexOf(h) === -1))
      for (let d = 0; d < h.inboundLayers.length; ++d) {
        const f = h.inboundLayers[d].name, p = h.nodeIndices[d], y = h.tensorIndices[d];
        o.push(`${f}[${p}][${y}]`);
      }
  const a = t.name, c = t.getClassName(), l = o.length === 0 ? "" : o[0], u = [
    `${a} (${c})`,
    r,
    i,
    t.countParams().toString(),
    l
  ];
  jy(u, e, s);
  for (let h = 1; h < o.length; ++h)
    jy(["", "", "", "", o[h]], e, s);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function PM(t, e, n) {
  return (t === "inboundNodes" || t === "outputLayers" || t === "inputLayers") && e === 0 && typeof n == "string";
}
function a1(t, e) {
  if (t === null)
    return null;
  if (typeof t == "string")
    return dc(t);
  if (typeof t == "number" || typeof t == "boolean")
    return t;
  if (t instanceof Array) {
    const n = [], s = t.length;
    for (let i = 0; i < s; ++i) {
      const r = t[i];
      PM(e, i, r) ? n.push(r) : n.push(a1(r, e));
    }
    return n;
  } else {
    const n = {};
    for (const s of Object.keys(t)) {
      const i = t[s];
      if (s === "name" && typeof i == "string")
        n[s] = i;
      else {
        const r = dc(s);
        n[r] = a1(i, r);
      }
    }
    return n;
  }
}
function c1(t, e) {
  if (t == null)
    return null;
  if (typeof t == "string")
    return wo(t);
  if (typeof t == "number" || typeof t == "boolean")
    return t;
  if (t instanceof Array) {
    const n = [], s = t.length;
    for (let i = 0; i < s; ++i) {
      const r = t[i];
      PM(e, i, r) ? n.push(r) : n.push(c1(r, e));
    }
    return n;
  } else {
    const n = {};
    for (const s of Object.keys(t)) {
      const i = t[s], r = wo(s);
      (s === "name" || s === "className") && typeof i == "string" ? n[r] = i : n[r] = c1(i, s);
    }
    return n;
  }
}
/** @license See the LICENSE file. */
const BM = "4.22.0";
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const D7 = (t) => {
  const e = Object.keys(t);
  if (e.length === 0)
    return !1;
  const n = e[0].split("/");
  return !isNaN(parseInt(n[n.length - 1], 10));
};
class fr extends Ft {
  constructor(e) {
    if (super({}), this.containerNodes = /* @__PURE__ */ new Set(), this.name = e.name, this.name == null) {
      const x = this.getClassName().toLowerCase();
      this.name = pb(x);
    }
    if (this.supportsMasking = !1, this.trainable_ = !0, Array.isArray(e.inputs) ? this.inputs = e.inputs.slice() : this.inputs = [e.inputs], Array.isArray(e.outputs) ? this.outputs = e.outputs.slice() : this.outputs = [e.outputs], ga(this.inputs).length !== this.inputs.length)
      throw new Z(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((x) => x.name)}`);
    ga(this.outputs).length !== this.outputs.length && console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((x) => x.name)}`), this.inputLayers = [], this.inputLayersNodeIndices = [], this.inputLayersTensorIndices = [], this.outputLayers = [], this.outputLayersNodeIndices = [], this.outputLayersTensorIndices = [], this.layers = [], this.internalContainerRefs = [];
    for (const x of this.outputs) {
      const v = x.sourceLayer, b = x.nodeIndex, w = x.tensorIndex;
      this.outputLayers.push(v), this.outputLayersNodeIndices.push(b), this.outputLayersTensorIndices.push(w);
    }
    for (const x of this.inputs) {
      const v = x.sourceLayer, b = x.nodeIndex, w = x.tensorIndex;
      zr(b === 0, "input layer has >1 nodes"), zr(w === 0, "input layer has >1 tensors"), this.inputLayers.push(v), this.inputLayersNodeIndices.push(b), this.inputLayersTensorIndices.push(w);
    }
    this.inputNames = [], this.outputNames = [], this.feedInputShapes = [], this.feedInputNames = [], this.feedOutputNames = [];
    for (let x = 0; x < this.inputLayers.length; x++) {
      const v = this.inputLayers[x];
      if (!(v instanceof ym))
        throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${x} (0-based) originates from layer type ${v.getClassName()}.`);
      this.inputNames.push(v.name), this.feedInputShapes.push(v.batchInputShape), this.feedInputNames.push(v.name);
    }
    for (const x of this.outputLayers)
      this.outputNames.push(x.name);
    this.internalInputShapes = this.inputs.map((x) => x.shape), this.internalOutputShapes = this.outputs.map((x) => x.shape);
    const n = {}, s = {}, i = {}, r = {}, o = {}, a = [], c = (x, v, b, w, S, _) => {
      (w == null || S == null || _ == null) && (w = x.sourceLayer, S = x.nodeIndex, _ = x.tensorIndex);
      const E = w.inboundNodes[S];
      if (b.indexOf(E) !== -1)
        throw new Ki(`The tensor ${x.name} at layer "${w.name}" is part of a cycle.`);
      if (v.indexOf(E) !== -1)
        return;
      this.containerNodes.add(fr.nodeKey(w, S)), w.id in o || (o[w.id] = Object.keys(o).length), b.indexOf(E) === -1 && b.push(E);
      const I = E.inboundLayers.length;
      for (let k = 0; k < I; k++) {
        const M = E.inputTensors[k], L = E.inboundLayers[k], O = E.nodeIndices[k], $ = E.tensorIndices[k];
        c(M, v, b, L, O, $);
      }
      for (v.push(E); b.indexOf(E) >= 0; )
        b.splice(b.indexOf(E), 1);
      a.push(E);
    }, l = [], u = [];
    for (const x of this.outputs)
      c(x, l, u);
    const h = a.slice().reverse();
    for (const x of h) {
      s[x.id] = x, x.id in n || (n[x.id] = 0);
      let v = n[x.id];
      const b = i[x.outboundLayer.id] == null ? 0 : i[x.outboundLayer.id];
      v = Math.max(v, b), i[x.outboundLayer.id] = v, r[x.outboundLayer.id] = x.outboundLayer, n[x.id] = v;
      for (let w = 0; w < x.inboundLayers.length; w++) {
        const S = x.inboundLayers[w], _ = x.nodeIndices[w], E = S.inboundNodes[_], I = n[E.id] == null ? 0 : n[E.id];
        n[E.id] = Math.max(v + 1, I), s[E.id] = E;
      }
    }
    const d = {};
    for (const x in n) {
      const v = n[x];
      v in d || (d[v] = []), d[v].push(s[x]);
    }
    const f = {};
    for (const x in i) {
      const v = i[x];
      v in f || (f[v] = []), f[v].push(r[x]);
    }
    let p = Object.keys(f).map((x) => parseInt(x, 10)).sort(gg);
    this.layers = [];
    for (const x of p) {
      const v = f[x];
      v.sort((b, w) => {
        const S = o[b.id], _ = o[w.id];
        return S < _ ? -1 : S > _ ? 1 : 0;
      });
      for (const b of v)
        b instanceof fr && this.internalContainerRefs.push(b), this.layers.push(b);
    }
    this.layersByDepth = f, p = Object.keys(d).map((x) => parseInt(x, 10)).sort(gg);
    const y = this.inputs.slice(), g = [];
    for (const x of p)
      for (const v of d[x]) {
        const b = v.outboundLayer;
        if (b != null) {
          for (const w of v.inputTensors)
            if (y.indexOf(w) === -1)
              throw new Ki(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${b.name}". The following previous layers were accessed without issue: ${g}`);
          for (const w of v.outputTensors)
            y.push(w);
          g.push(b.name);
        }
      }
    this.nodesByDepth = d;
    const m = this.layers.map((x) => x.name);
    for (const x of m) {
      const v = m.filter((b) => b === x).length;
      if (v !== 1)
        throw new Ki(`The name "${x}" is used ${v} times in the model. All layer names should be unique. Layer names: ` + JSON.stringify(m));
    }
    this.outboundNodes = [], this.inboundNodes = [], new gb({
      outboundLayer: this,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: this.inputs,
      outputTensors: this.outputs,
      inputMasks: this.inputs.map((x) => null),
      outputMasks: this.outputs.map((x) => null),
      inputShapes: this.inputs.map((x) => x.shape),
      outputShapes: this.outputs.map((x) => x.shape)
    }), this.built = !0, this._refCount = 1;
  }
  assertNotDisposed() {
    if (this._refCount === 0)
      throw new Error(`Container '${this.name}' is already disposed.`);
  }
  /**
   * Attempt to dispose a LayersModel's weights.
   *
   * This method decrease the reference count of the LayersModel object by 1.
   *
   * A LayersModel is reference-counted. Its reference count is incremented by 1
   * when it is first constructed and when it is used as a Layer of another
   * LayersModel.
   *
   * If the reference count of a LayersModel becomes 0, the `dispose` method of
   * all its constituent `Layer`s will be called.
   *
   * Note: If the reference count is greater than 0 after the decrement, the
   * `dispose` method of its constituent `Layer`s will *not* be called.
   *
   * After a LayersModel is disposed, it cannot be used in calls such as
   * 'predict`, `evaluate` or `fit` anymore.
   *
   * @returns A DisposeResult Object with the following fields:
   *   - refCountAfterDispose: The reference count of the LayersModel after this
   *     `dispose()` call.
   *   - numDisposedVariables: Number of `tf.Variable`s (i.e., weights) disposed
   *     during this `dispose()` call.
   * @throws {Error} If the layer is not built yet, or if the LayersModel has
   *   already been disposed.
   */
  dispose() {
    this.assertNotDisposed();
    const e = { refCountAfterDispose: null, numDisposedVariables: 0 };
    if (--this._refCount === 0) {
      for (const n of this.layers)
        e.numDisposedVariables += n.dispose().numDisposedVariables;
      for (const n of this.internalContainerRefs)
        e.numDisposedVariables += n.dispose().numDisposedVariables;
    }
    return e.refCountAfterDispose = this._refCount, e;
  }
  get trainable() {
    return this.trainable_;
  }
  set trainable(e) {
    this.layers.forEach((n) => {
      n._trainableWeights.forEach((s) => s.trainable = e);
    }), this.trainable_ = e;
  }
  get trainableWeights() {
    if (this._trainableWeights.length > 0)
      throw new Z("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
    if (!this.trainable)
      return [];
    let e = [];
    for (const n of this.layers)
      e = e.concat(n.trainableWeights);
    return e;
  }
  get nonTrainableWeights() {
    const e = [];
    for (const n of this.layers)
      e.push(...n.nonTrainableWeights);
    if (!this.trainable) {
      const n = [];
      for (const s of this.layers)
        n.push(...s.trainableWeights);
      return n.concat(e);
    }
    return e;
  }
  get weights() {
    return this.trainableWeights.concat(this.nonTrainableWeights);
  }
  /**
   * Loads all layer weights from a JSON object.
   *
   * Porting Note: HDF5 weight files cannot be directly loaded in JavaScript /
   *   TypeScript. The utility script at `scripts/pykeras.py` offers means
   *   to convert them into JSON strings compatible with this method.
   * Porting Note: TensorFlow.js Layers supports only loading by name currently.
   *
   * @param weights A JSON mapping weight names to weight values as nested
   *   arrays of numbers, or a `NamedTensorMap`, i.e., a JSON mapping weight
   *   names to `tf.Tensor` objects.
   * @param strict Require that the provided weights exactly match those
   *   required by the container.  Default: `true`.  Passing `false` means that
   *   extra weights and missing weights will be silently ignored.
   */
  loadWeights(e, n = !0) {
    const s = {};
    let i = 0;
    const r = D7(e);
    r && this.parseWeights(e);
    for (const a of this.layers)
      for (const [c, l] of a.weights.entries()) {
        const u = r ? `${l.name.split("/").slice(0, -1).join("/") + "/"}${c}` : l.originalName;
        if (s[u] != null)
          throw new Z(`Duplicate weight name: ${u}`);
        s[u] = l, i++;
      }
    const o = [];
    for (const a in e) {
      let c = a;
      if (s[a] == null) {
        const l = a.split("/");
        c = l.slice(0, -2).concat([l[l.length - 1]]).join("/");
      }
      if (s[c] != null)
        o.push([s[c], e[a]]);
      else if (n)
        throw new Z(`Provided weight data has no target variable: ${a}`);
      delete s[c];
    }
    if (n) {
      const a = [];
      for (const c in s)
        a.push(c);
      if (a.length > 0)
        throw new Z(`${a.length} of ${i} weights are not set: ${a}`);
    }
    cT(o);
  }
  parseWeights(e) {
    for (const n in Object.keys(e)) {
      const s = n.split("/"), i = ["vars", "layer_checkpoint_dependencies"], r = s.map((o) => o.startsWith("_") ? o.slice(1) : o).filter((o) => !i.includes(o)).join("/");
      r !== n && (e[r] = e[n], delete e[n]);
    }
  }
  /**
   * Util shared between different serialization methods.
   * @returns LayersModel config with Keras version information added.
   */
  updatedConfig() {
    const e = this.getConfig(), n = {};
    return n.className = this.getClassName(), n.config = e, n.kerasVersion = `tfjs-layers ${BM}`, n.backend = "TensorFlow.js", n;
  }
  /**
   * Returns a JSON string containing the network configuration.
   *
   * To load a network from a JSON save file, use
   * models.modelFromJSON(jsonString);
   * @param extraJsonArgs Unused in tfjs-layers, maintained for PyKeras
   * @param returnString Whether the return value should be stringified
   *    (default: `true`).
   * @returns a JSON string if `returnString` (default), or a JSON object if
   *   `!returnString`.
   */
  // tslint:disable-next-line:no-any
  toJSON(e, n = !0) {
    const s = c1(this.updatedConfig());
    return n ? JSON.stringify(s) : s;
  }
  /**
   * Call the model on new inputs.
   *
   * In this case `call` just reapplies all ops in the graph to the new inputs
   * (e.g. build a new computational graph from the provided inputs).
   *
   * @param inputs A tensor or list of tensors.
   * @param mask A mask or list of masks. A mask can be either a tensor or null
   *   (no mask).
   *
   * @return A tensor if there is a single output, or a list of tensors if there
   *   are more than one outputs.
   */
  call(e, n) {
    return Q(() => {
      e = Zt(e);
      const s = new la();
      for (let i = 0; i < this.inputs.length; ++i)
        s.add(this.inputs[i], e[i]);
      return pd(this.outputs, s, n);
    });
  }
  /**
   * Computes an output mask tensor.
   *
   * @param inputs Tensor or list of tensors.
   * @param mask Tensor or list of tensors.
   *
   * @return null or a tensor (or list of tensors, one per output tensor of the
   * layer).
   */
  computeMask(e, n) {
    return Q(() => {
      e = Zt(e);
      let s;
      return n == null ? s = Hc(null, e.length) : s = Zt(n), this.runInternalGraph(e, s)[1];
    });
  }
  /**
   * Computes the output shape of the layer.
   *
   * Assumes that the layer will be built to match that input shape provided.
   *
   * @param inputShape A shape (tuple of integers) or a list of shape tuples
   *   (one per output tensor of the layer). Shape tuples can include null for
   *   free dimensions, instead of an integer.
   */
  computeOutputShape(e) {
    const n = Py(e);
    if (n.length !== this.inputLayers.length)
      throw new Z(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);
    const s = {};
    for (let a = 0; a < n.length; a++) {
      const c = this.inputLayers[a], l = n[a], u = c.name + "_0_0";
      s[u] = l;
    }
    const i = Object.keys(this.nodesByDepth).map((a) => parseInt(a, 10)).sort(gg);
    if (i.length > 1)
      for (const a of i) {
        const c = this.nodesByDepth[a];
        for (const l of c) {
          const u = l.outboundLayer;
          if (this.inputLayers.map((y) => y.id).indexOf(u.id) !== -1)
            continue;
          const h = [];
          for (let y = 0; y < l.inboundLayers.length; y++) {
            const g = l.inboundLayers[y], m = l.nodeIndices[y], x = l.tensorIndices[y], v = `${g.name}_${m}_${x}`, b = s[v];
            h.push(b);
          }
          const d = u.computeOutputShape(Zs(h)), f = Py(d), p = u.inboundNodes.indexOf(l);
          for (let y = 0; y < f.length; y++) {
            const g = `${u.name}_${p}_${y}`;
            s[g] = f[y];
          }
        }
      }
    const r = [], o = [];
    for (let a = 0; a < this.outputLayers.length; a++) {
      const c = this.outputLayers[a], l = this.outputLayersNodeIndices[a], u = this.outputLayersTensorIndices[a], h = `${c.name}_${l}_${u}`;
      o.push(h);
    }
    for (let a = 0; a < o.length; a++) {
      const c = o[a];
      zr(c in s), r.push(s[c]);
    }
    return Zs(r);
  }
  /**
   * Computes output tensors for new inputs.
   *
   * Note:
   *   - Expects `inputs` to be a list (potentially with 1 element).
   *
   * @param inputs List of tensors
   * @param masks List of masks (tensors or null).
   * @return Three lists: outputTensors, outputMasks, outputShapes
   */
  runInternalGraph(e, n) {
    n == null && (n = Hc(null, e.length));
    const s = {};
    for (let c = 0; c < this.inputs.length; ++c) {
      const l = this.inputs[c], u = e[c], h = n[c];
      s[l.id] = [u, h];
    }
    const i = Object.keys(this.nodesByDepth).map((c) => parseInt(c, 10)).sort(gg);
    for (const c of i) {
      const l = this.nodesByDepth[c];
      for (const u of l) {
        const h = u.outboundLayer, d = u.inputTensors, f = u.outputTensors, p = new Array();
        for (const y of d)
          y.id in s && p.push(s[y.id]);
        if (p.length === d.length) {
          let y = {}, g, m, x, v;
          if (u.callArgs != null && (y = u.callArgs), p.length === 1) {
            const [b, w] = p[0];
            y.mask == null && (y.mask = w), x = Zt(h.call(b, y)), v = Zt(h.computeMask(b, w)), g = [b], m = [w];
          } else
            g = p.map((b) => b[0]), m = p.map((b) => b[1]), y.mask == null && (y.mask = m), x = Zt(h.call(g, y)), v = Zt(h.computeMask(g, m));
          if (h.activityRegularizer)
            throw new Ct("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
          for (let b = 0; b < f.length; ++b) {
            const w = f[b], S = x[b], _ = v[b];
            s[w.id] = [S, _];
          }
        }
      }
    }
    const r = [], o = [], a = [];
    for (const c of this.outputs) {
      zr(c.id in s, `Could not compute output ${c.name} : ${c.id}`);
      const [l, u] = s[c.id];
      a.push(l.shape), r.push(l), o.push(u);
    }
    return [r, o, a];
  }
  /**
   * Builds a map of internal node keys to node ordering.
   * Used in serializaion a node orderings may change as unused nodes are
   * dropped. Porting Note:  This helper method was pulled out of getConfig to
   * improve readability.
   * @param layers An array of Layers in the model.
   * @returns Map of Node Keys to index order within the layer.
   */
  buildNodeConversionMap(e) {
    const n = {};
    let s;
    for (const i of this.layers) {
      s = i instanceof fr ? 1 : 0;
      for (let r = 0; r < i.inboundNodes.length; r++) {
        const o = fr.nodeKey(i, r);
        this.containerNodes.has(o) && (n[o] = s, s += 1);
      }
    }
    return n;
  }
  getLayer(e, n) {
    if (n != null)
      return this.findLayer(n);
    if (e == null)
      throw new Z("Provide either a layer name or layer index");
    if (typeof e == "number")
      return this.findLayer(e);
    for (const s of this.layers)
      if (s.name === e)
        return s;
    throw new Z(`No such layer: ${e}`);
  }
  findLayer(e) {
    if (this.layers.length <= e)
      throw new Z(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);
    return this.layers[e];
  }
  /**
   * Retrieves the Container's current loss values.
   *
   * Used for regularizers during training.
   */
  calculateLosses() {
    return Q(() => {
      const e = [];
      for (const n of this.layers)
        for (let s = 0; s < n.inboundNodes.length; ++s) {
          const i = fr.nodeKey(n, s);
          this.containerNodes.has(i) && e.push(...n.calculateLosses());
        }
      return e;
    });
  }
  getConfig() {
    const e = { name: this.name }, n = this.buildNodeConversionMap(this.layers), s = [];
    for (const o of this.layers) {
      const a = o.getClassName(), c = o.getConfig(), l = [];
      for (let h = 0; h < o.inboundNodes.length; h++) {
        const d = o.inboundNodes[h], f = fr.nodeKey(o, h);
        let p = {};
        if (this.containerNodes.has(f)) {
          if (d.callArgs)
            try {
              JSON.stringify(d.callArgs), p = d.callArgs;
            } catch {
              console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`), p = {};
            }
          if (d.inboundLayers.length > 0) {
            const y = [];
            for (let g = 0; g < d.inboundLayers.length; g++) {
              const m = d.inboundLayers[g], x = d.nodeIndices[g], v = d.tensorIndices[g], b = fr.nodeKey(m, x);
              let w = n[b];
              w == null && (w = 0), y.push([m.name, w, v, p]);
            }
            l.push(y);
          }
        }
      }
      const u = {};
      u.name = o.name, u.className = a, u.config = c, u.inboundNodes = l, s.push(u);
    }
    e.layers = s;
    const i = [];
    for (let o = 0; o < this.inputLayers.length; o++) {
      const a = this.inputLayers[o], c = this.inputLayersNodeIndices[o], l = fr.nodeKey(a, c);
      if (!this.containerNodes.has(l))
        continue;
      let u = n[l];
      u == null && (u = 0);
      const h = this.inputLayersTensorIndices[o];
      i.push([a.name, u, h]);
    }
    e.inputLayers = i;
    const r = [];
    for (let o = 0; o < this.outputLayers.length; o++) {
      const a = this.outputLayers[o], c = this.outputLayersNodeIndices[o], l = fr.nodeKey(a, c);
      if (!this.containerNodes.has(l))
        continue;
      let u = n[l];
      u == null && (u = 0);
      const h = this.outputLayersTensorIndices[o];
      r.push([a.name, u, h]);
    }
    return e.outputLayers = r, e;
  }
  /**
   * Instantiates a LayersModel from its config (output of `get_config()`).
   * @param cls the class to create
   * @param config LayersModel config dictionary.
   * @param customObjects An optional dictionary of custom objects.
   * @param fastWeightInit Optional flag to use fast weight initialization
   *   during deserialization. This is applicable to cases in which
   *   the initialization will be immediately overwritten by loaded weight
   *   values. Default: `false`.
   * @returns A LayersModel instance.
   * @throws ValueError: In case of improperly formatted config dict.
   */
  /** @nocollapse */
  static fromConfig(e, n, s = {}, i = !1) {
    const r = {}, o = {};
    function a(g, m) {
      g.name in o ? o[g.name].push(m) : o[g.name] = [m];
    }
    function c(g, m) {
      const x = [];
      let v;
      for (const b of m) {
        const w = b[0], S = b[1], _ = b[2];
        if (v = b[3] == null ? {} : b[3], !(w in r)) {
          a(g, m);
          return;
        }
        const E = r[w];
        if (E.inboundNodes.length <= S) {
          a(g, m);
          return;
        }
        const I = E.inboundNodes[S];
        x.push(I.outputTensors[_]);
      }
      x.length > 0 && g.apply(Zs(x), v);
    }
    function l(g) {
      const m = g.name, x = Io(g, n.customObjects != null ? n.customObjects : {});
      x.setFastWeightInitDuringBuild(i), r[m] = x, g.inboundNodes.forEach((b) => {
        if (!(b instanceof Array))
          throw new Z(`Corrupted configuration, expected array for nodeData: ${b}`);
        a(x, b);
      });
    }
    const u = n.name, h = n.layers;
    for (const g of h)
      l(g);
    for (; !yX(o); )
      for (const g of h) {
        const m = r[g.name];
        if (m.name in o) {
          const x = o[m.name];
          delete o[m.name];
          for (const v of x)
            c(m, v);
        }
      }
    const d = [], f = [], p = n.inputLayers;
    for (const g of p) {
      const m = g[0], x = g[1], v = g[2];
      zr(m in r);
      const w = r[m].inboundNodes[x].outputTensors;
      d.push(w[v]);
    }
    const y = n.outputLayers;
    for (const g of y) {
      const m = g[0], x = g[1], v = g[2];
      zr(m in r);
      const w = r[m].inboundNodes[x].outputTensors;
      f.push(w[v]);
    }
    return new e({ inputs: d, outputs: f, name: u });
  }
  /**
   * Determine whether the container is stateful.
   *
   * Porting Note: this is the equivalent of the stateful @property of
   *   the Container class in PyKeras.
   */
  get stateful() {
    if (this._stateful)
      throw new Z("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
    for (const e of this.layers)
      if (e.stateful)
        return !0;
    return !1;
  }
  /**
   * Reset the state of all stateful constituent layers (if any).
   *
   * Examples of stateful layers include RNN layers whose `stateful` property
   * is set as `true`.
   */
  resetStates() {
    Q(() => {
      this.layers.forEach((e) => {
        e.stateful && e.resetStates();
      });
    });
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function $7(t, e, n) {
  const s = e.length;
  if (t == null || Array.isArray(t) && t.length === 0)
    return e.map((i) => null);
  if (s === 1)
    return Array.isArray(t) && t.length === 1 ? t : typeof t == "object" && e[0] in t ? [t[e[0]]] : [t];
  if (Array.isArray(t)) {
    if (t.length !== s)
      throw new Error(`Provided ${n} is an array of ${t.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);
    return t;
  } else if (typeof t == "object" && Object.keys(t).length > 0 && typeof t[Object.keys(t)[0]] == "object") {
    const i = [];
    return e.forEach((r) => {
      r in t ? i.push(t[r]) : i.push(null);
    }), i;
  } else
    throw new Error(`The model has multiple (${s}) outputs, so ${n} must be either an array with ${s} elements or an object with ${e} keys. Provided ${n} not understood: ${JSON.stringify(t)}`);
}
function zM(t, e) {
  return $7(t, e, "classWeight");
}
async function VM(t, e, n, s) {
  if (e != null || s != null)
    throw new Error("Support sampleWeight is not implemented yet");
  if (n != null) {
    const i = Q(() => {
      if (t.shape.length === 1)
        return qr(t);
      if (t.shape.length === 2) {
        if (t.shape[1] > 1)
          return Ea(t, 1);
        if (t.shape[1] === 1)
          return Y(t, [t.shape[0]]);
        throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`);
      } else
        throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`);
    }), r = Array.from(await i.data());
    At(i);
    const o = [];
    return r.forEach((a) => {
      if (n[a] == null)
        throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);
      o.push(n[a]);
    }), Ns(o, "float32");
  } else
    return null;
}
function O7(t, e) {
  return q(t, e);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const L7 = 32;
function UM(t, e) {
  let n, s;
  const i = e;
  n = i.xs, s = i.ys, A(n != null && s != null, () => `A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);
  const r = cI("input", t.inputNames, n), o = cI("output", t.outputNames, s), a = r[0].shape[0];
  A(r.length === t.inputs.length, () => `LayersModel has ${t.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`), A(o.length === t.outputs.length, () => `LayersModel has ${t.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);
  for (let c = 0; c < r.length; c++)
    A(r[c].shape[0] === a, () => `Batch size mismatch: input ${t.inputNames[c]} has ${r[c].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);
  for (let c = 0; c < o.length; c++)
    A(o[c].shape[0] === a, () => `Batch size mismatch: output ${t.outputNames[c]} has ${o[c].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);
  return { xs: r, ys: o };
}
function cI(t, e, n) {
  if (n instanceof Lt)
    return [n];
  if (Array.isArray(n))
    return A(n.length === e.length, () => `Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`), n;
  {
    const s = [];
    for (const i of e) {
      if (n[i] == null)
        throw new Z(`The feature data generated by the dataset lacks the required ${t} key '${i}'.`);
      s.push(n[i]);
    }
    return s;
  }
}
function F7(t) {
  if (t.length === 3)
    throw new Ct("Validation with sample weights is not implemented yet.");
  return { xs: t[0], ys: t[1] };
}
async function P7(t, e, n) {
  const s = n.batchesPerEpoch != null;
  if (A(t.optimizer != null, () => "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."), A(n != null, () => "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."), A(n.epochs != null && n.epochs > 0 && Number.isInteger(n.epochs), () => `For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`), A(!s || n.batchesPerEpoch > 0 && Number.isInteger(n.batchesPerEpoch), () => `For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`), A(
    // tslint:disable-next-line:no-any
    n.validationSplit == null,
    () => "`validationSplit` is not supported by `fitDataset()`. Use validationData instead."
  ), t.isTraining)
    throw new Error("Cannot start training because another fit() call is ongoing.");
  t.isTraining = !0;
  try {
    const i = n.validationData != null;
    let r, o;
    if (i)
      if (lI(n.validationData))
        A(n.validationBatches == null || n.validationBatches > 0 && Number.isInteger(n.validationBatches), () => `For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);
      else {
        const g = F7(n.validationData);
        r = g.xs, o = g.ys;
      }
    const a = t.makeTrainFunction(), c = t.getDedupedMetricsNames();
    let l;
    i ? l = c.slice().concat(c.map((g) => "val_" + g)) : l = c.slice();
    const u = MM(n.callbacks, n.yieldEvery), h = n.verbose == null ? 1 : n.verbose, { callbackList: d, history: f } = RM(
      u,
      h,
      n.epochs,
      null,
      null,
      B7(e, n),
      null,
      // Batch size determined by the dataset itself.
      i,
      l
    );
    d.setModel(t), t.history = f, await d.onTrainBegin(), t.stopTraining_ = !1;
    let p = n.initialEpoch == null ? 0 : n.initialEpoch, y = await e.iterator();
    for (; p < n.epochs; ) {
      const g = {};
      await d.onEpochBegin(p);
      let m = 0, x = 0;
      for (s || (y = await e.iterator()); !s || m < n.batchesPerEpoch; ) {
        const v = await y.next();
        if (s && v.done) {
          console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${m} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch * n.epochs} batches). You may need to use the repeat() function when building your dataset.`);
          break;
        }
        if (v.value != null) {
          const { xs: b, ys: w } = UM(t, v.value), S = {};
          S.batch = x, S.size = b[0].shape[0], await d.onBatchBegin(x, S);
          const _ = [];
          if (n.classWeight != null) {
            const k = zM(n.classWeight, t.outputNames);
            for (let M = 0; M < k.length; ++M)
              _.push(await VM(w[M], null, k[M]));
          }
          const E = b.concat(w).concat(_), I = a(E);
          At(E);
          for (let k = 0; k < c.length; ++k) {
            const M = c[k], L = I[k];
            S[M] = L, Zn(L);
          }
          await d.onBatchEnd(x, S), AM(S), x++, m++;
        }
        if (s ? m >= n.batchesPerEpoch : v.done) {
          if (i) {
            let b;
            lI(n.validationData) ? b = Zt(await t.evaluateDataset(n.validationData, { batches: n.validationBatches })) : b = Zt(t.evaluate(r, o, {
              batchSize: n.validationBatchSize == null ? L7 : n.validationBatchSize,
              verbose: 0
            }));
            for (let w = 0; w < t.metricsNames.length; ++w)
              g[`val_${t.metricsNames[w]}`] = b[w];
          }
          break;
        }
        if (t.stopTraining_)
          break;
      }
      if (await d.onEpochEnd(p, g), p++, t.stopTraining_)
        break;
    }
    return await d.onTrainEnd(), await t.history.syncData(), t.history;
  } finally {
    t.isTraining = !1;
  }
}
function B7(t, e) {
  let n = null;
  return e.batchesPerEpoch != null ? n = e.batchesPerEpoch : Number.isFinite(t.size) && (n = t.size), n;
}
function lI(t) {
  return typeof t.iterator == "function";
}
function z7(t) {
  return typeof t.next == "function";
}
async function V7(t, e, n) {
  n = n || {};
  const s = n.batches != null, i = t.testFunction;
  let r = [];
  if (n.verbose > 0)
    throw new Ct("Verbose mode is not implemented yet.");
  A(!s || n.batches > 0 && Number.isInteger(n.batches), () => `Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);
  const o = z7(e) ? e : await e.iterator();
  let a = 0, c = 0;
  for (; !s || c < n.batches; ) {
    const l = await o.next();
    if (r = Q(() => {
      if (l.value) {
        const { xs: u, ys: h } = UM(t, l.value), d = u.concat(h), f = Q(() => i(d));
        if (At(d), c === 0)
          for (let y = 0; y < f.length; ++y)
            r.push(ot(0));
        const p = d[0].shape[0];
        for (let y = 0; y < f.length; ++y) {
          const g = f[y], m = r[y];
          r[y] = Q(() => Se(r[y], q(p, g))), c > 0 && At(m);
        }
        At(f), a += p, ++c;
      }
      return r;
    }), l.done) {
      s && console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);
      break;
    }
  }
  for (let l = 0; l < r.length; ++l) {
    const u = r[l];
    r[l] = it(r[l], a), At(u);
  }
  return Zs(r);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Tv(t) {
  A(t > 0 && Number.isInteger(t), () => `batchSize is required to be a positive integer, but got ${t}`);
}
function od(t, e, n) {
  return t == null ? [null] : Array.isArray(t) ? t.map((s) => Cc(s, e, n - e)) : Cc(t, e, n - e);
}
function l1(t, e) {
  return Q(() => t == null ? null : Array.isArray(t) ? t.map((n) => l1(n, e)) : gM(t, e.dtype === "int32" ? e : Le(e, "int32")));
}
function Cv(t, e) {
  const n = [];
  let s = 0, i = null;
  for (; s < t; )
    i = s + e, i >= t && (i = t), n.push([s, i]), s = i;
  return n;
}
function GM(t) {
  const e = [];
  t instanceof Lt && (t = [t]);
  for (let n = 0; n < t.length; ++n) {
    const s = t[n];
    if (s.rank === 1)
      e.push(pm(s, 1));
    else {
      if (s.rank === 0)
        throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
      e.push(s);
    }
  }
  return e;
}
function hr(t, e) {
  if (t == null)
    return;
  const n = [];
  if (e instanceof Lt)
    n.push(e.id);
  else if (Array.isArray(e))
    e.forEach((i) => n.push(i.id));
  else if (e != null)
    for (const i in e) {
      const r = e[i];
      n.push(r.id);
    }
  const s = [];
  if (t instanceof Lt)
    n.indexOf(t.id) === -1 && s.push(t);
  else if (Array.isArray(t))
    t.forEach((i) => {
      n.indexOf(i.id) === -1 && s.push(i);
    });
  else if (t != null)
    for (const i in t) {
      const r = t[i];
      n.indexOf(r.id) === -1 && s.push(r);
    }
  s.forEach((i) => {
    i.isDisposed || i.dispose();
  });
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function U7(t) {
  return t instanceof Lt;
}
function u1(t) {
  return Array.isArray(t);
}
function uI(t) {
  return !U7(t) && !u1(t);
}
function hI(t, e, n, s = !0, i = "") {
  if (e == null || e.length === 0) {
    if (t != null) {
      let o = !1;
      if (u1(t) && t.length > 0)
        o = !0;
      else if (uI(t)) {
        for (const a in t)
          if (t.hasOwnProperty(a)) {
            o = !0;
            break;
          }
      } else
        o = !0;
      if (o)
        throw new Z(`Error when checking model ${i} expected no data, but got ${t}`);
    }
    return [];
  }
  if (t == null)
    return e.map((o) => null);
  let r;
  if (uI(t)) {
    t = t, r = [];
    for (const o of e) {
      if (t[o] == null)
        throw new Z(`No data provided for "${o}". Need data for each key in: ${e}`);
      r.push(t[o]);
    }
  } else if (u1(t)) {
    if (t = t, t.length !== e.length)
      throw new Z(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);
    r = t;
  } else {
    if (t = t, e.length > 1)
      throw new Z(`The model ${i} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);
    r = [t];
  }
  if (r = GM(r), n != null)
    for (let o = 0; o < e.length; ++o) {
      if (n[o] == null)
        continue;
      const a = r[o];
      if (a.shape.length !== n[o].length)
        throw new Z(`Error when checking ${i}: expected ${e[o]} to have ${n[o].length} dimension(s). but got array with shape ${a.shape}`);
      for (let c = 0; c < n[o].length; ++c) {
        if (c === 0 && !s)
          continue;
        const l = a.shape[c], u = n[o][c];
        if (u != null && u >= 0 && l !== u)
          throw new Z(`${i} expected a batch of elements where each example has shape [${n[o].slice(1, n[o].length)}] (i.e.,tensor shape [*,${n[o].slice(1, n[o].length)}]) but the ${i} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1, a.shape.length)}] (tensor shape [${a.shape}])`);
      }
    }
  return r;
}
function G7(t, e, n) {
  const s = ga(t.map((r) => r.shape[0]));
  s.sort();
  const i = ga(e.map((r) => r.shape[0]));
  if (i.sort(), s.length > 1)
    throw new Z(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((r) => r.shape))}`);
  if (i.length > 1)
    throw new Z(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((r) => r.shape))}`);
  if (s.length > 0 && i.length > 0 && !Bt(s, i))
    throw new Z(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${i[0]} target sample(s).`);
}
function W7(t, e, n) {
  const s = [
    yb,
    xb,
    _f
  ];
  for (let i = 0; i < t.length; ++i) {
    const r = t[i], o = e[i], a = n[i];
    if (o != null) {
      if (o === _f && r.shape[r.shape.length - 1] === 1)
        throw new Z(`You are passing a target array of shape ${r.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);
      if (s.indexOf(o) !== -1) {
        const c = r.shape.slice(1), l = a.slice(1);
        for (let u = 0; u < c.length; ++u) {
          const h = c[u], d = l[u];
          if (d != null && h !== d)
            throw new Z(`A target Tensor with shape ${r.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`);
        }
      }
    }
  }
}
function dI(t, e, n, s = !0, i = "") {
  let r;
  if (Array.isArray(t)) {
    if (t.length !== e.length)
      throw new Z(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);
    r = t;
  } else {
    if (e.length > 1)
      throw new Z(`The model expects ${e.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);
    r = [t];
  }
  if (n != null)
    for (let o = 0; o < e.length; ++o) {
      if (n[o] == null)
        continue;
      const a = r[o];
      if (a.shape.length !== n[o].length)
        throw new Z(`Error when checking ${i}: expected ${e[o]} to have ${n[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);
      for (let c = 0; c < n[o].length; ++c) {
        if (c === 0 && !s)
          continue;
        const l = a.shape[c], u = n[o][c];
        if (u != null && u !== l)
          throw new Z(`Error when checking ${i}: expected ${e[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(a.shape)}.`);
      }
    }
}
function H7(t, e) {
  if (t == null || Array.isArray(t) && t.length === 0)
    return e.map((s) => []);
  let n;
  if (typeof t == "string" || typeof t == "function")
    n = [t];
  else if (Array.isArray(t) || typeof t == "object")
    n = t;
  else
    throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);
  if (Array.isArray(n))
    return e.map((s) => n);
  {
    const s = [];
    for (const i of e) {
      let r = n.hasOwnProperty(i) ? n[i] : [];
      Array.isArray(r) || (r = [r]), s.push(r);
    }
    return s;
  }
}
const j7 = "layers-model";
class Zl extends fr {
  constructor(e) {
    super(e), this.isTraining = !1;
  }
  /**
   * Print a text summary of the model's layers.
   *
   * The summary includes
   * - Name and type of all layers that comprise the model.
   * - Output shape(s) of the layers
   * - Number of weight parameters of each layer
   * - If the model has non-sequential-like topology, the inputs each layer
   *   receives
   * - The total number of trainable and non-trainable parameters of the model.
   *
   * ```js
   * const input1 = tf.input({shape: [10]});
   * const input2 = tf.input({shape: [20]});
   * const dense1 = tf.layers.dense({units: 4}).apply(input1);
   * const dense2 = tf.layers.dense({units: 8}).apply(input2);
   * const concat = tf.layers.concatenate().apply([dense1, dense2]);
   * const output =
   *     tf.layers.dense({units: 3, activation: 'softmax'}).apply(concat);
   *
   * const model = tf.model({inputs: [input1, input2], outputs: output});
   * model.summary();
   * ```
   *
   * @param lineLength Custom line length, in number of characters.
   * @param positions Custom widths of each of the columns, as either
   *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number
   *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to
   *   right-most (i.e., ending) position of a column.
   * @param printFn Custom print function. Can be used to replace the default
   *   `console.log`. For example, you can use `x => {}` to mute the printed
   *   messages in the console.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  summary(e, n, s = console.log) {
    if (!this.built)
      throw new Z("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
    N7(this, e, n, s);
  }
  /**
   * Configures and prepares the model for training and evaluation.  Compiling
   * outfits the model with an optimizer, loss, and/or metrics.  Calling `fit`
   * or `evaluate` on an un-compiled model will throw an error.
   *
   * @param args a `ModelCompileArgs` specifying the loss, optimizer, and
   * metrics to be used for fitting and evaluating this model.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  compile(e) {
    if (e.loss == null && (e.loss = []), this.loss = e.loss, typeof e.optimizer == "string")
      this.optimizer_ = E7(e.optimizer), this.isOptimizerOwned = !0;
    else {
      if (!(e.optimizer instanceof jo))
        throw new Z("User-defined optimizer must be an instance of tf.Optimizer.");
      this.optimizer_ = e.optimizer, this.isOptimizerOwned = !1;
    }
    let n = [];
    if (!Array.isArray(e.loss) && typeof e.loss != "string" && typeof e.loss != "function") {
      e.loss = e.loss;
      for (const o in e.loss)
        if (this.outputNames.indexOf(o) === -1)
          throw new Z(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);
      for (const o of this.outputNames)
        e.loss[o] == null && console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`), n.push(_v(e.loss[o]));
    } else if (Array.isArray(e.loss)) {
      if (e.loss.length !== this.outputs.length)
        throw new Z(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);
      n = e.loss.map((a) => _v(a));
    } else {
      const o = _v(e.loss);
      this.outputs.forEach((a) => {
        n.push(o);
      });
    }
    this.lossFunctions = n, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
    for (let o = 0; o < this.outputs.length; ++o) {
      const a = this.internalOutputShapes[o], c = this.outputNames[o];
      this.feedOutputNames.push(c), this.feedOutputShapes.push(a), this.feedLossFns.push(this.lossFunctions[o]);
    }
    const s = [];
    this.metrics = e.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], Tc("loss", () => {
      for (let o = 0; o < this.outputs.length; ++o) {
        if (s.indexOf(o) !== -1)
          continue;
        const a = this.lossFunctions[o];
        this.outputs.length > 1 && (this.metricsTensors.push([a, o]), this.metricsNames.push(this.outputNames[o] + "_loss"));
      }
    });
    const i = H7(e.metrics, this.outputNames), r = (o, a, c) => {
      this.outputNames.length > 1 && (a = this.outputNames[o] + "_" + a), this.metricsNames.push(a), this.metricsTensors.push([c, o]);
    };
    Tc("metric", () => {
      for (let o = 0; o < this.outputs.length; ++o) {
        if (s.indexOf(o) !== -1)
          continue;
        const a = i[o];
        ((l) => {
          const u = "";
          let h, d, f;
          for (const p of l) {
            if (typeof p == "string" && ["accuracy", "acc", "crossentropy", "ce"].indexOf(p) !== -1) {
              const g = this.internalOutputShapes[o];
              g[g.length - 1] === 1 || this.lossFunctions[o] === xb ? ["accuracy", "acc"].indexOf(p) !== -1 ? d = $M : ["crossentropy", "ce"].indexOf(p) !== -1 && (d = y7) : this.lossFunctions[o] === Gy ? ["accuracy", "acc"].indexOf(p) !== -1 ? d = x7 : ["crossentropy", "ce"].indexOf(p) !== -1 && (d = FM) : ["accuracy", "acc"].indexOf(p) !== -1 ? d = OM : ["crossentropy", "ce"].indexOf(p) !== -1 && (d = LM);
              let m;
              ["accuracy", "acc"].indexOf(p) !== -1 ? m = "acc" : ["crossentropy", "ce"].indexOf(p) !== -1 && (m = "ce"), f = d, h = u + m;
            } else
              f = I7(p), h = u + bg(p);
            let y;
            Tc(h, () => {
              y = f;
            }), r(o, h, y);
          }
        })(a);
      }
    }), this.collectedTrainableWeights = this.trainableWeights;
  }
  /**
   * Check trainable weights count consistency.
   *
   * This will raise a warning if `this.trainableWeights` and
   * `this.collectedTrainableWeights` are inconsistent (i.e., have different
   * numbers of parameters).
   * Inconsistency will typically arise when one modifies `model.trainable`
   * without calling `model.compile()` again.
   */
  checkTrainableWeightsConsistency() {
    this.collectedTrainableWeights != null && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
  }
  /**
   * Returns the loss value & metrics values for the model in test mode.
   *
   * Loss and metrics are specified during `compile()`, which needs to happen
   * before calls to `evaluate()`.
   *
   * Computation is done in batches.
   *
   * ```js
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});
   * const result = model.evaluate(
   *     tf.ones([8, 10]), tf.ones([8, 1]), {batchSize: 4});
   * result.print();
   * ```
   *
   * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the
   * model has multiple inputs.
   * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the
   * model has multiple outputs.
   * @param args A `ModelEvaluateArgs`, containing optional fields.
   *
   * @return `Scalar` test loss (if the model has a single output and no
   *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs
   *   and/or metrics). The attribute `model.metricsNames`
   *   will give you the display labels for the scalar outputs.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  evaluate(e, n, s = {}) {
    const i = s.batchSize == null ? 32 : s.batchSize;
    Tv(i);
    const r = !0, o = this.standardizeUserDataXY(e, n, r, i);
    try {
      const a = o[0].concat(o[1]);
      this.makeTestFunction();
      const c = this.testFunction, l = this.testLoop(c, a, i, s.verbose, s.steps);
      return Zs(l);
    } finally {
      hr(o[0], e), hr(o[1], n);
    }
  }
  // TODO(cais): Add code snippet below once real dataset objects are
  //   available.
  /**
   * Evaluate model using a dataset object.
   *
   * Note: Unlike `evaluate()`, this method is asynchronous (`async`).
   *
   * @param dataset A dataset object. Its `iterator()` method is expected
   *   to generate a dataset iterator object, the `next()` method of which
   *   is expected to produce data batches for evaluation. The return value
   *   of the `next()` call ought to contain a boolean `done` field and a
   *   `value` field. The `value` field is expected to be an array of two
   *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former
   *   case is for models with exactly one input and one output (e.g.
   *   a sequential model). The latter case is for models with multiple
   *   inputs and/or multiple outputs. Of the two items in the array, the
   *   first is the input feature(s) and the second is the output target(s).
   * @param args A configuration object for the dataset-based evaluation.
   * @returns Loss and metric values as an Array of `Scalar` objects.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async evaluateDataset(e, n) {
    return this.makeTestFunction(), V7(this, e, n);
  }
  /**
   * Get number of samples provided for training, evaluation or prediction.
   *
   * @param ins Input `tf.Tensor`.
   * @param batchSize Integer batch size, optional.
   * @param steps Total number of steps (batches of samples) before
   * declaring loop finished. Optional.
   * @param stepsName The public API's parameter name for `steps`.
   * @returns Number of samples provided.
   */
  checkNumSamples(e, n, s, i = "steps") {
    let r;
    if (s != null) {
      if (r = null, n != null)
        throw new Z(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${n}`);
    } else if (e != null)
      Array.isArray(e) ? r = e[0].shape[0] : r = e.shape[0];
    else
      throw new Z(`Either the input data should have a defined shape, or ${i} shoud be specified.`);
    return r;
  }
  /**
   * Execute internal tensors of the model with input data feed.
   * @param inputs Input data feed. Must match the inputs of the model.
   * @param outputs Names of the output tensors to be fetched. Must match
   *   names of the SymbolicTensors that belong to the graph.
   * @returns Fetched values for `outputs`.
   */
  execute(e, n) {
    if (Array.isArray(n) && n.length === 0)
      throw new Z("`outputs` is an empty Array, which is not allowed.");
    const s = Array.isArray(n), i = s ? n : [n], r = this.retrieveSymbolicTensors(i), o = new la();
    if (e instanceof Lt && (e = [e]), Array.isArray(e)) {
      if (e.length !== this.inputs.length)
        throw new Z(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);
      for (let c = 0; c < this.inputs.length; ++c)
        o.add(this.inputs[c], e[c]);
    } else
      for (const c of this.inputs) {
        const l = e[c.name];
        if (l == null)
          throw new Z(`No value is provided for the model's input ${c.name}`);
        o.add(c, l);
      }
    const a = pd(r, o);
    return s ? a : a[0];
  }
  /**
   * Retrieve the model's internal symbolic tensors from symbolic-tensor names.
   */
  retrieveSymbolicTensors(e) {
    const n = Hc(null, e.length);
    let s = e.length;
    for (const i of this.layers) {
      const r = Array.isArray(i.output) ? i.output : [i.output], o = r.map((a) => a.name);
      for (let a = 0; a < e.length; ++a) {
        const c = o.indexOf(e[a]);
        if (c !== -1 && (n[a] = r[c], s--), s === 0)
          break;
      }
      if (s === 0)
        break;
    }
    if (s > 0) {
      const i = [];
      throw n.forEach((r, o) => {
        r == null && i.push(e[o]);
      }), new Z(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`);
    }
    return n;
  }
  /**
   * Helper method to loop over some data in batches.
   *
   * Porting Note: Not using the functional approach in the Python equivalent
   *   due to the imperative backend.
   * Porting Note: Does not support step mode currently.
   *
   * @param ins: input data
   * @param batchSize: integer batch size.
   * @param verbose: verbosity model
   * @returns: Predictions as `tf.Tensor` (if a single output) or an `Array` of
   *   `tf.Tensor` (if multipe outputs).
   */
  predictLoop(e, n = 32, s = !1) {
    return Q(() => {
      const i = this.checkNumSamples(e);
      if (s)
        throw new Ct("Verbose predictLoop() is not implemented yet.");
      const r = Cv(i, n), o = this.outputs.map((a) => []);
      for (let a = 0; a < r.length; ++a)
        Q(() => {
          const l = r[a][0], u = r[a][1], h = od(e, l, u), d = [];
          if (Array.isArray(h))
            for (let p = 0; p < h.length; ++p)
              d.push({ key: this.inputs[p], value: h[p] });
          else
            d.push({ key: this.inputs[0], value: h });
          const f = new la(d);
          return pd(this.outputs, f);
        }).forEach((l, u) => o[u].push(l));
      return Zs(o.map((a) => Pn(a, 0)));
    });
  }
  /**
   * Generates output predictions for the input samples.
   *
   * Computation is done in batches.
   *
   * Note: the "step" mode of predict() is currently not supported.
   *   This is because the TensorFlow.js core backend is imperative only.
   *
   * ```js
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.predict(tf.ones([8, 10]), {batchSize: 4}).print();
   * ```
   *
   * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if
   *   the model has multiple inputs.
   * @param args A `ModelPredictArgs` object containing optional fields.
   *
   * @return Prediction results as a `tf.Tensor`(s).
   *
   * @exception ValueError In case of mismatch between the provided input data
   *   and the model's expectations, or in case a stateful model receives a
   *   number of samples that is not a multiple of the batch size.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  predict(e, n = {}) {
    const s = GM(e);
    dI(s, this.inputNames, this.feedInputShapes, !1);
    try {
      const i = n.batchSize == null ? 32 : n.batchSize;
      return Tv(i), this.predictLoop(s, i);
    } finally {
      hr(s, e);
    }
  }
  /**
   * Returns predictions for a single batch of samples.
   *
   * ```js
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.predictOnBatch(tf.ones([8, 10])).print();
   * ```
   * @param x: Input samples, as a Tensor (for models with exactly one
   *   input) or an array of Tensors (for models with more than one input).
   * @return Tensor(s) of predictions
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  predictOnBatch(e) {
    dI(e, this.inputNames, this.feedInputShapes, !0);
    const n = (Array.isArray(e) ? e[0] : e).shape[0];
    return this.predictLoop(e, n);
  }
  standardizeUserDataXY(e, n, s = !0, i) {
    if (this.optimizer_ == null)
      throw new Ki("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
    const r = [];
    for (let o = 0; o < this.feedOutputShapes.length; ++o) {
      const a = this.feedOutputShapes[o];
      this.feedLossFns[o] === Gy ? r.push(a.slice(0, a.length - 1).concat([1])) : r.push(a);
    }
    if (e = hI(e, this.feedInputNames, this.feedInputShapes, !1, "input"), n = hI(n, this.feedOutputNames, r, !1, "target"), G7(e, n), W7(n, this.feedLossFns, this.feedOutputShapes), this.stateful && i != null && i > 0 && e[0].shape[0] % i !== 0)
      throw new Z(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);
    return [e, n];
  }
  async standardizeUserData(e, n, s, i, r = !0, o) {
    const [a, c] = this.standardizeUserDataXY(e, n, r, o);
    if (s != null)
      throw new Error("sample weight is not supported yet.");
    let l = null;
    if (i != null) {
      const u = zM(i, this.outputNames);
      l = [];
      for (let h = 0; h < u.length; ++h)
        l.push(await VM(c[h], null, u[h]));
    }
    return [a, c, l];
  }
  /**
   * Loop over some test data in batches.
   * @param f A Function returning a list of tensors.
   * @param ins Array of tensors to be fed to `f`.
   * @param batchSize Integer batch size or `null` / `undefined`.
   * @param verbose verbosity mode.
   * @param steps Total number of steps (batches of samples) before
   * declaring test finished. Ignored with the default value of `null` /
   * `undefined`.
   * @returns Array of Scalars.
   */
  testLoop(e, n, s, i = 0, r) {
    return Q(() => {
      const o = this.checkNumSamples(n, s, r, "steps"), a = [];
      if (i > 0)
        throw new Ct("Verbose mode is not implemented yet.");
      if (r != null)
        throw new Ct("steps mode in testLoop() is not implemented yet");
      {
        const c = Cv(o, s), l = Ns(Tr(0, o));
        for (let u = 0; u < c.length; ++u) {
          const h = c[u][0], d = c[u][1], f = Cc(l, h, d - h), p = l1(n, f), y = e(p);
          if (u === 0)
            for (let g = 0; g < y.length; ++g)
              a.push(ot(0));
          for (let g = 0; g < y.length; ++g) {
            const m = y[g];
            a[g] = Se(a[g], q(d - h, m));
          }
        }
        for (let u = 0; u < a.length; ++u)
          a[u] = it(a[u], o);
      }
      return a;
    });
  }
  getDedupedMetricsNames() {
    const e = this.metricsNames, n = [];
    for (let s = 0; s < e.length; ++s) {
      const i = e[s];
      let r = i;
      if (Y2(e, i) > 1) {
        const o = Y2(e.slice(0, s), i);
        r += `_${o}`;
      }
      n.push(r);
    }
    return n;
  }
  /**
   * Creates a function that performs the following actions:
   *
   * 1. computes the losses
   * 2. sums them to get the total loss
   * 3. call the optimizer computes the gradients of the LayersModel's
   *    trainable weights w.r.t. the total loss and update the variables
   * 4. calculates the metrics
   * 5. returns the values of the losses and metrics.
   */
  makeTrainFunction() {
    return (e) => {
      const n = [], s = e.slice(0, this.inputs.length), i = e.slice(this.inputs.length, this.inputs.length + this.outputs.length), r = e.slice(this.inputs.length + this.outputs.length, this.inputs.length + this.outputs.length * 2), o = [], a = () => {
        const h = [];
        for (let y = 0; y < this.inputs.length; ++y)
          h.push({ key: this.inputs[y], value: s[y] });
        const d = new la(h), f = pd(this.outputs, d, { training: !0 });
        let p;
        for (let y = 0; y < this.lossFunctions.length; ++y) {
          const g = this.lossFunctions[y];
          let m = g(i[y], f[y]);
          r[y] != null && (m = O7(m, r[y]));
          const x = En(m);
          n.push(x), y === 0 ? p = m : p = Se(p, m);
        }
        for (let y = 0; y < this.metricsTensors.length; ++y) {
          let g;
          if (this.outputs.length > 1 && y < this.outputs.length)
            g = n[y];
          else {
            const m = this.metricsTensors[y][0], x = this.metricsTensors[y][1];
            g = En(m(i[x], f[x]));
          }
          Zn(g), o.push(g);
        }
        return p = En(p), this.calculateLosses().forEach((y) => {
          p = Se(p, y);
        }), p;
      }, c = this.collectedTrainableWeights.map((h) => h.read()), l = !0;
      return [this.optimizer_.minimize(a, l, c)].concat(o);
    };
  }
  /**
   * Create a function which, when invoked with an array of `tf.Tensor`s as a
   * batch of inputs, returns the prespecified loss and metrics of the model
   * under the batch of input data.
   */
  makeTestFunction() {
    this.testFunction = (e) => Q(() => {
      const n = [];
      let s;
      const i = e.slice(0, this.inputs.length), r = e.slice(this.inputs.length, this.inputs.length + this.outputs.length), o = [];
      for (let l = 0; l < this.inputs.length; ++l)
        o.push({ key: this.inputs[l], value: i[l] });
      const a = new la(o), c = pd(this.outputs, a);
      for (let l = 0; l < this.lossFunctions.length; ++l) {
        const u = this.lossFunctions[l], h = En(u(r[l], c[l]));
        l === 0 ? s = h : s = Se(s, h), n.push(s);
      }
      for (let l = 0; l < this.metricsTensors.length; ++l) {
        const u = this.metricsTensors[l][0], h = this.metricsTensors[l][1], d = En(u(r[h], c[h]));
        n.push(d);
      }
      return n;
    });
  }
  /**
   * Trains the model for a fixed number of epochs (iterations on a
   * dataset).
   *
   * ```js
   * const model = tf.sequential({
   *     layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});
   * for (let i = 1; i < 5 ; ++i) {
   *   const h = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {
   *       batchSize: 4,
   *       epochs: 3
   *   });
   *   console.log("Loss after Epoch " + i + " : " + h.history.loss[0]);
   * }
   * ```
   *
   * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the
   * model has multiple inputs. If all inputs in the model are named, you
   * can also pass a dictionary mapping input names to `tf.Tensor`s.
   * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if
   * the model has multiple outputs. If all outputs in the model are named,
   * you can also pass a dictionary mapping output names to `tf.Tensor`s.
   * @param args A `ModelFitArgs`, containing optional fields.
   *
   * @return A `History` instance. Its `history` attribute contains all
   *   information collected during training.
   *
   * @exception ValueError In case of mismatch between the provided input
   * data and what the model expects.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async fit(e, n, s = {}) {
    if (this.isTraining)
      throw new Error("Cannot start training because another fit() call is ongoing.");
    this.isTraining = !0;
    let i, r, o, a, c, l, u, h, d;
    try {
      const f = s.batchSize == null ? 32 : s.batchSize;
      Tv(f);
      const p = !1, y = await this.standardizeUserData(e, n, s.sampleWeight, s.classWeight, p, f);
      i = y[0], r = y[1], d = y[2];
      let g = !1, m;
      if (s.validationData != null && s.validationData.length > 0) {
        if (g = !0, s.validationData.length === 2)
          c = s.validationData[0], l = s.validationData[1];
        else
          throw s.validationData.length === 3 ? new Ct("validationData including sample weights is not supported yet.") : new Z(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);
        const I = !0, k = await this.standardizeUserData(
          c,
          l,
          null,
          /** Unused sample weights. */
          null,
          /** Unused class weights. */
          I,
          f
        );
        u = k[0], h = k[1], m = u.concat(h);
      } else if (s.validationSplit != null && s.validationSplit > 0 && s.validationSplit < 1) {
        g = !0;
        const I = Math.floor(i[0].shape[0] * (1 - s.validationSplit)), k = i[0].shape[0];
        u = od(i, I, k), o = i, i = od(i, 0, I), h = od(r, I, k), a = r, r = od(r, 0, I), m = u.concat(h);
      } else
        s.validationSteps != null && (g = !0);
      const x = i.concat(r).concat(d);
      this.checkTrainableWeightsConsistency();
      const v = this.makeTrainFunction(), b = this.getDedupedMetricsNames();
      let w, S;
      g ? (this.makeTestFunction(), w = this.testFunction, S = b.slice().concat(b.map((I) => "val_" + I))) : (w = null, m = [], S = b.slice());
      const _ = MM(s.callbacks, s.yieldEvery);
      return await this.fitLoop(v, x, b, f, s.epochs, s.verbose, _, w, m, s.shuffle, S, s.initialEpoch, null, null);
    } finally {
      this.isTraining = !1, hr(i, e), hr(r, n), hr(o, e), hr(a, n), hr(u, c), hr(h, l), d != null && At(d);
    }
  }
  /**
   * Abstract fit function for `f(ins)`.
   * @param f A Function returning a list of tensors. For training, this
   *   function is expected to perform the updates to the variables.
   * @param ins List of tensors to be fed to `f`.
   * @param outLabels List of strings, display names of the outputs of `f`.
   * @param batchSize Integer batch size or `== null` if unknown. Default : 32.
   * @param epochs Number of times to iterate over the data. Default : 1.
   * @param verbose Verbosity mode: 0, 1, or 2. Default: 1.
   * @param callbacks List of callbacks to be called during training.
   * @param valF Function to call for validation.
   * @param valIns List of tensors to be fed to `valF`.
   * @param shuffle Whether to shuffle the data at the beginning of every
   * epoch. Default : true.
   * @param callbackMetrics List of strings, the display names of the metrics
   *   passed to the callbacks. They should be the concatenation of the
   *   display names of the outputs of `f` and the list of display names
   *   of the outputs of `valF`.
   * @param initialEpoch Epoch at which to start training (useful for
   *   resuming a previous training run). Default : 0.
   * @param stepsPerEpoch Total number of steps (batches on samples) before
   *   declaring one epoch finished and starting the next epoch. Ignored with
   *   the default value of `undefined` or `null`.
   * @param validationSteps Number of steps to run validation for (only if
   *   doing validation from data tensors). Not applicable for tfjs-layers.
   * @returns A `History` object.
   */
  async fitLoop(e, n, s, i, r, o, a, c, l, u, h, d, f, p) {
    i == null && (i = 32), r == null && (r = 1), u == null && (u = !0), d == null && (d = 0);
    let y = !1;
    if (c != null && l != null && (y = !0), p != null && (y = !0, f == null))
      throw new Z("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
    const g = this.checkNumSamples(n, i, f, "steps_per_epoch");
    let m;
    g != null && (m = Tr(0, g)), o == null && (o = 1);
    const { callbackList: x, history: v } = RM(a, o, r, d, g, f, i, y, h);
    x.setModel(this), this.history = v, await x.onTrainBegin(), this.stopTraining_ = !1;
    for (let b = d; b < r; ++b) {
      await x.onEpochBegin(b);
      const w = {};
      if (f != null)
        throw new Ct("stepsPerEpoch mode is not implemented yet.");
      {
        if (u === "batch")
          throw new Ct("batch shuffling is not implemneted yet");
        u && H1(m);
        const S = Ns(m), _ = Cv(g, i);
        for (let E = 0; E < _.length; ++E) {
          const I = {};
          if (await x.onBatchBegin(E, I), Q(() => {
            const k = _[E][0], M = _[E][1], L = Cc(S, k, M - k);
            I.batch = E, I.size = M - k;
            const O = l1(n, L), $ = e(O);
            for (let D = 0; D < s.length; ++D) {
              const z = s[D], W = $[D];
              I[z] = W, Zn(W);
            }
            if (E === _.length - 1 && y) {
              const D = this.testLoop(c, l, i);
              for (let z = 0; z < s.length; ++z) {
                const W = s[z], j = D[z];
                Zn(j), w["val_" + W] = j;
              }
            }
          }), await x.onBatchEnd(E, I), AM(I), this.stopTraining_)
            break;
        }
        S.dispose();
      }
      if (await x.onEpochEnd(b, w), this.stopTraining_)
        break;
    }
    return await x.onTrainEnd(), await this.history.syncData(), this.history;
  }
  // TODO(cais): Add code snippet below when it's possible to instantiate
  //   actual dataset objects.
  /**
   * Trains the model using a dataset object.
   *
   * @param dataset A dataset object. Its `iterator()` method is expected
   *   to generate a dataset iterator object, the `next()` method of which
   *   is expected to produce data batches for training. The return value
   *   of the `next()` call ought to contain a boolean `done` field and a
   *   `value` field. The `value` field is expected to be an array of two
   *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former
   *   case is for models with exactly one input and one output (e.g.
   *   a sequential model). The latter case is for models with multiple
   *   inputs and/or multiple outputs.
   *   Of the two items in the array, the first is the input feature(s) and
   *   the second is the output target(s).
   * @param args A `ModelFitDatasetArgs`, containing optional fields.
   *
   * @return A `History` instance. Its `history` attribute contains all
   *   information collected during training.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async fitDataset(e, n) {
    return P7(this, e, n);
  }
  /**
   * Runs a single gradient update on a single batch of data.
   *
   * This method differs from `fit()` and `fitDataset()` in the following
   * regards:
   *   - It operates on exactly one batch of data.
   *   - It returns only the loss and metric values, instead of
   *     returning the batch-by-batch loss and metric values.
   *   - It doesn't support fine-grained options such as verbosity and
   *     callbacks.
   *
   * @param x Input data. It could be one of the following:
   *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has
   *     multiple inputs).
   *   - An Object mapping input names to corresponding `tf.Tensor` (if the
   *     model has named inputs).
   * @param y Target data. It could be either a `tf.Tensor` or multiple
   *   `tf.Tensor`s. It should be consistent with `x`.
   * @returns Training loss or losses (in case the model has
   *   multiple outputs), along with metrics (if any), as numbers.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async trainOnBatch(e, n) {
    const s = await this.standardizeUserData(e, n), i = s[0], r = s[1], a = this.makeTrainFunction()(i.concat(r)), c = [];
    for (const l of a) {
      const u = await l.data();
      c.push(u[0]);
    }
    return At(a), hr(s[0], e), hr(s[1], n), Zs(c);
  }
  /**
   * Extract weight values of the model.
   *
   * @param config: An instance of `io.SaveConfig`, which specifies
   * model-saving options such as whether only trainable weights are to be
   * saved.
   * @returns A `NamedTensorMap` mapping original weight names (i.e.,
   *   non-uniqueified weight names) to their values.
   */
  getNamedWeights(e) {
    const n = [], s = e != null && e.trainableOnly, i = s ? this.trainableWeights : this.weights, r = this.getWeights(s);
    for (let o = 0; o < i.length; ++o)
      s && !i[o].trainable || n.push({ name: i[o].originalName, tensor: r[o] });
    return n;
  }
  /**
   * Setter used for force stopping of LayersModel.fit() (i.e., training).
   *
   * Example:
   *
   * ```js
   * const input = tf.input({shape: [10]});
   * const output = tf.layers.dense({units: 1}).apply(input);
   * const model = tf.model({inputs: [input], outputs: [output]});
   * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});
   * const xs = tf.ones([8, 10]);
   * const ys = tf.zeros([8, 1]);
   *
   * const history = await model.fit(xs, ys, {
   *   epochs: 10,
   *   callbacks: {
   *     onEpochEnd: async (epoch, logs) => {
   *       if (epoch === 2) {
   *         model.stopTraining = true;
   *       }
   *     }
   *   }
   * });
   *
   * // There should be only 3 values in the loss array, instead of 10
   * values,
   * // due to the stopping after 3 epochs.
   * console.log(history.history.loss);
   * ```
   */
  set stopTraining(e) {
    this.stopTraining_ = e;
  }
  get stopTraining() {
    return this.stopTraining_;
  }
  get optimizer() {
    return this.optimizer_;
  }
  set optimizer(e) {
    this.optimizer_ !== e && (this.optimizer_ = e, this.isOptimizerOwned = !1);
  }
  dispose() {
    const e = super.dispose();
    if (e.refCountAfterDispose === 0 && this.optimizer != null && this.isOptimizerOwned) {
      const n = Ly().numTensors;
      this.optimizer_.dispose(), e.numDisposedVariables += n - Ly().numTensors;
    }
    return e;
  }
  getLossIdentifiers() {
    let e;
    if (typeof this.loss == "string")
      e = wo(this.loss);
    else if (Array.isArray(this.loss)) {
      for (const n of this.loss)
        if (typeof n != "string")
          throw new Error("Serialization of non-string loss is not supported.");
      e = this.loss.map((n) => wo(n));
    } else {
      const n = Object.keys(this.loss);
      e = {};
      const s = this.loss;
      for (const i of n)
        if (typeof s[i] == "string")
          e[i] = wo(s[i]);
        else
          throw new Error("Serialization of non-string loss is not supported.");
    }
    return e;
  }
  getMetricIdentifiers() {
    if (typeof this.metrics == "string" || typeof this.metrics == "function")
      return [wo(bg(this.metrics))];
    if (Array.isArray(this.metrics))
      return this.metrics.map((e) => wo(bg(e)));
    {
      const e = {};
      for (const n in this.metrics)
        e[n] = wo(bg(this.metrics[n]));
      return e;
    }
  }
  getTrainingConfig() {
    return {
      loss: this.getLossIdentifiers(),
      metrics: this.getMetricIdentifiers(),
      optimizer_config: {
        class_name: this.optimizer.getClassName(),
        config: this.optimizer.getConfig()
      }
    };
  }
  loadTrainingConfig(e) {
    if (e.weighted_metrics != null)
      throw new Error("Loading weight_metrics is not supported yet.");
    if (e.loss_weights != null)
      throw new Error("Loading loss_weights is not supported yet.");
    if (e.sample_weight_mode != null)
      throw new Error("Loading sample_weight_mode is not supported yet.");
    const n = a1(e.optimizer_config), s = Io(n);
    let i;
    if (typeof e.loss == "string")
      i = dc(e.loss);
    else if (Array.isArray(e.loss))
      i = e.loss.map((o) => dc(o));
    else if (e.loss != null) {
      i = {};
      for (const o in e.loss)
        i[o] = dc(e.loss[o]);
    }
    let r;
    if (Array.isArray(e.metrics))
      r = e.metrics.map((o) => dc(o));
    else if (e.metrics != null) {
      r = {};
      for (const o in e.metrics)
        r[o] = dc(e.metrics[o]);
    }
    this.compile({ loss: i, metrics: r, optimizer: s });
  }
  /**
   * Save the configuration and/or weights of the LayersModel.
   *
   * An `IOHandler` is an object that has a `save` method of the proper
   * signature defined. The `save` method manages the storing or
   * transmission of serialized data ("artifacts") that represent the
   * model's topology and weights onto or via a specific medium, such as
   * file downloads, local storage, IndexedDB in the web browser and HTTP
   * requests to a server. TensorFlow.js provides `IOHandler`
   * implementations for a number of frequently used saving mediums, such as
   * `tf.io.browserDownloads` and `tf.io.browserLocalStorage`. See `tf.io`
   * for more details.
   *
   * This method also allows you to refer to certain types of `IOHandler`s
   * as URL-like string shortcuts, such as 'localstorage://' and
   * 'indexeddb://'.
   *
   * Example 1: Save `model`'s topology and weights to browser [local
   * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);
   * then load it back.
   *
   * ```js
   * const model = tf.sequential(
   *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
   * console.log('Prediction from original model:');
   * model.predict(tf.ones([1, 3])).print();
   *
   * const saveResults = await model.save('localstorage://my-model-1');
   *
   * const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');
   * console.log('Prediction from loaded model:');
   * loadedModel.predict(tf.ones([1, 3])).print();
   * ```
   *
   * Example 2. Saving `model`'s topology and weights to browser
   * [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);
   * then load it back.
   *
   * ```js
   * const model = tf.sequential(
   *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
   * console.log('Prediction from original model:');
   * model.predict(tf.ones([1, 3])).print();
   *
   * const saveResults = await model.save('indexeddb://my-model-1');
   *
   * const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');
   * console.log('Prediction from loaded model:');
   * loadedModel.predict(tf.ones([1, 3])).print();
   * ```
   *
   * Example 3. Saving `model`'s topology and weights as two files
   * (`my-model-1.json` and `my-model-1.weights.bin`) downloaded from
   * browser.
   *
   * ```js
   * const model = tf.sequential(
   *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
   * const saveResults = await model.save('downloads://my-model-1');
   * ```
   *
   * Example 4. Send  `model`'s topology and weights to an HTTP server.
   * See the documentation of `tf.io.http` for more details
   * including specifying request parameters and implementation of the
   * server.
   *
   * ```js
   * const model = tf.sequential(
   *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
   * const saveResults = await model.save('http://my-server/model/upload');
   * ```
   *
   * @param handlerOrURL An instance of `IOHandler` or a URL-like,
   * scheme-based string shortcut for `IOHandler`.
   * @param config Options for saving the model.
   * @returns A `Promise` of `SaveResult`, which summarizes the result of
   * the saving, such as byte sizes of the saved artifacts for the model's
   *   topology and weight values.
   *
   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
   */
  async save(e, n) {
    if (typeof e == "string") {
      const l = ik(e);
      if (l.length === 0)
        throw new Z(`Cannot find any save handlers for URL '${e}'`);
      if (l.length > 1)
        throw new Z(`Found more than one (${l.length}) save handlers for URL '${e}'`);
      e = l[0];
    }
    if (e.save == null)
      throw new Z("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
    const s = await Gw(this.getNamedWeights(n)), i = !1, r = null, a = {
      modelTopology: this.toJSON(r, i),
      format: j7,
      generatedBy: `TensorFlow.js tfjs-layers v${BM}`,
      convertedBy: null
    };
    if ((n == null ? !1 : n.includeOptimizer) && this.optimizer != null) {
      a.trainingConfig = this.getTrainingConfig();
      const l = "optimizer", { data: u, specs: h } = await Gw(await this.optimizer.getWeights(), l);
      s.specs.push(...h), s.data = tk([s.data, u]);
    }
    return this.userDefinedMetadata != null && (aI(this.userDefinedMetadata, this.name, !0), a.userDefinedMetadata = this.userDefinedMetadata), a.weightData = s.data, a.weightSpecs = s.specs, e.save(a);
  }
  /**
   * Set user-defined metadata.
   *
   * The set metadata will be serialized together with the topology
   * and weights of the model during `save()` calls.
   *
   * @param setUserDefinedMetadata
   */
  setUserDefinedMetadata(e) {
    aI(e, this.name), this.userDefinedMetadata = e;
  }
  /**
   * Get user-defined metadata.
   *
   * The metadata is supplied via one of the two routes:
   *   1. By calling `setUserDefinedMetadata()`.
   *   2. Loaded during model loading (if the model is constructed
   *      via `tf.loadLayersModel()`.)
   *
   * If no user-defined metadata is available from either of the
   * two routes, this function will return `undefined`.
   */
  getUserDefinedMetadata() {
    return this.userDefinedMetadata;
  }
}
Zl.className = "Model";
Ee(Zl);
class WM extends Zl {
}
WM.className = "Functional";
Ee(WM);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Tf extends Zl {
  constructor(e) {
    if (super({ inputs: [], outputs: [] }), e = e || {}, this.trainable = !0, this.built = !1, this.name = e.name != null ? e.name : pb("sequential_"), e.layers != null)
      for (const n of e.layers)
        this.add(n);
  }
  // Helper function to Sequential.add  Throws if the new output shape will be
  // invalid.
  checkShape(e) {
    if (e.inboundNodes[0].outputTensors[0].shape.some((s) => s < 0))
      throw new Z(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`);
  }
  /**
   * Adds a layer instance on top of the layer stack.
   *
   * ```js
   *  const model = tf.sequential();
   *  model.add(tf.layers.dense({units: 8, inputShape: [1]}));
   *  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));
   *  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));
   *  // Note that the untrained model is random at this point.
   *  model.predict(tf.randomNormal([10, 1])).print();
   * ```
   * @param layer Layer instance.
   *
   * @exception ValueError In case the `layer` argument does not know its
   * input shape.
   * @exception ValueError In case the `layer` argument has multiple output
   *   tensors, or is already connected somewhere else (forbidden in
   *   `Sequential` models).
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  add(e) {
    const n = e instanceof Tf || e instanceof Zl;
    let s;
    if (n) {
      if (s = e, s.outputs.length !== 1)
        throw new Z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      if (s.inputs.length !== 1)
        throw new Z("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
    }
    if (this.outputs.length === 0) {
      if (e.inboundNodes.length === 0) {
        if (e.batchInputShape == null)
          throw new Z("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
        const i = XX({
          batchShape: e.batchInputShape,
          dtype: e.dtype,
          name: e.name + "_input"
        });
        e.apply(i);
      }
      if (n)
        this.outputs = s.outputs, this.inputs = s.inputs;
      else {
        if (e.inboundNodes.length !== 1)
          throw new Z(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);
        if (e.inboundNodes[0].outputTensors.length !== 1)
          throw new Z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(e), this.outputs = [e.inboundNodes[0].outputTensors[0]], this.inputs = CM(this.outputs[0]);
      }
      this.inboundNodes = [], new gb({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: this.inputs,
        outputTensors: this.outputs,
        // no model-level masking for now
        inputMasks: Hc(null, this.inputs.length),
        outputMasks: [null],
        inputShapes: this.inputs.map((i) => i.shape),
        outputShapes: this.outputs[0].shape
      });
    } else {
      const i = e.apply(this.outputs[0]);
      if (Array.isArray(i))
        throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      this.checkShape(e), this.outputs = [i], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }
    this.layers.push(e), this.built = !1;
  }
  /**
   * Removes the last layer in the model.
   *
   * @exception TypeError if there are no layers in the model.
   */
  pop() {
    if (this.layers.length === 0)
      throw new TypeError("There are no layers in the model.");
    if (this.layers.pop(), this.layers.length === 0)
      this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
    else {
      const e = this.layers.length - 1;
      this.layers[e].outboundNodes = [], this.outputs = [this.layers[e].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }
  }
  call(e, n) {
    return this.model == null && this.build(), this.model.call(e, n);
  }
  build(e) {
    if (Ht(e), this.inputs.length === 0 || this.outputs.length === 0)
      throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
    this.model = new Zl({
      inputs: this.inputs,
      outputs: this.outputs[0],
      name: this.name + "_model"
    }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = !0;
  }
  countParams() {
    return this.built || this.build(), super.countParams();
  }
  /**
   * Print a text summary of the Sequential model's layers.
   *
   * The summary includes
   * - Name and type of all layers that comprise the model.
   * - Output shape(s) of the layers
   * - Number of weight parameters of each layer
   * - The total number of trainable and non-trainable parameters of the
   * model.
   *
   * ```js
   * const model = tf.sequential();
   * model.add(
   *     tf.layers.dense({units: 100, inputShape: [10], activation: 'relu'}));
   * model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));
   *
   * model.summary();
   * ```
   *
   * @param lineLength Custom line length, in number of characters.
   * @param positions Custom widths of each of the columns, as either
   *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number
   *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to
   *   right-most (i.e., ending) position of a column.
   * @param printFn Custom print function. Can be used to replace the default
   *   `console.log`. For example, you can use `x => {}` to mute the printed
   *   messages in the console.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  summary(e, n, s = console.log) {
    this.built || this.build(), super.summary(e, n, s);
  }
  /**
   * Sets the weights of the model.
   *
   * @param weights Should be a list of Tensors with shapes and types matching
   *   the output of `model.getWeights()`.
   */
  setWeights(e) {
    this.model == null && this.build(), this.model.setWeights(e);
  }
  /**
   * Returns the loss value & metrics values for the model in test mode.
   *
   * Loss and metrics are specified during `compile()`, which needs to happen
   * before calls to `evaluate()`.
   *
   * Computation is done in batches.
   *
   * ```js
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});
   * const result = model.evaluate(tf.ones([8, 10]), tf.ones([8, 1]), {
   *   batchSize: 4,
   * });
   * result.print();
   * ```
   *
   * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the
   * model has multiple inputs.
   * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the
   * model has multiple outputs.
   * @param args A `ModelEvaluateConfig`, containing optional fields.
   *
   * @return `Scalar` test loss (if the model has a single output and no
   *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs
   *   and/or metrics). The attribute `model.metricsNames`
   *   will give you the display labels for the scalar outputs.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  evaluate(e, n, s = {}) {
    if (!this.built)
      throw new Ki("The model needs to be compiled before being used.");
    return this.model.evaluate(e, n, s);
  }
  // TODO(cais): Add code snippet below once real dataset objects are
  //   available.
  /**
   * Evaluate model using a dataset object.
   *
   * Note: Unlike `evaluate()`, this method is asynchronous (`async`).
   *
   * @param dataset A dataset object. Its `iterator()` method is expected
   *   to generate a dataset iterator object, the `next()` method of which
   *   is expected to produce data batches for evaluation. The return value
   *   of the `next()` call ought to contain a boolean `done` field and a
   *   `value` field. The `value` field is expected to be an array of two
   *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former
   *   case is for models with exactly one input and one output (e.g.
   *   a sequential model). The latter case is for models with multiple
   *   inputs and/or multiple outputs. Of the two items in the array, the
   *   first is the input feature(s) and the second is the output target(s).
   * @param args A configuration object for the dataset-based evaluation.
   * @returns Loss and metric values as an Array of `Scalar` objects.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async evaluateDataset(e, n) {
    if (!this.built)
      throw new Ki("The model needs to be compiled before being used.");
    return this.model.evaluateDataset(e, n);
  }
  /**
   * Generates output predictions for the input samples.
   *
   * Computation is done in batches.
   *
   * Note: the "step" mode of predict() is currently not supported.
   *   This is because the TensorFlow.js core backend is imperative only.
   *
   * ```js
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.predict(tf.ones([2, 10])).print();
   * ```
   *
   * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if
   *   the model has multiple inputs.
   * @param conifg A `ModelPredictConfig` object containing optional fields.
   *
   * @return `tf.Tensor`(s) of predictions.
   *
   * @exception ValueError In case of mismatch between the provided input data
   *   and the model's expectations, or in case a stateful model receives a
   *   number of samples that is not a multiple of the batch size.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  predict(e, n = {}) {
    return this.model == null && this.build(), this.model.predict(e, n);
  }
  /**
   * Returns predictions for a single batch of samples.
   *
   * @param x: Input samples, as a Tensor, or list of Tensors (if the model
   *   has multiple inputs).
   * @return Tensor(s) of predictions
   */
  predictOnBatch(e) {
    return this.model == null && this.build(), this.model.predictOnBatch(e);
  }
  /**
   * See `LayersModel.compile`.
   *
   * @param args
   */
  compile(e) {
    this.build(), this.model.compile(e), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
  }
  get optimizer() {
    return this.model == null ? void 0 : this.model.optimizer;
  }
  set optimizer(e) {
    this.model.optimizer = e;
  }
  /**
   * Trains the model for a fixed number of epochs (iterations on a dataset).
   *
   * ```js
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});
   * const history = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {
   *   batchSize: 4,
   *   epochs: 3
   * });
   * console.log(history.history.loss[0]);
   * ```
   *
   * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the
   * model has multiple inputs. If all inputs in the model are named, you can
   * also pass a dictionary mapping input names to `tf.Tensor`s.
   * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if
   * the model has multiple outputs. If all outputs in the model are named, you
   *  can also pass a dictionary mapping output names to `tf.Tensor`s.
   * @param args  A `ModelFitConfig`, containing optional fields.
   *
   * @return A `History` instance. Its `history` attribute contains all
   *   information collected during training.
   *
   * @exception ValueError In case of mismatch between the provided input data
   *   and what the model expects.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async fit(e, n, s = {}) {
    if (!this.built)
      throw new Ki("The model needs to be compiled before being used.");
    return this.model.fit(e, n, s);
  }
  /**
   * Trains the model using a dataset object.
   *
   * ```js
   * const xArray = [
   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],
   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],
   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],
   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],
   * ];
   * const yArray = [1, 1, 1, 1];
   * // Create a dataset from the JavaScript array.
   * const xDataset = tf.data.array(xArray);
   * const yDataset = tf.data.array(yArray);
   * // Zip combines the `x` and `y` Datasets into a single Dataset, the
   * // iterator of which will return an object containing of two tensors,
   * // corresponding to `x` and `y`.  The call to `batch(4)` will bundle
   * // four such samples into a single object, with the same keys now pointing
   * // to tensors that hold 4 examples, organized along the batch dimension.
   * // The call to `shuffle(4)` causes each iteration through the dataset to
   * // happen in a different order.  The size of the shuffle window is 4.
   * const xyDataset = tf.data.zip({xs: xDataset, ys: yDataset})
   *     .batch(4)
   *     .shuffle(4);
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [9]})]
   * });
   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});
   * const history = await model.fitDataset(xyDataset, {
   *   epochs: 4,
   *   callbacks: {onEpochEnd: (epoch, logs) => console.log(logs.loss)}
   * });
   * ```
   *
   * @param dataset A dataset object. Its `iterator()` method is expected to
   *   generate a dataset iterator object, the `next()` method of which is
   *   expected to produce data batches for evaluation. The return value of the
   *   `next()` call ought to contain a boolean `done` field and a `value`
   *   field.
   *
   *   The `value` field is expected to be an object of with fields
   *   `xs` and `ys`, which point to the feature tensor and the target tensor,
   *   respectively. This case is for models with exactly one input and one
   *   output (e.g. a sequential model). For example:
   *   ```js
   *   {value: {xs: xsTensor, ys: ysTensor}, done: false}
   *   ```
   *
   *   If the model has multiple inputs, the `xs` field of `value` should
   *   be an object mapping input names to their respective feature tensors.
   *   For example:
   *   ```js
   *   {
   *     value: {
   *       xs: {
   *         input_1: xsTensor1,
   *         input_2: xsTensor2
   *       },
   *       ys: ysTensor
   *     },
   *     done: false
   *   }
   *   ```
   *   If the model has multiple outputs, the `ys` field of `value` should
   *   be an object mapping output names to their respective target tensors.
   *   For example:
   *   ```js
   *   {
   *     value: {
   *       xs: xsTensor,
   *       ys: {
   *         output_1: ysTensor1,
   *         output_2: ysTensor2
   *       },
   *     },
   *     done: false
   *   }
   *   ```
   * @param args A `ModelFitDatasetArgs`, containing optional fields.
   *
   * @return A `History` instance. Its `history` attribute contains all
   *   information collected during training.
   *
   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
   */
  async fitDataset(e, n) {
    if (!this.built)
      throw new Ki("The model needs to be compiled before being used.");
    return this.model.fitDataset(e, n);
  }
  /**
   * Runs a single gradient update on a single batch of data.
   *
   * This method differs from `fit()` and `fitDataset()` in the following
   * regards:
   *   - It operates on exactly one batch of data.
   *   - It returns only the loss and metric values, instead of
   *     returning the batch-by-batch loss and metric values.
   *   - It doesn't support fine-grained options such as verbosity and
   *     callbacks.
   *
   * @param x Input data. It could be one of the following:
   *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has
   *     multiple inputs).
   *   - An Object mapping input names to corresponding `tf.Tensor` (if the
   *     model has named inputs).
   * @param y Target data. It could be either a `tf.Tensor` or multiple
   *   `tf.Tensor`s. It should be consistent with `x`.
   * @returns Training loss or losses (in case the model has
   *   multiple outputs), along with metrics (if any), as numbers.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async trainOnBatch(e, n) {
    return this.model.trainOnBatch(e, n);
  }
  /* See parent class for JsDoc */
  /** @nocollapse */
  static fromConfig(e, n, s = {}, i = !1) {
    let r, o = {};
    if (n instanceof Array) {
      if (n[0].className == null || n[0].className === "Merge")
        throw new Z("Legacy serialization format not supported yet.");
      r = n;
    } else
      A(n.layers != null, () => "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."), r = n.layers, delete n.layers, o = n;
    const a = new e(o);
    if (!(a instanceof Tf))
      throw new Ct(`Sequential.fromConfig called on non-Sequential input: ${a}`);
    for (const c of r) {
      const u = Io(c, void 0, i);
      i && u.setFastWeightInitDuringBuild(!0), a.add(u);
    }
    return a;
  }
  /**
   * Setter used for force stopping of LayersModel.fit() (i.e., training).
   *
   * Example:
   *
   * ```js
   * const model = tf.sequential();
   * model.add(tf.layers.dense({units: 1, inputShape: [10]}));
   * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});
   * const xs = tf.ones([8, 10]);
   * const ys = tf.zeros([8, 1]);
   *
   * const history = await model.fit(xs, ys, {
   *   epochs: 10,
   *   callbacks: {
   *     onEpochEnd: async (epoch, logs) => {
   *       if (epoch === 2) {
   *         model.stopTraining = true;
   *       }
   *     }
   *   }
   * });
   *
   * // There should be only 3 values in the loss array, instead of 10 values,
   * // due to the stopping after 3 epochs.
   * console.log(history.history.loss);
   * ```
   */
  set stopTraining(e) {
    if (this.model == null)
      throw new Z("Cannot set the stopTraining property of a sequential model before it is compiled.");
    this.model.stopTraining = e;
  }
  get stopTraining() {
    if (this.model == null)
      throw new Z("Cannot get the stopTraining property of a sequential model before it is compiled.");
    return this.model.stopTraining;
  }
  // TODO(cais): Override get trainableWeights() here
  // tslint:disable-next-line:no-any
  getConfig() {
    const e = [];
    for (const n of this.layers) {
      const s = {};
      s.className = n.getClassName(), s.config = n.getConfig(), e.push(s);
    }
    return { name: this.name, layers: e };
  }
}
Tf.className = "Sequential";
Ee(Tf);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let ks = class extends ol {
  getConfig() {
    return {};
  }
};
class HM extends ks {
  /**
   * Calculate the activation function.
   *
   * @param x: Input.
   * @param alpha: Scaling factor the negative section.
   * @return Output of the ELU activation.
   */
  apply(e, n = 1) {
    return RX(e, n);
  }
}
HM.className = "elu";
Ee(HM);
class jM extends ks {
  apply(e) {
    return G0(e);
  }
}
jM.className = "selu";
Ee(jM);
class qM extends ks {
  apply(e) {
    return kr(e);
  }
}
qM.className = "relu";
Ee(qM);
class XM extends ks {
  apply(e) {
    return Q(() => Aa(6, kr(e)));
  }
}
XM.className = "relu6";
Ee(XM);
class KM extends ks {
  apply(e) {
    return e;
  }
}
KM.className = "linear";
Ee(KM);
class YM extends ks {
  apply(e) {
    return mi(e);
  }
}
YM.className = "sigmoid";
Ee(YM);
class ZM extends ks {
  apply(e) {
    return $X(e);
  }
}
ZM.className = "hardSigmoid";
Ee(ZM);
class JM extends ks {
  apply(e) {
    return sl(e);
  }
}
JM.className = "softplus";
Ee(JM);
class QM extends ks {
  apply(e) {
    return DX(e);
  }
}
QM.className = "softsign";
Ee(QM);
class eR extends ks {
  apply(e) {
    return ka(e);
  }
}
eR.className = "tanh";
Ee(eR);
let dT = class extends ks {
  /**
   * Calculate the activation function.
   *
   * @param x Tensor.
   * @param axis Integer, axis along which the softmax normalization is applied.
   * Invalid if < 2, as softmax across 1 (the batch dimension) is assumed to be
   * an error.
   *
   * @returns a Tensor of the same shape as x
   *
   * @throws ValueError: In case `dim(x) < 2`.
   */
  apply(e, n = -1) {
    return rm(e, n);
  }
};
dT.className = "softmax";
Ee(dT);
class tR extends ks {
  /**
   * Calculate the activation function of log softmax:
   * log( exp(x_i) / sum(exp(x)) )
   *
   * @param x Tensor.
   * @param axis Integer, axis along which the softmax normalization is applied.
   * Invalid if < 2, as softmax across 1 (the batch dimension) is assumed to be
   * an error.
   *
   * @returns a Tensor of the same shape as x
   *
   * @throws ValueError: In case `dim(x) < 2`.
   */
  apply(e, n = -1) {
    return O0(e, n);
  }
}
tR.className = "logSoftmax";
Ee(tR);
class nR extends ks {
  /**
   * Calculate the activation function.
   *
   * @param x Tensor.
   * @returns a Tensor of the same shape as x
   */
  apply(e) {
    return Q(() => Q(() => {
      const n = Math.sqrt(2), s = q(0.5, Se(1, R0(it(e, n))));
      return q(e, s);
    }));
  }
}
nR.className = "gelu";
Ee(nR);
class sR extends ks {
  /**
   * Calculate the activation function.
   *
   * @param x Tensor.
   * @returns a Tensor of the same shape as x
   */
  apply(e) {
    return Q(() => q(0.5, q(e, Se(1, ka(q(us(it(2, Math.PI)), Se(e, q(0.044715, io(e, 3)))))))));
  }
}
sR.className = "gelu_new";
Ee(sR);
class iR extends ks {
  /**
   * Calculate the activation function.
   *
   * @param x Tensor.
   * @returns a Tensor of the same shape as x
   */
  apply(e) {
    return Q(() => q(e, ka(sl(e))));
  }
}
iR.className = "mish";
Ee(iR);
class rR extends ks {
  /**
   * Calculate the activation function.
   *
   * @param x Tensor.
   * @param alpha Scaling factor for the sigmoid function.
   * @returns a Tensor of the same shape as x
   */
  apply(e, n = 1) {
    return Q(() => q(mi(q(e, n)), e));
  }
}
rR.className = "swish";
Ee(rR);
function Ra(t) {
  return t.getClassName();
}
function Iv(t, e = {}) {
  return fm(t, Ni.getMap().classNameMap, e, "activation");
}
function Da(t) {
  if (t == null) {
    const e = {};
    return e.className = "linear", e.config = {}, Iv(e);
  }
  if (typeof t == "string") {
    const e = {};
    return e.className = t, e.config = {}, Iv(e);
  } else
    return t instanceof ks ? t : Iv(t);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function q7(t) {
  if (t != null && typeof t != "object")
    throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`);
}
class oR extends ol {
}
class aR extends oR {
  constructor(e) {
    super(), q7(e), this.l1 = e == null || e.l1 == null ? 0.01 : e.l1, this.l2 = e == null || e.l2 == null ? 0.01 : e.l2, this.hasL1 = this.l1 !== 0, this.hasL2 = this.l2 !== 0;
  }
  /**
   * Porting note: Renamed from __call__.
   * @param x Variable of which to calculate the regularization score.
   */
  apply(e) {
    return Q(() => {
      let n = qn([1]);
      return this.hasL1 && (n = Se(n, Qe(q(this.l1, jn(e))))), this.hasL2 && (n = Se(n, Qe(q(this.l2, mm(e))))), Y(n, []);
    });
  }
  getConfig() {
    return { l1: this.l1, l2: this.l2 };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e({ l1: n.l1, l2: n.l2 });
  }
}
aR.className = "L1L2";
Ee(aR);
const fI = {
  l1l2: "L1L2"
};
function an(t) {
  return J_(t);
}
function pI(t, e = {}) {
  return fm(t, Ni.getMap().classNameMap, e, "regularizer");
}
function _n(t) {
  if (t == null)
    return null;
  if (typeof t == "string") {
    const n = { className: t in fI ? fI[t] : t, config: {} };
    return pI(n);
  } else
    return t instanceof oR ? t : pI(t);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class cR extends Ft {
  constructor(e) {
    super(e ?? {}), this.supportsMasking = !0, e != null && (this.maxValue = e.maxValue);
  }
  call(e, n) {
    e = gt(e);
    let s = kr(e);
    return this.maxValue != null && (s = Gs(s, 0, this.maxValue)), s;
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    const e = { maxValue: this.maxValue }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
cR.className = "ReLU";
Ee(cR);
class lR extends Ft {
  constructor(e) {
    super(e ?? {}), this.DEFAULT_ALPHA = 0.3, e == null && (e = {}), this.alpha = e.alpha == null ? this.DEFAULT_ALPHA : e.alpha;
  }
  call(e, n) {
    const s = gt(e);
    return Xp(s, this.alpha);
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    const e = { alpha: this.alpha }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
lR.className = "LeakyReLU";
Ee(lR);
class uR extends Ft {
  constructor(e) {
    if (super(e ?? {}), this.DEFAULT_ALPHA_INITIALIZER = "zeros", e == null && (e = {}), this.supportsMasking = !0, this.alphaInitializer = wn(e.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER), this.alphaRegularizer = _n(e.alphaRegularizer), this.alphaConstraint = ts(e.alphaConstraint), e.sharedAxes == null)
      this.sharedAxes = null;
    else if (Array.isArray(e.sharedAxes))
      this.sharedAxes = e.sharedAxes;
    else if (typeof e.sharedAxes == "number")
      this.sharedAxes = [e.sharedAxes];
    else
      throw new Z(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);
  }
  build(e) {
    e = Ht(e);
    const n = e.slice(1);
    if (this.sharedAxes != null)
      for (const i of this.sharedAxes)
        n[i - 1] = 1;
    this.alpha = this.addWeight("alpha", n, "float32", this.alphaInitializer, this.alphaRegularizer, !0, this.alphaConstraint);
    const s = {};
    if (this.sharedAxes != null)
      for (let i = 1; i < e.length; ++i)
        s[i] = e[i];
    this.inputSpec = [new Qn({
      ndim: e.length,
      axes: s
    })], this.built = !0;
  }
  call(e, n) {
    return e = gt(e), tm(e, this.alpha.read());
  }
  getConfig() {
    const e = {
      alphaInitializer: Nn(this.alphaInitializer),
      alphaRegularizer: an(this.alphaRegularizer),
      alphaConstraint: es(this.alphaConstraint),
      sharedAxes: this.sharedAxes
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
uR.className = "PReLU";
Ee(uR);
let hR = class extends Ft {
  constructor(e) {
    if (super(e ?? {}), this.DEFAULT_ALPHA = 1, e == null && (e = {}), e.alpha != null && e.alpha !== this.DEFAULT_ALPHA)
      throw new Ct(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);
    this.alpha = e.alpha == null ? this.DEFAULT_ALPHA : e.alpha;
  }
  call(e, n) {
    const s = gt(e);
    return Dh(s);
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    const e = { alpha: this.alpha }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
};
hR.className = "ELU";
Ee(hR);
class dR extends Ft {
  constructor(e) {
    super(e ?? {}), this.DEFAULT_THETA = 1, e == null && (e = {}), this.theta = e.theta == null ? this.DEFAULT_THETA : e.theta;
  }
  call(e, n) {
    const s = gt(e);
    return q(s, Le(js(s, this.theta), "float32"));
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    const e = { theta: this.theta }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
dR.className = "ThresholdedReLU";
Ee(dR);
class fR extends Ft {
  constructor(e) {
    super(e ?? {}), this.DEFAULT_AXIS = 1, e == null && (e = {}), this.softmax = new dT().apply, this.axis = e.axis == null ? this.DEFAULT_AXIS : e.axis;
  }
  call(e, n) {
    return Q(() => {
      let s = gt(e);
      const i = n.mask;
      if (i != null) {
        const r = q(je(Qs(s.shape), Le(i, s.dtype)), ot(-1e9));
        s = Se(s, r);
      }
      return this.axis instanceof Array ? this.axis.length > 1 ? ii(je(s, Yp(s, this.axis, !0))) : this.softmax(s, this.axis[0]) : this.softmax(s, this.axis);
    });
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    const e = { axis: this.axis }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
fR.className = "Softmax";
Ee(fR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Jl(t, e, n) {
  if (typeof t == "number")
    return Hc(t, e);
  if (t.length !== e)
    throw new Z(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);
  for (let s = 0; s < e; ++s) {
    const i = t[s];
    if (!NX(i))
      throw new Z(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${i}`);
  }
  return t;
}
function vr(t, e, n, s, i = 1) {
  if (t == null)
    return t;
  const r = e + (e - 1) * (i - 1);
  let o;
  return n === "same" ? o = t : o = t - r + 1, Math.floor((o + s - 1) / s);
}
function Vr(t, e, n, s) {
  if (t == null)
    return null;
  if (s === "valid")
    t = t * e + Ma([n - e, 0]);
  else if (s === "same")
    t = t * e;
  else
    throw new Z(`Unsupport padding mode: ${s}.`);
  return t;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function fT(t, e) {
  return Q(() => (Un(e), e === "channelsFirst" ? zt(t, [0, 2, 3, 1]) : t));
}
function pR(t, e) {
  return Q(() => (Un(e), e === "channelsFirst" ? zt(t, [0, 2, 3, 4, 1]) : t));
}
function X7(t, e, n, s = 1, i = "valid", r, o = 1) {
  return Q(() => {
    if (r == null && (r = Cr()), Un(r), t.shape.length !== 3)
      throw new Z(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);
    if (e.shape.length !== 3)
      throw new Z(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);
    if (n != null && n.shape.length !== 1)
      throw new Z(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);
    if (r === "channelsFirst" && (t = zt(t, [0, 2, 1])), i === "causal")
      throw new Ct("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    let a = N0(t, e, s, i === "same" ? "same" : "valid", "NWC", o);
    return n != null && (a = Ar(a, n)), a;
  });
}
function mI(t, e, n, s = [1, 1], i = "valid", r, o, a = null) {
  return Q(() => {
    if (r == null && (r = Cr()), Un(r), t.rank !== 3 && t.rank !== 4)
      throw new Z(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);
    if (e.rank !== 3 && e.rank !== 4)
      throw new Z(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);
    let c = fT(t, r);
    if (i === "causal")
      throw new Ct("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    return c = iA({
      x: c,
      filter: e,
      strides: s,
      pad: i === "same" ? "same" : "valid",
      dilations: o,
      dataFormat: "NHWC",
      bias: n,
      activation: a
    }), r === "channelsFirst" && (c = zt(c, [0, 3, 1, 2])), c;
  });
}
function K7(t, e, n, s = [1, 1, 1], i = "valid", r, o) {
  return Q(() => {
    if (r == null && (r = Cr()), Un(r), t.rank !== 4 && t.rank !== 5)
      throw new Z(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);
    if (e.rank !== 4 && e.rank !== 5)
      throw new Z(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);
    let a = pR(t, r);
    if (i === "causal")
      throw new Ct("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
    return a = ES(a, e, s, i === "same" ? "same" : "valid", "NDHWC", o), n != null && (a = Ar(a, n)), r === "channelsFirst" && (a = zt(a, [0, 4, 1, 2, 3])), a;
  });
}
class bb extends Ft {
  constructor(e, n) {
    if (super(n), this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", bb.verifyArgs(n), this.rank = e, cs(this.rank, "rank"), this.rank !== 1 && this.rank !== 2 && this.rank !== 3)
      throw new Ct(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);
    if (this.kernelSize = Jl(n.kernelSize, e, "kernelSize"), this.strides = Jl(n.strides == null ? 1 : n.strides, e, "strides"), this.padding = n.padding == null ? "valid" : n.padding, Bi(this.padding), this.dataFormat = n.dataFormat == null ? "channelsLast" : n.dataFormat, Un(this.dataFormat), this.activation = Da(n.activation), this.useBias = n.useBias == null ? !0 : n.useBias, this.biasInitializer = wn(n.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.biasConstraint = ts(n.biasConstraint), this.biasRegularizer = _n(n.biasRegularizer), this.activityRegularizer = _n(n.activityRegularizer), this.dilationRate = Jl(n.dilationRate == null ? 1 : n.dilationRate, e, "dilationRate"), this.rank === 1 && Array.isArray(this.dilationRate) && this.dilationRate.length !== 1)
      throw new Z(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);
    if (this.rank === 2) {
      if (typeof this.dilationRate == "number")
        this.dilationRate = [this.dilationRate, this.dilationRate];
      else if (this.dilationRate.length !== 2)
        throw new Z(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`);
    } else if (this.rank === 3) {
      if (typeof this.dilationRate == "number")
        this.dilationRate = [this.dilationRate, this.dilationRate, this.dilationRate];
      else if (this.dilationRate.length !== 3)
        throw new Z(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`);
    }
  }
  static verifyArgs(e) {
    if (zr("kernelSize" in e, "required key 'kernelSize' not in config"), typeof e.kernelSize != "number" && !Q_(e.kernelSize, "number", 1, 3))
      throw new Z(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`);
  }
  getConfig() {
    const e = {
      kernelSize: this.kernelSize,
      strides: this.strides,
      padding: this.padding,
      dataFormat: this.dataFormat,
      dilationRate: this.dilationRate,
      activation: Ra(this.activation),
      useBias: this.useBias,
      biasInitializer: Nn(this.biasInitializer),
      biasRegularizer: an(this.biasRegularizer),
      activityRegularizer: an(this.activityRegularizer),
      biasConstraint: es(this.biasConstraint)
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
class Ph extends bb {
  constructor(e, n) {
    super(e, n), this.kernel = null, Ph.verifyArgs(n), this.filters = n.filters, cs(this.filters, "filters"), this.kernelInitializer = wn(n.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.kernelConstraint = ts(n.kernelConstraint), this.kernelRegularizer = _n(n.kernelRegularizer);
  }
  build(e) {
    e = Ht(e);
    const n = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
    if (e[n] == null)
      throw new Z(`The channel dimension of the input should be defined. Found ${e[n]}`);
    const s = e[n], i = this.kernelSize.concat([s, this.filters]);
    this.kernel = this.addWeight("kernel", i, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [{ ndim: this.rank + 2, axes: { [n]: s } }], this.built = !0;
  }
  call(e, n) {
    return Q(() => {
      e = gt(e);
      let s;
      const i = this.bias == null ? null : this.bias.read(), r = uM(this.activation.getClassName());
      if (r != null && this.rank === 2)
        s = mI(e, this.kernel.read(), i, this.strides, this.padding, this.dataFormat, this.dilationRate, r);
      else {
        if (this.rank === 1)
          s = X7(e, this.kernel.read(), i, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);
        else if (this.rank === 2)
          s = mI(e, this.kernel.read(), i, this.strides, this.padding, this.dataFormat, this.dilationRate);
        else if (this.rank === 3)
          s = K7(e, this.kernel.read(), i, this.strides, this.padding, this.dataFormat, this.dilationRate);
        else
          throw new Ct("convolutions greater than 3D are not implemented yet.");
        this.activation != null && (s = this.activation.apply(s));
      }
      return s;
    });
  }
  computeOutputShape(e) {
    e = Ht(e);
    const n = [], s = this.dataFormat === "channelsLast" ? e.slice(1, e.length - 1) : e.slice(2);
    for (let r = 0; r < s.length; ++r) {
      const o = vr(s[r], this.kernelSize[r], this.padding, this.strides[r], typeof this.dilationRate == "number" ? this.dilationRate : this.dilationRate[r]);
      n.push(o);
    }
    let i = [e[0]];
    return this.dataFormat === "channelsLast" ? (i = i.concat(n), i.push(this.filters)) : (i.push(this.filters), i = i.concat(n)), i;
  }
  getConfig() {
    const e = {
      filters: this.filters,
      kernelInitializer: Nn(this.kernelInitializer),
      kernelRegularizer: an(this.kernelRegularizer),
      kernelConstraint: es(this.kernelConstraint)
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
  static verifyArgs(e) {
    if (!("filters" in e) || typeof e.filters != "number" || e.filters < 1)
      throw new Z(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`);
  }
}
class bm extends Ph {
  constructor(e) {
    super(2, e), bm.verifyArgs(e);
  }
  getConfig() {
    const e = super.getConfig();
    return delete e.rank, e;
  }
  static verifyArgs(e) {
    if (typeof e.kernelSize != "number" && !Q_(e.kernelSize, "number", 1, 2))
      throw new Z(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`);
  }
}
bm.className = "Conv2D";
Ee(bm);
class vm extends Ph {
  constructor(e) {
    super(3, e), vm.verifyArgs(e);
  }
  getConfig() {
    const e = super.getConfig();
    return delete e.rank, e;
  }
  static verifyArgs(e) {
    if (typeof e.kernelSize != "number" && !(Array.isArray(e.kernelSize) && (e.kernelSize.length === 1 || e.kernelSize.length === 3)))
      throw new Z(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`);
  }
}
vm.className = "Conv3D";
Ee(vm);
class mR extends bm {
  constructor(e) {
    if (super(e), this.inputSpec = [new Qn({ ndim: 4 })], this.padding !== "same" && this.padding !== "valid")
      throw new Z(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
  }
  build(e) {
    if (e = Ht(e), e.length !== 4)
      throw new Z("Input should have rank 4; Received input shape: " + JSON.stringify(e));
    const n = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
    if (e[n] == null)
      throw new Z("The channel dimension of the inputs should be defined. Found `None`.");
    const s = e[n], i = this.kernelSize.concat([this.filters, s]);
    this.kernel = this.addWeight("kernel", i, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new Qn({ ndim: 4, axes: { [n]: s } })], this.built = !0;
  }
  call(e, n) {
    return Q(() => {
      let s = gt(e);
      if (s.shape.length !== 4)
        throw new Z(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);
      const i = s.shape, r = i[0];
      let o, a;
      this.dataFormat === "channelsFirst" ? (o = 2, a = 3) : (o = 1, a = 2);
      const c = i[o], l = i[a], u = this.kernelSize[0], h = this.kernelSize[1], d = this.strides[0], f = this.strides[1], p = Vr(c, d, u, this.padding), y = Vr(l, f, h, this.padding), g = [r, p, y, this.filters];
      this.dataFormat !== "channelsLast" && (s = zt(s, [0, 2, 3, 1]));
      let m = k0(s, this.kernel.read(), g, this.strides, this.padding);
      return this.dataFormat !== "channelsLast" && (m = zt(m, [0, 3, 1, 2])), this.bias != null && (m = Ar(m, this.bias.read(), this.dataFormat)), this.activation != null && (m = this.activation.apply(m)), m;
    });
  }
  computeOutputShape(e) {
    e = Ht(e);
    const n = e.slice();
    let s, i, r;
    this.dataFormat === "channelsFirst" ? (s = 1, i = 2, r = 3) : (s = 3, i = 1, r = 2);
    const o = this.kernelSize[0], a = this.kernelSize[1], c = this.strides[0], l = this.strides[1];
    return n[s] = this.filters, n[i] = Vr(n[i], c, o, this.padding), n[r] = Vr(n[r], l, a, this.padding), n;
  }
  getConfig() {
    const e = super.getConfig();
    return delete e.dilationRate, e;
  }
}
mR.className = "Conv2DTranspose";
Ee(mR);
class gR extends vm {
  constructor(e) {
    if (super(e), this.inputSpec = [new Qn({ ndim: 5 })], this.padding !== "same" && this.padding !== "valid")
      throw new Z(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
  }
  build(e) {
    if (e = Ht(e), e.length !== 5)
      throw new Z("Input should have rank 5; Received input shape: " + JSON.stringify(e));
    const n = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
    if (e[n] == null)
      throw new Z("The channel dimension of the inputs should be defined. Found `None`.");
    const s = e[n], i = this.kernelSize.concat([this.filters, s]);
    this.kernel = this.addWeight("kernel", i, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new Qn({ ndim: 5, axes: { [n]: s } })], this.built = !0;
  }
  call(e, n) {
    return Q(() => {
      let s = gt(e);
      if (s.shape.length !== 5)
        throw new Z(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);
      const i = s.shape, r = i[0];
      let o, a, c;
      this.dataFormat === "channelsFirst" ? (c = 2, o = 3, a = 4) : (c = 1, o = 2, a = 3);
      const l = i[c], u = i[o], h = i[a], d = this.kernelSize[0], f = this.kernelSize[1], p = this.kernelSize[2], y = this.strides[0], g = this.strides[1], m = this.strides[2], x = Vr(l, y, d, this.padding), v = Vr(u, g, f, this.padding), b = Vr(h, m, p, this.padding), w = [r, x, v, b, this.filters];
      this.dataFormat !== "channelsLast" && (s = zt(s, [0, 2, 3, 4, 1]));
      let S = NS(s, this.kernel.read(), w, this.strides, this.padding);
      return this.dataFormat !== "channelsLast" && (S = zt(S, [0, 4, 1, 2, 3])), this.bias !== null && (S = Ar(S, this.bias.read(), this.dataFormat)), this.activation !== null && (S = this.activation.apply(S)), S;
    });
  }
  computeOutputShape(e) {
    e = Ht(e);
    const n = e.slice();
    let s, i, r, o;
    this.dataFormat === "channelsFirst" ? (s = 1, i = 2, r = 3, o = 4) : (s = 4, i = 1, r = 2, o = 3);
    const a = this.kernelSize[0], c = this.kernelSize[1], l = this.kernelSize[2], u = this.strides[0], h = this.strides[1], d = this.strides[2];
    return n[s] = this.filters, n[i] = Vr(n[i], u, a, this.padding), n[r] = Vr(n[r], h, c, this.padding), n[o] = Vr(n[o], d, l, this.padding), n;
  }
  getConfig() {
    const e = super.getConfig();
    return delete e.dilationRate, e;
  }
}
gR.className = "Conv3DTranspose";
Ee(gR);
class yR extends Ph {
  constructor(e, n) {
    if (super(e, n), this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", this.depthwiseKernel = null, this.pointwiseKernel = null, n.filters == null)
      throw new Z("The `filters` configuration field is required by SeparableConv, but is unspecified.");
    if (n.kernelInitializer != null || n.kernelRegularizer != null || n.kernelConstraint != null)
      throw new Z("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
    if (n.padding != null && n.padding !== "same" && n.padding !== "valid")
      throw new Z(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);
    this.depthMultiplier = n.depthMultiplier == null ? 1 : n.depthMultiplier, this.depthwiseInitializer = wn(n.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER), this.depthwiseRegularizer = _n(n.depthwiseRegularizer), this.depthwiseConstraint = ts(n.depthwiseConstraint), this.pointwiseInitializer = wn(n.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER), this.pointwiseRegularizer = _n(n.pointwiseRegularizer), this.pointwiseConstraint = ts(n.pointwiseConstraint);
  }
  build(e) {
    if (e = Ht(e), e.length < this.rank + 2)
      throw new Z(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank + 2}, but received input shape: ${JSON.stringify(e)}`);
    const n = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
    if (e[n] == null || e[n] < 0)
      throw new Z(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[n])}`);
    const s = e[n], i = this.kernelSize.concat([s, this.depthMultiplier]), r = [];
    for (let a = 0; a < this.rank; ++a)
      r.push(1);
    r.push(s * this.depthMultiplier, this.filters);
    const o = !0;
    this.depthwiseKernel = this.addWeight("depthwise_kernel", i, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, o, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", r, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, o, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, o, this.biasConstraint) : this.bias = null, this.inputSpec = [new Qn({ ndim: this.rank + 2, axes: { [n]: s } })], this.built = !0;
  }
  call(e, n) {
    return Q(() => {
      e = gt(e);
      let s;
      if (this.rank === 1)
        throw new Ct("1D separable convolution is not implemented yet.");
      return this.rank === 2 && (this.dataFormat === "channelsFirst" && (e = zt(e, [0, 2, 3, 1])), s = W0(e, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC")), this.useBias && (s = Ar(s, this.bias.read(), this.dataFormat)), this.activation != null && (s = this.activation.apply(s)), this.dataFormat === "channelsFirst" && (s = zt(s, [0, 3, 1, 2])), s;
    });
  }
  getConfig() {
    const e = super.getConfig();
    return delete e.rank, delete e.kernelInitializer, delete e.kernelRegularizer, delete e.kernelConstraint, e.depthwiseInitializer = Nn(this.depthwiseInitializer), e.pointwiseInitializer = Nn(this.pointwiseInitializer), e.depthwiseRegularizer = an(this.depthwiseRegularizer), e.pointwiseRegularizer = an(this.pointwiseRegularizer), e.depthwiseConstraint = es(this.depthwiseConstraint), e.pointwiseConstraint = es(this.pointwiseConstraint), e;
  }
}
yR.className = "SeparableConv";
class xR extends yR {
  constructor(e) {
    super(2, e);
  }
}
xR.className = "SeparableConv2D";
Ee(xR);
class vb extends Ph {
  constructor(e) {
    super(1, e), vb.verifyArgs(e), this.inputSpec = [{ ndim: 3 }];
  }
  getConfig() {
    const e = super.getConfig();
    return delete e.rank, delete e.dataFormat, e;
  }
  static verifyArgs(e) {
    if (typeof e.kernelSize != "number" && !Q_(e.kernelSize, "number", 1, 1))
      throw new Z(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`);
  }
}
vb.className = "Conv1D";
Ee(vb);
class bR extends Ft {
  constructor(e) {
    super(e), typeof e.cropping == "number" ? this.cropping = [[e.cropping, e.cropping], [e.cropping, e.cropping]] : typeof e.cropping[0] == "number" ? this.cropping = [
      [e.cropping[0], e.cropping[0]],
      [e.cropping[1], e.cropping[1]]
    ] : this.cropping = e.cropping, this.dataFormat = e.dataFormat === void 0 ? "channelsLast" : e.dataFormat, this.inputSpec = [{ ndim: 4 }];
  }
  computeOutputShape(e) {
    return this.dataFormat === "channelsFirst" ? [
      e[0],
      e[1],
      e[2] - this.cropping[0][0] - this.cropping[0][1],
      e[3] - this.cropping[1][0] - this.cropping[1][1]
    ] : [
      e[0],
      e[1] - this.cropping[0][0] - this.cropping[0][1],
      e[2] - this.cropping[1][0] - this.cropping[1][1],
      e[3]
    ];
  }
  call(e, n) {
    return Q(() => {
      if (e = gt(e), this.dataFormat === "channelsLast") {
        const s = xg(e, this.cropping[0][0], e.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);
        return xg(s, this.cropping[1][0], e.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3);
      } else {
        const s = xg(e, this.cropping[0][0], e.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);
        return xg(s, this.cropping[1][0], e.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4);
      }
    });
  }
  getConfig() {
    const e = { cropping: this.cropping, dataFormat: this.dataFormat }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
bR.className = "Cropping2D";
Ee(bR);
class vR extends Ft {
  constructor(e) {
    super(e), this.DEFAULT_SIZE = [2, 2], this.inputSpec = [{ ndim: 4 }], this.size = e.size == null ? this.DEFAULT_SIZE : e.size, this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, Un(this.dataFormat), this.interpolation = e.interpolation == null ? "nearest" : e.interpolation, CX(this.interpolation);
  }
  computeOutputShape(e) {
    if (this.dataFormat === "channelsFirst") {
      const n = e[2] == null ? null : this.size[0] * e[2], s = e[3] == null ? null : this.size[1] * e[3];
      return [e[0], e[1], n, s];
    } else {
      const n = e[1] == null ? null : this.size[0] * e[1], s = e[2] == null ? null : this.size[1] * e[2];
      return [e[0], n, s, e[3]];
    }
  }
  call(e, n) {
    return Q(() => {
      let s = gt(e);
      const i = s.shape;
      if (this.dataFormat === "channelsFirst") {
        s = zt(s, [0, 2, 3, 1]);
        const r = this.size[0] * i[2], o = this.size[1] * i[3], a = this.interpolation === "nearest" ? as.resizeNearestNeighbor(s, [r, o]) : as.resizeBilinear(s, [r, o]);
        return zt(a, [0, 3, 1, 2]);
      } else {
        const r = this.size[0] * i[1], o = this.size[1] * i[2];
        return this.interpolation === "nearest" ? as.resizeNearestNeighbor(s, [r, o]) : as.resizeBilinear(s, [r, o]);
      }
    });
  }
  getConfig() {
    const e = {
      size: this.size,
      dataFormat: this.dataFormat,
      interpolation: this.interpolation
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
vR.className = "UpSampling2D";
Ee(vR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Y7(t, e, n = [1, 1], s = "valid", i, r) {
  return Q(() => {
    i == null && (i = Cr()), Un(i);
    let o = fT(t, i);
    if (t.rank !== 4)
      throw new Z(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);
    if (e.rank !== 4)
      throw new Z(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);
    return o = Rh(o, e, n, s === "same" ? "same" : "valid", "NHWC", r), i === "channelsFirst" && (o = zt(o, [0, 3, 1, 2])), o;
  });
}
class wR extends bb {
  constructor(e) {
    super(2, e), this.depthwiseKernel = null, this.depthMultiplier = e.depthMultiplier == null ? 1 : e.depthMultiplier, this.depthwiseInitializer = wn(e.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.depthwiseConstraint = ts(e.depthwiseConstraint), this.depthwiseRegularizer = _n(e.depthwiseRegularizer);
  }
  build(e) {
    if (e = Ht(e), e.length < 4)
      throw new Z(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);
    const n = this.dataFormat === "channelsFirst" ? 1 : 3;
    if (e[n] == null || e[n] < 0)
      throw new Z(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[n]}).`);
    const s = e[n], i = [
      this.kernelSize[0],
      this.kernelSize[1],
      s,
      this.depthMultiplier
    ];
    this.depthwiseKernel = this.addWeight("depthwise_kernel", i, null, this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [s * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0;
  }
  call(e, n) {
    return Q(() => {
      e = gt(e);
      let s = Y7(e, this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);
      return this.useBias && (s = Ar(s, this.bias.read(), this.dataFormat)), this.activation != null && (s = this.activation.apply(s)), s;
    });
  }
  computeOutputShape(e) {
    e = Ht(e);
    const n = this.dataFormat === "channelsFirst" ? e[2] : e[1], s = this.dataFormat === "channelsFirst" ? e[3] : e[2], i = this.dataFormat === "channelsFirst" ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier, r = vr(n, this.kernelSize[0], this.padding, this.strides[0]), o = vr(s, this.kernelSize[1], this.padding, this.strides[1]);
    return this.dataFormat === "channelsFirst" ? [e[0], i, r, o] : [e[0], r, o, i];
  }
  getConfig() {
    const e = super.getConfig();
    return e.depthMultiplier = this.depthMultiplier, e.depthwiseInitializer = Nn(this.depthwiseInitializer), e.depthwiseRegularizer = an(this.depthwiseRegularizer), e.depthwiseConstraint = es(this.depthwiseRegularizer), e;
  }
}
wR.className = "DepthwiseConv2D";
Ee(wR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function SR(t, e, n, s) {
  if (Array.isArray(t)) {
    if (e != null || n != null)
      throw new Z("When inputs is an array, neither initialState or constants should be provided");
    s != null && (n = t.slice(t.length - s, t.length), t = t.slice(0, t.length - s)), t.length > 1 && (e = t.slice(1, t.length)), t = t[0];
  }
  function i(r) {
    return r == null || Array.isArray(r) ? r : [r];
  }
  return e = i(e), n = i(n), { inputs: t, initialState: e, constants: n };
}
function _R(t, e, n, s = !1, i, r, o = !1, a = !1) {
  return Q(() => {
    const c = e.shape.length;
    if (c < 3)
      throw new Z(`Input should be at least 3D, but is ${c}D.`);
    const l = [1, 0].concat(Tr(2, c));
    if (e = zt(e, l), r != null)
      throw new Ct("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
    o && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), i != null && (i = Le(Le(i, "bool"), "float32"), i.rank === c - 1 && (i = vn(i, -1)), i = zt(i, l)), s && (e = Fi(e, 0), i != null && (i = Fi(i, 0)));
    const u = [];
    let h, d = n;
    const f = e.shape[0], p = Pi(e);
    let y;
    i != null && (y = Pi(i));
    for (let m = 0; m < f; ++m) {
      const x = p[m], v = Q(() => t(x, d));
      if (i == null)
        h = v[0], d = v[1];
      else {
        const b = Q(() => {
          const w = y[m], S = je(vi(w), w), _ = Se(q(v[0], w), q(d[0], S)), E = d.map((I, k) => Se(q(v[1][k], w), q(I, S)));
          return { output: _, newStates: E };
        });
        h = b.output, d = b.newStates;
      }
      a && u.push(h);
    }
    let g;
    return a && (g = ri(u, 1)), [h, g, d];
  });
}
class Ga extends Ft {
  constructor(e) {
    super(e);
    let n;
    if (e.cell == null)
      throw new Z("cell property is missing for the constructor of RNN.");
    if (Array.isArray(e.cell) ? n = new gT({ cells: e.cell }) : n = e.cell, n.stateSize == null)
      throw new Z("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
    this.cell = n, this.returnSequences = e.returnSequences == null ? !1 : e.returnSequences, this.returnState = e.returnState == null ? !1 : e.returnState, this.goBackwards = e.goBackwards == null ? !1 : e.goBackwards, this._stateful = e.stateful == null ? !1 : e.stateful, this.unroll = e.unroll == null ? !1 : e.unroll, this.supportsMasking = !0, this.inputSpec = [new Qn({ ndim: 3 })], this.stateSpec = null, this.states_ = null, this.numConstants = null, this.keptStates = [];
  }
  // Porting Note: This is the equivalent of `RNN.states` property getter in
  //   PyKeras.
  getStates() {
    if (this.states_ == null) {
      const e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
      return Tr(0, e).map((n) => null);
    } else
      return this.states_;
  }
  // Porting Note: This is the equivalent of the `RNN.states` property setter in
  //   PyKeras.
  setStates(e) {
    this.states_ = e;
  }
  computeOutputShape(e) {
    i1(e) && (e = e[0]), e = e;
    let n = this.cell.stateSize;
    Array.isArray(n) || (n = [n]);
    const s = n[0];
    let i;
    if (this.returnSequences ? i = [e[0], e[1], s] : i = [e[0], s], this.returnState) {
      const r = [];
      for (const o of n)
        r.push([e[0], o]);
      return [i].concat(r);
    } else
      return i;
  }
  computeMask(e, n) {
    return Q(() => {
      Array.isArray(n) && (n = n[0]);
      const s = this.returnSequences ? n : null;
      if (this.returnState) {
        const i = this.states.map((r) => null);
        return [s].concat(i);
      } else
        return s;
    });
  }
  /**
   * Get the current state tensors of the RNN.
   *
   * If the state hasn't been set, return an array of `null`s of the correct
   * length.
   */
  get states() {
    if (this.states_ == null) {
      const e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, n = [];
      for (let s = 0; s < e; ++s)
        n.push(null);
      return n;
    } else
      return this.states_;
  }
  set states(e) {
    this.states_ = e;
  }
  build(e) {
    if (this.numConstants != null)
      throw new Ct("Constants support is not implemented in RNN yet.");
    i1(e) && (e = e[0]), e = e;
    const n = this.stateful ? e[0] : null, s = e.slice(2);
    this.inputSpec[0] = new Qn({ shape: [n, null, ...s] });
    const i = [e[0]].concat(e.slice(2));
    this.cell.build(i);
    let r;
    if (Array.isArray(this.cell.stateSize) ? r = this.cell.stateSize : r = [this.cell.stateSize], this.stateSpec != null) {
      if (!Bt(this.stateSpec.map((o) => o.shape[o.shape.length - 1]), r))
        throw new Z(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`);
    } else
      this.stateSpec = r.map((o) => new Qn({ shape: [null, o] }));
    this.stateful && this.resetStates();
  }
  /**
   * Reset the state tensors of the RNN.
   *
   * If the `states` argument is `undefined` or `null`, will set the
   * state tensor(s) of the RNN to all-zero tensors of the appropriate
   * shape(s).
   *
   * If `states` is provided, will set the state tensors of the RNN to its
   * value.
   *
   * @param states Optional externally-provided initial states.
   * @param training Whether this call is done during training. For stateful
   *   RNNs, this affects whether the old states are kept or discarded. In
   *   particular, if `training` is `true`, the old states will be kept so
   *   that subsequent backpropgataion through time (BPTT) may work properly.
   *   Else, the old states will be discarded.
   */
  resetStates(e, n = !1) {
    Q(() => {
      if (!this.stateful)
        throw new Br("Cannot call resetStates() on an RNN Layer that is not stateful.");
      const s = this.inputSpec[0].shape[0];
      if (s == null)
        throw new Z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      if (this.states_ == null)
        Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((i) => qn([s, i])) : this.states_ = [qn([s, this.cell.stateSize])];
      else if (e == null)
        At(this.states_), this.keptStates != null && (At(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((i) => qn([s, i])) : this.states_[0] = qn([s, this.cell.stateSize]);
      else {
        if (Array.isArray(e) || (e = [e]), e.length !== this.states_.length)
          throw new Z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);
        n === !0 ? this.keptStates.push(this.states_.slice()) : At(this.states_);
        for (let i = 0; i < this.states_.length; ++i) {
          const r = e[i], o = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[i] : this.cell.stateSize, a = [s, o];
          if (!Bt(r.shape, a))
            throw new Z(`State ${i} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);
          this.states_[i] = r;
        }
      }
      this.states_ = this.states_.map((i) => Zn(i.clone()));
    });
  }
  apply(e, n) {
    let s = n == null ? null : n.initialState, i = n == null ? null : n.constants;
    n == null && (n = {});
    const r = SR(e, s, i, this.numConstants);
    e = r.inputs, s = r.initialState, i = r.constants;
    let o = [], a = [];
    if (s != null) {
      n.initialState = s, o = o.concat(s), this.stateSpec = [];
      for (const l of s)
        this.stateSpec.push(new Qn({ shape: l.shape }));
      a = a.concat(this.stateSpec);
    }
    if (i != null && (n.constants = i, o = o.concat(i), this.numConstants = i.length), o[0] instanceof oo) {
      const l = [e].concat(o), u = this.inputSpec.concat(a), h = this.inputSpec;
      this.inputSpec = u;
      const d = super.apply(l, n);
      return this.inputSpec = h, d;
    } else
      return super.apply(e, n);
  }
  // tslint:disable-next-line:no-any
  call(e, n) {
    return Q(() => {
      const s = n == null ? null : n.mask, i = n == null ? null : n.training;
      let r = n == null ? null : n.initialState;
      e = gt(e), r == null && (this.stateful ? r = this.states_ : r = this.getInitialState(e));
      const o = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
      if (r.length !== o)
        throw new Z(`RNN Layer has ${o} state(s) but was passed ${r.length} initial state(s).`);
      this.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
      const a = { training: i }, l = _R((p, y) => {
        const g = this.cell.call([p].concat(y), a);
        return [g[0], g.slice(1)];
      }, e, r, this.goBackwards, s, null, this.unroll, this.returnSequences), u = l[0], h = l[1], d = l[2];
      this.stateful && this.resetStates(d, i);
      const f = this.returnSequences ? h : u;
      return this.returnState ? [f].concat(d) : f;
    });
  }
  getInitialState(e) {
    return Q(() => {
      let n = qn(e.shape);
      return n = Qe(n, [1, 2]), n = pm(n), Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map((s) => s > 1 ? n1(n, [1, s]) : n) : this.cell.stateSize > 1 ? [n1(n, [1, this.cell.stateSize])] : [n];
    });
  }
  get trainableWeights() {
    return this.trainable ? this.cell.trainableWeights : [];
  }
  get nonTrainableWeights() {
    return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
  }
  setFastWeightInitDuringBuild(e) {
    super.setFastWeightInitDuringBuild(e), this.cell != null && this.cell.setFastWeightInitDuringBuild(e);
  }
  getConfig() {
    const e = super.getConfig(), n = {
      returnSequences: this.returnSequences,
      returnState: this.returnState,
      goBackwards: this.goBackwards,
      stateful: this.stateful,
      unroll: this.unroll
    };
    this.numConstants != null && (n.numConstants = this.numConstants);
    const s = this.cell.getConfig();
    return this.getClassName() === Ga.className && (n.cell = {
      className: this.cell.getClassName(),
      config: s
    }), Object.assign(Object.assign(Object.assign({}, s), e), n);
  }
  /** @nocollapse */
  static fromConfig(e, n, s = {}) {
    const i = n.cell, r = Io(i, s);
    return new e(Object.assign(n, { cell: r }));
  }
}
Ga.className = "RNN";
Ee(Ga);
class wb extends Ft {
}
class pT extends wb {
  constructor(e) {
    super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = e.units, cs(this.units, "units"), this.activation = Da(e.activation == null ? this.DEFAULT_ACTIVATION : e.activation), this.useBias = e.useBias == null ? !0 : e.useBias, this.kernelInitializer = wn(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = wn(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = wn(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = _n(e.kernelRegularizer), this.recurrentRegularizer = _n(e.recurrentRegularizer), this.biasRegularizer = _n(e.biasRegularizer), this.kernelConstraint = ts(e.kernelConstraint), this.recurrentConstraint = ts(e.recurrentConstraint), this.biasConstraint = ts(e.biasConstraint), this.dropout = Iu([1, Ma([0, e.dropout == null ? 0 : e.dropout])]), this.recurrentDropout = Iu([
      1,
      Ma([0, e.recurrentDropout == null ? 0 : e.recurrentDropout])
    ]), this.dropoutFunc = e.dropoutFunc, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
  }
  build(e) {
    e = Ht(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0;
  }
  // Porting Note: PyKeras' equivalent of this method takes two tensor inputs:
  //   `inputs` and `states`. Here, the two tensors are combined into an
  //   `Tensor[]` Array as the first input argument.
  //   Similarly, PyKeras' equivalent of this method returns two values:
  //    `output` and `[output]`. Here the two are combined into one length-2
  //    `Tensor[]`, consisting of `output` repeated.
  call(e, n) {
    return Q(() => {
      if (e = e, e.length !== 2)
        throw new Z(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);
      let s = e[1];
      e = e[0];
      const i = n.training == null ? !1 : n.training;
      0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = $a({
        ones: () => vi(e),
        rate: this.dropout,
        training: i,
        dropoutFunc: this.dropoutFunc
      })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = $a({
        ones: () => vi(s),
        rate: this.recurrentDropout,
        training: i,
        dropoutFunc: this.dropoutFunc
      }));
      let r;
      const o = this.dropoutMask, a = this.recurrentDropoutMask;
      o != null ? r = Yr(q(e, o), this.kernel.read()) : r = Yr(e, this.kernel.read()), this.bias != null && (r = Ar(r, this.bias.read())), a != null && (s = q(s, a));
      let c = Se(r, Yr(s, this.recurrentKernel.read()));
      return this.activation != null && (c = this.activation.apply(c)), [c, c];
    });
  }
  getConfig() {
    const e = super.getConfig(), n = {
      units: this.units,
      activation: Ra(this.activation),
      useBias: this.useBias,
      kernelInitializer: Nn(this.kernelInitializer),
      recurrentInitializer: Nn(this.recurrentInitializer),
      biasInitializer: Nn(this.biasInitializer),
      kernelRegularizer: an(this.kernelRegularizer),
      recurrentRegularizer: an(this.recurrentRegularizer),
      biasRegularizer: an(this.biasRegularizer),
      activityRegularizer: an(this.activityRegularizer),
      kernelConstraint: es(this.kernelConstraint),
      recurrentConstraint: es(this.recurrentConstraint),
      biasConstraint: es(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout
    };
    return Object.assign(Object.assign({}, e), n);
  }
}
pT.className = "SimpleRNNCell";
Ee(pT);
class TR extends Ga {
  constructor(e) {
    e.cell = new pT(e), super(e);
  }
  call(e, n) {
    return Q(() => {
      this.cell.dropoutMask != null && (At(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (At(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
      const s = n == null ? null : n.mask, i = n == null ? null : n.training, r = n == null ? null : n.initialState;
      return super.call(e, { mask: s, training: i, initialState: r });
    });
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n);
  }
}
TR.className = "SimpleRNN";
Ee(TR);
class mT extends wb {
  constructor(e) {
    if (super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", e.resetAfter)
      throw new Z("GRUCell does not support reset_after parameter set to true.");
    this.units = e.units, cs(this.units, "units"), this.activation = Da(e.activation === void 0 ? this.DEFAULT_ACTIVATION : e.activation), this.recurrentActivation = Da(e.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), this.useBias = e.useBias == null ? !0 : e.useBias, this.kernelInitializer = wn(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = wn(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = wn(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = _n(e.kernelRegularizer), this.recurrentRegularizer = _n(e.recurrentRegularizer), this.biasRegularizer = _n(e.biasRegularizer), this.kernelConstraint = ts(e.kernelConstraint), this.recurrentConstraint = ts(e.recurrentConstraint), this.biasConstraint = ts(e.biasConstraint), this.dropout = Iu([1, Ma([0, e.dropout == null ? 0 : e.dropout])]), this.recurrentDropout = Iu([
      1,
      Ma([0, e.recurrentDropout == null ? 0 : e.recurrentDropout])
    ]), this.dropoutFunc = e.dropoutFunc, this.implementation = e.implementation, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
  }
  build(e) {
    e = Ht(e);
    const n = e[e.length - 1];
    this.kernel = this.addWeight("kernel", [n, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units * 3], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0;
  }
  call(e, n) {
    return Q(() => {
      if (e = e, e.length !== 2)
        throw new Z(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);
      const s = n.training == null ? !1 : n.training;
      let i = e[1];
      e = e[0], 0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = $a({
        ones: () => vi(e),
        rate: this.dropout,
        training: s,
        count: 3,
        dropoutFunc: this.dropoutFunc
      })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = $a({
        ones: () => vi(i),
        rate: this.recurrentDropout,
        training: s,
        count: 3,
        dropoutFunc: this.dropoutFunc
      }));
      const r = this.dropoutMask, o = this.recurrentDropoutMask;
      let a, c, l;
      0 < this.dropout && this.dropout < 1 && (e = q(e, r[0]));
      let u = Yr(e, this.kernel.read());
      this.useBias && (u = Ar(u, this.bias.read())), 0 < this.recurrentDropout && this.recurrentDropout < 1 && (i = q(i, o[0]));
      const h = this.recurrentKernel.read(), [d, f] = ti(h, [2 * this.units, this.units], h.rank - 1), p = Yr(i, d), [y, g, m] = ti(u, 3, u.rank - 1), [x, v] = ti(p, 2, p.rank - 1);
      a = this.recurrentActivation.apply(Se(y, x)), c = this.recurrentActivation.apply(Se(g, v));
      const b = Yr(q(c, i), f);
      l = this.activation.apply(Se(m, b));
      const w = Se(q(a, i), q(Se(1, hn(a)), l));
      return [w, w];
    });
  }
  getConfig() {
    const e = super.getConfig(), n = {
      units: this.units,
      activation: Ra(this.activation),
      recurrentActivation: Ra(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: Nn(this.kernelInitializer),
      recurrentInitializer: Nn(this.recurrentInitializer),
      biasInitializer: Nn(this.biasInitializer),
      kernelRegularizer: an(this.kernelRegularizer),
      recurrentRegularizer: an(this.recurrentRegularizer),
      biasRegularizer: an(this.biasRegularizer),
      activityRegularizer: an(this.activityRegularizer),
      kernelConstraint: es(this.kernelConstraint),
      recurrentConstraint: es(this.recurrentConstraint),
      biasConstraint: es(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation,
      resetAfter: !1
    };
    return Object.assign(Object.assign({}, e), n);
  }
}
mT.className = "GRUCell";
Ee(mT);
class CR extends Ga {
  constructor(e) {
    e.implementation === 0 && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new mT(e), super(e);
  }
  call(e, n) {
    return Q(() => {
      this.cell.dropoutMask != null && (At(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (At(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
      const s = n == null ? null : n.mask, i = n == null ? null : n.training, r = n == null ? null : n.initialState;
      return super.call(e, { mask: s, training: i, initialState: r });
    });
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return n.implmentation === 0 && (n.implementation = 1), new e(n);
  }
}
CR.className = "GRU";
Ee(CR);
class Sb extends wb {
  constructor(e) {
    super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = e.units, cs(this.units, "units"), this.activation = Da(e.activation === void 0 ? this.DEFAULT_ACTIVATION : e.activation), this.recurrentActivation = Da(e.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), this.useBias = e.useBias == null ? !0 : e.useBias, this.kernelInitializer = wn(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = wn(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = wn(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.unitForgetBias = e.unitForgetBias, this.kernelRegularizer = _n(e.kernelRegularizer), this.recurrentRegularizer = _n(e.recurrentRegularizer), this.biasRegularizer = _n(e.biasRegularizer), this.kernelConstraint = ts(e.kernelConstraint), this.recurrentConstraint = ts(e.recurrentConstraint), this.biasConstraint = ts(e.biasConstraint), this.dropout = Iu([1, Ma([0, e.dropout == null ? 0 : e.dropout])]), this.recurrentDropout = Iu([
      1,
      Ma([0, e.recurrentDropout == null ? 0 : e.recurrentDropout])
    ]), this.dropoutFunc = e.dropoutFunc, this.implementation = e.implementation, this.stateSize = [this.units, this.units], this.dropoutMask = null, this.recurrentDropoutMask = null;
  }
  build(e) {
    var n;
    e = Ht(e);
    const s = e[e.length - 1];
    this.kernel = this.addWeight("kernel", [s, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint);
    let i;
    if (this.useBias) {
      if (this.unitForgetBias) {
        const r = this.biasInitializer, o = this.units;
        i = new (n = class extends rr {
          apply(c, l) {
            const u = r.apply([o]), h = new tT().apply([o]), d = r.apply([o * 2]);
            return J2(J2(u, h), d);
          }
        }, /** @nocollapse */
        n.className = "CustomInit", n)();
      } else
        i = this.biasInitializer;
      this.bias = this.addWeight("bias", [this.units * 4], null, i, this.biasRegularizer, !0, this.biasConstraint);
    } else
      this.bias = null;
    this.built = !0;
  }
  call(e, n) {
    return Q(() => {
      const s = n.training == null ? !1 : n.training;
      if (e = e, e.length !== 3)
        throw new Z(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);
      let i = e[1];
      const r = e[2];
      e = e[0], 0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = $a({
        ones: () => vi(e),
        rate: this.dropout,
        training: s,
        count: 4,
        dropoutFunc: this.dropoutFunc
      })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = $a({
        ones: () => vi(i),
        rate: this.recurrentDropout,
        training: s,
        count: 4,
        dropoutFunc: this.dropoutFunc
      }));
      const o = this.dropoutMask, a = this.recurrentDropoutMask;
      let c, l, u, h;
      0 < this.dropout && this.dropout < 1 && (e = q(e, o[0]));
      let d = Yr(e, this.kernel.read());
      0 < this.recurrentDropout && this.recurrentDropout < 1 && (i = q(i, a[0])), d = Se(d, Yr(i, this.recurrentKernel.read())), this.useBias && (d = Ar(d, this.bias.read()));
      const [f, p, y, g] = ti(d, 4, d.rank - 1);
      c = this.recurrentActivation.apply(f), l = this.recurrentActivation.apply(p), u = Se(q(l, r), q(c, this.activation.apply(y))), h = this.recurrentActivation.apply(g);
      const m = q(h, this.activation.apply(u));
      return [m, m, u];
    });
  }
  getConfig() {
    const e = super.getConfig(), n = {
      units: this.units,
      activation: Ra(this.activation),
      recurrentActivation: Ra(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: Nn(this.kernelInitializer),
      recurrentInitializer: Nn(this.recurrentInitializer),
      biasInitializer: Nn(this.biasInitializer),
      unitForgetBias: this.unitForgetBias,
      kernelRegularizer: an(this.kernelRegularizer),
      recurrentRegularizer: an(this.recurrentRegularizer),
      biasRegularizer: an(this.biasRegularizer),
      activityRegularizer: an(this.activityRegularizer),
      kernelConstraint: es(this.kernelConstraint),
      recurrentConstraint: es(this.recurrentConstraint),
      biasConstraint: es(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation
    };
    return Object.assign(Object.assign({}, e), n);
  }
}
Sb.className = "LSTMCell";
Ee(Sb);
class IR extends Ga {
  constructor(e) {
    e.implementation === 0 && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new Sb(e), super(e);
  }
  call(e, n) {
    return Q(() => {
      this.cell.dropoutMask != null && (At(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (At(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
      const s = n == null ? null : n.mask, i = n == null ? null : n.training, r = n == null ? null : n.initialState;
      return super.call(e, { mask: s, training: i, initialState: r });
    });
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return n.implmentation === 0 && (n.implementation = 1), new e(n);
  }
}
IR.className = "LSTM";
Ee(IR);
class gT extends wb {
  constructor(e) {
    super(e), this.cells = e.cells;
  }
  get stateSize() {
    const e = [];
    for (const n of this.cells.slice().reverse())
      Array.isArray(n.stateSize) ? e.push(...n.stateSize) : e.push(n.stateSize);
    return e;
  }
  call(e, n) {
    return Q(() => {
      e = e;
      let s = e.slice(1);
      const i = [];
      for (const a of this.cells.slice().reverse())
        Array.isArray(a.stateSize) ? i.push(s.splice(0, a.stateSize.length)) : i.push(s.splice(0, 1));
      i.reverse();
      const r = [];
      let o;
      for (let a = 0; a < this.cells.length; ++a) {
        const c = this.cells[a];
        s = i[a], a === 0 ? o = [e[0]].concat(s) : o = [o[0]].concat(s), o = c.call(o, n), r.push(o.slice(1));
      }
      s = [];
      for (const a of r.slice().reverse())
        s.push(...a);
      return [o[0]].concat(s);
    });
  }
  build(e) {
    i1(e) && (e = e[0]), e = e;
    let n;
    this.cells.forEach((s, i) => {
      Tc(`RNNCell_${i}`, () => {
        s.build(e), Array.isArray(s.stateSize) ? n = s.stateSize[0] : n = s.stateSize, e = [e[0], n];
      });
    }), this.built = !0;
  }
  getConfig() {
    const e = super.getConfig(), n = (r) => ({
      className: r.getClassName(),
      config: r.getConfig()
    }), i = { cells: this.cells.map(n) };
    return Object.assign(Object.assign({}, e), i);
  }
  /** @nocollapse */
  static fromConfig(e, n, s = {}) {
    const i = [];
    for (const r of n.cells)
      i.push(Io(r, s));
    return new e({ cells: i });
  }
  get trainableWeights() {
    if (!this.trainable)
      return [];
    const e = [];
    for (const n of this.cells)
      e.push(...n.trainableWeights);
    return e;
  }
  get nonTrainableWeights() {
    const e = [];
    for (const n of this.cells)
      e.push(...n.nonTrainableWeights);
    if (!this.trainable) {
      const n = [];
      for (const s of this.cells)
        n.push(...s.trainableWeights);
      return n.concat(e);
    }
    return e;
  }
  /**
   * Retrieve the weights of a the model.
   *
   * @returns A flat `Array` of `tf.Tensor`s.
   */
  getWeights() {
    const e = [];
    for (const n of this.cells)
      e.push(...n.weights);
    return r1(e);
  }
  /**
   * Set the weights of the model.
   *
   * @param weights An `Array` of `tf.Tensor`s with shapes and types matching
   *     the output of `getWeights()`.
   */
  setWeights(e) {
    const n = [];
    for (const s of this.cells) {
      const i = s.weights.length, r = e.splice(i);
      for (let o = 0; o < s.weights.length; ++o)
        n.push([s.weights[o], r[o]]);
    }
    cT(n);
  }
}
gT.className = "StackedRNNCells";
Ee(gT);
function $a(t) {
  const { ones: e, rate: n, training: s = !1, count: i = 1, dropoutFunc: r } = t, o = () => r != null ? r(e(), n) : yM(e(), n), a = () => gm(o, e, s);
  return !i || i <= 1 ? Zn(a().clone()) : Array(i).fill(void 0).map(a).map((l) => Zn(l.clone()));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
var Z7 = globalThis && globalThis.__rest || function(t, e) {
  var n = {};
  for (var s in t)
    Object.prototype.hasOwnProperty.call(t, s) && e.indexOf(s) < 0 && (n[s] = t[s]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, s = Object.getOwnPropertySymbols(t); i < s.length; i++)
      e.indexOf(s[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, s[i]) && (n[s[i]] = t[s[i]]);
  return n;
};
class ER extends Ga {
  constructor(e) {
    if (e.unroll)
      throw new Ct("Unrolling is not possible with convolutional RNNs.");
    if (Array.isArray(e.cell))
      throw new Ct("It is not possible at the moment to stack convolutional cells.");
    super(e), this.inputSpec = [new Qn({ ndim: 5 })];
  }
  call(e, n) {
    return Q(() => {
      if (this.cell.dropoutMask != null && (At(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (At(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), n && n.constants)
        throw new Z("ConvRNN2D cell does not support constants");
      const s = n == null ? null : n.mask, i = n == null ? null : n.training, r = n == null ? null : n.initialState;
      return super.call(e, { mask: s, training: i, initialState: r });
    });
  }
  computeOutputShape(e) {
    let n = this.computeSingleOutputShape(e);
    return this.returnSequences || (n = [n[0], ...n.slice(2)]), this.returnState && (n = [n, ...Array(2).fill([e[0], ...n.slice(-3)])]), n;
  }
  getInitialState(e) {
    return Q(() => {
      const { stateSize: n } = this.cell, s = e.shape, i = this.computeSingleOutputShape(s), r = [i[0], ...i.slice(2)], o = qn(r);
      return Array.isArray(n) ? Array(n.length).fill(o) : [o];
    });
  }
  resetStates(e, n = !1) {
    Q(() => {
      if (!this.stateful)
        throw new Br("Cannot call resetStates() on an RNN Layer that is not stateful.");
      const s = this.inputSpec[0].shape, i = this.computeSingleOutputShape(s), r = [i[0], ...i.slice(2)];
      if (s[0] == null)
        throw new Z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      if (this.getStates() == null)
        Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => qn(r)) : this.states_ = [qn(r)];
      else if (e == null)
        At(this.states_), this.keptStates != null && (At(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => qn(r)) : this.states_[0] = qn(r);
      else {
        if (Array.isArray(e) || (e = [e]), e.length !== this.states_.length)
          throw new Z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);
        n ? this.keptStates.push(this.states_.slice()) : At(this.states_);
        for (let a = 0; a < this.states_.length; ++a) {
          const c = e[a], l = r;
          if (!Bt(c.shape, l))
            throw new Z(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${c.shape}`);
          this.states_[a] = c;
        }
      }
      this.states_ = this.states_.map((a) => Zn(a.clone()));
    });
  }
  computeSingleOutputShape(e) {
    const { dataFormat: n, filters: s, kernelSize: i, padding: r, strides: o, dilationRate: a } = this.cell, c = n === "channelsFirst", l = e[c ? 3 : 2], u = e[c ? 4 : 3], h = vr(l, i[0], r, o[0], a[0]), d = vr(u, i[1], r, o[1], a[1]);
    return [
      ...e.slice(0, 2),
      ...c ? [s, h, d] : [h, d, s]
    ];
  }
}
ER.className = "ConvRNN2D";
class yT extends Sb {
  constructor(e) {
    const { filters: n, kernelSize: s, strides: i, padding: r, dataFormat: o, dilationRate: a } = e;
    super(Object.assign(Object.assign({}, e), { units: n })), this.filters = n, cs(this.filters, "filters"), this.kernelSize = Jl(s, 2, "kernelSize"), this.kernelSize.forEach((c) => cs(c, "kernelSize")), this.strides = Jl(i || 1, 2, "strides"), this.strides.forEach((c) => cs(c, "strides")), this.padding = r || "valid", Bi(this.padding), this.dataFormat = o || "channelsLast", Un(this.dataFormat), this.dilationRate = Jl(a || 1, 2, "dilationRate"), this.dilationRate.forEach((c) => cs(c, "dilationRate"));
  }
  build(e) {
    var n;
    e = Ht(e);
    const s = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
    if (e[s] == null)
      throw new Z(`The channel dimension of the input should be defined. Found ${e[s]}`);
    const i = e[s], r = 4, o = this.kernelSize.concat([i, this.filters * r]);
    this.kernel = this.addWeight("kernel", o, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint);
    const a = this.kernelSize.concat([this.filters, this.filters * r]);
    if (this.recurrentKernel = this.addWeight("recurrent_kernel", a, null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
      let c;
      if (this.unitForgetBias) {
        const l = this.biasInitializer, u = this.filters;
        c = new (n = class extends rr {
          apply(d, f) {
            const p = l.apply([u]), y = Qs([u]), g = l.apply([u * 2]);
            return eT([p, y, g]);
          }
        }, /** @nocollapse */
        n.className = "CustomInit", n)();
      } else
        c = this.biasInitializer;
      this.bias = this.addWeight("bias", [this.filters * r], null, c, this.biasRegularizer, !0, this.biasConstraint);
    }
    this.built = !0;
  }
  call(e, n) {
    return Q(() => {
      if (e.length !== 3)
        throw new Z(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);
      const s = n.training || !1, i = e[0], r = e[1], o = e[2], a = 4;
      0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = $a({
        ones: () => vi(i),
        rate: this.dropout,
        training: s,
        count: a,
        dropoutFunc: this.dropoutFunc
      }));
      const c = this.dropoutMask, l = (ne, re, fe) => !re || !re[fe] ? ne : q(re[fe], ne);
      let u = l(i, c, 0), h = l(i, c, 1), d = l(i, c, 2), f = l(i, c, 3);
      0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = $a({
        ones: () => vi(r),
        rate: this.recurrentDropout,
        training: s,
        count: a,
        dropoutFunc: this.dropoutFunc
      }));
      const p = this.recurrentDropoutMask;
      let y = l(r, p, 0), g = l(r, p, 1), m = l(r, p, 2), x = l(r, p, 3);
      const v = 3, [b, w, S, _] = ti(this.kernel.read(), a, v), [E, I, k, M] = this.useBias ? ti(this.bias.read(), a) : [null, null, null, null];
      u = this.inputConv(u, b, E, this.padding), h = this.inputConv(h, w, I, this.padding), d = this.inputConv(d, S, k, this.padding), f = this.inputConv(f, _, M, this.padding);
      const [L, O, $, D] = ti(this.recurrentKernel.read(), a, v);
      y = this.recurrentConv(y, L), g = this.recurrentConv(g, O), m = this.recurrentConv(m, $), x = this.recurrentConv(x, D);
      const z = this.recurrentActivation.apply(Se(u, y)), W = this.recurrentActivation.apply(Se(h, g)), j = Se(q(W, o), q(z, this.activation.apply(Se(d, m)))), J = q(this.recurrentActivation.apply(Se(f, x)), this.activation.apply(j));
      return [J, J, j];
    });
  }
  getConfig() {
    const e = super.getConfig(), n = Z7(e, ["units"]), s = {
      filters: this.filters,
      kernelSize: this.kernelSize,
      padding: this.padding,
      dataFormat: this.dataFormat,
      dilationRate: this.dilationRate,
      strides: this.strides
    };
    return Object.assign(Object.assign({}, n), s);
  }
  inputConv(e, n, s, i) {
    const r = $o(e, n, this.strides, i || "valid", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC", this.dilationRate);
    return s ? Ar(r, s, this.dataFormat) : r;
  }
  recurrentConv(e, n) {
    return $o(e, n, 1, "same", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC");
  }
}
yT.className = "ConvLSTM2DCell";
Ee(yT);
class NR extends ER {
  constructor(e) {
    const n = new yT(e);
    super(Object.assign(Object.assign({}, e), { cell: n }));
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n);
  }
}
NR.className = "ConvLSTM2D";
Ee(NR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class xT extends Ft {
  constructor(e) {
    super(e), this.rate = Math.max(Math.min(e.rate, 1), 0), this.noiseShape = e.noiseShape, this.seed = e.seed, this.supportsMasking = !0;
  }
  getNoiseShape(e) {
    if (this.noiseShape == null)
      return this.noiseShape;
    const n = e.shape, s = [];
    for (let i = 0; i < this.noiseShape.length; ++i)
      s.push(this.noiseShape[i] == null ? n[i] : this.noiseShape[i]);
    return s;
  }
  call(e, n) {
    return Q(() => {
      this.invokeCallHook(e, n);
      const s = gt(e);
      if (0 < this.rate && this.rate < 1) {
        const i = n.training == null ? !1 : n.training, r = this.getNoiseShape(s);
        return gm(() => yM(s, this.rate, r, this.seed), () => s, i);
      }
      return e;
    });
  }
  getConfig() {
    const e = {
      rate: this.rate,
      noiseShape: this.noiseShape,
      seed: this.seed
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
  dispose() {
    return super.dispose();
  }
}
xT.className = "Dropout";
Ee(xT);
class kR extends xT {
  constructor(e) {
    super(e), this.inputSpec = [{ ndim: 3 }];
  }
  getNoiseShape(e) {
    const n = e.shape;
    return [n[0], 1, n[2]];
  }
}
kR.className = "SpatialDropout1D";
Ee(kR);
class AR extends Ft {
  constructor(e) {
    if (super(e), this.activation = null, this.useBias = !0, this.kernel = null, this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", e.batchInputShape == null && e.inputShape == null && e.inputDim != null) {
      let n = null;
      e.batchSize != null && (n = e.batchSize), this.batchInputShape = [n, e.inputDim];
    }
    this.units = e.units, cs(this.units, "units"), this.activation = Da(e.activation), e.useBias != null && (this.useBias = e.useBias), this.kernelInitializer = wn(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.biasInitializer = wn(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelConstraint = ts(e.kernelConstraint), this.biasConstraint = ts(e.biasConstraint), this.kernelRegularizer = _n(e.kernelRegularizer), this.biasRegularizer = _n(e.biasRegularizer), this.activityRegularizer = _n(e.activityRegularizer), this.supportsMasking = !0, this.inputSpec = [{ minNDim: 2 }];
  }
  build(e) {
    e = Ht(e);
    const n = e[e.length - 1];
    this.kernel == null && (this.kernel = this.addWeight("kernel", [n, this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint))), this.inputSpec = [{ minNDim: 2, axes: { [-1]: n } }], this.built = !0;
  }
  computeOutputShape(e) {
    e = Ht(e);
    const n = e.slice();
    return n[n.length - 1] = this.units, n;
  }
  call(e, n) {
    return Q(() => {
      this.invokeCallHook(e, n);
      const s = gt(e), i = uM(this.activation.getClassName());
      let r;
      return i != null ? r = Yr(s, this.kernel.read(), i, this.bias ? this.bias.read() : null) : (r = Yr(s, this.kernel.read()), this.bias != null && (r = Ar(r, this.bias.read())), this.activation != null && (r = this.activation.apply(r))), r;
    });
  }
  getConfig() {
    const e = {
      units: this.units,
      activation: Ra(this.activation),
      useBias: this.useBias,
      kernelInitializer: Nn(this.kernelInitializer),
      biasInitializer: Nn(this.biasInitializer),
      kernelRegularizer: an(this.kernelRegularizer),
      biasRegularizer: an(this.biasRegularizer),
      activityRegularizer: an(this.activityRegularizer),
      kernelConstraint: es(this.kernelConstraint),
      biasConstraint: es(this.biasConstraint)
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
AR.className = "Dense";
Ee(AR);
class MR extends Ft {
  constructor(e) {
    e = e || {}, super(e), this.inputSpec = [{ minNDim: 3 }], this.dataFormat = e.dataFormat;
  }
  computeOutputShape(e) {
    e = Ht(e);
    for (const n of e.slice(1))
      if (n == null)
        throw new Z(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);
    return [e[0], ya(e, 1)];
  }
  call(e, n) {
    return Q(() => {
      this.invokeCallHook(e, n);
      let s = gt(e);
      if (this.dataFormat === "channelsFirst" && s.rank > 1) {
        const i = [0];
        for (let r = 2; r < s.rank; ++r)
          i.push(r);
        i.push(1), s = zt(s, i);
      }
      return MX(s);
    });
  }
  getConfig() {
    const e = {};
    this.dataFormat != null && (e.dataFormat = this.dataFormat);
    const n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
MR.className = "Flatten";
Ee(MR);
class RR extends Ft {
  constructor(e) {
    super(e), this.supportsMasking = !0, this.activation = Da(e.activation);
  }
  call(e, n) {
    return Q(() => {
      this.invokeCallHook(e, n);
      const s = gt(e);
      return this.activation.apply(s);
    });
  }
  getConfig() {
    const e = { activation: Ra(this.activation) }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
RR.className = "Activation";
Ee(RR);
class DR extends Ft {
  constructor(e) {
    super(e), this.n = e.n, this.inputSpec = [{ ndim: 2 }];
  }
  computeOutputShape(e) {
    return [e[0], this.n, e[1]];
  }
  call(e, n) {
    return Q(() => (e = gt(e), kX(e, this.n)));
  }
  getConfig() {
    const e = {
      n: this.n
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
DR.className = "RepeatVector";
Ee(DR);
class $R extends Ft {
  constructor(e) {
    super(e), this.targetShape = e.targetShape;
    for (let n = 0; n < this.targetShape.length; ++n)
      this.isUnknown(this.targetShape[n]) && (this.targetShape[n] = null);
  }
  isUnknown(e) {
    return e < 0 || e == null;
  }
  /**
   * Finds and replaces a missing dimension in output shape.
   *
   * This is a near direct port of the internal Numpy function
   * `_fix_unknown_dimension` in `numpy/core/src/multiarray/shape.c`.
   *
   * @param inputShape: Original shape of array begin reshape.
   * @param outputShape: Target shape of the array, with at most a single
   * `null` or negative number, which indicates an underdetermined dimension
   * that should be derived from `inputShape` and the known dimensions of
   *   `outputShape`.
   * @returns: The output shape with `null` replaced with its computed value.
   * @throws: ValueError: If `inputShape` and `outputShape` do not match.
   */
  fixUnknownDimension(e, n) {
    const s = "Total size of new array must be unchanged.", i = n.slice();
    let r = 1, o = null;
    for (let c = 0; c < i.length; ++c) {
      const l = i[c];
      if (this.isUnknown(l))
        if (o === null)
          o = c;
        else
          throw new Z("Can only specifiy one unknown dimension.");
      else
        r *= l;
    }
    const a = ya(e);
    if (o !== null) {
      if (r === 0 || a % r !== 0)
        throw new Z(s);
      i[o] = a / r;
    } else if (a !== r)
      throw new Z(s);
    return i;
  }
  computeOutputShape(e) {
    let n = !1;
    for (let s = 0; s < e.length; ++s)
      if (this.isUnknown(e[s])) {
        n = !0;
        break;
      }
    return n ? e.slice(0, 1).concat(this.targetShape) : e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape));
  }
  call(e, n) {
    return Q(() => {
      this.invokeCallHook(e, n);
      const s = gt(e), i = s.shape, r = i.slice(0, 1).concat(this.fixUnknownDimension(i.slice(1), this.targetShape));
      return Y(s, r);
    });
  }
  getConfig() {
    const e = {
      targetShape: this.targetShape
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
$R.className = "Reshape";
Ee($R);
class OR extends Ft {
  constructor(e) {
    if (super(e), e.dims == null)
      throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
    if (!Array.isArray(e.dims))
      throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);
    const n = Tr(1, e.dims.length + 1);
    if (!Bt(e.dims.slice().sort(), n))
      throw new Error("Invalid permutation `dims`: " + JSON.stringify(e.dims) + " `dims` must contain consecutive integers starting from 1.");
    this.dims = e.dims, this.dimsIncludingBatch = [0].concat(this.dims), this.inputSpec = [new Qn({ ndim: this.dims.length + 1 })];
  }
  computeOutputShape(e) {
    e = Ht(e);
    const n = e.slice();
    return this.dims.forEach((s, i) => {
      n[i + 1] = e[s];
    }), n;
  }
  call(e, n) {
    return zt(gt(e), this.dimsIncludingBatch);
  }
  getConfig() {
    const e = {
      dims: this.dims
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
OR.className = "Permute";
Ee(OR);
class LR extends Ft {
  constructor(e) {
    super(e ?? {}), this.supportsMasking = !0, e != null ? this.maskValue = e.maskValue == null ? 0 : e.maskValue : this.maskValue = 0;
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    const e = super.getConfig(), n = { maskValue: this.maskValue };
    return Object.assign(n, e), n;
  }
  computeMask(e, n) {
    const s = gt(e), i = -1;
    return xf(Uc(s, this.maskValue), i);
  }
  call(e, n) {
    return Q(() => {
      this.invokeCallHook(e, n);
      const s = gt(e), i = -1, r = !0, o = xf(Uc(s, this.maskValue), i, r);
      return q(s, Le(o, s.dtype));
    });
  }
}
LR.className = "Masking";
Ee(LR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class FR extends Ft {
  constructor(e) {
    if (super(e), this.embeddings = null, this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", e.batchInputShape == null && e.inputShape == null) {
      let n = null;
      e.batchSize != null && (n = e.batchSize), e.inputLength == null ? this.batchInputShape = [n, null] : this.batchInputShape = [n].concat(Zt(e.inputLength));
    }
    this.inputDim = e.inputDim, cs(this.inputDim, "inputDim"), this.outputDim = e.outputDim, cs(this.outputDim, "outputDim"), this.embeddingsInitializer = wn(e.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER), this.embeddingsRegularizer = _n(e.embeddingsRegularizer), this.activityRegularizer = _n(e.activityRegularizer), this.embeddingsConstraint = ts(e.embeddingsConstraint), this.maskZero = e.maskZero, this.supportsMasking = e.maskZero, this.inputLength = e.inputLength;
  }
  build(e) {
    this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, !0, this.embeddingsConstraint), this.built = !0;
  }
  // Override warnOnIncompatibleInputShape because an embedding layer allows
  // the input to have varying ranks.
  warnOnIncompatibleInputShape(e) {
  }
  computeMask(e, n) {
    return Q(() => this.maskZero ? (e = gt(e), Uc(e, Ut(e))) : null);
  }
  computeOutputShape(e) {
    if (e = Ht(e), this.inputLength == null)
      return [...e, this.outputDim];
    const n = Zt(this.inputLength);
    if (n.length !== e.length - 1)
      throw new Z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);
    {
      let s = 0;
      for (let i = 0; i < n.length; ++i) {
        const r = n[i], o = e[i + 1];
        if (r != null && o != null && r !== o)
          throw new Z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);
        r == null && (n[s] = o), s++;
      }
    }
    return [e[0], ...n, this.outputDim];
  }
  call(e, n) {
    return Q(() => {
      this.invokeCallHook(e, n);
      let s = gt(e);
      s.dtype !== "int32" && (s = Kr(s, "int32"));
      const i = gM(this.embeddings.read(), Y(s, [s.size]));
      return Y(i, Ht(this.computeOutputShape(s.shape)));
    });
  }
  getConfig() {
    const e = {
      inputDim: this.inputDim,
      outputDim: this.outputDim,
      embeddingsInitializer: Nn(this.embeddingsInitializer),
      embeddingsRegularizer: an(this.embeddingsRegularizer),
      activityRegularizer: an(this.activityRegularizer),
      embeddingsConstraint: es(this.embeddingsConstraint),
      maskZero: this.maskZero,
      inputLength: this.inputLength
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
FR.className = "Embedding";
Ee(FR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class cl extends Ft {
  constructor(e) {
    super(e || {}), this.supportsMasking = !0;
  }
  /**
   * Logic for merging multiple tensors, to be overridden by subclasses.
   * @param inputs
   */
  mergeFunction(e) {
    throw new Ct();
  }
  /**
   * Computes the shape of the result of an elementwise operation.
   *
   * @param shape1: Shape of the first tensor.
   * @param shape2: Shape of the second tensor.
   * @returns Expected output shape when an elementwise operation is carried
   *   out on 2 tensors with shapes `shape1` and `shape2`.
   * @throws ValueError: If `shape1` and `shape2` are not compatible for
   *   element-wise operations.
   */
  computeElementwiseOpOutputShape(e, n) {
    if (e == null || n == null)
      return null;
    if (e.length < n.length)
      return this.computeElementwiseOpOutputShape(n, e);
    if (n.length === 0)
      return e;
    const s = e.slice(0, e.length - n.length);
    for (let i = 0; i < n.length; ++i) {
      const r = e[e.length - n.length + i], o = n[i];
      if (r == null || o == null || r < 0 || o < 0)
        s.push(null);
      else if (r === 1)
        s.push(o);
      else if (o === 1)
        s.push(r);
      else {
        if (r !== o)
          throw new Z("Operands could not be broadcast together with shapes " + JSON.stringify(e) + " " + JSON.stringify(n));
        s.push(r);
      }
    }
    return s;
  }
  build(e) {
    if (Array.isArray(e) && !Array.isArray(e[0]) && (e = [Ht(e)]), e = e, e.length < 2)
      throw new Z(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);
    let n = [];
    for (const r of e)
      r != null && r[0] !== null && n.push(r[0]);
    if (n = ga(n), n.length > 1)
      throw new Z(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);
    let s = e[0] == null ? null : e[0].slice(1);
    for (let r = 1; r < e.length; ++r) {
      const o = e[r] == null ? null : e[r].slice(1);
      s = this.computeElementwiseOpOutputShape(s, o);
    }
    const i = e.map((r) => r.length);
    e.indexOf(null) === -1 && ga(i).length === 1 ? this.reshapeRequired = !1 : this.reshapeRequired = !0;
  }
  call(e, n) {
    return Q(() => {
      if (e = e, this.reshapeRequired) {
        const s = [], i = e.map((r) => r.rank);
        if (i.indexOf(null) === -1) {
          const r = Ma(i);
          for (let o of e) {
            const a = o.rank;
            for (let c = 0; c < r - a; ++c)
              o = pm(o, 1);
            s.push(o);
          }
          return this.mergeFunction(s);
        } else {
          let r = !1;
          for (const c of e) {
            const l = c.rank;
            if (l == null) {
              const u = c.shape, h = u[0], d = u.slice(1).concat([h]);
              let f = Y(c, [h].concat(ya(u.slice(1))));
              f = zt(f, [1, 0]), f = Y(f, d), s.push(f), r = !0;
            } else if (l > 1) {
              const u = Tr(1, l).concat([0]);
              s.push(zt(c, u)), r = !0;
            } else
              s.push(c);
          }
          let o = this.mergeFunction(s);
          const a = o.rank;
          if (r) {
            if (a == null) {
              const c = o.shape, l = c.length, u = c[l - 1], h = [u].concat(c.slice(0, c.length - 1));
              o = Y(zt(Y(o, [-1, u]), [1, 0]), h);
            } else if (a > 1) {
              const c = [a - 1].concat(Tr(0, a - 1));
              o = zt(o, c);
            }
          }
          return o;
        }
      } else
        return this.mergeFunction(e);
    });
  }
  computeOutputShape(e) {
    e = e;
    let n;
    e[0] == null ? n = null : n = e[0].slice(1);
    for (let i = 1; i < e.length; ++i) {
      const r = e[i] == null ? null : e[i].slice(1);
      n = this.computeElementwiseOpOutputShape(n, r);
    }
    let s = [];
    for (const i of e)
      i != null && i[0] !== null && s.push(i[0]);
    return s = ga(s), s.length === 1 ? n = s.concat(n) : n = [null].concat(n), n;
  }
  computeMask(e, n) {
    return Q(() => {
      if (n == null)
        return null;
      if (!Array.isArray(n))
        throw new Z("`mask` should be an Array");
      if (!Array.isArray(e))
        throw new Z("`inputs` should be an Array");
      if (n.length !== e.length)
        throw new Z(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${n.length})`);
      if (n.every((i) => i == null))
        return null;
      n = n.map((i) => i == null ? i : vn(i, 0));
      let s = n[0];
      for (let i = 1; i < n.length - 1; ++i)
        s = _r(s, n[i]);
      return s;
    });
  }
}
class PR extends cl {
  constructor(e) {
    super(e);
  }
  mergeFunction(e) {
    return Q(() => {
      let n = e[0].clone();
      for (let s = 1; s < e.length; ++s)
        n = Se(n, e[s]);
      return n;
    });
  }
}
PR.className = "Add";
Ee(PR);
class BR extends cl {
  constructor(e) {
    super(e);
  }
  mergeFunction(e) {
    return Q(() => {
      let n = e[0].clone();
      for (let s = 1; s < e.length; ++s)
        n = q(n, e[s]);
      return n;
    });
  }
}
BR.className = "Multiply";
Ee(BR);
class zR extends cl {
  constructor(e) {
    super(e);
  }
  mergeFunction(e) {
    return Q(() => {
      let n = e[0].clone();
      for (let s = 1; s < e.length; ++s)
        n = Se(n, e[s]);
      return q(1 / e.length, n);
    });
  }
}
zR.className = "Average";
Ee(zR);
class VR extends cl {
  constructor(e) {
    super(e);
  }
  mergeFunction(e) {
    return Q(() => {
      let n = e[0];
      for (let s = 1; s < e.length; ++s)
        n = lo(n, e[s]);
      return n;
    });
  }
}
VR.className = "Maximum";
Ee(VR);
class UR extends cl {
  constructor(e) {
    super(e);
  }
  mergeFunction(e) {
    return Q(() => {
      let n = e[0];
      for (let s = 1; s < e.length; ++s)
        n = Aa(n, e[s]);
      return n;
    });
  }
}
UR.className = "Minimum";
Ee(UR);
class GR extends cl {
  constructor(e) {
    super(e), this.DEFAULT_AXIS = -1, e == null && (e = {}), this.axis = e.axis == null ? this.DEFAULT_AXIS : e.axis, this.supportsMasking = !0, this.reshapeRequired = !1;
  }
  build(e) {
    if (!(Array.isArray(e) && Array.isArray(e[0])) || e.length === 1)
      throw new Z("A `Concatenate` layer should be called on a list of at least 2 inputs");
    e = e;
    let n = !0;
    for (const i of e)
      if (i != null) {
        n = !1;
        break;
      }
    if (n)
      return;
    const s = [];
    for (let i = 0; i < e.length; ++i) {
      const r = e[i].slice();
      r.splice(this.axis, 1);
      let o = !1;
      for (const a of s)
        if (Bt(a, r)) {
          o = !0;
          break;
        }
      o || s.push(r);
    }
    if (s.length > 1)
      throw new Z("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e));
  }
  mergeFunction(e) {
    return Q(() => eT(e, this.axis));
  }
  computeOutputShape(e) {
    if (!(Array.isArray(e) && Array.isArray(e[0])))
      throw new Z("A `Concatenate` layer should be called on a list of inputs.");
    const n = e, s = n[0].slice(), i = this.axis < 0 ? s.length + this.axis : this.axis;
    for (const r of n.slice(1)) {
      if (s[i] == null || r[i] == null) {
        s[i] = null;
        break;
      }
      s[i] += r[i];
    }
    return s;
  }
  computeMask(e, n) {
    if (n == null)
      return null;
    if (!Array.isArray(n))
      throw new Z("`mask` should be an array for Concatenate");
    if (!Array.isArray(e))
      throw new Z("`inputs` should be an array for Concatenate");
    if (n.length !== e.length)
      throw new Z(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${e.length})`);
    return Q(() => {
      let s = !0;
      if (n.forEach((o) => {
        if (o != null) {
          s = !1;
          return;
        }
      }), s)
        return null;
      const i = [];
      for (let o = 0; o < e.length; ++o)
        n[o] == null ? i.push(Le(vi(e[o]), "bool")) : n[o].rank < e[o].rank ? i.push(vn(n[o], -1)) : i.push(n[o]);
      const r = Pn(i, this.axis);
      return E0(r, -1, !1);
    });
  }
  getConfig() {
    const e = {
      axis: this.axis
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
GR.className = "Concatenate";
Ee(GR);
function ad(t, e) {
  for (; t < 0; )
    t += e;
  return t;
}
function J7(t, e, n) {
  if (t.shape.length > 3 || e.shape.length > 3)
    throw new Ct("batchDot is not implemented for tensors of 4D or higher rank yet");
  if (A(t.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`), A(t.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`), typeof n == "number" && (n = [n, n]), t.dtype === "complex64" || e.dtype === "complex64")
    throw new Ct("batchDot is not implemented for complex64-type Tensors yet.");
  const s = t.shape.length, i = e.shape.length;
  n == null && (n = [s - 1, i - 2]);
  const r = n;
  return Q(() => {
    let o;
    if (s > i) {
      o = s - i;
      const c = [];
      for (let l = 0; l < o; ++l)
        c.push(1);
      e = Y(e, e.shape.concat(c));
    } else if (i > s) {
      o = i - s;
      const c = [];
      for (let l = 0; l < o; ++l)
        c.push(1);
      t = Y(t, t.shape.concat(c));
    } else
      o = 0;
    let a;
    if (t.shape.length === 2 && e.shape.length === 2)
      r[0] === r[1] ? a = Qe(q(t, e), r[0]) : a = Qe(q(zt(t, [1, 0]), e), r[1]);
    else {
      const c = r[0] !== t.shape.length - 1, l = r[1] === e.shape.length - 1;
      a = Tt(t, e, c, l);
    }
    if (o > 0) {
      let c;
      s > i ? c = s + i - 3 : c = s - 1;
      const l = [];
      for (let u = c; u < c + o; ++u)
        l.push(u);
      a = ys(a, l);
    }
    return a.shape.length === 1 && (a = vn(a, 1)), a;
  });
}
class WR extends cl {
  constructor(e) {
    super(e), this.axes = e.axes, this.normalize = e.normalize == null ? !1 : e.normalize, this.supportsMasking = !0, this.reshapeRequired = !1;
  }
  build(e) {
    A(Array.isArray(e) && e.length === 2 && Array.isArray(e[0]) && Array.isArray(e[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
    const n = e[0], s = e[1];
    if (n.length > 3 || s.length > 3)
      throw new Ct("Dot layer does not support tensors of 4D or higher rank yet.");
    const i = this.interpretAxes(n, s);
    if (n[i[0]] !== s[i[1]])
      throw new Z(`Dimension incompatibility: ${n[i[0]]} !== ${s[i[1]]}`);
  }
  mergeFunction(e) {
    if (e.length !== 2)
      throw new Z(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);
    let n = e[0], s = e[1], i;
    return Array.isArray(this.axes) ? i = this.axes.map((r, o) => ad(r, e[o].shape.length)) : i = [
      ad(this.axes, n.shape.length),
      ad(this.axes, s.shape.length)
    ], this.normalize && (n = Uy(n, i[0]), s = Uy(s, i[1])), J7(n, s, i);
  }
  interpretAxes(e, n) {
    let s;
    return Array.isArray(this.axes) ? s = this.axes : s = [
      ad(this.axes, e.length),
      ad(this.axes, n.length)
    ], s;
  }
  computeOutputShape(e) {
    A(Array.isArray(e) && e.length === 2 && Array.isArray(e[0]) && Array.isArray(e[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
    const n = e[0].slice(), s = e[1].slice();
    if (n.length > 3 || s.length > 3)
      throw new Ct("Dot layer does not support tensors of 4D or higher rank yet.");
    const i = this.interpretAxes(n, s);
    n.splice(i[0], 1), s.splice(i[1], 1), s.splice(0, 1);
    const r = n.concat(s);
    return r.length === 1 && r.push(1), r;
  }
  computeMask(e, n) {
    return null;
  }
  getConfig() {
    const e = {
      axes: this.axes,
      normalize: this.normalize
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
WR.className = "Dot";
Ee(WR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class HR extends Ft {
  constructor(e) {
    super(e), this.supportsMasking = !0, this.stddev = e.stddev;
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    const e = super.getConfig(), n = { stddev: this.stddev };
    return Object.assign(n, e), n;
  }
  call(e, n) {
    return Q(() => {
      this.invokeCallHook(e, n);
      const s = gt(e);
      return gm(() => Se(mb(s.shape, 0, this.stddev), s), () => s, n.training || !1);
    });
  }
}
HR.className = "GaussianNoise";
Ee(HR);
class jR extends Ft {
  constructor(e) {
    super(e), this.supportsMasking = !0, this.rate = e.rate;
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    const e = super.getConfig(), n = { rate: this.rate };
    return Object.assign(n, e), n;
  }
  call(e, n) {
    return Q(() => {
      this.invokeCallHook(e, n);
      const s = gt(e);
      return this.rate > 0 && this.rate < 1 ? gm(() => {
        const r = Math.sqrt(this.rate / (1 - this.rate));
        return q(s, mb(s.shape, 1, r));
      }, () => s, n.training || !1) : s;
    });
  }
}
jR.className = "GaussianDropout";
Ee(jR);
class qR extends Ft {
  constructor(e) {
    super(e), this.supportsMasking = !0, this.rate = e.rate, this.noiseShape = e.noiseShape;
  }
  _getNoiseShape(e) {
    return this.noiseShape || gt(e).shape;
  }
  computeOutputShape(e) {
    return e;
  }
  getConfig() {
    const e = super.getConfig(), n = { rate: this.rate };
    return Object.assign(n, e), n;
  }
  call(e, n) {
    return Q(() => {
      if (this.rate < 1 && this.rate > 0) {
        const s = this._getNoiseShape(e);
        return gm(() => {
          const r = gt(e), o = 1.6732632423543772, a = 1.0507009873554805, c = -o * a;
          let l = Wo(Va(s), this.rate);
          l = Kr(l, "float32");
          const u = ((1 - this.rate) * (1 + this.rate * c ** 2)) ** -0.5, h = -u * c * this.rate, d = Se(q(r, l), q(Se(l, -1), c));
          return Se(q(d, u), h);
        }, () => gt(e), n.training || !1);
      }
      return e;
    });
  }
}
qR.className = "AlphaDropout";
Ee(qR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Cf(t, e, n, s, i, r = 1e-3) {
  let o;
  if (t.rank === 2)
    o = yS(t, e, n, s, i, r);
  else if (t.rank === 3)
    o = xS(t, e, n, s, i, r);
  else if (t.rank === 4)
    o = bS(t, e, n, s, i, r);
  else
    throw new Ct(`batchNormalization is not implemented for array of rank ${t.rank} yet`);
  return o;
}
function Q7(t, e, n, s, i = 1e-3) {
  return Q(() => {
    const r = Qp(t, s), o = r.mean, a = r.variance;
    return [Cf(t, o, a, n, e, i), o, a];
  });
}
function eK(t, e, n, s, i = 1e-3) {
  return Q(() => {
    const r = Qp(t, s), o = r.mean, a = r.variance, c = [];
    for (const p of Tr(0, t.rank))
      s.indexOf(p) !== -1 ? c.push(1) : c.push(t.shape[p]);
    const l = Y(o, c), u = Y(a, c), h = e == null ? null : Y(e, c), d = n == null ? null : Y(n, c);
    return [Cf(t, l, u, d, h, i), o, a];
  });
}
function tK(t, e, n, s, i = 1e-3) {
  return Bt(s.slice().sort(), Tr(0, t.rank - 1)) ? Q7(t, e, n, s, i) : eK(t, e, n, s, i);
}
class XR extends Ft {
  constructor(e) {
    e == null && (e = {}), super(e), this.supportsMasking = !0, this.axis = e.axis == null ? -1 : e.axis, this.momentum = e.momentum == null ? 0.99 : e.momentum, this.epsilon = e.epsilon == null ? 1e-3 : e.epsilon, this.center = e.center == null ? !0 : e.center, this.scale = e.scale == null ? !0 : e.scale, this.betaInitializer = wn(e.betaInitializer || "zeros"), this.gammaInitializer = wn(e.gammaInitializer || "ones"), this.movingMeanInitializer = wn(e.movingMeanInitializer || "zeros"), this.movingVarianceInitializer = wn(e.movingVarianceInitializer || "ones"), this.betaConstraint = ts(e.betaConstraint), this.gammaConstraint = ts(e.gammaConstraint), this.betaRegularizer = _n(e.betaRegularizer), this.gammaRegularizer = _n(e.gammaRegularizer);
  }
  build(e) {
    e = Ht(e);
    const n = this.axis >= 0 ? this.axis : this.axis + e.length, s = e[n];
    if (s == null)
      throw new Z(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);
    this.inputSpec = [new Qn({ ndim: e.length, axes: { [n]: s } })];
    const i = [s];
    this.scale && (this.gamma = this.addWeight("gamma", i, null, this.gammaInitializer, this.gammaRegularizer, !0, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", i, null, this.betaInitializer, this.betaRegularizer, !0, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", i, null, this.movingMeanInitializer, null, !1), this.movingVariance = this.addWeight("moving_variance", i, null, this.movingVarianceInitializer, null, !1), this.built = !0;
  }
  call(e, n) {
    return Q(() => {
      const s = n.training == null ? !1 : n.training, i = gt(e), r = i.shape, o = r.length, a = Tr(0, o), c = this.axis >= 0 ? this.axis : this.axis + o;
      a.splice(c, 1);
      const l = Hc(1, o);
      l[c] = r[c];
      const u = a.slice();
      u.sort();
      const h = !Bt(u, Tr(0, o).slice(0, o - 1)), d = () => {
        if (h) {
          const x = Y(this.movingMean.read(), l), v = Y(this.movingVariance.read(), l), b = this.center ? Y(this.beta.read(), l) : null, w = this.scale ? Y(this.gamma.read(), l) : null;
          return Cf(i, x, v, b, w, this.epsilon);
        } else
          return Cf(i, this.movingMean.read(), this.movingVariance.read(), this.beta == null ? null : this.beta.read(), this.gamma == null ? null : this.gamma.read(), this.epsilon);
      };
      if (!s)
        return d();
      const [f, p, y] = tK(i, this.gamma.read(), this.beta.read(), a, this.epsilon), g = (x, v, b) => {
        Q(() => {
          const w = 1 - b, S = x.read(), _ = q(je(S, v), w);
          x.write(je(S, _));
        });
      };
      return (() => {
        g(this.movingMean, p, this.momentum), g(this.movingVariance, y, this.momentum);
      })(), f;
    });
  }
  getConfig() {
    const e = {
      axis: this.axis,
      momentum: this.momentum,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: Nn(this.betaInitializer),
      gammaInitializer: Nn(this.gammaInitializer),
      movingMeanInitializer: Nn(this.movingMeanInitializer),
      movingVarianceInitializer: Nn(this.movingVarianceInitializer),
      betaRegularizer: an(this.betaRegularizer),
      gammaRegularizer: an(this.gammaRegularizer),
      betaConstraint: es(this.betaConstraint),
      gammaConstraint: es(this.gammaConstraint)
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
XR.className = "BatchNormalization";
Ee(XR);
class KR extends Ft {
  constructor(e) {
    if (e == null && (e = {}), super(e), this.axis = e.axis == null ? -1 : e.axis, typeof this.axis == "number") {
      if (!Number.isInteger(this.axis))
        throw new Error(`Expected axis to be an integer, but received ${this.axis}`);
    } else if (Array.isArray(this.axis)) {
      for (const n of this.axis)
        if (!Number.isInteger(n))
          throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`);
    } else
      throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);
    this.epsilon = e.epsilon == null ? 1e-3 : e.epsilon, this.center = e.center == null ? !0 : e.center, this.scale = e.scale == null ? !0 : e.scale, this.betaInitializer = wn(e.betaInitializer || "zeros"), this.gammaInitializer = wn(e.gammaInitializer || "ones"), this.betaRegularizer = _n(e.betaRegularizer), this.gammaRegularizer = _n(e.gammaRegularizer), this.supportsMasking = !0;
  }
  build(e) {
    e = Ht(e);
    const n = e.length;
    typeof this.axis == "number" && (this.axis = [this.axis]);
    for (let r = 0; r < this.axis.length; ++r)
      this.axis[r] < 0 && (this.axis[r] += n);
    for (const r of this.axis)
      if (r < 0 || r >= n)
        throw new Error(`Invalid axis: ${r}`);
    if (this.axis.length !== ga(this.axis).length)
      throw new Error(`Found duplicate axes in: ${this.axis}`);
    const s = this.axis.map((r) => e[r]), i = !0;
    this.scale ? this.gamma = this.addWeight("gamma", s, "float32", this.gammaInitializer, this.gammaRegularizer, i) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", s, "float32", this.betaInitializer, this.betaRegularizer, i) : this.beta = null, this.built = !0;
  }
  call(e, n) {
    const s = gt(e), i = s.shape, r = i.length;
    return Q(() => {
      let { mean: a, variance: c } = Qp(s, this.axis, !0);
      const l = Hc(1, r);
      for (const y of this.axis)
        l[y] = i[y];
      const u = (y) => y != null && y.shape.length !== r ? Y(y, l) : y;
      let h = this.scale ? u(this.gamma.read()) : null, d = this.center ? u(this.beta.read()) : null;
      const f = [], p = [];
      for (let y = 0; y < r; ++y)
        this.axis.indexOf(y) !== -1 ? (f.push(i[y]), p.push(1)) : (f.push(1), p.push(i[y]));
      return a = pi(a, f), c = pi(c, f), h != null && (h = pi(h, p)), d != null && (d = pi(d, p)), Cf(s, a, c, d, h, this.epsilon);
    });
  }
  getConfig() {
    const e = {
      axis: this.axis,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: Nn(this.betaInitializer),
      gammaInitializer: Nn(this.gammaInitializer),
      betaRegularizer: an(this.betaRegularizer),
      gammaRegularizer: an(this.gammaRegularizer)
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
KR.className = "LayerNormalization";
Ee(KR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function nK(t, e, n) {
  return Q(() => {
    if (t.rank !== 4)
      throw new Z(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);
    if (e == null && (e = [[1, 1], [1, 1]]), e.length !== 2 || e[0].length !== 2 || e[1].length !== 2)
      throw new Z("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
    if (n == null && (n = Cr()), n !== "channelsLast" && n !== "channelsFirst")
      throw new Z(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);
    let s;
    return n === "channelsFirst" ? s = [[0, 0], [0, 0], e[0], e[1]] : s = [[0, 0], e[0], e[1], [0, 0]], uo(t, s);
  });
}
class YR extends Ft {
  constructor(e) {
    if (e == null && (e = {}), super(e), this.dataFormat = e.dataFormat == null ? Cr() : e.dataFormat, e.padding == null)
      this.padding = [[1, 1], [1, 1]];
    else if (typeof e.padding == "number")
      this.padding = [[e.padding, e.padding], [e.padding, e.padding]];
    else {
      if (e.padding = e.padding, e.padding.length !== 2)
        throw new Z(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);
      let n, s;
      if (typeof e.padding[0] == "number")
        n = [e.padding[0], e.padding[0]], s = [e.padding[1], e.padding[1]];
      else {
        if (e.padding = e.padding, e.padding[0].length !== 2)
          throw new Z(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);
        if (n = e.padding[0], e.padding[1].length !== 2)
          throw new Z(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);
        s = e.padding[1];
      }
      this.padding = [n, s];
    }
    this.inputSpec = [new Qn({ ndim: 4 })];
  }
  computeOutputShape(e) {
    e = Ht(e);
    let n, s;
    return this.dataFormat === "channelsFirst" ? (e[2] != null && e[2] >= 0 ? n = e[2] + this.padding[0][0] + this.padding[0][1] : n = null, e[3] != null && e[3] >= 0 ? s = e[3] + this.padding[1][0] + this.padding[1][1] : s = null, [e[0], e[1], n, s]) : (e[1] != null && e[1] >= 0 ? n = e[1] + this.padding[0][0] + this.padding[0][1] : n = null, e[2] != null && e[2] >= 0 ? s = e[2] + this.padding[1][0] + this.padding[1][1] : s = null, [e[0], n, s, e[3]]);
  }
  call(e, n) {
    return Q(() => nK(gt(e), this.padding, this.dataFormat));
  }
  getConfig() {
    const e = {
      padding: this.padding,
      dataFormat: this.dataFormat
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
YR.className = "ZeroPadding2D";
Ee(YR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function _b(t, e, n, s, i, r) {
  return Q(() => {
    Un(i), dM(r), Bi(s), n == null && (n = [1, 1]), s == null && (s = "valid"), i == null && (i = Cr()), r == null && (r = "max"), t = fT(t, i);
    let o;
    const a = s === "same" ? "same" : "valid";
    return r === "max" ? o = Jp(t, e, n, a) : o = Wp(
      // TODO(cais): Rank check?
      t,
      e,
      n,
      a
    ), i === "channelsFirst" && (o = zt(o, [0, 3, 1, 2])), o;
  });
}
function ZR(t, e, n, s, i, r) {
  return Q(() => {
    Un(i), dM(r), Bi(s), n == null && (n = [1, 1, 1]), s == null && (s = "valid"), i == null && (i = Cr()), r == null && (r = "max"), t = pR(t, i);
    let o;
    const a = s === "same" ? "same" : "valid";
    return r === "max" ? o = US(t, e, n, a) : o = gS(t, e, n, a), i === "channelsFirst" && (o = zt(o, [0, 4, 1, 2, 3])), o;
  });
}
class JR extends Ft {
  /**
   *
   * @param args Parameters for the Pooling layer.
   *
   * config.poolSize defaults to 2.
   */
  constructor(e) {
    if (e.poolSize == null && (e.poolSize = 2), super(e), typeof e.poolSize == "number")
      this.poolSize = [e.poolSize];
    else if (Array.isArray(e.poolSize) && e.poolSize.length === 1 && typeof e.poolSize[0] == "number")
      this.poolSize = e.poolSize;
    else
      throw new Z(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);
    if (cs(this.poolSize, "poolSize"), e.strides == null)
      this.strides = this.poolSize;
    else if (typeof e.strides == "number")
      this.strides = [e.strides];
    else if (Array.isArray(e.strides) && e.strides.length === 1 && typeof e.strides[0] == "number")
      this.strides = e.strides;
    else
      throw new Z(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);
    cs(this.strides, "strides"), this.padding = e.padding == null ? "valid" : e.padding, Bi(this.padding), this.inputSpec = [new Qn({ ndim: 3 })];
  }
  computeOutputShape(e) {
    e = Ht(e);
    const n = vr(e[1], this.poolSize[0], this.padding, this.strides[0]);
    return [e[0], n, e[2]];
  }
  call(e, n) {
    return Q(() => {
      this.invokeCallHook(e, n), e = pm(gt(e), 2);
      const s = this.poolingFunction(gt(e), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, "channelsLast");
      return ys(s, [2]);
    });
  }
  getConfig() {
    const e = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
class QR extends JR {
  constructor(e) {
    super(e);
  }
  poolingFunction(e, n, s, i, r) {
    return Un(r), Bi(i), _b(e, n, s, i, r, "max");
  }
}
QR.className = "MaxPooling1D";
Ee(QR);
class eD extends JR {
  constructor(e) {
    super(e);
  }
  poolingFunction(e, n, s, i, r) {
    return Un(r), Bi(i), _b(e, n, s, i, r, "avg");
  }
}
eD.className = "AveragePooling1D";
Ee(eD);
class tD extends Ft {
  constructor(e) {
    if (e.poolSize == null && (e.poolSize = [2, 2]), super(e), this.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize], e.strides == null)
      this.strides = this.poolSize;
    else if (Array.isArray(e.strides)) {
      if (e.strides.length !== 2)
        throw new Z(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);
      this.strides = e.strides;
    } else
      this.strides = [e.strides, e.strides];
    cs(this.poolSize, "poolSize"), cs(this.strides, "strides"), this.padding = e.padding == null ? "valid" : e.padding, this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, Un(this.dataFormat), Bi(this.padding), this.inputSpec = [new Qn({ ndim: 4 })];
  }
  computeOutputShape(e) {
    e = Ht(e);
    let n = this.dataFormat === "channelsFirst" ? e[2] : e[1], s = this.dataFormat === "channelsFirst" ? e[3] : e[2];
    return n = vr(n, this.poolSize[0], this.padding, this.strides[0]), s = vr(s, this.poolSize[1], this.padding, this.strides[1]), this.dataFormat === "channelsFirst" ? [e[0], e[1], n, s] : [e[0], n, s, e[3]];
  }
  call(e, n) {
    return Q(() => (this.invokeCallHook(e, n), this.poolingFunction(gt(e), this.poolSize, this.strides, this.padding, this.dataFormat)));
  }
  getConfig() {
    const e = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
class nD extends tD {
  constructor(e) {
    super(e);
  }
  poolingFunction(e, n, s, i, r) {
    return Un(r), Bi(i), _b(e, n, s, i, r, "max");
  }
}
nD.className = "MaxPooling2D";
Ee(nD);
class sD extends tD {
  constructor(e) {
    super(e);
  }
  poolingFunction(e, n, s, i, r) {
    return Un(r), Bi(i), _b(e, n, s, i, r, "avg");
  }
}
sD.className = "AveragePooling2D";
Ee(sD);
class iD extends Ft {
  constructor(e) {
    if (e.poolSize == null && (e.poolSize = [2, 2, 2]), super(e), this.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize, e.poolSize], e.strides == null)
      this.strides = this.poolSize;
    else if (Array.isArray(e.strides)) {
      if (e.strides.length !== 3)
        throw new Z(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);
      this.strides = e.strides;
    } else
      this.strides = [e.strides, e.strides, e.strides];
    cs(this.poolSize, "poolSize"), cs(this.strides, "strides"), this.padding = e.padding == null ? "valid" : e.padding, this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, Un(this.dataFormat), Bi(this.padding), this.inputSpec = [new Qn({ ndim: 5 })];
  }
  computeOutputShape(e) {
    e = Ht(e);
    let n = this.dataFormat === "channelsFirst" ? e[2] : e[1], s = this.dataFormat === "channelsFirst" ? e[3] : e[2], i = this.dataFormat === "channelsFirst" ? e[4] : e[3];
    return n = vr(n, this.poolSize[0], this.padding, this.strides[0]), s = vr(s, this.poolSize[1], this.padding, this.strides[1]), i = vr(i, this.poolSize[2], this.padding, this.strides[2]), this.dataFormat === "channelsFirst" ? [e[0], e[1], n, s, i] : [e[0], n, s, i, e[4]];
  }
  call(e, n) {
    return Q(() => (this.invokeCallHook(e, n), this.poolingFunction(gt(e), this.poolSize, this.strides, this.padding, this.dataFormat)));
  }
  getConfig() {
    const e = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
class rD extends iD {
  constructor(e) {
    super(e);
  }
  poolingFunction(e, n, s, i, r) {
    return Un(r), Bi(i), ZR(e, n, s, i, r, "max");
  }
}
rD.className = "MaxPooling3D";
Ee(rD);
class oD extends iD {
  constructor(e) {
    super(e);
  }
  poolingFunction(e, n, s, i, r) {
    return Un(r), Bi(i), ZR(e, n, s, i, r, "avg");
  }
}
oD.className = "AveragePooling3D";
Ee(oD);
class aD extends Ft {
  constructor(e) {
    super(e), this.inputSpec = [new Qn({ ndim: 3 })];
  }
  computeOutputShape(e) {
    return [e[0], e[2]];
  }
  call(e, n) {
    throw new Ct();
  }
}
class cD extends aD {
  constructor(e) {
    super(e || {});
  }
  call(e, n) {
    return Q(() => {
      const s = gt(e);
      return En(s, 1);
    });
  }
}
cD.className = "GlobalAveragePooling1D";
Ee(cD);
class lD extends aD {
  constructor(e) {
    super(e || {});
  }
  call(e, n) {
    return Q(() => {
      const s = gt(e);
      return Ri(s, 1);
    });
  }
}
lD.className = "GlobalMaxPooling1D";
Ee(lD);
class uD extends Ft {
  constructor(e) {
    super(e), this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, Un(this.dataFormat), this.inputSpec = [new Qn({ ndim: 4 })];
  }
  computeOutputShape(e) {
    return e = e, this.dataFormat === "channelsLast" ? [e[0], e[3]] : [e[0], e[1]];
  }
  call(e, n) {
    throw new Ct();
  }
  getConfig() {
    const e = { dataFormat: this.dataFormat }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
class hD extends uD {
  call(e, n) {
    return Q(() => {
      const s = gt(e);
      return this.dataFormat === "channelsLast" ? En(s, [1, 2]) : En(s, [2, 3]);
    });
  }
}
hD.className = "GlobalAveragePooling2D";
Ee(hD);
class dD extends uD {
  call(e, n) {
    return Q(() => {
      const s = gt(e);
      return this.dataFormat === "channelsLast" ? Ri(s, [1, 2]) : Ri(s, [2, 3]);
    });
  }
}
dD.className = "GlobalMaxPooling2D";
Ee(dD);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class fD extends Ft {
  constructor(e) {
    super(e), this.layer = e.layer;
  }
  build(e) {
    this.built = !0;
  }
  // TODO(cais): Implement activityRegularizer getter.
  get trainable() {
    return this.layer != null ? this.layer.trainable : !1;
  }
  set trainable(e) {
    this.layer != null && (this.layer.trainable = e);
  }
  get trainableWeights() {
    return this.layer.trainableWeights;
  }
  // TODO(cais): Implement setter for trainableWeights.
  get nonTrainableWeights() {
    return this.layer.nonTrainableWeights;
  }
  // TODO(cais): Implement setter for nonTrainableWeights.
  get updates() {
    return this.layer._updates;
  }
  // TODO(cais): Implement getUpdatesFor().
  get losses() {
    return this.layer.losses;
  }
  // TODO(cais): Implement getLossesFor().
  getWeights() {
    return this.layer.getWeights();
  }
  setWeights(e) {
    this.layer.setWeights(e);
  }
  getConfig() {
    const e = {
      layer: {
        className: this.layer.getClassName(),
        config: this.layer.getConfig()
      }
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
  setFastWeightInitDuringBuild(e) {
    super.setFastWeightInitDuringBuild(e), this.layer != null && this.layer.setFastWeightInitDuringBuild(e);
  }
  /** @nocollapse */
  static fromConfig(e, n, s = {}) {
    const i = n.layer, r = Io(i, s);
    delete n.layer;
    const o = { layer: r };
    return Object.assign(o, n), new e(o);
  }
}
class pD extends fD {
  constructor(e) {
    super(e), this.supportsMasking = !0;
  }
  build(e) {
    if (e = Ht(e), e.length < 3)
      throw new Z(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);
    this.inputSpec = [{ shape: e }];
    const n = [e[0]].concat(e.slice(2));
    this.layer.built || (this.layer.build(n), this.layer.built = !0), super.build(e);
  }
  computeOutputShape(e) {
    e = Ht(e);
    const n = [e[0]].concat(e.slice(2)), s = this.layer.computeOutputShape(n), i = e[1];
    return [s[0], i].concat(s.slice(1));
  }
  call(e, n) {
    return Q(() => (e = gt(e), _R(
      (o, a) => [gt(this.layer.call(o, n)), []],
      e,
      [],
      !1,
      null,
      null,
      !1,
      !0
      /* needPerStepOutputs */
    )[1]));
  }
}
pD.className = "TimeDistributed";
Ee(pD);
function sK(t) {
  al(TX, "BidirectionalMergeMode", t);
}
const iK = "concat";
class mD extends fD {
  constructor(e) {
    super(e);
    const n = e.layer.getConfig(), s = {};
    s.className = e.layer.getClassName(), s.config = n, this.forwardLayer = Io(s), n.goBackwards = n.goBackwards !== !0;
    const i = {};
    if (i.className = e.layer.getClassName(), i.config = n, this.backwardLayer = Io(i), this.forwardLayer.name = "forward_" + this.forwardLayer.name, this.backwardLayer.name = "backward_" + this.backwardLayer.name, this.mergeMode = e.mergeMode === void 0 ? iK : e.mergeMode, sK(this.mergeMode), e.weights)
      throw new Ct("weights support is not implemented for Bidirectional layer yet.");
    this._stateful = e.layer.stateful, this.returnSequences = e.layer.returnSequences, this.returnState = e.layer.returnState, this.supportsMasking = !0, this._trainable = !0, this.inputSpec = e.layer.inputSpec, this.numConstants = null;
  }
  get trainable() {
    return this._trainable;
  }
  set trainable(e) {
    this._trainable = e, this.forwardLayer != null && (this.forwardLayer.trainable = e), this.backwardLayer != null && (this.backwardLayer.trainable = e);
  }
  getWeights() {
    return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
  }
  setWeights(e) {
    const n = e.length, s = Math.floor(n / 2);
    this.forwardLayer.setWeights(e.slice(0, s)), this.backwardLayer.setWeights(e.slice(s));
  }
  computeOutputShape(e) {
    let n = this.forwardLayer.computeOutputShape(e);
    Array.isArray(n) && Array.isArray(n[0]) || (n = [n]), n = n;
    let s, i, r;
    return this.returnState && (r = n.slice(1)), s = n[0], s = s, this.mergeMode === "concat" ? (s[s.length - 1] *= 2, i = [s]) : this.mergeMode == null ? i = [s, s.slice()] : i = [s], this.returnState ? this.mergeMode == null ? i.concat(r).concat(r.slice()) : [s].concat(r).concat(r.slice()) : Zs(i);
  }
  apply(e, n) {
    let s = n == null ? null : n.initialState, i = n == null ? null : n.constants;
    n == null && (n = {});
    const r = SR(e, s, i, this.numConstants);
    if (e = r.inputs, s = r.initialState, i = r.constants, Array.isArray(e) && (s = e.slice(1), e = e[0]), (s == null || s.length === 0) && i == null)
      return super.apply(e, n);
    const o = [], a = [];
    if (s != null) {
      const l = s.length;
      if (l % 2 > 0)
        throw new Z("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
      n.initialState = s, o.push(...s);
      const u = s.map((h) => new Qn({ shape: h.shape }));
      this.forwardLayer.stateSpec = u.slice(0, l / 2), this.backwardLayer.stateSpec = u.slice(l / 2), a.push(...u);
    }
    if (i != null)
      throw new Ct("Support for constants in Bidirectional layers is not implemented yet.");
    const c = o[0] instanceof oo;
    for (const l of o)
      if (l instanceof oo !== c)
        throw new Z("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
    if (c) {
      const l = [e].concat(o), u = this.inputSpec.concat(a), h = this.inputSpec;
      this.inputSpec = u;
      const d = super.apply(l, n);
      return this.inputSpec = h, d;
    } else
      return super.apply(e, n);
  }
  call(e, n) {
    return Q(() => {
      const s = n.initialState;
      let i, r;
      if (s == null)
        i = this.forwardLayer.call(e, n), r = this.backwardLayer.call(e, n);
      else {
        const c = s.slice(0, s.length / 2), l = s.slice(s.length / 2);
        i = this.forwardLayer.call(e, Object.assign(n, { initialState: c })), r = this.backwardLayer.call(e, Object.assign(n, { initialState: l }));
      }
      let o;
      this.returnState && (Array.isArray(i) && (o = i.slice(1).concat(r.slice(1))), i = i[0], r = r[0]), this.returnSequences && (r = Fi(r, 1));
      let a;
      return this.mergeMode === "concat" ? a = eT([i, r]) : this.mergeMode === "sum" ? a = Se(i, r) : this.mergeMode === "ave" ? a = q(0.5, Se(i, r)) : this.mergeMode === "mul" ? a = q(i, r) : this.mergeMode == null && (a = [i, r]), this.returnState ? this.mergeMode == null ? a.concat(o) : [a].concat(o) : a;
    });
  }
  resetStates(e) {
    this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
  }
  build(e) {
    Tc(this.forwardLayer.name, () => {
      this.forwardLayer.build(e);
    }), Tc(this.backwardLayer.name, () => {
      this.backwardLayer.build(e);
    }), this.built = !0;
  }
  computeMask(e, n) {
    Array.isArray(n) && (n = n[0]);
    let s;
    if (this.returnSequences ? this.mergeMode == null ? s = [n, n] : s = n : this.mergeMode == null ? s = [null, null] : s = null, this.returnState) {
      const r = this.forwardLayer.states.map((o) => null);
      return Array.isArray(s) ? s.concat(r).concat(r) : [s].concat(r).concat(r);
    } else
      return s;
  }
  get trainableWeights() {
    return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
  }
  get nonTrainableWeights() {
    return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
  }
  // TODO(cais): Implement constraints().
  setFastWeightInitDuringBuild(e) {
    super.setFastWeightInitDuringBuild(e), this.forwardLayer != null && this.forwardLayer.setFastWeightInitDuringBuild(e), this.backwardLayer != null && this.backwardLayer.setFastWeightInitDuringBuild(e);
  }
  getConfig() {
    const e = {
      mergeMode: this.mergeMode
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    const s = Io(n.layer);
    if (delete n.layer, n.numConstants != null)
      throw new Ct("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
    const i = n;
    return i.layer = s, new e(i);
  }
}
mD.className = "Bidirectional";
Ee(mD);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class gD extends Ft {
  constructor(e) {
    super(e), this.scale = e.scale, e.offset ? this.offset = e.offset : this.offset = 0;
  }
  getConfig() {
    const e = {
      scale: this.scale,
      offset: this.offset
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
  call(e, n) {
    return Q(() => (e = gt(e), e.dtype !== "float32" && (e = Kr(e, "float32")), Se(q(e, this.scale), this.offset)));
  }
}
gD.className = "Rescaling";
Ee(gD);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const { resizeBilinear: rK, cropAndResize: oK } = as;
class yD extends Ft {
  constructor(e) {
    super(e), this.height = e.height, this.width = e.width;
  }
  centerCrop(e, n, s, i, r, o, a, c) {
    return Q(() => {
      let l, u = !1;
      const h = n / o, d = s / a, f = (i + n) / o, p = (r + s) / a, y = [h, d, f, p], g = [];
      e.rank === 3 ? (u = !0, l = ri([e])) : l = e;
      for (let w = 0; w < l.shape[0]; w++)
        g.push(y);
      const m = Mi(g, [g.length, 4]), x = Oo(0, g.length, 1, "int32"), b = oK(l, m, x, [i, r], "nearest");
      return Kr(u ? gt(Pi(b)) : b, c);
    });
  }
  upsize(e, n, s, i) {
    return Q(() => {
      const r = rK(e, [n, s]);
      return Kr(r, i);
    });
  }
  call(e, n) {
    return Q(() => {
      const s = gt(e), i = s.dtype, r = s.shape, o = r[r.length - 3], a = r[r.length - 2];
      let c = 0;
      o !== this.height && (c = Math.floor((o - this.height) / 2));
      let l = 0;
      return a !== this.width && (l = Math.floor((a - this.width) / 2), l === 0 && (l = 1)), c >= 0 && l >= 0 ? this.centerCrop(s, c, l, this.height, this.width, o, a, i) : this.upsize(e, this.height, this.width, i);
    });
  }
  getConfig() {
    const e = {
      height: this.height,
      width: this.width
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
  computeOutputShape(e) {
    e = Ht(e);
    const n = e.length - 3, s = e.length - 2;
    return e[n] = this.height, e[s] = this.width, e;
  }
}
yD.className = "CenterCrop";
Ee(yD);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function aK(t, e, n, s) {
  let i = gt(t);
  if (i.dtype !== "int32" && (i = Kr(i, "int32")), e === "int")
    return i;
  const r = i.shape;
  if (i.rank === 0 && (i = vn(i, -1)), e === "oneHot" && i.shape[i.shape.length - 1] !== 1 && (i = vn(i, -1)), i.rank > 2)
    throw new Z(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${r} which would result in output rank ${i.rank}.`);
  const o = ["multiHot", "oneHot"].includes(e), a = i;
  let c;
  if (typeof s < "u" && e === "count" ? c = Fy(a, s, n, o) : c = Fy(a, [], n, o), e !== "tfIdf")
    return c;
  if (s)
    return q(c, s);
  throw new Z("When outputMode is 'tfIdf', weights must be provided.");
}
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class xD extends Ft {
  constructor(e) {
    super(e), this.numTokens = e.numTokens, e.outputMode ? this.outputMode = e.outputMode : this.outputMode = "multiHot";
  }
  getConfig() {
    const e = {
      numTokens: this.numTokens,
      outputMode: this.outputMode
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
  computeOutputShape(e) {
    return e = Ht(e), e == null ? [this.numTokens] : this.outputMode === "oneHot" && e[e.length - 1] !== 1 ? (e.push(this.numTokens), e) : (e[e.length - 1] = this.numTokens, e);
  }
  call(e, n) {
    return Q(() => {
      e = gt(e), e.dtype !== "int32" && (e = Kr(e, "int32"));
      let s;
      if (typeof n.countWeights < "u") {
        if (this.outputMode !== "count")
          throw new Z(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);
        s = gt(n.countWeights);
      }
      const i = Ri(e), r = wu(e), o = js(this.numTokens, i).bufferSync().get(0), a = Wo(r, 0).bufferSync().get(0);
      if (!(o && a))
        throw new Z(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);
      return aK(e, this.outputMode, this.numTokens, s);
    });
  }
}
xD.className = "CategoryEncoding";
Ee(xD);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const cK = ["bilinear", "nearest"], gI = new Set(cK);
class bD extends Ft {
  constructor(e) {
    if (super(e), this.height = e.height, this.width = e.width, e.interpolation)
      if (gI.has(e.interpolation))
        this.interpolation = e.interpolation;
      else
        throw new Z(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);
    else
      this.interpolation = "bilinear";
    this.cropToAspectRatio = !!e.cropToAspectRatio;
  }
  computeOutputShape(e) {
    e = Ht(e);
    const n = e[2];
    return [this.height, this.width, n];
  }
  getConfig() {
    const e = {
      height: this.height,
      width: this.width,
      interpolation: this.interpolation,
      cropToAspectRatio: this.cropToAspectRatio
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
  call(e, n) {
    return Q(() => {
      const s = [this.height, this.width];
      if (this.interpolation === "bilinear")
        return as.resizeBilinear(e, s, !this.cropToAspectRatio);
      if (this.interpolation === "nearest")
        return as.resizeNearestNeighbor(e, s, !this.cropToAspectRatio);
      throw new Error(`Interpolation is ${this.interpolation} but only ${[...gI]} are supported`);
    });
  }
}
bD.className = "Resizing";
Ee(bD);
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class vD {
  constructor(e) {
    this.seed = e;
  }
  next() {
    if (this.seed !== void 0)
      return this.seed++;
  }
}
vD.className = "RandomSeed";
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class wD extends Ft {
  constructor(e) {
    super(e), this.randomGenerator = new vD(e.seed);
  }
  getConfig() {
    const e = {
      seed: this.randomGenerator.seed
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
}
wD.className = "BaseRandomLayer";
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const lK = ["bilinear", "nearest"], yI = new Set(lK);
class SD extends wD {
  constructor(e) {
    super(e);
    const { factor: n, interpolation: s = "bilinear" } = e;
    if (this.factor = n, Array.isArray(this.factor) && this.factor.length === 2)
      this.widthLower = this.factor[0], this.widthUpper = this.factor[1];
    else if (!Array.isArray(this.factor) && this.factor > 0)
      this.widthLower = -this.factor, this.widthUpper = this.factor;
    else
      throw new Z(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);
    if (this.widthLower < -1 || this.widthUpper < -1)
      throw new Z(`factor must have values larger than -1. Got: ${this.factor}`);
    if (this.widthUpper < this.widthLower)
      throw new Z(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);
    if (s)
      if (yI.has(s))
        this.interpolation = s;
      else
        throw new Z(`Invalid interpolation parameter: ${s} is not implemented`);
  }
  getConfig() {
    const e = {
      factor: this.factor,
      interpolation: this.interpolation
    }, n = super.getConfig();
    return Object.assign(e, n), e;
  }
  computeOutputShape(e) {
    e = Ht(e);
    const n = e[2];
    return [this.imgHeight, -1, n];
  }
  call(e, n) {
    return Q(() => {
      const s = gt(e);
      this.imgHeight = s.shape[s.shape.length - 3];
      const i = s.shape[s.shape.length - 2];
      this.widthFactor = Va([1], 1 + this.widthLower, 1 + this.widthUpper, "float32", this.randomGenerator.next());
      let r = this.widthFactor.dataSync()[0] * i;
      r = Math.round(r);
      const o = [this.imgHeight, r];
      switch (this.interpolation) {
        case "bilinear":
          return as.resizeBilinear(e, o);
        case "nearest":
          return as.resizeNearestNeighbor(e, o);
        default:
          throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...yI]} are supported`);
      }
    });
  }
}
SD.className = "RandomWidth";
Ee(SD);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uK = ie();
uK.registerFlag("KEEP_INTERMEDIATE_TENSORS", () => !1, (t) => {
  t && console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
var ci;
(function(t) {
  t[t.DT_INVALID = 0] = "DT_INVALID", t[t.DT_FLOAT = 1] = "DT_FLOAT", t[t.DT_DOUBLE = 2] = "DT_DOUBLE", t[t.DT_INT32 = 3] = "DT_INT32", t[t.DT_UINT8 = 4] = "DT_UINT8", t[t.DT_INT16 = 5] = "DT_INT16", t[t.DT_INT8 = 6] = "DT_INT8", t[t.DT_STRING = 7] = "DT_STRING", t[t.DT_COMPLEX64 = 8] = "DT_COMPLEX64", t[t.DT_INT64 = 9] = "DT_INT64", t[t.DT_BOOL = 10] = "DT_BOOL", t[t.DT_QINT8 = 11] = "DT_QINT8", t[t.DT_QUINT8 = 12] = "DT_QUINT8", t[t.DT_QINT32 = 13] = "DT_QINT32", t[t.DT_BFLOAT16 = 14] = "DT_BFLOAT16", t[t.DT_QINT16 = 15] = "DT_QINT16", t[t.DT_QUINT16 = 16] = "DT_QUINT16", t[t.DT_UINT16 = 17] = "DT_UINT16", t[t.DT_COMPLEX128 = 18] = "DT_COMPLEX128", t[t.DT_HALF = 19] = "DT_HALF", t[t.DT_RESOURCE = 20] = "DT_RESOURCE", t[t.DT_VARIANT = 21] = "DT_VARIANT", t[t.DT_UINT32 = 22] = "DT_UINT32", t[t.DT_UINT64 = 23] = "DT_UINT64", t[t.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", t[t.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", t[t.DT_INT32_REF = 103] = "DT_INT32_REF", t[t.DT_UINT8_REF = 104] = "DT_UINT8_REF", t[t.DT_INT16_REF = 105] = "DT_INT16_REF", t[t.DT_INT8_REF = 106] = "DT_INT8_REF", t[t.DT_STRING_REF = 107] = "DT_STRING_REF", t[t.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", t[t.DT_INT64_REF = 109] = "DT_INT64_REF", t[t.DT_BOOL_REF = 110] = "DT_BOOL_REF", t[t.DT_QINT8_REF = 111] = "DT_QINT8_REF", t[t.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", t[t.DT_QINT32_REF = 113] = "DT_QINT32_REF", t[t.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF", t[t.DT_QINT16_REF = 115] = "DT_QINT16_REF", t[t.DT_QUINT16_REF = 116] = "DT_QUINT16_REF", t[t.DT_UINT16_REF = 117] = "DT_UINT16_REF", t[t.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF", t[t.DT_HALF_REF = 119] = "DT_HALF_REF", t[t.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF", t[t.DT_VARIANT_REF = 121] = "DT_VARIANT_REF", t[t.DT_UINT32_REF = 122] = "DT_UINT32_REF", t[t.DT_UINT64_REF = 123] = "DT_UINT64_REF";
})(ci || (ci = {}));
var xI;
(function(t) {
  (function(e) {
    e[e.LEGACY = 0] = "LEGACY", e[e.V1 = 1] = "V1", e[e.V2 = 2] = "V2";
  })(t.CheckpointFormatVersion || (t.CheckpointFormatVersion = {}));
})(xI || (xI = {}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const hK = {};
function _D(t) {
  return hK[t];
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function C(t, e, n, s, i) {
  const r = e.inputParams[t];
  if (r && r.inputIndexStart !== void 0) {
    const a = r.inputIndexStart, c = r.inputIndexEnd === 0 ? void 0 : r.inputIndexEnd === void 0 ? a + 1 : r.inputIndexEnd, l = a < 0 ? e.inputNames.length + a : a;
    if (r.type === "tensor")
      return ms(e.inputNames[l], n, s, i);
    if (r.type === "tensors") {
      const d = e.inputs.slice(a, c);
      return e.inputNames.slice(a, c).filter((p, y) => {
        var g;
        return ((g = d[y]) === null || g === void 0 ? void 0 : g.op) !== "NoOp";
      }).map((p) => ms(p, n, s, i));
    }
    const u = ms(e.inputNames[l], n, s, i), h = u.dataSync();
    return r.type === "number" ? h[0] : Ai(u.shape, h);
  }
  const o = e.attrParams[t];
  return o && o.value;
}
function ms(t, e, n, s) {
  const [i, r] = li(t, n);
  if (s != null) {
    const a = s.getHashTableHandleByName(i);
    if (a != null)
      return a;
  }
  const o = n.currentContextIds.find((a) => !!e[qy(i, a)]);
  return o !== void 0 ? e[qy(i, o)][r] : void 0;
}
function bI(t, e, n) {
  return e[qy(t, n.currentContextId)];
}
function So(t, e) {
  const [n, s, i] = li(t, e);
  return [
    qy(n, e && e.currentContextId),
    s,
    i
  ];
}
function qy(t, e) {
  return e ? `${t}-${e}` : t;
}
function li(t, e) {
  if (t === "")
    return ["", 0, void 0];
  const n = e != null && e.parseNodeNameCache != null;
  if (n) {
    const r = e.parseNodeNameCache.get(t);
    if (r != null)
      return r;
  }
  const s = t.split(":");
  let i;
  if (s.length === 1)
    i = [t, 0, void 0];
  else {
    const r = s[0], o = s.length === 3 ? s[1] : void 0, a = Number(s[s.length - 1]);
    i = [r, a, o];
  }
  return n && e.parseNodeNameCache.set(t, i), i;
}
function Vg(t, e, n) {
  let s = C("pad", t, e, n);
  if (s === "explicit") {
    s = C("explicitPaddings", t, e, n);
    const i = [[0, 0], [0, 0], [0, 0], [0, 0]];
    for (let r = 0; r < 4; r++)
      i[r][0] = s[r * 2], i[r][1] = s[r * 2 + 1];
    return i;
  }
  return s;
}
function _o(t) {
  return t.kept ? t : qr(t);
}
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dK = [
  {
    tfOpName: "Add",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "AddV2",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "AddN",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }
    ]
  },
  {
    tfOpName: "BiasAdd",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Sub",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "RealDiv",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Div",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "DivNoNan",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "FloorDiv",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Mul",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Maximum",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Minimum",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Pow",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "SquaredDifference",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Mod",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "FloorMod",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  }
], fK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: dK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pK = [
  {
    tfOpName: "Abs",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Acos",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Asin",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Atan",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Atan2",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "y",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Ceil",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "ClipByValue",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "clipValueMin",
        type: "number"
      },
      {
        start: 2,
        name: "clipValueMax",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Complex",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "real",
        type: "tensor"
      },
      {
        start: 1,
        name: "imag",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "ComplexAbs",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Cos",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Cosh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Elu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Exp",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Floor",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Log",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Imag",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "Tout",
        name: "outputType",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Neg",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Real",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "Tout",
        name: "outputType",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Prelu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "alpha",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Relu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Relu6",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Selu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Sigmoid",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Sin",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Sinh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Sqrt",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Rsqrt",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Square",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Tan",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Tanh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Sign",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Round",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Expm1",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Log1p",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Reciprocal",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Softplus",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Asinh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Acosh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Atanh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Erf",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LeakyRelu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "alpha",
        name: "alpha",
        type: "number",
        defaultValue: 0.2
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "IsNan",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "IsFinite",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "IsInf",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  }
], mK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: pK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const gK = [
  {
    tfOpName: "EmptyTensorList",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "elementShape",
        type: "shape"
      },
      {
        start: 1,
        name: "maxNumElements",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "LoopCond",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "pred",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Switch",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "data",
        type: "tensor"
      },
      {
        start: 1,
        name: "pred",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Merge",
    category: "control",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }
    ]
  },
  {
    tfOpName: "Enter",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "frame_name",
        name: "frameName",
        type: "string"
      },
      {
        tfName: "is_constant",
        name: "isConstant",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Exit",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "NextIteration",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "TensorArrayV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "size",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      },
      {
        tfName: "dynamic_size",
        name: "dynamicSize",
        type: "bool"
      },
      {
        tfName: "clear_after_read",
        name: "clearAfterRead",
        type: "bool"
      },
      {
        tfName: "identical_element_shapes",
        name: "identicalElementShapes",
        type: "bool"
      },
      {
        tfName: "tensor_array_name",
        name: "name",
        type: "string"
      }
    ]
  },
  {
    tfOpName: "TensorArrayWriteV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "index",
        type: "number"
      },
      {
        start: 2,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 3,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "TensorArrayReadV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "index",
        type: "number"
      },
      {
        start: 2,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "TensorArrayGatherV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      }
    ]
  },
  {
    tfOpName: "TensorArrayScatterV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 3,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorArrayConcatV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "element_shape_except0",
        name: "elementShapeExcept0",
        type: "shape",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "TensorArraySplitV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 2,
        name: "lengths",
        type: "number[]"
      },
      {
        start: 3,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorArraySizeV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "flowIn",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "TensorArrayCloseV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "StatelessIf",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "cond",
        type: "tensor"
      },
      {
        start: 1,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "then_branch",
        name: "thenBranch",
        type: "func"
      },
      {
        tfName: "else_branch",
        name: "elseBranch",
        type: "func"
      }
    ]
  },
  {
    tfOpName: "If",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "cond",
        type: "tensor"
      },
      {
        start: 1,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "then_branch",
        name: "thenBranch",
        type: "func"
      },
      {
        tfName: "else_branch",
        name: "elseBranch",
        type: "func"
      }
    ]
  },
  {
    tfOpName: "StatelessWhile",
    category: "control",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "cond",
        name: "cond",
        type: "func"
      },
      {
        tfName: "body",
        name: "body",
        type: "func"
      }
    ]
  },
  {
    tfOpName: "While",
    category: "control",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "cond",
        name: "cond",
        type: "func"
      },
      {
        tfName: "body",
        name: "body",
        type: "func"
      }
    ]
  },
  {
    tfOpName: "TensorListScatter",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListScatterV2",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "elementShape",
        type: "shape"
      },
      {
        start: 3,
        name: "numElements",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListGather",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListGetItem",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "index",
        type: "number"
      },
      {
        start: 2,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListSetItem",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "index",
        type: "number"
      },
      {
        start: 2,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListReserve",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "elementShape",
        type: "shape"
      },
      {
        start: 1,
        name: "numElements",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListFromTensor",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListStack",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      },
      {
        tfName: "num_elements",
        name: "numElements",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListSplit",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "elementShape",
        type: "shape"
      },
      {
        start: 2,
        name: "lengths",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListConcat",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      },
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListConcatV2",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      },
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListPopBack",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListPushBack",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListLength",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "TensorListResize",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number"
      }
    ]
  }
], yK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: gK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xK = [
  {
    tfOpName: "AvgPool",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "MaxPool",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: [],
        notSupported: !0
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "MaxPoolWithArgmax",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "include_batch_in_index",
        name: "includeBatchInIndex",
        type: "bool"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "AvgPool3D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "MaxPool3D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Conv1D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "stride",
        name: "stride",
        type: "number"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NWC"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "dilation",
        name: "dilation",
        type: "number",
        defaultValue: 1
      }
    ]
  },
  {
    tfOpName: "Conv2D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "useCudnnOnGpu",
        name: "useCudnnOnGpu",
        type: "bool"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "_FusedConv2D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      },
      {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "num_args",
        name: "numArgs",
        type: "number"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "use_cudnn_on_gpu",
        name: "useCudnnOnGpu",
        type: "bool",
        defaultValue: !0
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        defaultValue: [
          1,
          1,
          1,
          1
        ]
      },
      {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
      },
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-4
      },
      {
        tfName: "leakyrelu_alpha",
        name: "leakyreluAlpha",
        type: "number",
        defaultValue: 0.2
      }
    ]
  },
  {
    tfOpName: "Conv2DBackpropInput",
    category: "convolution",
    inputs: [
      {
        start: 2,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      },
      {
        start: 0,
        name: "outputShape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "DepthwiseConv2d",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "DepthwiseConv2dNative",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "FusedDepthwiseConv2dNative",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      },
      {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "num_args",
        name: "numArgs",
        type: "number"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        defaultValue: [
          1,
          1,
          1,
          1
        ]
      },
      {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      }
    ]
  },
  {
    tfOpName: "Conv3D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "Dilation2D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "rates",
        name: "dilations",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      }
    ]
  }
], bK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: xK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const vK = [
  {
    tfOpName: "Fill",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      },
      {
        start: 1,
        name: "value",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "LinSpace",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "start",
        type: "number"
      },
      {
        start: 1,
        name: "stop",
        type: "number"
      },
      {
        start: 2,
        name: "num",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "OneHot",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "indices",
        type: "tensor"
      },
      {
        start: 1,
        name: "depth",
        type: "number"
      },
      {
        start: 2,
        name: "onValue",
        type: "number",
        defaultValue: 1
      },
      {
        start: 3,
        name: "offValue",
        type: "number",
        defaultValue: 0
      }
    ],
    attrs: [
      {
        tfName: "axis",
        name: "axis",
        type: "number",
        notSupported: !0
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "Ones",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "OnesLike",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "RandomStandardNormal",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "RandomUniform",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "minval",
        name: "minval",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "maxval",
        name: "maxval",
        type: "number",
        defaultValue: 1
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
      },
      {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "RandomUniformInt",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "minval",
        name: "minval",
        type: "number"
      },
      {
        tfName: "maxval",
        name: "maxval",
        type: "number"
      },
      {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Range",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "start",
        type: "number"
      },
      {
        start: 1,
        name: "stop",
        type: "number"
      },
      {
        start: 2,
        name: "step",
        type: "number",
        defaultValue: 0
      }
    ],
    attrs: [
      {
        tfName: "Tidx",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TruncatedNormal",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "means",
        name: "mean",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "stddev",
        name: "stdDev",
        type: "number",
        defaultValue: 1
      },
      {
        tfName: "seed",
        name: "seed",
        type: "number"
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Zeros",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "ZerosLike",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "Multinomial",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "logits",
        type: "tensor"
      },
      {
        start: 1,
        name: "numSamples",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "seed",
        name: "seed",
        type: "number"
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "output_dtype",
        name: "output_dtype",
        type: "dtype"
      }
    ]
  }
], wK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: vK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const SK = [
  {
    tfOpName: "NonMaxSuppressionV2",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 1,
        name: "scores",
        type: "tensor"
      },
      {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      },
      {
        start: 3,
        name: "iouThreshold",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "NonMaxSuppressionV3",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 1,
        name: "scores",
        type: "tensor"
      },
      {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      },
      {
        start: 3,
        name: "iouThreshold",
        type: "number"
      },
      {
        start: 4,
        name: "scoreThreshold",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "NonMaxSuppressionV4",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 1,
        name: "scores",
        type: "tensor"
      },
      {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      },
      {
        start: 3,
        name: "iouThreshold",
        type: "number"
      },
      {
        start: 4,
        name: "scoreThreshold",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "T_threshold",
        name: "threshold",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "pad_to_max_output_size",
        name: "padToMaxOutputSize",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "NonMaxSuppressionV5",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 1,
        name: "scores",
        type: "tensor"
      },
      {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      },
      {
        start: 3,
        name: "iouThreshold",
        type: "number"
      },
      {
        start: 4,
        name: "scoreThreshold",
        type: "number"
      },
      {
        start: 5,
        name: "softNmsSigma",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "Where",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "condition",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "ListDiff",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "y",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  }
], _K = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: SK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const TK = [
  {
    tfOpName: "LowerBound",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "sortedSequence",
        type: "tensor"
      },
      {
        start: 1,
        name: "values",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "TopKV2",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "k",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "sorted",
        name: "sorted",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "UpperBound",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "sortedSequence",
        type: "tensor"
      },
      {
        start: 1,
        name: "values",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Unique",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "UniqueV2",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ]
  }
], CK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: TK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const IK = [
  {
    tfOpName: "PlaceholderWithDefault",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "default",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "shape",
        name: "shape",
        type: "shape"
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "Placeholder",
    category: "graph",
    attrs: [
      {
        tfName: "shape",
        name: "shape",
        type: "shape"
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "Const",
    category: "graph"
  },
  {
    tfOpName: "Identity",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "IdentityN",
    category: "graph",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "x",
        type: "tensors"
      }
    ]
  },
  {
    tfOpName: "Snapshot",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Rank",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Size",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Shape",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "ShapeN",
    category: "graph",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "x",
        type: "tensors"
      }
    ]
  },
  {
    tfOpName: "Print",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "data",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "message",
        name: "message",
        type: "string"
      },
      {
        tfName: "first_n",
        name: "firstN",
        type: "number",
        notSupported: !0
      },
      {
        tfName: "summarize",
        name: "summarize",
        type: "number",
        defaultValue: 3
      }
    ]
  },
  {
    tfOpName: "NoOp",
    category: "graph",
    inputs: []
  },
  {
    tfOpName: "StopGradient",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "FakeQuantWithMinMaxVars",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "min",
        name: "min",
        type: "number"
      },
      {
        tfName: "max",
        name: "max",
        type: "number"
      }
    ]
  }
], EK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: IK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const NK = [
  {
    tfOpName: "HashTable",
    category: "hash_table",
    inputs: [],
    attrs: [
      {
        tfName: "shared_name",
        name: "sharedName",
        type: "string"
      },
      {
        tfName: "use_node_name_sharing",
        name: "useNodeNameSharing",
        type: "bool"
      },
      {
        tfName: "key_dtype",
        name: "keyDType",
        type: "dtype"
      },
      {
        tfName: "value_dtype",
        name: "valueDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "HashTableV2",
    category: "hash_table",
    inputs: [],
    attrs: [
      {
        tfName: "shared_name",
        name: "sharedName",
        type: "string"
      },
      {
        tfName: "use_node_name_sharing",
        name: "useNodeNameSharing",
        type: "bool"
      },
      {
        tfName: "key_dtype",
        name: "keyDType",
        type: "dtype"
      },
      {
        tfName: "value_dtype",
        name: "valueDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "LookupTableImport",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LookupTableImportV2",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LookupTableFind",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "defaultValue",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LookupTableFindV2",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "defaultValue",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LookupTableSize",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "LookupTableSizeV2",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "InitializeTable",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "InitializeTableV2",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ]
  }
], kK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: NK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const AK = [
  {
    tfOpName: "ResizeBilinear",
    category: "image",
    inputs: [
      {
        start: 0,
        name: "images",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "align_corners",
        name: "alignCorners",
        type: "bool"
      },
      {
        tfName: "half_pixel_centers",
        name: "halfPixelCenters",
        type: "bool"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "ResizeNearestNeighbor",
    category: "image",
    inputs: [
      {
        start: 0,
        name: "images",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "align_corners",
        name: "alignCorners",
        type: "bool"
      },
      {
        tfName: "half_pixel_centers",
        name: "halfPixelCenters",
        type: "bool"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "CropAndResize",
    category: "image",
    inputs: [
      {
        start: 0,
        name: "image",
        type: "tensor"
      },
      {
        start: 1,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 2,
        name: "boxInd",
        type: "tensor"
      },
      {
        start: 3,
        name: "cropSize",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "method",
        name: "method",
        type: "string"
      },
      {
        tfName: "extrapolation_value",
        name: "extrapolationValue",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "ImageProjectiveTransformV3",
    category: "image",
    inputs: [
      {
        start: 0,
        name: "images",
        type: "tensor"
      },
      {
        start: 1,
        name: "transforms",
        type: "tensor"
      },
      {
        start: 2,
        name: "outputShape",
        type: "number[]"
      },
      {
        start: 3,
        name: "fillValue",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "interpolation",
        name: "interpolation",
        type: "string"
      },
      {
        tfName: "fill_mode",
        name: "fillMode",
        type: "string"
      }
    ]
  }
], MK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: AK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const RK = [
  {
    tfOpName: "Equal",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "NotEqual",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Greater",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "GreaterEqual",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Less",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LessEqual",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LogicalAnd",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LogicalNot",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LogicalOr",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Select",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "condition",
        type: "tensor"
      },
      {
        start: 1,
        name: "a",
        type: "tensor"
      },
      {
        start: 2,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "SelectV2",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "condition",
        type: "tensor"
      },
      {
        start: 1,
        name: "a",
        type: "tensor"
      },
      {
        start: 2,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "BitwiseAnd",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "y",
        type: "tensor"
      }
    ]
  }
], DK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: RK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $K = [
  {
    tfOpName: "_FusedMatMul",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      },
      {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "num_args",
        name: "numArgs",
        type: "number"
      },
      {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
      },
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-4
      },
      {
        tfName: "transpose_a",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "transpose_b",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "leakyrelu_alpha",
        name: "leakyreluAlpha",
        type: "number",
        defaultValue: 0.2
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "MatMul",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "transpose_a",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "transpose_b",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "BatchMatMul",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "adj_x",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "adj_y",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "BatchMatMulV2",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "adj_x",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "adj_y",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Transpose",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "perm",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Einsum",
    category: "matrices",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "equation",
        name: "equation",
        type: "string"
      },
      {
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "MatrixBandPart",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "numLower",
        type: "tensor"
      },
      {
        start: 1,
        name: "numUpper",
        type: "tensor"
      }
    ]
  }
], OK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: $K
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const LK = [
  {
    tfOpName: "EuclideanNorm",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool",
        defaultValue: !1
      }
    ]
  },
  {
    tfOpName: "FusedBatchNorm",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "scale",
        type: "tensor"
      },
      {
        start: 2,
        name: "offset",
        type: "tensor"
      },
      {
        start: 3,
        name: "mean",
        type: "tensor"
      },
      {
        start: 4,
        name: "variance",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-3
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "FusedBatchNormV2",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "scale",
        type: "tensor"
      },
      {
        start: 2,
        name: "offset",
        type: "tensor"
      },
      {
        start: 3,
        name: "mean",
        type: "tensor"
      },
      {
        start: 4,
        name: "variance",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-3
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "FusedBatchNormV3",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "scale",
        type: "tensor"
      },
      {
        start: 2,
        name: "offset",
        type: "tensor"
      },
      {
        start: 3,
        name: "mean",
        type: "tensor"
      },
      {
        start: 4,
        name: "variance",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-3
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LRN",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "depth_radius",
        name: "radius",
        type: "number",
        defaultValue: 5
      },
      {
        tfName: "bias",
        name: "bias",
        type: "number",
        defaultValue: 1
      },
      {
        tfName: "alpha",
        name: "alpha",
        type: "number",
        defaultValue: 1
      },
      {
        tfName: "beta",
        name: "beta",
        type: "number",
        defaultValue: 0.5
      }
    ]
  },
  {
    tfOpName: "Softmax",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "LogSoftmax",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  }
], FK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: LK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const PK = [
  {
    tfOpName: "Bincount",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number"
      },
      {
        start: 2,
        name: "weights",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "DenseBincount",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number"
      },
      {
        start: 2,
        name: "weights",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "binary_output",
        name: "binaryOutput",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Max",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Mean",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Min",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Sum",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "All",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Any",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "ArgMax",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "ArgMin",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "Prod",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Cumprod",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "exclusive",
        name: "exclusive",
        type: "bool"
      },
      {
        tfName: "reverse",
        name: "reverse",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Cumsum",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "exclusive",
        name: "exclusive",
        type: "bool"
      },
      {
        tfName: "reverse",
        name: "reverse",
        type: "bool"
      }
    ]
  }
], BK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: PK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const zK = [
  {
    tfOpName: "ConcatV2",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        end: -1,
        name: "tensors",
        type: "tensors"
      },
      {
        start: -1,
        name: "axis",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
      }
    ]
  },
  {
    tfOpName: "Concat",
    category: "slice_join",
    inputs: [
      {
        start: 1,
        end: 0,
        name: "tensors",
        type: "tensors"
      },
      {
        start: 0,
        name: "axis",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
      }
    ]
  },
  {
    tfOpName: "GatherV2",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      },
      {
        start: 2,
        name: "axis",
        type: "number",
        defaultValue: 0
      }
    ],
    attrs: [
      {
        tfName: "batch_dims",
        name: "batchDims",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "Gather",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Reverse",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "dims",
        type: "bool[]"
      }
    ]
  },
  {
    tfOpName: "ReverseV2",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "Slice",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "begin",
        type: "number[]"
      },
      {
        start: 2,
        name: "size",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "StridedSlice",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "begin",
        type: "number[]"
      },
      {
        start: 2,
        name: "end",
        type: "number[]"
      },
      {
        start: 3,
        name: "strides",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "begin_mask",
        name: "beginMask",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "end_mask",
        name: "endMask",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "new_axis_mask",
        name: "newAxisMask",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "ellipsis_mask",
        name: "ellipsisMask",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "shrink_axis_mask",
        name: "shrinkAxisMask",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "Pack",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "axis",
        name: "axis",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "Unpack",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "axis",
        name: "axis",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "num",
        name: "num",
        type: "number",
        defaultValue: 0,
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Tile",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "reps",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "Split",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "axis",
        type: "number",
        defaultValue: 0
      },
      {
        start: 1,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "num_split",
        name: "numOrSizeSplits",
        type: "number",
        defaultValue: 1
      }
    ]
  },
  {
    tfOpName: "SplitV",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "numOrSizeSplits",
        type: "number[]"
      },
      {
        start: 2,
        name: "axis",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "ScatterNd",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "indices",
        type: "tensor"
      },
      {
        start: 1,
        name: "values",
        type: "tensor"
      },
      {
        start: 2,
        name: "shape",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "GatherNd",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "SparseToDense",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "sparseIndices",
        type: "tensor"
      },
      {
        start: 1,
        name: "outputShape",
        type: "number[]"
      },
      {
        start: 2,
        name: "sparseValues",
        type: "tensor"
      },
      {
        start: 3,
        name: "defaultValue",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        defaultValue: !1,
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "TensorScatterUpdate",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ]
  }
], VK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: zK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const UK = [
  {
    tfOpName: "SparseFillEmptyRows",
    category: "sparse",
    inputs: [
      {
        start: 0,
        name: "indices",
        type: "tensor"
      },
      {
        start: 1,
        name: "values",
        type: "tensor"
      },
      {
        start: 2,
        name: "denseShape",
        type: "tensor"
      },
      {
        start: 3,
        name: "defaultValue",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "SparseReshape",
    category: "sparse",
    inputs: [
      {
        start: 0,
        name: "inputIndices",
        type: "tensor"
      },
      {
        start: 1,
        name: "inputShape",
        type: "tensor"
      },
      {
        start: 2,
        name: "newShape",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "SparseSegmentMean",
    category: "sparse",
    inputs: [
      {
        start: 0,
        name: "data",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      },
      {
        start: 2,
        name: "segmentIds",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "SparseSegmentSum",
    category: "sparse",
    inputs: [
      {
        start: 0,
        name: "data",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      },
      {
        start: 2,
        name: "segmentIds",
        type: "tensor"
      }
    ]
  }
], GK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: UK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const WK = [
  {
    tfOpName: "FFT",
    category: "spectral",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "IFFT",
    category: "spectral",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "RFFT",
    category: "spectral",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "fft_length",
        type: "number",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "IRFFT",
    category: "spectral",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "fft_length",
        type: "number",
        notSupported: !0
      }
    ]
  }
], HK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: WK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jK = [
  {
    tfOpName: "StaticRegexReplace",
    category: "string",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "pattern",
        name: "pattern",
        type: "string"
      },
      {
        tfName: "rewrite",
        name: "rewrite",
        type: "string"
      },
      {
        tfName: "replace_global",
        name: "replaceGlobal",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "StringNGrams",
    category: "string",
    inputs: [
      {
        start: 0,
        name: "data",
        type: "tensor"
      },
      {
        start: 1,
        name: "dataSplits",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "separator",
        name: "separator",
        type: "string"
      },
      {
        tfName: "ngram_widths",
        name: "nGramWidths",
        type: "number[]"
      },
      {
        tfName: "left_pad",
        name: "leftPad",
        type: "string"
      },
      {
        tfName: "right_pad",
        name: "rightPad",
        type: "string"
      },
      {
        tfName: "pad_width",
        name: "padWidth",
        type: "number"
      },
      {
        tfName: "preserve_short_sequences",
        name: "preserveShortSequences",
        type: "bool"
      }
    ],
    outputs: [
      "ngrams",
      "ngrams_splits"
    ]
  },
  {
    tfOpName: "StringSplit",
    category: "string",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      },
      {
        start: 1,
        name: "delimiter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "skip_empty",
        name: "skipEmpty",
        type: "bool"
      }
    ],
    outputs: [
      "indices",
      "values",
      "shape"
    ]
  },
  {
    tfOpName: "StringToHashBucketFast",
    category: "string",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "num_buckets",
        name: "numBuckets",
        type: "number"
      }
    ]
  }
], qK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: jK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const XK = [
  {
    tfOpName: "Cast",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "SrcT",
        name: "sdtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "DstT",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "ExpandDims",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "MirrorPad",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "padding",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "mode",
        name: "mode",
        type: "string"
      }
    ]
  },
  {
    tfOpName: "Pad",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "padding",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "constant_value",
        name: "constantValue",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "PadV2",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "padding",
        type: "number[]"
      },
      {
        start: 2,
        name: "constantValue",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "Reshape",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "shape",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "EnsureShape",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "shape",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "Squeeze",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "axis",
        tfDeprecatedName: "squeeze_dims",
        name: "axis",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "SpaceToBatchND",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "blockShape",
        type: "number[]"
      },
      {
        start: 2,
        name: "paddings",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "BatchToSpaceND",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "blockShape",
        type: "number[]"
      },
      {
        start: 2,
        name: "crops",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "DepthToSpace",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "block_size",
        name: "blockSize",
        type: "number"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string"
      }
    ]
  },
  {
    tfOpName: "BroadcastTo",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: []
  },
  {
    tfOpName: "BroadcastArgs",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "s0",
        type: "tensor"
      },
      {
        start: 1,
        name: "s1",
        type: "tensor"
      }
    ],
    attrs: []
  }
], KK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: XK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class vI {
  // Singleton instance for the mapper
  static get Instance() {
    return this._instance || (this._instance = new this());
  }
  // Loads the op mapping from the JSON file.
  constructor() {
    const e = [
      fK,
      mK,
      yK,
      bK,
      wK,
      _K,
      CK,
      EK,
      kK,
      MK,
      DK,
      OK,
      FK,
      BK,
      VK,
      GK,
      HK,
      qK,
      KK
    ], n = [].concat(...e.map((s) => s.json));
    this.opMappers = n.reduce((s, i) => (s[i.tfOpName] = i, s), {});
  }
  // Converts the model inference graph from Tensorflow GraphDef to local
  // representation for TensorFlow.js API
  transformGraph(e, n = {}) {
    const s = e.node, i = [], r = [], o = [], a = s.reduce((y, g) => (y[g.name] = this.mapNode(g), g.op.startsWith("Placeholder") ? i.push(y[g.name]) : g.op === "Const" ? r.push(y[g.name]) : (g.input == null || g.input.length === 0) && o.push(y[g.name]), y), {});
    let c = [];
    const l = [];
    let u = {}, h = {};
    n != null && (u = this.mapSignatureEntries(n.inputs), h = this.mapSignatureEntries(n.outputs));
    const d = Object.keys(a);
    d.forEach((y) => {
      const g = a[y];
      g.inputNames.forEach((m, x) => {
        const [v, , b] = So(m), w = a[v];
        if (w.outputs != null) {
          const S = w.outputs.indexOf(b);
          if (S !== -1) {
            const _ = `${v}:${S}`;
            g.inputNames[x] = _;
          }
        }
        g.inputs.push(w), w.children.push(g);
      });
    }), Object.keys(h).length === 0 ? d.forEach((y) => {
      const g = a[y];
      g.children.length === 0 && l.push(g);
    }) : Object.keys(h).forEach((y) => {
      const [g] = So(y), m = a[g];
      m != null && (m.signatureKey = h[y], l.push(m));
    }), Object.keys(u).length > 0 ? Object.keys(u).forEach((y) => {
      const [g] = So(y), m = a[g];
      m && (m.signatureKey = u[y], c.push(m));
    }) : c = i;
    let f = {};
    e.library != null && e.library.function != null && (f = e.library.function.reduce((y, g) => (y[g.signature.name] = this.mapFunction(g), y), {}));
    const p = { nodes: a, inputs: c, outputs: l, weights: r, placeholders: i, signature: n, functions: f };
    return o.length > 0 && (p.initNodes = o), p;
  }
  mapSignatureEntries(e) {
    return Object.keys(e || {}).reduce((n, s) => (n[e[s].name] = s, n), {});
  }
  mapNode(e) {
    const n = _D(e.op) || this.opMappers[e.op] || {};
    e.attr == null && (e.attr = {});
    const s = {
      name: e.name,
      op: e.op,
      category: n.category,
      inputNames: (e.input || []).map((i) => i.startsWith("^") ? i.slice(1) : i),
      inputs: [],
      children: [],
      inputParams: {},
      attrParams: {},
      rawAttrs: e.attr,
      outputs: n.outputs
    };
    return n.inputs != null && (s.inputParams = n.inputs.reduce((i, r) => (i[r.name] = {
      type: r.type,
      inputIndexStart: r.start,
      inputIndexEnd: r.end
    }, i), {})), n.attrs != null && (s.attrParams = n.attrs.reduce((i, r) => {
      const o = r.type;
      let a;
      switch (r.type) {
        case "string":
          a = h1(e.attr, r.tfName, r.defaultValue), a === void 0 && r.tfDeprecatedName && (a = h1(e.attr, r.tfDeprecatedName, r.defaultValue));
          break;
        case "string[]":
          a = x1(e.attr, r.tfName, r.defaultValue), a === void 0 && r.tfDeprecatedName && (a = x1(e.attr, r.tfDeprecatedName, r.defaultValue));
          break;
        case "number":
          a = f1(e.attr, r.tfName, r.defaultValue || 0), a === void 0 && r.tfDeprecatedName && (a = f1(e.attr, r.tfDeprecatedName, r.defaultValue));
          break;
        case "number[]":
          a = y1(e.attr, r.tfName, r.defaultValue), a === void 0 && r.tfDeprecatedName && (a = y1(e.attr, r.tfDeprecatedName, r.defaultValue));
          break;
        case "bool":
          a = d1(e.attr, r.tfName, r.defaultValue), a === void 0 && r.tfDeprecatedName && (a = d1(e.attr, r.tfDeprecatedName, r.defaultValue));
          break;
        case "bool[]":
          a = v1(e.attr, r.tfName, r.defaultValue), a === void 0 && r.tfDeprecatedName && (a = v1(e.attr, r.tfDeprecatedName, r.defaultValue));
          break;
        case "shape":
          a = g1(e.attr, r.tfName, r.defaultValue), a === void 0 && r.tfDeprecatedName && (a = g1(e.attr, r.tfDeprecatedName, r.defaultValue));
          break;
        case "shape[]":
          a = b1(e.attr, r.tfName, r.defaultValue), a === void 0 && r.tfDeprecatedName && (a = b1(e.attr, r.tfDeprecatedName, r.defaultValue));
          break;
        case "dtype":
          a = p1(e.attr, r.tfName, r.defaultValue), a === void 0 && r.tfDeprecatedName && (a = p1(e.attr, r.tfDeprecatedName, r.defaultValue));
          break;
        case "dtype[]":
          a = m1(e.attr, r.tfName, r.defaultValue), a === void 0 && r.tfDeprecatedName && (a = m1(e.attr, r.tfDeprecatedName, r.defaultValue));
          break;
        case "func":
          a = wI(e.attr, r.tfName, r.defaultValue), a === void 0 && r.tfDeprecatedName && (a = wI(e.attr, r.tfDeprecatedName, r.defaultValue));
          break;
        case "tensor":
        case "tensors":
          break;
        default:
          throw new Error(`Unsupported param type: ${r.type} for op: ${e.op}`);
      }
      return i[r.name] = { value: a, type: o }, i;
    }, {})), s;
  }
  // map the TFunctionDef to TFJS graph object
  mapFunction(e) {
    const n = e.nodeDef, s = [], i = [];
    let r = {};
    n != null && (r = n.reduce((h, d) => (h[d.name] = this.mapNode(d), d.op === "Const" && i.push(h[d.name]), h), {}));
    const o = [], a = [];
    e.signature.inputArg.forEach((h) => {
      const [d] = So(h.name), f = {
        name: d,
        op: "Placeholder",
        inputs: [],
        inputNames: [],
        category: "graph",
        inputParams: {},
        attrParams: { dtype: { value: bT(h.type), type: "dtype" } },
        children: []
      };
      f.signatureKey = h.name, o.push(f), r[d] = f;
    }), Object.keys(r).forEach((h) => {
      const d = r[h];
      d.inputNames.forEach((f, p) => {
        const [y, , g] = So(f), m = r[y];
        if (m.outputs != null) {
          const x = m.outputs.indexOf(g);
          if (x !== -1) {
            const v = `${y}:${x}`;
            d.inputNames[p] = v;
          }
        }
        d.inputs.push(m), m.children.push(d);
      });
    });
    const l = e.ret;
    e.signature.outputArg.forEach((h) => {
      const [d, f] = So(l[h.name]), p = r[d];
      p != null && (p.defaultOutput = f, a.push(p));
    });
    const u = this.mapArgsToSignature(e);
    return { nodes: r, inputs: o, outputs: a, weights: i, placeholders: s, signature: u };
  }
  mapArgsToSignature(e) {
    return {
      methodName: e.signature.name,
      inputs: e.signature.inputArg.reduce((n, s) => (n[s.name] = this.mapArgToTensorInfo(s), n), {}),
      outputs: e.signature.outputArg.reduce((n, s) => (n[s.name] = this.mapArgToTensorInfo(s, e.ret), n), {})
    };
  }
  mapArgToTensorInfo(e, n) {
    let s = e.name;
    return n != null && (s = n[s]), { name: s, dtype: e.type };
  }
}
function YK(t) {
  const e = ie().global;
  if (typeof e.atob < "u")
    return e.atob(t);
  if (typeof Buffer < "u")
    return new Buffer(t, "base64").toString();
  throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
}
function TD(t, e) {
  const n = Array.isArray(t) ? String.fromCharCode.apply(null, t) : YK(t);
  return e ? n : n.toLowerCase();
}
function h1(t, e, n, s = !1) {
  const i = t[e];
  return i != null ? TD(i.s, s) : n;
}
function d1(t, e, n) {
  const s = t[e];
  return s ? s.b : n;
}
function f1(t, e, n) {
  const s = t[e] || {}, i = s.i != null ? s.i : s.f != null ? s.f : n;
  return typeof i == "number" ? i : parseInt(i, 10);
}
function bT(t) {
  switch (typeof t == "string" && (t = ci[t]), t) {
    case ci.DT_FLOAT:
    case ci.DT_HALF:
      return "float32";
    case ci.DT_INT32:
    case ci.DT_INT64:
    case ci.DT_INT8:
    case ci.DT_UINT8:
      return "int32";
    case ci.DT_BOOL:
      return "bool";
    case ci.DT_DOUBLE:
      return "float32";
    case ci.DT_STRING:
      return "string";
    case ci.DT_COMPLEX64:
    case ci.DT_COMPLEX128:
      return "complex64";
    default:
      return null;
  }
}
function wI(t, e, n) {
  const s = t[e];
  return s && s.func ? s.func.name : n;
}
function p1(t, e, n) {
  const s = t[e];
  return s && s.type ? bT(s.type) : n;
}
function m1(t, e, n) {
  const s = t[e];
  return s && s.list && s.list.type ? s.list.type.map((i) => bT(i)) : n;
}
function CD(t) {
  if (!t.unknownRank)
    return t.dim != null ? t.dim.map((e) => typeof e.size == "number" ? e.size : parseInt(e.size, 10)) : [];
}
function g1(t, e, n) {
  const s = t[e];
  return s && s.shape ? CD(s.shape) : n;
}
function y1(t, e, n) {
  const s = t[e];
  return s ? ((s.list.f && s.list.f.length ? s.list.f : s.list.i) || []).map((i) => typeof i == "number" ? i : parseInt(i, 10)) : n;
}
function x1(t, e, n, s = !1) {
  const i = t[e];
  return i && i.list && i.list.s ? i.list.s.map((r) => TD(r, s)) : n;
}
function b1(t, e, n) {
  const s = t[e];
  return s && s.list && s.list.shape ? s.list.shape.map((i) => CD(i)) : n;
}
function v1(t, e, n) {
  const s = t[e];
  return s && s.list && s.list.b ? s.list.b : n;
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ZK {
  constructor(e, n, s) {
    this.node = e, this.tensorMap = n, this.context = s, this.inputs = [], this.attrs = {}, this.inputs = e.inputNames.map((i) => this.getInput(i)), e.rawAttrs != null && (this.attrs = Object.keys(e.rawAttrs).reduce((i, r) => (i[r] = this.getAttr(r), i), {}));
  }
  /**
   * Return the value of the attribute or input param.
   * @param name String: name of attribute or input param.
   */
  getInput(e) {
    return ms(e, this.tensorMap, this.context);
  }
  /**
   * Return the value of the attribute or input param.
   * @param name String: name of attribute or input param.
   */
  getAttr(e, n) {
    const s = this.node.rawAttrs[e];
    if (s.tensor != null)
      return ms(e, this.tensorMap, this.context);
    if (s.i != null || s.f != null)
      return f1(this.node.rawAttrs, e, n);
    if (s.s != null)
      return h1(this.node.rawAttrs, e, n);
    if (s.b != null)
      return d1(this.node.rawAttrs, e, n);
    if (s.shape != null)
      return g1(this.node.rawAttrs, e, n);
    if (s.type != null)
      return p1(this.node.rawAttrs, e, n);
    if (s.list != null) {
      if (s.list.i != null || s.list.f != null)
        return y1(this.node.rawAttrs, e, n);
      if (s.list.s != null)
        return x1(this.node.rawAttrs, e, n);
      if (s.list.shape != null)
        return b1(this.node.rawAttrs, e, n);
      if (s.list.b != null)
        return v1(this.node.rawAttrs, e, n);
      if (s.list.type != null)
        return m1(this.node.rawAttrs, e, n);
    }
    return n;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OP_SCOPE_SUFFIX: nS,
  abs: jn,
  acos: aS,
  acosh: cS,
  add: Se,
  addN: dk,
  all: E0,
  any: xf,
  argMax: Ea,
  argMin: lS,
  asin: uS,
  asinh: hS,
  atan: dS,
  atan2: fS,
  atanh: pS,
  avgPool: Wp,
  avgPool3d: gS,
  basicLSTMCell: fk,
  batchNorm: Mh,
  batchNorm2d: yS,
  batchNorm3d: xS,
  batchNorm4d: bS,
  batchToSpaceND: Hp,
  bincount: vS,
  bitwiseAnd: pk,
  booleanMaskAsync: Jk,
  broadcastArgs: mk,
  broadcastTo: Sc,
  buffer: It,
  cast: Le,
  ceil: wS,
  clipByValue: Gs,
  clone: qr,
  complex: Do,
  concat: Pn,
  concat1d: SS,
  concat2d: _S,
  concat3d: TS,
  concat4d: CS,
  conv1d: N0,
  conv2d: $o,
  conv2dTranspose: k0,
  conv3d: ES,
  conv3dTranspose: NS,
  cos: jp,
  cosh: A0,
  cosineWindow: eb,
  cumprod: wf,
  cumsum: M0,
  denseBincount: Fy,
  depthToSpace: kS,
  depthwiseConv2d: Rh,
  diag: yk,
  dilation2d: AS,
  div: it,
  divNoNan: MS,
  dot: RS,
  dropout: d_,
  einsum: hc,
  elu: Dh,
  enclosingPowerOfTwo: f_,
  ensureShape: xk,
  equal: xi,
  erf: R0,
  euclideanNorm: $S,
  exp: ii,
  expandDims: vn,
  expm1: OS,
  eye: D0,
  fft: om,
  fill: nl,
  floor: Oh,
  floorDiv: I0,
  fused: aA,
  gather: Lh,
  gatherND: nA,
  greater: js,
  greaterEqual: Wo,
  ifft: Cu,
  imag: qp,
  image: as,
  inTopKAsync: sA,
  irfft: X0,
  isFinite: LS,
  isInf: FS,
  isNaN: PS,
  leakyRelu: Xp,
  less: Su,
  lessEqual: za,
  linalg: g_,
  linspace: wk,
  localResponseNormalization: BS,
  log: bi,
  log1p: Kp,
  logSigmoid: zS,
  logSoftmax: O0,
  logSumExp: Yp,
  logicalAnd: _r,
  logicalNot: Zp,
  logicalOr: L0,
  logicalXor: VS,
  losses: pA,
  lowerBound: _k,
  matMul: Tt,
  max: Ri,
  maxPool: Jp,
  maxPool3d: US,
  maxPoolWithArgmax: Tk,
  maximum: lo,
  mean: En,
  meshgrid: Ck,
  min: wu,
  minimum: Aa,
  mirrorPad: P0,
  mod: GS,
  moments: Qp,
  movingAverage: Qk,
  mul: q,
  multiRNNCell: Ik,
  multinomial: Ek,
  neg: hn,
  norm: $h,
  notEqual: Uc,
  oneHot: Gc,
  ones: Qs,
  onesLike: vi,
  op: H,
  outerProduct: Nk,
  pad: uo,
  pad1d: kk,
  pad2d: Ak,
  pad3d: WS,
  pad4d: Mk,
  pool: HS,
  pow: io,
  prelu: tm,
  print: oS,
  prod: jS,
  raggedGather: Rk,
  raggedRange: Dk,
  raggedTensorToTensor: $k,
  rand: Ok,
  randomGamma: Bk,
  randomNormal: z0,
  randomStandardNormal: zk,
  randomUniform: Va,
  randomUniformInt: Vk,
  range: Oo,
  real: _u,
  reciprocal: n_,
  relu: kr,
  relu6: V0,
  reshape: Y,
  reverse: Fi,
  reverse1d: Uk,
  reverse2d: Gk,
  reverse3d: Wk,
  reverse4d: Hk,
  rfft: am,
  round: nm,
  rsqrt: U0,
  scalar: ot,
  scatterND: eA,
  searchSorted: F0,
  selu: G0,
  separableConv2d: W0,
  setdiff1dAsync: jk,
  sigmoid: mi,
  sign: s_,
  signal: fA,
  sin: H0,
  sinh: j0,
  slice: Pt,
  slice1d: sm,
  slice2d: q0,
  slice3d: im,
  slice4d: Tu,
  softmax: rm,
  softplus: sl,
  spaceToBatchND: em,
  sparse: mA,
  sparseToDense: tA,
  spectral: dA,
  split: ti,
  sqrt: us,
  square: tn,
  squaredDifference: K0,
  squeeze: ys,
  stack: ri,
  step: rl,
  stridedSlice: i_,
  string: gA,
  sub: je,
  sum: Qe,
  tan: r_,
  tanh: ka,
  tensor: Mi,
  tensor1d: Ns,
  tensor2d: _c,
  tensor3d: o_,
  tensor4d: qk,
  tensor5d: Xk,
  tensor6d: Kk,
  tensorScatterUpdate: Yk,
  tile: pi,
  topk: c_,
  transpose: zt,
  truncatedNormal: Z0,
  unique: l_,
  unsortedSegmentSum: J0,
  unstack: Pi,
  upperBound: Zk,
  variable: u_,
  where: bs,
  whereAsync: h_,
  zeros: qn,
  zerosLike: Ut
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const JK = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "BiasAdd":
    case "AddV2":
    case "Add":
      return [s.add(C("a", t, e, n), C("b", t, e, n))];
    case "AddN":
      return [s.addN(C("tensors", t, e, n))];
    case "FloorMod":
    case "Mod":
      return [s.mod(C("a", t, e, n), C("b", t, e, n))];
    case "Mul":
      return [s.mul(C("a", t, e, n), C("b", t, e, n))];
    case "RealDiv":
    case "Div":
      return [s.div(C("a", t, e, n), C("b", t, e, n))];
    case "DivNoNan":
      return [s.divNoNan(C("a", t, e, n), C("b", t, e, n))];
    case "FloorDiv":
      return [s.floorDiv(C("a", t, e, n), C("b", t, e, n))];
    case "Sub":
      return [s.sub(C("a", t, e, n), C("b", t, e, n))];
    case "Minimum":
      return [s.minimum(C("a", t, e, n), C("b", t, e, n))];
    case "Maximum":
      return [s.maximum(C("a", t, e, n), C("b", t, e, n))];
    case "Pow":
      return [s.pow(C("a", t, e, n), C("b", t, e, n))];
    case "SquaredDifference":
      return [s.squaredDifference(C("a", t, e, n), C("b", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const QK = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "Abs":
    case "ComplexAbs":
      return [s.abs(C("x", t, e, n))];
    case "Acos":
      return [s.acos(C("x", t, e, n))];
    case "Acosh":
      return [s.acosh(C("x", t, e, n))];
    case "Asin":
      return [s.asin(C("x", t, e, n))];
    case "Asinh":
      return [s.asinh(C("x", t, e, n))];
    case "Atan":
      return [s.atan(C("x", t, e, n))];
    case "Atan2":
      return [s.atan2(C("x", t, e, n), C("y", t, e, n))];
    case "Atanh":
      return [s.atanh(C("x", t, e, n))];
    case "Ceil":
      return [s.ceil(C("x", t, e, n))];
    case "Complex":
      return [s.complex(C("real", t, e, n), C("imag", t, e, n))];
    case "Cos":
      return [s.cos(C("x", t, e, n))];
    case "Cosh":
      return [s.cosh(C("x", t, e, n))];
    case "Elu":
      return [s.elu(C("x", t, e, n))];
    case "Erf":
      return [s.erf(C("x", t, e, n))];
    case "Exp":
      return [s.exp(C("x", t, e, n))];
    case "Expm1":
      return [s.expm1(C("x", t, e, n))];
    case "Floor":
      return [s.floor(C("x", t, e, n))];
    case "Log":
      return [s.log(C("x", t, e, n))];
    case "Log1p":
      return [s.log1p(C("x", t, e, n))];
    case "Imag":
      return [s.imag(C("x", t, e, n))];
    case "Neg":
      return [s.neg(C("x", t, e, n))];
    case "Reciprocal":
      return [s.reciprocal(C("x", t, e, n))];
    case "Real":
      return [s.real(C("x", t, e, n))];
    case "Relu":
      return [s.relu(C("x", t, e, n))];
    case "Round":
      return [s.round(C("x", t, e, n))];
    case "Selu":
      return [s.selu(C("x", t, e, n))];
    case "Sigmoid":
      return [s.sigmoid(C("x", t, e, n))];
    case "Sin":
      return [s.sin(C("x", t, e, n))];
    case "Sign":
      return [s.sign(C("x", t, e, n))];
    case "Sinh":
      return [s.sinh(C("x", t, e, n))];
    case "Softplus":
      return [s.softplus(C("x", t, e, n))];
    case "Sqrt":
      return [s.sqrt(C("x", t, e, n))];
    case "Square":
      return [s.square(C("x", t, e, n))];
    case "Tanh":
      return [s.tanh(C("x", t, e, n))];
    case "Tan":
      return [s.tan(C("x", t, e, n))];
    case "ClipByValue":
      return [s.clipByValue(C("x", t, e, n), C("clipValueMin", t, e, n), C("clipValueMax", t, e, n))];
    case "Relu6":
      return [s.relu6(C("x", t, e, n))];
    case "Rsqrt":
      return [s.rsqrt(ms(t.inputNames[0], e, n))];
    case "LeakyRelu":
      return [s.leakyRelu(C("x", t, e, n), C("alpha", t, e, n))];
    case "Prelu":
      return [s.prelu(C("x", t, e, n), C("alpha", t, e, n))];
    case "IsNan":
      return [s.isNaN(ms(t.inputNames[0], e, n))];
    case "IsInf":
      return [s.isInf(ms(t.inputNames[0], e, n))];
    case "IsFinite":
      return [s.isFinite(ms(t.inputNames[0], e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Wi(t, e, n = "") {
  if (!(typeof t == "number" || typeof e == "number")) {
    A(t.length === e.length, () => n + ` Shapes ${t} and ${e} must match`);
    for (let s = 0; s < t.length; s++) {
      const i = t[s], r = e[s];
      A(i < 0 || r < 0 || i === r, () => n + ` Shapes ${t} and ${e} must match`);
    }
  }
}
function SI(t) {
  return !(typeof t == "number" || t.some((e) => e < 0));
}
function cd(t, e, n) {
  let s = w1(t, n);
  const i = !SI(s);
  if (i && e.length === 0)
    throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);
  if (i && e.forEach((r) => {
    s = w1(r.shape, s);
  }), !SI(s))
    throw new Error(`Non-fully-defined elementShape: ${s}`);
  return s;
}
function w1(t, e) {
  if (typeof t == "number")
    return e;
  if (typeof e == "number")
    return t;
  if (t.length !== e.length)
    throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);
  const n = [];
  for (let s = 0; s < t.length; ++s) {
    const i = t[s], r = e[s];
    if (i >= 0 && r >= 0 && i !== r)
      throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);
    n[s] = i >= 0 ? i : r;
  }
  return n;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class e9 {
  constructor(e, n, s, i, r, o, a) {
    this.name = e, this.dtype = n, this.maxSize = s, this.elementShape = i, this.identicalElementShapes = r, this.dynamicSize = o, this.clearAfterRead = a, this.tensors = [], this.closed_ = !1, this.idTensor = ot(0), Zn(this.idTensor);
  }
  get id() {
    return this.idTensor.id;
  }
  get closed() {
    return this.closed_;
  }
  /**
   * Dispose the tensors and idTensor and mark the TensoryArray as closed.
   */
  clearAndClose(e) {
    this.tensors.forEach((n) => {
      (e == null || !e.has(n.tensor.id)) && n.tensor.dispose();
    }), this.tensors = [], this.closed_ = !0, this.idTensor.dispose();
  }
  size() {
    return this.tensors.length;
  }
  /**
   * Read the value at location index in the TensorArray.
   * @param index Number the index to read from.
   */
  read(e) {
    if (this.closed_)
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    if (e < 0 || e >= this.size())
      throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);
    const n = this.tensors[e];
    if (n.cleared)
      throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
    return this.clearAfterRead && (n.cleared = !0), n.read = !0, n.tensor;
  }
  /**
   * Helper method to read multiple tensors from the specified indices.
   */
  readMany(e) {
    return e.map((n) => this.read(n));
  }
  /**
   * Write value into the index of the TensorArray.
   * @param index number the index to write to.
   * @param tensor
   */
  write(e, n) {
    if (this.closed_)
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    if (e < 0 || !this.dynamicSize && e >= this.maxSize)
      throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);
    const s = this.tensors[e] || {};
    if (n.dtype !== this.dtype)
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);
    if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0) && (this.elementShape = n.shape), Wi(this.elementShape, n.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${e}.`), s.read)
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);
    if (s.written)
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);
    s.tensor = n, Zn(n), s.written = !0, this.tensors[e] = s;
  }
  /**
   * Helper method to write multiple tensors to the specified indices.
   */
  writeMany(e, n) {
    if (e.length !== n.length)
      throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);
    e.forEach((s, i) => this.write(s, n[i]));
  }
  /**
   * Return selected values in the TensorArray as a packed Tensor. All of
   * selected values must have been written and their shapes must all match.
   * @param [indices] number[] Optional. Taking values in [0, max_value). If the
   *    TensorArray is not dynamic, max_value=size(). If not specified returns
   *    all tensors in the original order.
   * @param [dtype]
   */
  gather(e, n) {
    if (n && n !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);
    if (e)
      e = e.slice(0, this.size());
    else {
      e = [];
      for (let i = 0; i < this.size(); i++)
        e.push(i);
    }
    if (e.length === 0)
      return Mi([], [0].concat(this.elementShape));
    const s = this.readMany(e);
    return Wi(this.elementShape, s[0].shape, "TensorArray shape mismatch: "), ri(s, 0);
  }
  /**
   * Return the values in the TensorArray as a concatenated Tensor.
   */
  concat(e) {
    if (e && e !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);
    if (this.size() === 0)
      return Mi([], [0].concat(this.elementShape));
    const n = [];
    for (let i = 0; i < this.size(); i++)
      n.push(i);
    const s = this.readMany(n);
    return Wi(this.elementShape, s[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`), Pn(s, 0);
  }
  /**
   * Scatter the values of a Tensor in specific indices of a TensorArray.
   * @param indices number[] values in [0, max_value). If the
   *    TensorArray is not dynamic, max_value=size().
   * @param tensor Tensor input tensor.
   */
  scatter(e, n) {
    if (n.dtype !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);
    if (e.length !== n.shape[0])
      throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);
    const s = Math.max(...e);
    if (!this.dynamicSize && s >= this.maxSize)
      throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);
    this.writeMany(e, Pi(n, 0));
  }
  /**
   * Split the values of a Tensor into the TensorArray.
   * @param length number[] with the lengths to use when splitting value along
   *    its first dimension.
   * @param tensor Tensor, the tensor to split.
   */
  split(e, n) {
    if (n.dtype !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);
    let s = 0;
    const i = e.map((c) => (s += c, s));
    if (s !== n.shape[0])
      throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);
    if (!this.dynamicSize && e.length !== this.maxSize)
      throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);
    const r = s === 0 ? 0 : n.size / s, o = [];
    Q(() => {
      n = Y(n, [1, s, r]);
      for (let c = 0; c < e.length; ++c) {
        const u = [0, c === 0 ? 0 : i[c - 1], 0], h = [1, e[c], r];
        o[c] = Y(Pt(n, u, h), this.elementShape);
      }
      return o;
    });
    const a = [];
    for (let c = 0; c < e.length; c++)
      a[c] = c;
    this.writeMany(a, o);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class jc {
  get id() {
    return this.idTensor.id;
  }
  /**
   *
   * @param tensors list of tensors
   * @param elementShape shape of each tensor, this can be a single number (any
   * shape is allowed) or partial shape (dim = -1).
   * @param elementDtype data type of each tensor
   * @param maxNumElements The maximum allowed size of `tensors`. Defaults to -1
   *   meaning that the size of `tensors` is unbounded.
   */
  constructor(e, n, s, i = -1) {
    this.tensors = e, this.elementShape = n, this.elementDtype = s, e != null && e.forEach((r) => {
      if (s !== r.dtype)
        throw new Error(`Invalid data types; op elements ${s}, but list elements ${r.dtype}`);
      Wi(n, r.shape, "TensorList shape mismatch: "), Zn(r);
    }), this.idTensor = ot(0), this.maxNumElements = i, Zn(this.idTensor);
  }
  /**
   * Get a new TensorList containing a copy of the underlying tensor container.
   */
  copy() {
    return new jc([...this.tensors], this.elementShape, this.elementDtype);
  }
  /**
   * Dispose the tensors and idTensor and clear the tensor list.
   */
  clearAndClose(e) {
    this.tensors.forEach((n) => {
      (e == null || !e.has(n.id)) && n.dispose();
    }), this.tensors.length = 0, this.idTensor.dispose();
  }
  /**
   * The size of the tensors in the tensor list.
   */
  size() {
    return this.tensors.length;
  }
  /**
   * Return a tensor that stacks a list of rank-R tf.Tensors into one rank-(R+1)
   * tf.Tensor.
   * @param elementShape shape of each tensor
   * @param elementDtype data type of each tensor
   * @param numElements the number of elements to stack
   */
  stack(e, n, s = -1) {
    if (n !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
    if (s !== -1 && this.tensors.length !== s)
      throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);
    Wi(e, this.elementShape, "TensorList shape mismatch: ");
    const i = cd(this.elementShape, this.tensors, e);
    return Q(() => {
      const r = this.tensors.map((o) => Y(o, i));
      return ri(r, 0);
    });
  }
  /**
   * Pop a tensor from the end of the list.
   * @param elementShape shape of the tensor
   * @param elementDtype data type of the tensor
   */
  popBack(e, n) {
    if (n !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
    if (this.size() === 0)
      throw new Error("Trying to pop from an empty list.");
    const s = cd(this.elementShape, this.tensors, e), i = this.tensors.pop();
    return i.kept = !1, Wi(i.shape, e, "TensorList shape mismatch: "), Y(i, s);
  }
  /**
   * Push a tensor to the end of the list.
   * @param tensor Tensor to be pushed.
   */
  pushBack(e) {
    if (e.dtype !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);
    if (Wi(e.shape, this.elementShape, "TensorList shape mismatch: "), this.maxNumElements === this.size())
      throw new Error("Trying to push element into a full list.");
    Zn(e), this.tensors.push(e);
  }
  /**
   * Update the size of the list.
   * @param size the new size of the list.
   */
  resize(e) {
    if (e < 0)
      throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);
    if (this.maxNumElements !== -1 && e > this.maxNumElements)
      throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);
    const n = new jc([], this.elementShape, this.elementDtype, this.maxNumElements);
    n.tensors.length = e;
    for (let s = 0; s < Math.min(this.tensors.length, e); ++s)
      n.tensors[s] = this.tensors[s];
    return n;
  }
  /**
   * Retrieve the element at the provided index
   * @param elementShape shape of the tensor
   * @param elementDtype dtype of the tensor
   * @param elementIndex index of the tensor
   */
  getItem(e, n, s) {
    if (s !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);
    if (e < 0 || e > this.tensors.length)
      throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);
    if (this.tensors[e] == null)
      throw new Error(`element at index ${e} is null.`);
    Wi(this.tensors[e].shape, n, "TensorList shape mismatch: ");
    const i = cd(this.elementShape, this.tensors, n);
    return Y(this.tensors[e], i);
  }
  /**
   * Set the tensor at the index
   * @param elementIndex index of the tensor
   * @param tensor the tensor to be inserted into the list
   */
  setItem(e, n) {
    if (n.dtype !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);
    if (e < 0 || this.maxNumElements !== -1 && e >= this.maxNumElements)
      throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);
    Wi(this.elementShape, n.shape, "TensorList shape mismatch: "), Zn(n), this.tensors[e] != null && (this.tensors[e].kept = !1), this.tensors[e] = n;
  }
  /**
   * Return selected values in the TensorList as a stacked Tensor. All of
   * selected values must have been written and their shapes must all match.
   * @param indices indices of tensors to gather
   * @param elementDtype output tensor dtype
   * @param elementShape output tensor element shape
   */
  gather(e, n, s) {
    if (n !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
    Wi(this.elementShape, s, "TensorList shape mismatch: "), e = e.slice(0, this.size());
    const i = cd(this.elementShape, this.tensors, s);
    return e.length === 0 ? Mi([], [0].concat(i)) : Q(() => {
      const r = e.map((o) => Y(this.tensors[o], i));
      return ri(r, 0);
    });
  }
  /**
   * Return the values in the TensorList as a concatenated Tensor.
   * @param elementDtype output tensor dtype
   * @param elementShape output tensor element shape
   */
  concat(e, n) {
    if (e && e !== this.elementDtype)
      throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);
    Wi(this.elementShape, n, "TensorList shape mismatch: ");
    const s = cd(this.elementShape, this.tensors, n);
    return this.size() === 0 ? Mi([], [0].concat(s)) : Q(() => {
      const i = this.tensors.map((r) => Y(r, s));
      return Pn(i, 0);
    });
  }
}
function t9(t, e, n) {
  const s = t.dtype;
  if (t.shape.length < 1)
    throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);
  if (t.dtype !== n)
    throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);
  const i = t.shape.slice(1);
  Wi(i, e, "TensorList shape mismatch: ");
  const r = Pi(t);
  return new jc(r, e, s);
}
function n9(t, e, n, s) {
  return new jc([], t, e, s);
}
function s9(t, e, n, s) {
  if (e.length !== t.shape[0])
    throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);
  const i = Math.max(...e);
  if (s != null && s !== -1 && i >= s)
    throw new Error(`Max index must be < array size (${i}  vs. ${s})`);
  const r = new jc([], n, t.dtype, s), o = Pi(t, 0);
  return e.forEach((a, c) => {
    r.setItem(a, o[c]);
  }), r;
}
function i9(t, e, n) {
  let s = 0;
  const i = e.map((u) => (s += u, s));
  if (s !== t.shape[0])
    throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);
  const r = t.shape.slice(1), o = w1(r, n), a = s === 0 ? 0 : t.size / s, c = Q(() => {
    const u = [];
    t = Y(t, [1, s, a]);
    for (let h = 0; h < e.length; ++h) {
      const f = [0, h === 0 ? 0 : i[h - 1], 0], p = [1, e[h], a];
      u[h] = Y(Pt(t, f, p), o);
    }
    return t.dispose(), u;
  }), l = new jc([], n, t.dtype, e.length);
  for (let u = 0; u < c.length; u++)
    l.setItem(u, c[u]);
  return l;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r9 = async (t, e, n) => {
  switch (t.op) {
    case "If":
    case "StatelessIf": {
      const s = C("thenBranch", t, e, n), i = C("elseBranch", t, e, n), r = C("cond", t, e, n), o = C("args", t, e, n);
      return (await r.data())[0] ? n.functionMap[s].executeFunctionAsync(o, n.tensorArrayMap, n.tensorListMap) : n.functionMap[i].executeFunctionAsync(o, n.tensorArrayMap, n.tensorListMap);
    }
    case "While":
    case "StatelessWhile": {
      const s = C("body", t, e, n), i = C("cond", t, e, n), r = C("args", t, e, n), o = await n.functionMap[i].executeFunctionAsync(r, n.tensorArrayMap, n.tensorListMap), a = r.map((u) => u.id);
      let c = await o[0].data();
      o.forEach((u) => {
        !u.kept && a.indexOf(u.id) === -1 && u.dispose();
      });
      let l = r;
      for (; c[0]; ) {
        const u = l;
        l = await n.functionMap[s].executeFunctionAsync(l, n.tensorArrayMap, n.tensorListMap);
        const h = l.map((f) => f.id);
        u.forEach((f) => {
          !f.kept && a.indexOf(f.id) === -1 && h.indexOf(f.id) === -1 && f.dispose();
        });
        const d = await n.functionMap[i].executeFunctionAsync(l, n.tensorArrayMap, n.tensorListMap);
        c = await d[0].data(), d.forEach((f) => {
          !f.kept && a.indexOf(f.id) === -1 && h.indexOf(f.id) === -1 && f.dispose();
        });
      }
      return l;
    }
    case "LoopCond": {
      const s = C("pred", t, e, n);
      return [_o(s)];
    }
    case "Switch": {
      const s = C("pred", t, e, n);
      let i = C("data", t, e, n);
      return i.kept || (i = _o(i)), (await s.data())[0] ? [void 0, i] : [i, void 0];
    }
    case "Merge": {
      const s = t.inputNames.find((i) => ms(i, e, n) !== void 0);
      if (s) {
        const i = ms(s, e, n);
        return [_o(i)];
      }
      return;
    }
    case "Enter": {
      const s = C("frameName", t, e, n), i = C("tensor", t, e, n);
      return n.enterFrame(s), [_o(i)];
    }
    case "Exit": {
      const s = C("tensor", t, e, n);
      return n.exitFrame(), [_o(s)];
    }
    case "NextIteration": {
      const s = C("tensor", t, e, n);
      return n.nextIteration(), [_o(s)];
    }
    case "TensorArrayV3": {
      const s = C("size", t, e, n), i = C("dtype", t, e, n), r = C("elementShape", t, e, n), o = C("dynamicSize", t, e, n), a = C("clearAfterRead", t, e, n), c = C("identicalElementShapes", t, e, n), l = C("name", t, e, n), u = new e9(l, i, s, r, c, o, a);
      return n.addTensorArray(u), [u.idTensor, ot(1)];
    }
    case "TensorArrayWriteV3": {
      const s = C("tensorArrayId", t, e, n), i = C("index", t, e, n), r = C("tensor", t, e, n), o = n.getTensorArray(s.id);
      return o.write(i, r), [o.idTensor];
    }
    case "TensorArrayReadV3": {
      const s = C("tensorArrayId", t, e, n), i = C("index", t, e, n);
      return [n.getTensorArray(s.id).read(i)];
    }
    case "TensorArrayGatherV3": {
      const s = C("tensorArrayId", t, e, n), i = C("indices", t, e, n), r = C("dtype", t, e, n);
      return [n.getTensorArray(s.id).gather(i, r)];
    }
    case "TensorArrayScatterV3": {
      const s = C("tensorArrayId", t, e, n), i = C("indices", t, e, n), r = C("tensor", t, e, n), o = n.getTensorArray(s.id);
      return o.scatter(i, r), [o.idTensor];
    }
    case "TensorArrayConcatV3": {
      const s = C("tensorArrayId", t, e, n), i = n.getTensorArray(s.id), r = C("dtype", t, e, n);
      return [i.concat(r)];
    }
    case "TensorArraySplitV3": {
      const s = C("tensorArrayId", t, e, n), i = C("tensor", t, e, n), r = C("lengths", t, e, n), o = n.getTensorArray(s.id);
      return o.split(r, i), [o.idTensor];
    }
    case "TensorArraySizeV3": {
      const s = C("tensorArrayId", t, e, n), i = n.getTensorArray(s.id);
      return [ot(i.size(), "int32")];
    }
    case "TensorArrayCloseV3": {
      const s = C("tensorArrayId", t, e, n), i = n.getTensorArray(s.id);
      return i.clearAndClose(), [i.idTensor];
    }
    case "TensorListSetItem": {
      const s = C("tensorListId", t, e, n), i = C("index", t, e, n), r = C("tensor", t, e, n), o = n.getTensorList(s.id);
      return o.setItem(i, r), [o.idTensor];
    }
    case "TensorListGetItem": {
      const s = C("tensorListId", t, e, n), i = C("index", t, e, n), r = C("elementShape", t, e, n), o = C("elementDType", t, e, n);
      return [n.getTensorList(s.id).getItem(i, r, o)];
    }
    case "TensorListScatterV2":
    case "TensorListScatter": {
      const s = C("indices", t, e, n), i = C("tensor", t, e, n), r = C("elementShape", t, e, n), o = C("numElements", t, e, n), a = s9(i, s, r, o);
      return n.addTensorList(a), [a.idTensor];
    }
    case "TensorListReserve":
    case "EmptyTensorList": {
      const s = C("elementShape", t, e, n), i = C("elementDType", t, e, n);
      let r;
      t.op === "TensorListReserve" ? r = "numElements" : r = "maxNumElements";
      const o = C(r, t, e, n), a = t.op === "TensorListReserve" ? -1 : o, c = n9(s, i, o, a);
      return n.addTensorList(c), [c.idTensor];
    }
    case "TensorListGather": {
      const s = C("tensorListId", t, e, n), i = C("indices", t, e, n), r = C("elementShape", t, e, n), o = C("elementDType", t, e, n);
      return [n.getTensorList(s.id).gather(i, o, r)];
    }
    case "TensorListStack": {
      const s = C("tensorListId", t, e, n), i = C("elementShape", t, e, n), r = C("elementDType", t, e, n), o = C("numElements", t, e, n);
      return [n.getTensorList(s.id).stack(i, r, o)];
    }
    case "TensorListFromTensor": {
      const s = C("tensor", t, e, n), i = C("elementShape", t, e, n), r = C("elementDType", t, e, n), o = t9(s, i, r);
      return n.addTensorList(o), [o.idTensor];
    }
    case "TensorListConcat":
    case "TensorListConcatV2": {
      const s = C("tensorListId", t, e, n), i = n.getTensorList(s.id), r = C("dtype", t, e, n), o = C("elementShape", t, e, n);
      return [i.concat(r, o)];
    }
    case "TensorListPushBack": {
      const s = C("tensorListId", t, e, n), i = C("tensor", t, e, n), r = n.getTensorList(s.id);
      return r.pushBack(i), [r.idTensor];
    }
    case "TensorListPopBack": {
      const s = C("tensorListId", t, e, n), i = C("elementShape", t, e, n), r = C("elementDType", t, e, n);
      return [n.getTensorList(s.id).popBack(i, r)];
    }
    case "TensorListSplit": {
      const s = C("tensor", t, e, n), i = C("elementShape", t, e, n), r = C("lengths", t, e, n), o = i9(s, r, i);
      return n.addTensorList(o), [o.idTensor];
    }
    case "TensorListLength": {
      const s = C("tensorListId", t, e, n), i = n.getTensorList(s.id);
      return [ot(i.size(), "int32")];
    }
    case "TensorListResize": {
      const s = C("tensorListId", t, e, n), i = C("size", t, e, n), o = n.getTensorList(s.id).resize(i);
      return n.addTensorList(o), [o.idTensor];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _I(t, e, n) {
  const [s, i] = C("fusedOps", t, e, n), r = s === "biasadd", o = !r, a = i === "prelu", c = s === "fusedbatchnorm", l = C("numArgs", t, e, n);
  if (r) {
    if (a && l !== 2)
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
    if (!a && r && l !== 1)
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
  }
  if (c)
    throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
  const u = C("strides", t, e, n), h = Vg(t, e, n), d = C("dataFormat", t, e, n).toUpperCase(), f = C("dilations", t, e, n);
  let [p, y] = C("args", t, e, n);
  o && (y = p, p = void 0);
  const g = C("leakyreluAlpha", t, e, n);
  return {
    stride: u,
    pad: h,
    dataFormat: d,
    dilations: f,
    biasArg: p,
    preluArg: y,
    activationFunc: i,
    leakyreluAlpha: g
  };
}
const o9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "Conv1D": {
      const i = C("stride", t, e, n), r = C("pad", t, e, n), o = C("dataFormat", t, e, n).toUpperCase(), a = C("dilation", t, e, n);
      return [s.conv1d(C("x", t, e, n), C("filter", t, e, n), i, r, o, a)];
    }
    case "Conv2D": {
      const i = C("strides", t, e, n), r = Vg(t, e, n), o = C("dataFormat", t, e, n).toUpperCase(), a = C("dilations", t, e, n);
      return [s.conv2d(C("x", t, e, n), C("filter", t, e, n), [i[1], i[2]], r, o, [a[1], a[2]])];
    }
    case "_FusedConv2D": {
      const { stride: i, pad: r, dataFormat: o, dilations: a, biasArg: c, preluArg: l, activationFunc: u, leakyreluAlpha: h } = _I(t, e, n);
      return [s.fused.conv2d({
        x: C("x", t, e, n),
        filter: C("filter", t, e, n),
        strides: [i[1], i[2]],
        pad: r,
        dataFormat: o,
        dilations: [a[1], a[2]],
        bias: c,
        activation: u,
        preluActivationWeights: l,
        leakyreluAlpha: h
      })];
    }
    case "FusedDepthwiseConv2dNative": {
      const { stride: i, pad: r, dataFormat: o, dilations: a, biasArg: c, preluArg: l, activationFunc: u, leakyreluAlpha: h } = _I(t, e, n);
      return [s.fused.depthwiseConv2d({
        x: C("x", t, e, n),
        filter: C("filter", t, e, n),
        strides: [i[1], i[2]],
        pad: r,
        dataFormat: o,
        dilations: [a[1], a[2]],
        bias: c,
        activation: u,
        preluActivationWeights: l,
        leakyreluAlpha: h
      })];
    }
    case "Conv2DBackpropInput":
    case "Conv2dTranspose": {
      const i = C("outputShape", t, e, n), r = C("strides", t, e, n), o = Vg(t, e, n);
      return [s.conv2dTranspose(C("x", t, e, n), C("filter", t, e, n), i, [r[1], r[2]], o)];
    }
    case "DepthwiseConv2dNative":
    case "DepthwiseConv2d": {
      const i = C("strides", t, e, n), r = Vg(t, e, n), o = C("dilations", t, e, n), a = C("dataFormat", t, e, n).toUpperCase();
      return [s.depthwiseConv2d(C("input", t, e, n), C("filter", t, e, n), [i[1], i[2]], r, a, [o[1], o[2]])];
    }
    case "Conv3D": {
      const i = C("strides", t, e, n), r = C("pad", t, e, n), o = C("dataFormat", t, e, n).toUpperCase(), a = C("dilations", t, e, n);
      return [s.conv3d(C("x", t, e, n), C("filter", t, e, n), [i[1], i[2], i[3]], r, o, [a[1], a[2], a[3]])];
    }
    case "AvgPool": {
      const i = C("strides", t, e, n), r = C("pad", t, e, n), o = C("kernelSize", t, e, n);
      return [s.avgPool(C("x", t, e, n), [o[1], o[2]], [i[1], i[2]], r)];
    }
    case "MaxPool": {
      const i = C("strides", t, e, n), r = C("pad", t, e, n), o = C("kernelSize", t, e, n);
      return [s.maxPool(C("x", t, e, n), [o[1], o[2]], [i[1], i[2]], r)];
    }
    case "MaxPoolWithArgmax": {
      const i = C("strides", t, e, n), r = C("pad", t, e, n), o = C("kernelSize", t, e, n), a = C("includeBatchInIndex", t, e, n), { result: c, indexes: l } = s.maxPoolWithArgmax(C("x", t, e, n), [o[1], o[2]], [i[1], i[2]], r, a);
      return [c, l];
    }
    case "AvgPool3D": {
      const i = C("strides", t, e, n), r = C("pad", t, e, n), o = C("kernelSize", t, e, n);
      return [s.avgPool3d(C("x", t, e, n), [o[1], o[2], o[3]], [i[1], i[2], i[3]], r)];
    }
    case "MaxPool3D": {
      const i = C("strides", t, e, n), r = C("pad", t, e, n), o = C("kernelSize", t, e, n);
      return [s.maxPool3d(C("x", t, e, n), [o[1], o[2], o[3]], [i[1], i[2], i[3]], r)];
    }
    case "Dilation2D": {
      const i = C("strides", t, e, n), r = C("pad", t, e, n), o = C("dilations", t, e, n), a = i[1], c = i[2], l = o[1], u = o[2];
      return [s.dilation2d(
        C("x", t, e, n),
        C("filter", t, e, n),
        [a, c],
        r,
        [l, u],
        "NHWC"
        /* dataFormat */
      )];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const a9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "Fill": {
      const i = C("shape", t, e, n), r = C("dtype", t, e, n), o = C("value", t, e, n);
      return [s.fill(i, o, r)];
    }
    case "LinSpace": {
      const i = C("start", t, e, n), r = C("stop", t, e, n), o = C("num", t, e, n);
      return [s.linspace(i, r, o)];
    }
    case "Multinomial": {
      const i = C("logits", t, e, n), r = C("numSamples", t, e, n), o = C("seed", t, e, n);
      return [s.multinomial(i, r, o)];
    }
    case "OneHot": {
      const i = C("indices", t, e, n), r = C("depth", t, e, n), o = C("onValue", t, e, n), a = C("offValue", t, e, n), c = C("dtype", t, e, n);
      return [s.oneHot(i, r, o, a, c)];
    }
    case "Ones":
      return [s.ones(C("shape", t, e, n), C("dtype", t, e, n))];
    case "OnesLike":
      return [s.onesLike(C("x", t, e, n))];
    case "RandomStandardNormal":
      return [s.randomStandardNormal(C("shape", t, e, n), C("dtype", t, e, n), C("seed", t, e, n))];
    case "RandomUniform":
      return [s.randomUniform(
        // tslint:disable-next-line:no-any
        C("shape", t, e, n),
        C("minval", t, e, n),
        C("maxval", t, e, n),
        C("dtype", t, e, n)
      )];
    case "RandomUniformInt":
      return [s.randomUniformInt(C("shape", t, e, n), C("minval", t, e, n), C("maxval", t, e, n), C("seed", t, e, n))];
    case "Range": {
      const i = C("start", t, e, n), r = C("stop", t, e, n), o = C("step", t, e, n);
      return [s.range(i, r, o, C("dtype", t, e, n))];
    }
    case "TruncatedNormal": {
      const i = C("shape", t, e, n), r = C("mean", t, e, n), o = C("stdDev", t, e, n), a = C("seed", t, e, n);
      return [s.truncatedNormal(i, r, o, C("dtype", t, e, n), a)];
    }
    case "Zeros":
      return [s.zeros(C("shape", t, e, n), C("dtype", t, e, n))];
    case "ZerosLike":
      return [s.zerosLike(C("x", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ev(t, e, n) {
  const s = C("boxes", t, e, n), i = C("scores", t, e, n), r = C("maxOutputSize", t, e, n), o = C("iouThreshold", t, e, n), a = C("scoreThreshold", t, e, n), c = C("softNmsSigma", t, e, n);
  return {
    boxes: s,
    scores: i,
    maxOutputSize: r,
    iouThreshold: o,
    scoreThreshold: a,
    softNmsSigma: c
  };
}
const c9 = async (t, e, n, s, i = Ts) => {
  switch (t.op) {
    case "NonMaxSuppressionV5": {
      const { boxes: r, scores: o, maxOutputSize: a, iouThreshold: c, scoreThreshold: l, softNmsSigma: u } = Ev(t, e, n), h = await i.image.nonMaxSuppressionWithScoreAsync(r, o, a, c, l, u);
      return [h.selectedIndices, h.selectedScores];
    }
    case "NonMaxSuppressionV4": {
      const { boxes: r, scores: o, maxOutputSize: a, iouThreshold: c, scoreThreshold: l } = Ev(t, e, n), u = C("padToMaxOutputSize", t, e, n), h = await i.image.nonMaxSuppressionPaddedAsync(r, o, a, c, l, u);
      return [h.selectedIndices, h.validOutputs];
    }
    case "NonMaxSuppressionV3":
    case "NonMaxSuppressionV2": {
      const { boxes: r, scores: o, maxOutputSize: a, iouThreshold: c, scoreThreshold: l } = Ev(t, e, n);
      return [await i.image.nonMaxSuppressionAsync(r, o, a, c, l)];
    }
    case "Where": {
      const r = i.cast(C("condition", t, e, n), "bool"), o = [await i.whereAsync(r)];
      return r.dispose(), o;
    }
    case "ListDiff":
      return i.setdiff1dAsync(C("x", t, e, n), C("y", t, e, n));
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const l9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "LowerBound": {
      const i = C("sortedSequence", t, e, n), r = C("values", t, e, n);
      return [s.lowerBound(i, r)];
    }
    case "TopKV2": {
      const i = C("x", t, e, n), r = C("k", t, e, n), o = C("sorted", t, e, n), a = s.topk(i, r, o);
      return [a.values, a.indices];
    }
    case "UpperBound": {
      const i = C("sortedSequence", t, e, n), r = C("values", t, e, n);
      return [s.upperBound(i, r)];
    }
    case "Unique": {
      const i = C("x", t, e, n), r = s.unique(i);
      return [r.values, r.indices];
    }
    case "UniqueV2": {
      const i = C("x", t, e, n), r = C("axis", t, e, n), o = s.unique(i, r);
      return [o.values, o.indices];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const u9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "Const":
      return e[t.name];
    case "PlaceholderWithDefault":
      const i = C("default", t, e, n);
      return [ms(t.name, e, n) || i];
    case "Placeholder":
      return [ms(t.name, e, n)];
    case "Identity":
    case "StopGradient":
    case "FakeQuantWithMinMaxVars": {
      const u = C("x", t, e, n);
      return [_o(u)];
    }
    case "IdentityN":
      return C("x", t, e, n).map((u) => _o(u));
    case "Snapshot":
      const r = C("x", t, e, n);
      return [_o(r)];
    case "Shape":
      return [s.tensor1d(C("x", t, e, n).shape, "int32")];
    case "ShapeN":
      return C("x", t, e, n).map((u) => s.tensor1d(u.shape));
    case "Size":
      return [s.scalar(C("x", t, e, n).size, "int32")];
    case "Rank":
      return [s.scalar(C("x", t, e, n).rank, "int32")];
    case "NoOp":
      return [s.scalar(1)];
    case "Print":
      const o = C("x", t, e, n), a = C("data", t, e, n), c = C("message", t, e, n), l = C("summarize", t, e, n);
      console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(c);
      for (let u = 0; u < a.length; u++)
        console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0, l));
      return [o];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class h9 {
  get id() {
    return this.handle.id;
  }
  /**
   * Constructor of HashTable. Creates a hash table.
   *
   * @param keyDType `dtype` of the table keys.
   * @param valueDType `dtype` of the table values.
   */
  constructor(e, n) {
    this.keyDType = e, this.valueDType = n, this.handle = ot(0), this.tensorMap = /* @__PURE__ */ new Map(), Zn(this.handle);
  }
  /**
   * Dispose the tensors and handle and clear the hashtable.
   */
  clearAndClose() {
    this.tensorMap.forEach((e) => e.dispose()), this.tensorMap.clear(), this.handle.dispose();
  }
  /**
   * The number of items in the hash table.
   */
  size() {
    return this.tensorMap.size;
  }
  /**
   * The number of items in the hash table as a rank-0 tensor.
   */
  tensorSize() {
    return ot(this.size(), "int32");
  }
  /**
   * Replaces the contents of the table with the specified keys and values.
   * @param keys Keys to store in the hashtable.
   * @param values Values to store in the hashtable.
   */
  async import(e, n) {
    this.checkKeyAndValueTensor(e, n);
    const s = await e.data();
    return this.tensorMap.forEach((i) => i.dispose()), this.tensorMap.clear(), Q(() => {
      const i = Pi(n), r = s.length, o = i.length;
      A(r === o, () => `The number of elements doesn't match, keys has ${r} elements, the values has ${o} elements.`);
      for (let a = 0; a < r; a++) {
        const c = s[a], l = i[a];
        Zn(l), this.tensorMap.set(c, l);
      }
      return this.handle;
    });
  }
  /**
   * Looks up keys in a hash table, outputs the corresponding values.
   *
   * Performs batch lookups, for every element in the key tensor, `find`
   * stacks the corresponding value into the return tensor.
   *
   * If an element is not present in the table, the given `defaultValue` is
   * used.
   *
   * @param keys Keys to look up. Must have the same type as the keys of the
   *     table.
   * @param defaultValue The scalar `defaultValue` is the value output for keys
   *     not present in the table. It must also be of the same type as the
   *     table values.
   */
  async find(e, n) {
    this.checkKeyAndValueTensor(e, n);
    const s = await e.data();
    return Q(() => {
      const i = [];
      for (let r = 0; r < s.length; r++) {
        const o = s[r], a = this.findWithDefault(o, n);
        i.push(a);
      }
      return ri(i);
    });
  }
  // tslint:disable-next-line: no-any
  findWithDefault(e, n) {
    const s = this.tensorMap.get(e);
    return s ?? n;
  }
  checkKeyAndValueTensor(e, n) {
    if (e.dtype !== this.keyDType)
      throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);
    if (n.dtype !== this.valueDType)
      throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const d9 = async (t, e, n, s) => {
  switch (t.op) {
    case "HashTable":
    case "HashTableV2": {
      const i = s.getHashTableHandleByName(t.name);
      if (i != null)
        return [i];
      {
        const r = C("keyDType", t, e, n), o = C("valueDType", t, e, n), a = new h9(r, o);
        return s.addHashTable(t.name, a), [a.handle];
      }
    }
    case "InitializeTable":
    case "InitializeTableV2":
    case "LookupTableImport":
    case "LookupTableImportV2": {
      const i = C("tableHandle", t, e, n, s), r = C("keys", t, e, n), o = C("values", t, e, n);
      return [await s.getHashTableById(i.id).import(r, o)];
    }
    case "LookupTableFind":
    case "LookupTableFindV2": {
      const i = C("tableHandle", t, e, n, s), r = C("keys", t, e, n), o = C("defaultValue", t, e, n);
      return [await s.getHashTableById(i.id).find(r, o)];
    }
    case "LookupTableSize":
    case "LookupTableSizeV2": {
      const i = C("tableHandle", t, e, n, s);
      return [s.getHashTableById(i.id).tensorSize()];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const f9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "ResizeBilinear": {
      const i = C("images", t, e, n), r = C("size", t, e, n), o = C("alignCorners", t, e, n), a = C("halfPixelCenters", t, e, n);
      return [s.image.resizeBilinear(i, [r[0], r[1]], o, a)];
    }
    case "ResizeNearestNeighbor": {
      const i = C("images", t, e, n), r = C("size", t, e, n), o = C("alignCorners", t, e, n), a = C("halfPixelCenters", t, e, n);
      return [s.image.resizeNearestNeighbor(i, [r[0], r[1]], o, a)];
    }
    case "CropAndResize": {
      const i = C("image", t, e, n), r = C("boxes", t, e, n), o = C("boxInd", t, e, n), a = C("cropSize", t, e, n), c = C("method", t, e, n), l = C("extrapolationValue", t, e, n);
      return [s.image.cropAndResize(i, r, o, a, c, l)];
    }
    case "ImageProjectiveTransformV3": {
      const i = C("images", t, e, n), r = C("transforms", t, e, n), o = C("outputShape", t, e, n), a = C("fillValue", t, e, n), c = C("interpolation", t, e, n), l = C("fillMode", t, e, n);
      return [s.image.transform(i, r, c.toLowerCase(), l.toLowerCase(), a, o)];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const p9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "Equal":
      return [s.equal(C("a", t, e, n), C("b", t, e, n))];
    case "NotEqual":
      return [s.notEqual(C("a", t, e, n), C("b", t, e, n))];
    case "Greater":
      return [s.greater(C("a", t, e, n), C("b", t, e, n))];
    case "GreaterEqual":
      return [s.greaterEqual(C("a", t, e, n), C("b", t, e, n))];
    case "Less":
      return [s.less(C("a", t, e, n), C("b", t, e, n))];
    case "LessEqual":
      return [s.lessEqual(C("a", t, e, n), C("b", t, e, n))];
    case "LogicalAnd":
      return [s.logicalAnd(C("a", t, e, n), C("b", t, e, n))];
    case "LogicalNot":
      return [s.logicalNot(C("a", t, e, n))];
    case "LogicalOr":
      return [s.logicalOr(C("a", t, e, n), C("b", t, e, n))];
    case "Select":
    case "SelectV2":
      return [s.where(C("condition", t, e, n), C("a", t, e, n), C("b", t, e, n))];
    case "BitwiseAnd":
      return [s.bitwiseAnd(C("a", t, e, n), C("b", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const m9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "BatchMatMul":
    case "BatchMatMulV2":
    case "MatMul":
      return [s.matMul(C("a", t, e, n), C("b", t, e, n), C("transposeA", t, e, n), C("transposeB", t, e, n))];
    case "Einsum":
      return [s.einsum(C("equation", t, e, n), ...C("tensors", t, e, n))];
    case "Transpose":
      return [s.transpose(C("x", t, e, n), C("perm", t, e, n))];
    case "_FusedMatMul":
      const [i, r] = C("fusedOps", t, e, n), o = i === "biasadd", a = r === "prelu", c = C("numArgs", t, e, n), l = C("leakyreluAlpha", t, e, n);
      if (o) {
        if (a && c !== 2)
          throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        if (!a && c !== 1)
          throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
      }
      const [u, h] = C("args", t, e, n);
      return [s.fused.matMul({
        a: C("a", t, e, n),
        b: C("b", t, e, n),
        transposeA: C("transposeA", t, e, n),
        transposeB: C("transposeB", t, e, n),
        bias: u,
        activation: r,
        preluActivationWeights: h,
        leakyreluAlpha: l
      })];
    case "MatrixBandPart":
      return [s.linalg.bandPart(C("a", t, e, n), C("numLower", t, e, n), C("numUpper", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const g9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "EuclideanNorm":
      return [s.euclideanNorm(C("x", t, e, n), C("axis", t, e, n), C("keepDims", t, e, n))];
    case "FusedBatchNorm":
    case "FusedBatchNormV2":
      return [s.batchNorm(C("x", t, e, n), C("mean", t, e, n), C("variance", t, e, n), C("offset", t, e, n), C("scale", t, e, n), C("epsilon", t, e, n))];
    case "FusedBatchNormV3":
      return [s.batchNorm(C("x", t, e, n), C("mean", t, e, n), C("variance", t, e, n), C("offset", t, e, n), C("scale", t, e, n), C("epsilon", t, e, n))];
    case "LRN":
      return [s.localResponseNormalization(C("x", t, e, n), C("radius", t, e, n), C("bias", t, e, n), C("alpha", t, e, n), C("beta", t, e, n))];
    case "Softmax":
      return [s.softmax(C("x", t, e, n))];
    case "LogSoftmax":
      return [s.logSoftmax(C("x", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const y9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "RaggedGather": {
      const { outputNestedSplits: i, outputDenseValues: r } = s.raggedGather(C("paramsNestedSplits", t, e, n), C("paramsDenseValues", t, e, n), C("indices", t, e, n), C("outputRaggedRank", t, e, n));
      return i.concat(r);
    }
    case "RaggedRange": {
      const { rtNestedSplits: i, rtDenseValues: r } = s.raggedRange(C("starts", t, e, n), C("limits", t, e, n), C("splits", t, e, n));
      return [i, r];
    }
    case "RaggedTensorToTensor":
      return [s.raggedTensorToTensor(C("shape", t, e, n), C("values", t, e, n), C("defaultValue", t, e, n), C("rowPartitionTensors", t, e, n), C("rowPartitionTypes", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const x9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "Max": {
      const a = C("axis", t, e, n), c = C("keepDims", t, e, n);
      return [s.max(C("x", t, e, n), a, c)];
    }
    case "Mean": {
      const a = C("axis", t, e, n), c = C("keepDims", t, e, n);
      return [s.mean(C("x", t, e, n), a, c)];
    }
    case "Min": {
      const a = C("axis", t, e, n), c = C("keepDims", t, e, n);
      return [s.min(C("x", t, e, n), a, c)];
    }
    case "Sum": {
      const a = C("axis", t, e, n), c = C("keepDims", t, e, n);
      return [s.sum(C("x", t, e, n), a, c)];
    }
    case "All": {
      const a = C("axis", t, e, n), c = C("keepDims", t, e, n);
      return [s.all(C("x", t, e, n), a, c)];
    }
    case "Any": {
      const a = C("axis", t, e, n), c = C("keepDims", t, e, n);
      return [s.any(C("x", t, e, n), a, c)];
    }
    case "ArgMax": {
      const a = C("axis", t, e, n);
      return [s.argMax(C("x", t, e, n), a)];
    }
    case "ArgMin": {
      const a = C("axis", t, e, n);
      return [s.argMin(C("x", t, e, n), a)];
    }
    case "Prod": {
      const a = C("axis", t, e, n), c = C("keepDims", t, e, n);
      return [s.prod(C("x", t, e, n), a, c)];
    }
    case "Cumprod": {
      const a = C("axis", t, e, n), c = C("exclusive", t, e, n), l = C("reverse", t, e, n);
      return [s.cumprod(C("x", t, e, n), a, c, l)];
    }
    case "Cumsum": {
      const a = C("axis", t, e, n), c = C("exclusive", t, e, n), l = C("reverse", t, e, n);
      return [s.cumsum(C("x", t, e, n), a, c, l)];
    }
    case "Bincount":
      const i = C("x", t, e, n), r = C("weights", t, e, n), o = C("size", t, e, n);
      return [s.bincount(i, r, o)];
    case "DenseBincount": {
      const a = C("x", t, e, n), c = C("weights", t, e, n), l = C("size", t, e, n), u = C("binaryOutput", t, e, n);
      return [s.denseBincount(a, c, l, u)];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const b9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "ConcatV2":
    case "Concat": {
      const i = C("n", t, e, n), r = C("axis", t, e, n);
      let o = C("tensors", t, e, n);
      return o = o.slice(0, i), [s.concat(o, r)];
    }
    case "Gather": {
      const i = C("x", t, e, n), r = C("indices", t, e, n);
      return [s.gather(i, s.cast(r, "int32"), 0)];
    }
    case "GatherV2": {
      const i = C("axis", t, e, n), r = C("batchDims", t, e, n), o = C("x", t, e, n), a = C("indices", t, e, n);
      return [s.gather(o, s.cast(a, "int32"), i, r)];
    }
    case "Reverse": {
      const i = C("dims", t, e, n), r = [];
      for (let a = 0; a < i.length; a++)
        i[a] && r.push(a);
      const o = C("x", t, e, n);
      return [s.reverse(o, r)];
    }
    case "ReverseV2": {
      const i = C("axis", t, e, n), r = C("x", t, e, n);
      return [s.reverse(r, i)];
    }
    case "Slice": {
      const i = C("begin", t, e, n), r = C("size", t, e, n);
      return [s.slice(C("x", t, e, n), i, r)];
    }
    case "StridedSlice": {
      const i = C("begin", t, e, n), r = C("end", t, e, n), o = C("strides", t, e, n), a = C("beginMask", t, e, n), c = C("endMask", t, e, n), l = C("ellipsisMask", t, e, n), u = C("newAxisMask", t, e, n), h = C("shrinkAxisMask", t, e, n), d = C("x", t, e, n);
      return [s.stridedSlice(d, i, r, o, a, c, l, u, h)];
    }
    case "Pack":
      return Q(() => {
        const i = C("axis", t, e, n), r = C("tensors", t, e, n), o = r[0].shape, a = s.squeeze(r[0]).shape, c = r.map((l) => {
          const u = Bt(l.shape, o);
          if (!u && !Bt(s.squeeze(l).shape, a))
            throw new Error("the input tensors shape does not match");
          return u ? l : s.reshape(l, o);
        });
        return [s.stack(c, i)];
      });
    case "Unpack": {
      const i = C("axis", t, e, n), r = C("tensor", t, e, n);
      return s.unstack(r, i);
    }
    case "Tile": {
      const i = C("reps", t, e, n);
      return [s.tile(C("x", t, e, n), i)];
    }
    case "Split":
    case "SplitV": {
      const i = C("axis", t, e, n), r = C("numOrSizeSplits", t, e, n), o = C("x", t, e, n);
      return s.split(o, r, i);
    }
    case "ScatterNd": {
      const i = C("indices", t, e, n), r = C("values", t, e, n), o = C("shape", t, e, n);
      return [s.scatterND(i, r, o)];
    }
    case "GatherNd": {
      const i = C("x", t, e, n), r = C("indices", t, e, n);
      return [s.gatherND(i, r)];
    }
    case "SparseToDense": {
      const i = C("sparseIndices", t, e, n), r = C("outputShape", t, e, n), o = C("sparseValues", t, e, n), a = C("defaultValue", t, e, n);
      return [s.sparseToDense(i, o, r, o.dtype === a.dtype ? a : s.cast(a, o.dtype))];
    }
    case "TensorScatterUpdate": {
      const i = C("indices", t, e, n), r = C("values", t, e, n), o = C("tensor", t, e, n);
      return [s.tensorScatterUpdate(o, i, r)];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const v9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "SparseFillEmptyRows": {
      const { outputIndices: i, outputValues: r, emptyRowIndicator: o, reverseIndexMap: a } = s.sparse.sparseFillEmptyRows(C("indices", t, e, n), C("values", t, e, n), C("denseShape", t, e, n), C("defaultValue", t, e, n));
      return [
        i,
        r,
        o,
        a
      ];
    }
    case "SparseReshape": {
      const { outputIndices: i, outputShape: r } = s.sparse.sparseReshape(C("inputIndices", t, e, n), C("inputShape", t, e, n), C("newShape", t, e, n));
      return [i, r];
    }
    case "SparseSegmentMean":
      return [s.sparse.sparseSegmentMean(C("data", t, e, n), C("indices", t, e, n), C("segmentIds", t, e, n))];
    case "SparseSegmentSum":
      return [s.sparse.sparseSegmentSum(C("data", t, e, n), C("indices", t, e, n), C("segmentIds", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const w9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "FFT":
      return [s.fft(C("x", t, e, n))];
    case "IFFT":
      return [s.ifft(C("x", t, e, n))];
    case "RFFT":
      return [s.rfft(C("x", t, e, n))];
    case "IRFFT":
      return [s.irfft(C("x", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const S9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "StaticRegexReplace":
      return [s.string.staticRegexReplace(C("input", t, e, n), C("pattern", t, e, n), C("rewrite", t, e, n), C("replaceGlobal", t, e, n))];
    case "StringNGrams": {
      const { nGrams: i, nGramsSplits: r } = s.string.stringNGrams(C("data", t, e, n), C("dataSplits", t, e, n), C("separator", t, e, n), C("nGramWidths", t, e, n), C("leftPad", t, e, n), C("rightPad", t, e, n), C("padWidth", t, e, n), C("preserveShortSequences", t, e, n));
      return [i, r];
    }
    case "StringSplit": {
      const { indices: i, values: r, shape: o } = s.string.stringSplit(C("input", t, e, n), C("delimiter", t, e, n), C("skipEmpty", t, e, n));
      return [i, r, o];
    }
    case "StringToHashBucketFast":
      return [s.string.stringToHashBucketFast(C("input", t, e, n), C("numBuckets", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _9 = (t, e, n, s = Ts) => {
  switch (t.op) {
    case "Cast":
      return [s.cast(C("x", t, e, n), C("dtype", t, e, n))];
    case "ExpandDims": {
      const i = C("axis", t, e, n);
      return [s.expandDims(C("x", t, e, n), i)];
    }
    case "Squeeze": {
      const i = C("axis", t, e, n);
      return [s.squeeze(C("x", t, e, n), i)];
    }
    case "Reshape":
      return [s.reshape(C("x", t, e, n), C("shape", t, e, n))];
    case "EnsureShape":
      return [s.ensureShape(C("x", t, e, n), C("shape", t, e, n))];
    case "MirrorPad":
      return [s.mirrorPad(C("x", t, e, n), C("padding", t, e, n), C("mode", t, e, n))];
    case "PadV2":
    case "Pad":
      return [s.pad(C("x", t, e, n), C("padding", t, e, n), C("constantValue", t, e, n))];
    case "SpaceToBatchND": {
      const i = C("blockShape", t, e, n), r = C("paddings", t, e, n);
      return [s.spaceToBatchND(C("x", t, e, n), i, r)];
    }
    case "BatchToSpaceND": {
      const i = C("blockShape", t, e, n), r = C("crops", t, e, n);
      return [s.batchToSpaceND(C("x", t, e, n), i, r)];
    }
    case "DepthToSpace": {
      const i = C("blockSize", t, e, n), r = C("dataFormat", t, e, n).toUpperCase();
      return [s.depthToSpace(C("x", t, e, n), i, r)];
    }
    case "BroadcastTo":
      return [s.broadcastTo(C("x", t, e, n), C("shape", t, e, n))];
    case "BroadcastArgs":
      return [s.broadcastArgs(C("s0", t, e, n), C("s1", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TI(t, e, n, s, i = Q) {
  const r = ((o, a, c) => {
    switch (o.category) {
      case "arithmetic":
        return i(() => JK(o, a, c));
      case "basic_math":
        return i(() => QK(o, a, c));
      case "control":
        return r9(o, a, c);
      case "convolution":
        return i(() => o9(o, a, c));
      case "creation":
        return i(() => a9(o, a, c));
      case "dynamic":
        return c9(o, a, c);
      case "evaluation":
        return i(() => l9(o, a, c));
      case "image":
        return i(() => f9(o, a, c));
      case "graph":
        return i(() => u9(o, a, c));
      case "logical":
        return i(() => p9(o, a, c));
      case "matrices":
        return i(() => m9(o, a, c));
      case "normalization":
        return i(() => g9(o, a, c));
      case "ragged":
        return i(() => y9(o, a, c));
      case "reduction":
        return i(() => x9(o, a, c));
      case "slice_join":
        return i(() => b9(o, a, c));
      case "sparse":
        return i(() => v9(o, a, c));
      case "spectral":
        return i(() => w9(o, a, c));
      case "string":
        return i(() => S9(o, a, c));
      case "transformation":
        return i(() => _9(o, a, c));
      case "hash_table":
        return d9(o, a, c, s);
      case "custom":
        const l = _D(o.op);
        if (l && l.customExecutor)
          return l.customExecutor(new ZK(o, a, c));
        throw TypeError(`Custom op ${o.op} is not registered.`);
      default:
        throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`);
    }
  })(t, e, n);
  return Ca(r) ? r.then((o) => [].concat(o)) : [].concat(r);
}
class CI {
  constructor(e = {}, n = {}, s = {}, i = {}, r) {
    this.weightMap = e, this.tensorArrayMap = n, this.tensorListMap = s, this.functionMap = i, this.parseNodeNameCache = r, this.rootContext = { id: 0, frameName: "", iterationId: 0 }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();
  }
  newFrame(e, n) {
    return { id: e, frameName: n, iterationId: 0 };
  }
  /**
   * Set the current context
   * @param contexts: ExecutionContextInfo[] the current path of execution
   * frames
   */
  set currentContext(e) {
    this.contexts !== e && (this.contexts = e, this.generateCurrentContextIds());
  }
  get currentContext() {
    return this.contexts;
  }
  /**
   * Returns the current context in string format.
   */
  get currentContextId() {
    return this._currentContextIds[0];
  }
  /**
   * Returns the current context and all parent contexts in string format.
   * This allow access to the nodes in the current and parent frames.
   */
  get currentContextIds() {
    return this._currentContextIds;
  }
  generateCurrentContextIds() {
    const e = [];
    for (let n = 0; n < this.contexts.length - 1; n++) {
      const s = this.contexts.slice(0, this.contexts.length - n);
      e.push(this.contextIdforContexts(s));
    }
    e.push(""), this._currentContextIds = e;
  }
  contextIdforContexts(e) {
    return e ? e.map((n) => n.id === 0 && n.iterationId === 0 ? "" : `${n.frameName}-${n.iterationId}`).join("/") : "";
  }
  /**
   * Enter a new frame, a new context is pushed on the current context list.
   * @param frameId new frame id
   */
  enterFrame(e) {
    this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
  }
  /**
   * Exit the current frame, the last context is removed from the current
   * context list.
   */
  exitFrame() {
    if (this.contexts && this.contexts.length > 1)
      this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
    else
      throw new Error("Cannot exit frame, the context is empty");
  }
  /**
   * Enter the next iteration of a loop, the iteration id of last context is
   * increased.
   */
  nextIteration() {
    if (this.contexts && this.contexts.length > 0) {
      this.contexts = this.contexts.slice(), this.lastId++;
      const e = Object.assign({}, this.contexts[this.contexts.length - 1]);
      e.iterationId += 1, e.id = this.lastId, this.contexts.splice(-1, 1, e), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
    } else
      throw new Error("Cannot increase frame iteration, the context is empty");
  }
  getWeight(e) {
    return this.weightMap[e];
  }
  addTensorArray(e) {
    this.tensorArrayMap[e.id] = e;
  }
  getTensorArray(e) {
    return this.tensorArrayMap[e];
  }
  addTensorList(e) {
    this.tensorListMap[e.id] = e;
  }
  getTensorList(e) {
    return this.tensorListMap[e];
  }
  dispose(e) {
    for (const n in this.tensorArrayMap)
      this.tensorArrayMap[n].clearAndClose(e);
    for (const n in this.tensorListMap)
      this.tensorListMap[n].clearAndClose(e);
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function II(t, e, n, s) {
  const i = /* @__PURE__ */ new Set(), r = [];
  let o = null, a = null;
  const c = /* @__PURE__ */ new Set(), l = new Set(Object.keys(t).map((d) => li(d)[0]));
  s = s || [];
  const u = new Set(s.map((d) => li(d.name)[0])), h = [...e];
  for (; h.length > 0; ) {
    const d = h.pop();
    if ((fc(d) || M9(d) || R9(d)) && o == null && (o = d, a = o.children.map((f) => f.name).filter((f) => i.has(f))), i.add(d.name), n[d.name] == null && !l.has(d.name) && !u.has(d.name)) {
      if (d.inputs.length === 0) {
        r.push(d.name);
        continue;
      }
      d.inputs.forEach((f) => {
        c.has(f.name) || (c.add(f.name), h.push(f));
      });
    }
  }
  return { inputs: t, outputs: e, usedNodes: i, missingInputs: r, dynamicNode: o, syncInputs: a };
}
function T9(t, e) {
  const { usedNodes: n, inputs: s } = e, i = Object.keys(s).map((g) => li(g)[0]).map((g) => t.nodes[g]), r = t.initNodes || [], o = (g) => n.has(typeof g == "string" ? g : g.name);
  function a(g) {
    return [...new Map(g.map((m) => [m.name, m])).values()];
  }
  const c = a([
    ...i,
    ...t.weights,
    ...r
  ]).filter(o), l = a([
    ...c,
    ...Object.values(t.nodes)
  ]).filter(o), u = new Map(l.map((g) => [g.name, g])), h = {};
  for (const g of l) {
    h[g.name] = h[g.name] || 0;
    for (const m of g.children)
      o(m) || (h[m.name] = Number.POSITIVE_INFINITY), h[m.name] = (h[m.name] || 0) + 1;
  }
  const d = Object.entries(h).filter(([, g]) => g === 0).map(([g]) => g), f = [...d];
  for (; d.length > 0; ) {
    const g = d.pop(), m = u.get(g);
    for (const x of m.children.filter(o))
      --h[x.name] === 0 && (f.push(x.name), d.push(x.name));
  }
  const p = f.map((g) => u.get(g)), y = C9(p, c);
  return I9(y, c), y;
}
function C9(t, e) {
  const n = new Map(t.map((o) => [o.name, o])), s = e.map((o) => o.name), i = new Set(s);
  for (; s.length > 0; ) {
    const o = s.pop(), a = n.get(o);
    for (const c of a.children)
      !n.has(c.name) || i.has(c.name) || (i.add(c.name), s.push(c.name));
  }
  return t.filter((o) => i.has(o.name));
}
class vg extends Error {
  constructor(e) {
    super(`NodesExecutionOrderError: ${e}`);
  }
}
function I9(t, e) {
  const n = new Map(t.map((a, c) => [a.name, c])), s = new Set(e.map((a) => a.name)), i = (a) => s.has(typeof a == "string" ? a : a.name), r = new Set(t.map((a) => a.name)), o = (a) => r.has(typeof a == "string" ? a : a.name);
  for (const a of t) {
    for (const c of a.children.filter(o)) {
      if (!n.has(c.name))
        throw new vg(`Child ${c.name} of node ${a.name} is unreachable.`);
      if (n.get(a.name) > n.get(c.name))
        throw new vg(`Node ${a.name} is scheduled to run after its child ${c.name}.`);
    }
    if (!i(a))
      for (const c of a.inputs) {
        if (!n.has(c.name))
          throw new vg(`Input ${c.name} of node ${a.name} is unreachable.`);
        if (n.get(c.name) > n.get(a.name))
          throw new vg(`Node ${a.name} is scheduled to run before its input ${c.name}.`);
      }
  }
}
function E9(t) {
  const e = new Map(t.map((a, c) => [a.name, c])), n = Number.MAX_SAFE_INTEGER, s = t.map((a, c) => fc(a) ? n : c), i = (a) => {
    const c = s[e.get(a.name)];
    return c ?? -1;
  }, r = t.map((a, c) => a.children.map(i).reduce((l, u) => Math.max(l, u), s[c])), o = /* @__PURE__ */ new Map();
  for (let a = 0; a < t.length; ++a) {
    const c = r[a];
    if (c === n)
      continue;
    const l = t[a], u = t[c];
    o.has(u.name) || o.set(u.name, []), o.get(u.name).push(l);
  }
  return o;
}
const N9 = /* @__PURE__ */ new Set([
  "Switch",
  "Merge",
  "Enter",
  "Exit",
  "NextIteration",
  "StatelessIf",
  "StatelessWhile",
  "if",
  "While"
]), k9 = /* @__PURE__ */ new Set([
  "NonMaxSuppressionV2",
  "NonMaxSuppressionV3",
  "NonMaxSuppressionV5",
  "Where"
]), A9 = /* @__PURE__ */ new Set([
  "HashTable",
  "HashTableV2",
  "LookupTableImport",
  "LookupTableImportV2",
  "LookupTableFind",
  "LookupTableFindV2",
  "LookupTableSize",
  "LookupTableSizeV2"
]);
function fc(t) {
  return N9.has(t.op);
}
function M9(t) {
  return k9.has(t.op);
}
function R9(t) {
  return A9.has(t.op);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Xy {
  get weightIds() {
    return this.parent ? this.parent.weightIds : this._weightIds;
  }
  get functionExecutorMap() {
    return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
  }
  get weightMap() {
    return this.parent ? this.parent.weightMap : this._weightMap;
  }
  set weightMap(e) {
    const n = Object.keys(e).map((s) => e[s].map((i) => i.id));
    this._weightIds = [].concat(...n), this._weightMap = e;
  }
  /**
   * Set `ResourceManager` shared by executors of a model.
   * @param resourceManager: `ResourceManager` of the `GraphModel`.
   */
  set resourceManager(e) {
    this._resourceManager = e;
  }
  get inputs() {
    return this._inputs.map((e) => ({
      name: e.name,
      shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
      dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
    }));
  }
  get outputs() {
    return this._outputs.map((e) => ({
      name: e.name,
      shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
      dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
    }));
  }
  get inputNodes() {
    return this._inputs.map((e) => e.signatureKey || e.name);
  }
  get outputNodes() {
    return this._outputs.map((e) => {
      const n = e.signatureKey || e.name;
      return e.defaultOutput ? `${n}:${e.defaultOutput}` : n;
    });
  }
  get functions() {
    return Object.keys(this._functions).reduce((e, n) => (e[n] = this._functions[n].signature, e), {});
  }
  /**
   *
   * @param graph Graph the model or function graph to be executed.
   * @param parent When building function exector you need to set the parent
   * executor. Since the weights and function executor maps are set at parant
   * level, that function executor can access the function maps and weight maps
   * through the parent.
   */
  constructor(e, n) {
    this.graph = e, this.parent = n, this.compiledMap = /* @__PURE__ */ new Map(), this.parseNodeNameCache = /* @__PURE__ */ new Map(), this._weightMap = {}, this.SEPARATOR = ",", this._functions = {}, this._functionExecutorMap = {}, this.keepIntermediateTensors = !1, this._outputs = e.outputs, this._inputs = e.inputs, this._initNodes = e.initNodes, this._signature = e.signature, this._functions = e.functions, e.functions != null && Object.keys(e.functions).forEach((s) => {
      this._functionExecutorMap[s] = new Xy(e.functions[s], this);
    });
  }
  getCompilationKey(e, n) {
    const s = e.map((r) => r.name).sort(), i = n.map((r) => r.name).sort();
    return s.join(this.SEPARATOR) + "--" + i.join(this.SEPARATOR);
  }
  /**
   * Compiles the inference graph and returns the minimal set of nodes that are
   * required for execution, in the correct execution order.
   * @returns {Object} compilation The compile result.
   * @returns {Node[]} compilation.orderedNodes Nodes in the correct execution
   *     order.
   * @returns {Map<string, Node[]>} compilation.nodeLiveUntilMap A map from node
   *     to disposable nodes after its execution. That is, for a node `x`,
   *     `nodeLiveUntilMap[x]` indicates all nodes whose intermediate
   *     tensors should be disposed after `x` is executed.
   */
  compile(e, n) {
    const s = II(e, n, this.weightMap, this._initNodes), { missingInputs: i, dynamicNode: r, syncInputs: o } = s;
    if (r != null)
      throw new Error(`This execution contains the node '${r.name}', which has the dynamic op '${r.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);
    if (i.length > 0) {
      const l = n.map((h) => h.name), u = Object.keys(e);
      throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${u}]. Missing the following inputs: [${i}]`);
    }
    const a = T9(this.graph, s), c = E9(a);
    return { orderedNodes: a, nodeLiveUntilMap: c };
  }
  cloneAndKeepTensor(e) {
    if (e == null)
      return null;
    const n = e.clone();
    return Zn(n), n;
  }
  cloneTensorList(e) {
    return e ? e.map((s) => this.cloneAndKeepTensor(s)) : null;
  }
  cloneTensorMap(e) {
    return Object.fromEntries(Object.entries(e).map(([n, s]) => [n, this.cloneTensorList(s)]));
  }
  /**
   * Executes the inference for given input tensors.
   * @param inputs Tensor map for the model inputs, keyed by the input node
   * names.
   * @param outputs Optional. output node name from the Tensorflow model, if
   * no outputs are specified, the default outputs of the model would be used.
   * You can inspect intermediate nodes of the model by adding them to the
   * outputs array.
   */
  execute(e, n) {
    this.disposeIntermediateTensors(), e = this.mapInputs(e);
    const s = Object.keys(e).sort();
    this.checkInputs(e), this.checkInputShapeAndType(e), n = this.mapOutputs(n), this.checkOutputs(n);
    const i = s.map((d) => this.graph.nodes[li(d)[0]]), r = n.map((d) => li(d)[0]), o = new Set(r);
    let a = r.map((d) => this.graph.nodes[d]);
    a.length === 0 && (a = this._outputs);
    const c = this.getCompilationKey(i, a);
    let l = this.compiledMap.get(c);
    l == null && (l = this.compile(e, a), this.compiledMap.set(c, l));
    try {
      this.keepIntermediateTensors = ie().getBool("KEEP_INTERMEDIATE_TENSORS");
    } catch (d) {
      this.keepIntermediateTensors = !1, console.warn(d.message);
    }
    const u = {}, h = {};
    return Q(() => {
      const d = new CI(this.weightMap, u, h, this.functionExecutorMap, this.parseNodeNameCache), f = Object.assign({}, this.weightMap);
      this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap)), Object.keys(e).forEach((m) => {
        const [x, v] = li(m, d), b = [];
        b[v] = e[m], f[x] = b, this.keepIntermediateTensors && (this.clonedTensorsMap[x] = this.cloneTensorList(b));
      });
      const p = this.getFrozenTensorIds(f), { orderedNodes: y, nodeLiveUntilMap: g } = l;
      for (const m of y) {
        if (f[m.name])
          continue;
        const x = TI(m, f, d, this._resourceManager);
        if (Ca(x))
          throw new Error(`The execution of the op '${m.op}' returned a promise. Please use model.executeAsync() instead.`);
        f[m.name] = x, this.keepIntermediateTensors && (this.clonedTensorsMap[m.name] = this.cloneTensorList(x)), this.checkTensorForDisposalWithNodeLiveUntilInfo(m, f, d, p, o, g.get(m.name));
      }
      return this.parent == null && d.dispose(p), n.map((m) => ms(m, f, d));
    });
  }
  getFrozenTensorIds(e) {
    const n = [].concat.apply([], Object.keys(e).map((s) => e[s]).map((s) => s.map((i) => i.id)));
    return new Set(n);
  }
  checkTensorForDisposal(e, n, s, i, r, o, a) {
    if (!(fc(n) || o.has(e))) {
      for (const c of s[e])
        c != null && (a[c.id] = (a[c.id] || 0) + n.children.length);
      for (const c of n.inputs) {
        if (fc(c))
          continue;
        const l = bI(c.name, s, i);
        if (l != null)
          for (const u of l) {
            if (!u || u.kept || r.has(u.id))
              continue;
            const h = a[u.id];
            h === 1 ? (u.dispose(), delete a[u.id]) : h != null && a[u.id]--;
          }
      }
    }
  }
  checkTensorForDisposalWithNodeLiveUntilInfo(e, n, s, i, r, o) {
    function a(c) {
      return fc(c) || r.has(c.name);
    }
    if (!(fc(e) || o == null))
      for (const c of o) {
        if (a(c))
          continue;
        const l = bI(c.name, n, s);
        for (const u of l)
          !u || u.kept || i.has(u.id) || u.dispose();
      }
  }
  /**
   * Executes the inference for given input tensors in Async fashion.
   * @param inputs Tensor map for the model inputs, keyed by the input node
   * names.
   * @param outputs output node name from the Tensorflow model, if no outputs
   * are specified, the default outputs of the model would be used. You can
   * inspect intermediate nodes of the model by adding them to the outputs
   * array.
   */
  async executeAsync(e, n) {
    return this._executeAsync(e, n);
  }
  disposeIntermediateTensors() {
    this.clonedTensorsMap && (Object.values(this.clonedTensorsMap).forEach((e) => {
      for (const n of e)
        n && !n.isDisposed && n.dispose();
    }), this.clonedTensorsMap = null);
  }
  getIntermediateTensors() {
    return this.clonedTensorsMap;
  }
  /**
   * Executes the inference for given input tensors in Async fashion.
   * @param inputs Tensor map for the model inputs, keyed by the input node
   * names.
   * @param outputs Optional. output node name from the Tensorflow model,
   * if no outputs are specified, the default outputs of the model would be
   * used. You can inspect intermediate nodes of the model by adding them to
   * the outputs array.
   * @param isFunctionExecution Optional. Flag for executing a function.
   * @param tensorArrayMap Optional, global TensorArray map by id. Used for
   * function execution.
   * @param tensorArrayMap Optional global TensorList map by id. Used for
   * function execution.
   */
  async _executeAsync(e, n, s = !1, i = {}, r = {}) {
    this.disposeIntermediateTensors(), s || (e = this.mapInputs(e), this.checkInputs(e), this.checkInputShapeAndType(e), n = this.mapOutputs(n), this.checkOutputs(n));
    try {
      this.keepIntermediateTensors = ie().getBool("KEEP_INTERMEDIATE_TENSORS");
    } catch (d) {
      this.keepIntermediateTensors = !1, console.warn(d.message);
    }
    const o = new CI(this.weightMap, i, r, this.functionExecutorMap, this.parseNodeNameCache);
    this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap));
    const a = await this.executeWithControlFlow(e, o, n, s), c = n.map((d) => ms(d, a, o)), l = c.map((d) => d.id), u = Object.keys(e).map((d) => e[d].id), h = /* @__PURE__ */ new Set([...l, ...u, ...this.weightIds]);
    return Object.values(a).forEach((d) => {
      d.forEach((f) => {
        f && !f.isDisposed && !h.has(f.id) && f.dispose();
      });
    }), this.parent == null && o.dispose(h), c;
  }
  async executeFunctionAsync(e, n, s) {
    const i = e.reduce((r, o, a) => (r[this.inputs[a].name] = o, r), {});
    return this._executeAsync(i, this.outputNodes, !0, n, s);
  }
  /**
   * When there are control flow nodes in the graph, the graph execution use
   * ExecutionContext to keep track of the frames and loop iterators.
   * @param inputs placeholder tensors for the graph.
   * @param context the execution context object for current execution.
   * @param outputNames Optional. output node name from the Tensorflow model,
   * if no outputs are specified, the default outputs of the model would be
   * used. You can inspect intermediate nodes of the model by adding them to
   * the outputs array.
   * @param isFunctionExecution Flag for executing a function.
   */
  async executeWithControlFlow(e, n, s, i) {
    const r = Object.keys(e), o = r.map((b) => this.graph.nodes[li(b)[0]]), a = s.map((b) => li(b)[0]), c = new Set(a);
    let l = a.map((b) => this.graph.nodes[b]);
    l.length === 0 && (l = this._outputs);
    const { usedNodes: u, missingInputs: h, dynamicNode: d, syncInputs: f } = II(e, l, this.weightMap, this._initNodes), p = [
      ...o,
      ...this.graph.weights,
      ...this._initNodes || []
    ].map((b) => ({ node: b, contexts: n.currentContext })), y = Object.assign({}, this.weightMap);
    Object.keys(e).forEach((b) => {
      const [w, S] = li(b), _ = [];
      _[S] = e[b], y[w] = _;
    });
    const g = {}, m = this.getFrozenTensorIds(y), x = {};
    for (; p.length > 0; ) {
      const b = this.processStack(o, p, n, y, x, m, c, g, u);
      await Promise.all(b);
    }
    d == null && !i && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");
    const v = l.filter((b) => !fc(b) && !ms(b.name, y, n)).map((b) => b.name);
    if (v.length > 0) {
      let b = "";
      throw d != null && (b = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`), new Error(`Cannot compute the outputs [${v}] from the provided inputs [${r}]. Consider providing the following inputs: [${h}]. ${b}`);
    }
    return y;
  }
  processStack(e, n, s, i, r, o, a, c, l) {
    const u = [];
    for (; n.length > 0; ) {
      const h = n.pop();
      s.currentContext = h.contexts;
      let d = "";
      if (h.node.op === "Enter" && C("isConstant", h.node, i, s) && ([d] = So(h.node.name, s)), i[h.node.name] == null) {
        const f = TI(h.node, i, s, this._resourceManager);
        d || ([d] = So(h.node.name, s));
        const p = s.currentContext;
        Ca(f) ? u.push(f.then((y) => (i[d] = y, this.keepIntermediateTensors && (this.clonedTensorsMap[d] = this.cloneTensorList(y)), s.currentContext = p, this.checkTensorForDisposal(d, h.node, i, s, o, a, c), this.processChildNodes(h.node, n, s, i, r, l), y))) : (i[d] = f, this.keepIntermediateTensors && (this.clonedTensorsMap[d] = this.cloneTensorList(f)), this.checkTensorForDisposal(d, h.node, i, s, o, a, c), this.processChildNodes(h.node, n, s, i, r, l));
      } else
        this.processChildNodes(h.node, n, s, i, r, l);
    }
    return u;
  }
  processChildNodes(e, n, s, i, r, o) {
    e.children.forEach((a) => {
      const [c] = So(a.name, s);
      r[c] || !o.has(a.name) || (a.op === "Merge" ? a.inputNames.some((l) => !!ms(l, i, s)) && (r[c] = !0, n.push({ contexts: s.currentContext, node: a })) : a.inputNames.every((l) => !!ms(l, i, s)) && (r[c] = !0, n.push({ contexts: s.currentContext, node: a })));
    });
  }
  /**
   * Releases the memory used by the weight tensors.
   */
  dispose() {
    Object.keys(this.weightMap).forEach((e) => this.weightMap[e].forEach((n) => n.dispose()));
  }
  checkInputShapeAndType(e) {
    Object.keys(e).forEach((n) => {
      const s = e[n], [i] = li(n), r = this.graph.nodes[i];
      if (r.attrParams.shape && r.attrParams.shape.value) {
        const o = r.attrParams.shape.value, a = o.length === s.shape.length && s.shape.every((c, l) => o[l] === -1 || o[l] === c);
        A(a, () => `The shape of dict['${r.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`);
      }
      r.attrParams.dtype && r.attrParams.dtype.value && A(s.dtype === r.attrParams.dtype.value, () => `The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${s.dtype}`);
    });
  }
  mapInputs(e) {
    var n, s;
    const i = {};
    for (const r in e) {
      const o = (s = (n = this._signature) === null || n === void 0 ? void 0 : n.inputs) === null || s === void 0 ? void 0 : s[r];
      o != null ? i[o.name] = e[r] : i[r] = e[r];
    }
    return i;
  }
  checkInputs(e) {
    const n = Object.keys(e).filter((s) => {
      const [i] = li(s);
      return this.graph.nodes[i] == null;
    });
    if (n.length > 0)
      throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`);
  }
  mapOutputs(e) {
    return e.map((n) => {
      var s, i;
      const r = (i = (s = this._signature) === null || s === void 0 ? void 0 : s.outputs) === null || i === void 0 ? void 0 : i[n];
      return r != null ? r.name : n;
    }, {});
  }
  checkOutputs(e) {
    e.forEach((n) => {
      const [s] = li(n);
      if (!this.graph.nodes[s])
        throw new Error(`The output '${n}' is not found in the graph`);
    });
  }
}
class D9 {
  constructor(e = {}, n = {}) {
    this.hashTableNameToHandle = e, this.hashTableMap = n;
  }
  /**
   * Register a `HashTable` in the resource manager.
   *
   * The `HashTable` can be retrieved by `resourceManager.getHashTableById`,
   * where id is the table handle tensor's id.
   *
   * @param name Op node name that creates the `HashTable`.
   * @param hashTable The `HashTable` to be added to resource manager.
   */
  addHashTable(e, n) {
    this.hashTableNameToHandle[e] = n.handle, this.hashTableMap[n.id] = n;
  }
  /**
   * Get the table handle by node name.
   * @param name Op node name that creates the `HashTable`. This name is also
   *     used in the inputs list of lookup and import `HashTable` ops.
   */
  getHashTableHandleByName(e) {
    return this.hashTableNameToHandle[e];
  }
  /**
   * Get the actual `HashTable` by its handle tensor's id.
   * @param id The id of the handle tensor.
   */
  getHashTableById(e) {
    return this.hashTableMap[e];
  }
  /**
   * Dispose `ResourceManager`, including its hashTables and tensors in them.
   */
  dispose() {
    for (const e in this.hashTableMap)
      this.hashTableMap[e].clearAndClose(), delete this.hashTableMap[e];
    for (const e in this.hashTableNameToHandle)
      this.hashTableNameToHandle[e].dispose(), delete this.hashTableNameToHandle[e];
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $9 = "?tfjs-format=file", O9 = "model.json";
class L9 {
  // Returns the version information for the tensorflow model GraphDef.
  get modelVersion() {
    return this.version;
  }
  get inputNodes() {
    return this.executor.inputNodes;
  }
  get outputNodes() {
    return this.executor.outputNodes;
  }
  get inputs() {
    return this.executor.inputs;
  }
  get outputs() {
    return this.executor.outputs;
  }
  get weights() {
    return this.executor.weightMap;
  }
  get metadata() {
    return this.artifacts.userDefinedMetadata;
  }
  get modelSignature() {
    return this.signature;
  }
  get modelStructuredOutputKeys() {
    return this.structuredOutputKeys;
  }
  /**
   * @param modelUrl url for the model, or an `io.IOHandler`.
   * @param weightManifestUrl url for the weight file generated by
   * scripts/convert.py script.
   * @param requestOption options for Request, which allows to send credentials
   * and custom headers.
   * @param onProgress Optional, progress callback function, fired periodically
   * before the load is completed.
   */
  constructor(e, n = {}, s = C_) {
    this.modelUrl = e, this.loadOptions = n, this.version = "n/a", this.io = s, n == null && (this.loadOptions = {}), this.resourceManager = new D9();
  }
  findIOHandler() {
    const e = this.modelUrl;
    if (e.load != null)
      this.handler = e;
    else if (this.loadOptions.requestInit != null)
      this.handler = this.io.browserHTTPRequest(e, this.loadOptions);
    else {
      const n = this.io.getLoadHandlers(e, this.loadOptions);
      if (n.length === 0)
        n.push(this.io.browserHTTPRequest(e, this.loadOptions));
      else if (n.length > 1)
        throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);
      this.handler = n[0];
    }
  }
  /**
   * Loads the model and weight files, construct the in memory weight map and
   * compile the inference graph.
   */
  load() {
    if (this.findIOHandler(), this.handler.load == null)
      throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
    const e = this.handler.load();
    return Ca(e) ? e.then((n) => n.getWeightStream == null ? this.loadSync(n) : this.loadStreaming(n)) : this.loadSync(e);
  }
  /**
   * Synchronously construct the in memory weight map and
   * compile the inference graph.
   *
   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
   */
  loadSync(e) {
    const n = this.io.decodeWeights(e.weightData, e.weightSpecs);
    return this.loadWithWeightMap(e, n);
  }
  async loadStreaming(e) {
    if (e.getWeightStream == null)
      throw new Error("Model artifacts missing streamWeights function");
    const n = await ek(e.getWeightStream(), e.weightSpecs);
    return this.loadWithWeightMap(e, n);
  }
  loadWithWeightMap(e, n) {
    this.artifacts = e;
    const s = this.artifacts.modelTopology;
    let i = this.artifacts.signature;
    if (this.artifacts.userDefinedMetadata != null) {
      const r = this.artifacts.userDefinedMetadata;
      r.signature != null && (i = r.signature), r.structuredOutputKeys != null && (this.structuredOutputKeys = r.structuredOutputKeys);
    }
    if (this.signature = i, this.version = `${s.versions.producer}.${s.versions.minConsumer}`, this.executor = new Xy(vI.Instance.transformGraph(s, this.signature)), this.executor.weightMap = this.convertTensorMapToTensorsMap(n), this.executor.resourceManager = this.resourceManager, e.modelInitializer != null && e.modelInitializer.node != null) {
      const r = vI.Instance.transformGraph(e.modelInitializer);
      this.initializer = new Xy(r), this.initializer.weightMap = this.executor.weightMap, this.initializer.resourceManager = this.resourceManager, this.initializerSignature = e.initializerSignature;
    }
    return !0;
  }
  /**
   * Save the configuration and/or weights of the GraphModel.
   *
   * An `IOHandler` is an object that has a `save` method of the proper
   * signature defined. The `save` method manages the storing or
   * transmission of serialized data ("artifacts") that represent the
   * model's topology and weights onto or via a specific medium, such as
   * file downloads, local storage, IndexedDB in the web browser and HTTP
   * requests to a server. TensorFlow.js provides `IOHandler`
   * implementations for a number of frequently used saving mediums, such as
   * `tf.io.browserDownloads` and `tf.io.browserLocalStorage`. See `tf.io`
   * for more details.
   *
   * This method also allows you to refer to certain types of `IOHandler`s
   * as URL-like string shortcuts, such as 'localstorage://' and
   * 'indexeddb://'.
   *
   * Example 1: Save `model`'s topology and weights to browser [local
   * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);
   * then load it back.
   *
   * ```js
   * const modelUrl =
   *    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';
   * const model = await tf.loadGraphModel(modelUrl);
   * const zeros = tf.zeros([1, 224, 224, 3]);
   * model.predict(zeros).print();
   *
   * const saveResults = await model.save('localstorage://my-model-1');
   *
   * const loadedModel = await tf.loadGraphModel('localstorage://my-model-1');
   * console.log('Prediction from loaded model:');
   * model.predict(zeros).print();
   * ```
   *
   * @param handlerOrURL An instance of `IOHandler` or a URL-like,
   * scheme-based string shortcut for `IOHandler`.
   * @param config Options for saving the model.
   * @returns A `Promise` of `SaveResult`, which summarizes the result of
   * the saving, such as byte sizes of the saved artifacts for the model's
   *   topology and weight values.
   *
   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
   */
  async save(e, n) {
    if (typeof e == "string") {
      const s = this.io.getSaveHandlers(e);
      if (s.length === 0)
        throw new Error(`Cannot find any save handlers for URL '${e}'`);
      if (s.length > 1)
        throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);
      e = s[0];
    }
    if (e.save == null)
      throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
    return e.save(this.artifacts);
  }
  addStructuredOutputNames(e) {
    if (this.structuredOutputKeys) {
      const n = e instanceof Lt ? [e] : e, s = {};
      return n.forEach((i, r) => s[this.structuredOutputKeys[r]] = i), s;
    }
    return e;
  }
  /**
   * Execute the inference for the input tensors.
   *
   * @param input The input tensors, when there is single input for the model,
   * inputs param should be a `tf.Tensor`. For models with multiple inputs,
   * inputs params should be in either `tf.Tensor`[] if the input order is
   * fixed, or otherwise NamedTensorMap format.
   *
   * For model with multiple inputs, we recommend you use NamedTensorMap as the
   * input type, if you use `tf.Tensor`[], the order of the array needs to
   * follow the
   * order of inputNodes array. @see {@link GraphModel.inputNodes}
   *
   * You can also feed any intermediate nodes using the NamedTensorMap as the
   * input type. For example, given the graph
   *    InputNode => Intermediate => OutputNode,
   * you can execute the subgraph Intermediate => OutputNode by calling
   *    model.execute('IntermediateNode' : tf.tensor(...));
   *
   * This is useful for models that uses tf.dynamic_rnn, where the intermediate
   * state needs to be fed manually.
   *
   * For batch inference execution, the tensors for each input need to be
   * concatenated together. For example with mobilenet, the required input shape
   * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
   * If we are provide a batched data of 100 images, the input tensor should be
   * in the shape of [100, 244, 244, 3].
   *
   * @param config Prediction configuration for specifying the batch size.
   * Currently the batch size option is ignored for graph model.
   *
   * @returns Inference result tensors. If the model is converted and it
   * originally had structured_outputs in tensorflow, then a NamedTensorMap
   * will be returned matching the structured_outputs. If no structured_outputs
   * are present, the output will be single `tf.Tensor` if the model has single
   * output node, otherwise Tensor[].
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  predict(e, n) {
    const s = this.execute(e, this.outputNodes);
    return this.addStructuredOutputNames(s);
  }
  /**
   * Execute the inference for the input tensors in async fashion, use this
   * method when your model contains control flow ops.
   *
   * @param input The input tensors, when there is single input for the model,
   * inputs param should be a `tf.Tensor`. For models with mutliple inputs,
   * inputs params should be in either `tf.Tensor`[] if the input order is
   * fixed, or otherwise NamedTensorMap format.
   *
   * For model with multiple inputs, we recommend you use NamedTensorMap as the
   * input type, if you use `tf.Tensor`[], the order of the array needs to
   * follow the
   * order of inputNodes array. @see {@link GraphModel.inputNodes}
   *
   * You can also feed any intermediate nodes using the NamedTensorMap as the
   * input type. For example, given the graph
   *    InputNode => Intermediate => OutputNode,
   * you can execute the subgraph Intermediate => OutputNode by calling
   *    model.execute('IntermediateNode' : tf.tensor(...));
   *
   * This is useful for models that uses tf.dynamic_rnn, where the intermediate
   * state needs to be fed manually.
   *
   * For batch inference execution, the tensors for each input need to be
   * concatenated together. For example with mobilenet, the required input shape
   * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
   * If we are provide a batched data of 100 images, the input tensor should be
   * in the shape of [100, 244, 244, 3].
   *
   * @param config Prediction configuration for specifying the batch size.
   * Currently the batch size option is ignored for graph model.
   *
   * @returns A Promise of inference result tensors. If the model is converted
   * and it originally had structured_outputs in tensorflow, then a
   * NamedTensorMap will be returned matching the structured_outputs. If no
   * structured_outputs are present, the output will be single `tf.Tensor` if
   * the model has single output node, otherwise Tensor[].
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async predictAsync(e, n) {
    const s = await this.executeAsync(e, this.outputNodes);
    return this.addStructuredOutputNames(s);
  }
  normalizeInputs(e) {
    var n;
    if (!(e instanceof Lt) && !Array.isArray(e)) {
      const r = (n = this.signature) === null || n === void 0 ? void 0 : n.inputs;
      if (r != null)
        for (const o in r) {
          const a = r[o];
          a.resourceId != null && (e[o] = this.resourceIdToCapturedInput[a.resourceId]);
        }
      return e;
    }
    e = Array.isArray(e) ? e : [e];
    const s = Object.keys(this.resourceIdToCapturedInput).length;
    if (e.length + s !== this.inputNodes.length)
      throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length - s} non-resource placeholders, while there are ${e.length} input tensors provided.`);
    let i = 0;
    return this.inputNodes.reduce((r, o) => {
      var a, c, l;
      const u = (l = (c = (a = this.signature) === null || a === void 0 ? void 0 : a.inputs) === null || c === void 0 ? void 0 : c[o]) === null || l === void 0 ? void 0 : l.resourceId;
      return u != null ? r[o] = this.resourceIdToCapturedInput[u] : r[o] = e[i++], r;
    }, {});
  }
  normalizeOutputs(e) {
    return e = e || this.outputNodes, Array.isArray(e) ? e : [e];
  }
  executeInitializerGraph() {
    return this.initializer == null ? [] : this.initializerSignature == null ? this.initializer.execute({}, []) : this.initializer.execute({}, Object.keys(this.initializerSignature.outputs));
  }
  async executeInitializerGraphAsync() {
    return this.initializer == null ? [] : this.initializerSignature == null ? this.initializer.executeAsync({}, []) : this.initializer.executeAsync({}, Object.keys(this.initializerSignature.outputs));
  }
  setResourceIdToCapturedInput(e) {
    if (this.resourceIdToCapturedInput = {}, this.initializerSignature) {
      const n = this.initializerSignature.outputs, s = Object.keys(n);
      for (let i = 0; i < s.length; i++) {
        const r = s[i], o = n[r];
        this.resourceIdToCapturedInput[o.resourceId] = e[i];
      }
    }
  }
  /**
   * Executes inference for the model for given input tensors.
   * @param inputs tensor, tensor array or tensor map of the inputs for the
   * model, keyed by the input node names.
   * @param outputs output node name from the TensorFlow model, if no
   * outputs are specified, the default outputs of the model would be used.
   * You can inspect intermediate nodes of the model by adding them to the
   * outputs array.
   *
   * @returns A single tensor if provided with a single output or no outputs
   * are provided and there is only one default output, otherwise return a
   * tensor array. The order of the tensor array is the same as the outputs
   * if provided, otherwise the order of outputNodes attribute of the model.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  execute(e, n) {
    this.resourceIdToCapturedInput == null && this.setResourceIdToCapturedInput(this.executeInitializerGraph()), e = this.normalizeInputs(e), n = this.normalizeOutputs(n);
    const s = this.executor.execute(e, n);
    return s.length > 1 ? s : s[0];
  }
  /**
   * Executes inference for the model for given input tensors in async
   * fashion, use this method when your model contains control flow ops.
   * @param inputs tensor, tensor array or tensor map of the inputs for the
   * model, keyed by the input node names.
   * @param outputs output node name from the TensorFlow model, if no outputs
   * are specified, the default outputs of the model would be used. You can
   * inspect intermediate nodes of the model by adding them to the outputs
   * array.
   *
   * @returns A Promise of single tensor if provided with a single output or
   * no outputs are provided and there is only one default output, otherwise
   * return a tensor map.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async executeAsync(e, n) {
    this.resourceIdToCapturedInput == null && this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()), e = this.normalizeInputs(e), n = this.normalizeOutputs(n);
    const s = await this.executor.executeAsync(e, n);
    return s.length > 1 ? s : s[0];
  }
  /**
   * Get intermediate tensors for model debugging mode (flag
   * KEEP_INTERMEDIATE_TENSORS is true).
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  getIntermediateTensors() {
    return this.executor.getIntermediateTensors();
  }
  /**
   * Dispose intermediate tensors for model debugging mode (flag
   * KEEP_INTERMEDIATE_TENSORS is true).
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  disposeIntermediateTensors() {
    this.executor.disposeIntermediateTensors();
  }
  convertTensorMapToTensorsMap(e) {
    return Object.keys(e).reduce((n, s) => (n[s] = [e[s]], n), {});
  }
  /**
   * Releases the memory used by the weight tensors and resourceManager.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  dispose() {
    this.executor.dispose(), this.initializer && (this.initializer.dispose(), this.resourceIdToCapturedInput && At(this.resourceIdToCapturedInput)), this.resourceManager.dispose();
  }
}
async function Tb(t, e = {}, n = C_) {
  if (t == null)
    throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
  e == null && (e = {}), e.fromTFHub && typeof t == "string" && (t = F9(t));
  const s = new L9(t, e, n);
  return await s.load(), s;
}
function F9(t) {
  return t.endsWith("/") || (t = t + "/"), `${t}${O9}${$9}`;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
var EI;
(function(t) {
  t[t.FAIL = 0] = "FAIL", t[t.SHORTEST = 1] = "SHORTEST", t[t.LONGEST = 2] = "LONGEST";
})(EI || (EI = {}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nt(t, e) {
  Array.isArray(t) || (t = [t]), t.forEach((n) => {
    n != null && A(n.dtype !== "complex64", () => `${e} does not support complex64 tensors in the CPU backend.`);
  });
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const P9 = Q0;
class Cb extends mx {
  nextDataId() {
    return Cb.nextDataId++;
  }
  constructor() {
    super(), this.blockSize = 48, this.firstUse = !0, this.data = new W1(this, ui());
  }
  write(e, n, s) {
    this.firstUse && (this.firstUse = !1, ie().get("IS_NODE") && Ei(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));
    const i = { id: this.nextDataId() };
    return this.data.set(i, { values: e, dtype: s, refCount: 1 }), i;
  }
  /**
   * Create a data bucket in cpu backend.
   * @param shape Shape of the `TensorInfo`.
   * @param dtype DType of the `TensorInfo`.
   * @param values The value of the `TensorInfo` stored as a flattened array.
   */
  makeTensorInfo(e, n, s) {
    let i;
    if (n === "string" && s != null && s.length > 0 && Wr(s[0])) {
      const r = s.map((o) => jr(o));
      i = this.write(r, e, n);
    } else
      i = this.write(s, e, n);
    return { dataId: i, shape: e, dtype: n };
  }
  /** Return refCount of a `TensorData`. */
  refCount(e) {
    return this.data.has(e) ? this.data.get(e).refCount : 0;
  }
  /** Increase refCount of a `TensorData`. */
  incRef(e) {
    const n = this.data.get(e);
    n.refCount++;
  }
  /** Decrease refCount of a `TensorData`. */
  decRef(e) {
    if (this.data.has(e)) {
      const n = this.data.get(e);
      n.refCount--;
    }
  }
  move(e, n, s, i, r) {
    this.data.set(e, { values: n, dtype: i, refCount: r });
  }
  numDataIds() {
    return this.data.numDataIds();
  }
  async read(e) {
    return this.readSync(e);
  }
  readSync(e) {
    const { dtype: n, complexTensorInfos: s } = this.data.get(e);
    if (n === "complex64") {
      const i = this.readSync(s.real.dataId), r = this.readSync(s.imag.dataId);
      return Lo(i, r);
    }
    return kN(this.data.get(e).values, n);
  }
  bufferSync(e) {
    const n = this.readSync(e.dataId);
    if (e.dtype === "string")
      try {
        const s = n.map((i) => Ro(i));
        return It(e.shape, e.dtype, s);
      } catch {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    return It(e.shape, e.dtype, n);
  }
  makeOutput(e, n, s) {
    return ui().makeTensorFromTensorInfo(this.makeTensorInfo(n, s, e), this);
  }
  /**
   * Dispose the memory if the dataId has 0 refCount. Return true if the memory
   * is released or memory is not managed in this backend, false if memory is
   * not cleared.
   * @param dataId
   * @oaram force Optional, remove the data regardless of refCount
   */
  disposeData(e, n = !1) {
    if (this.data.has(e)) {
      if (this.data.get(e).refCount--, !n && this.data.get(e).refCount > 0)
        return !1;
      const { complexTensorInfos: s } = this.data.get(e);
      s != null && (this.disposeData(s.real.dataId, !0), this.disposeData(s.imag.dataId, !0)), this.data.delete(e);
    }
    return !0;
  }
  disposeIntermediateTensorInfo(e) {
    this.disposeData(e.dataId);
  }
  async time(e) {
    const n = Ls();
    return e(), { kernelMs: Ls() - n };
  }
  memory() {
    return {
      // Unreliable due to automatic gc. The numbers above are cumulative.
      unreliable: !0,
      reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
    };
  }
  where(e) {
    nt([e], "where");
    const n = this.readSync(e.dataId);
    return P9(e.shape, n);
  }
  dispose() {
  }
  floatPrecision() {
    return 32;
  }
  /** Returns the smallest representable number.  */
  epsilon() {
    return super.epsilon();
  }
}
Cb.nextDataId = 0;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ID(t) {
  const e = new Float32Array(t.length);
  for (let n = 0; n < t.length; ++n)
    e[n] = Math.abs(t[n]);
  return e;
}
const B9 = (t) => {
  const { x: e } = t.inputs, n = t.backend;
  nt(e, "abs");
  let s = new Float32Array(ue(e.shape));
  const i = n.data.get(e.dataId).values;
  return s = ID(i), n.makeOutput(s, e.shape, e.dtype);
}, z9 = {
  kernelName: Ff,
  backendName: "cpu",
  kernelFunc: B9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Gn(t) {
  return (e, n, s, i, r) => {
    const o = bt(e, n), a = o.length, c = ct(o), l = ue(o), u = ls(r, l), h = e.length, d = n.length, f = ct(e), p = ct(n), y = Vc(e, o), g = Vc(n, o);
    if (y.length + g.length === 0)
      for (let m = 0; m < u.length; ++m)
        u[m] = t(s[m % s.length], i[m % i.length]);
    else
      for (let m = 0; m < u.length; ++m) {
        const x = Jc(m, a, c), v = x.slice(-h);
        y.forEach((_) => v[_] = 0);
        const b = br(v, h, f), w = x.slice(-d);
        g.forEach((_) => w[_] = 0);
        const S = br(w, d, p);
        u[m] = t(s[b], i[S]);
      }
    return [u, o];
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function di(t) {
  const { inputs: e, backend: n } = t, { real: s, imag: i } = e, r = n.data.get(s.dataId).values, o = n.data.get(i.dataId).values, a = n.makeTensorInfo(s.shape, "complex64"), c = n.data.get(a.dataId);
  return c.complexTensorInfos = {
    real: n.makeTensorInfo(s.shape, "float32", r),
    imag: n.makeTensorInfo(i.shape, "float32", o)
  }, a;
}
const V9 = {
  kernelName: Tx,
  backendName: "cpu",
  kernelFunc: di
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ky(t, e, n = "float32") {
  if (n === "complex64") {
    const i = Ky(t, e, "float32"), r = Ky(t, e, "float32");
    return di({ inputs: { real: i, imag: r }, backend: t });
  }
  const s = vs(ue(e), n);
  return t.makeTensorInfo(e, n, s);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ao(t) {
  const { inputs: e, backend: n } = t, { x: s } = e;
  return n.incRef(s.dataId), { dataId: s.dataId, shape: s.shape, dtype: s.dtype };
}
const U9 = {
  kernelName: nh,
  backendName: "cpu",
  kernelFunc: ao
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qc(t) {
  const { inputs: e, backend: n } = t, { input: s } = e, i = n.data.get(s.dataId).complexTensorInfos.real, r = n.data.get(i.dataId).values;
  return n.makeTensorInfo(i.shape, i.dtype, r);
}
const G9 = {
  kernelName: s0,
  backendName: "cpu",
  kernelFunc: qc
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ED(t, e, n, s) {
  if (s === "int32") {
    const i = Int32Array.from(t);
    return [e, "int32", i];
  }
  if (s === "bool") {
    const i = La([0], n), [r, o] = Gn((a, c) => a !== c ? 1 : 0)(e, [], t, i, "bool");
    return [o, "bool", r];
  }
  throw new Error(`Error in Cast: failed to cast ${n} to ${s}`);
}
function Oa(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { dtype: r } = s;
  if (r === "complex64") {
    if (i.dtype === "complex64")
      return ao({ inputs: { x: i }, backend: n });
    const u = Ky(n, i.shape, i.dtype), h = Oa({ inputs: { x: i }, backend: n, attrs: { dtype: "float32" } }), d = di({ inputs: { real: h, imag: u }, backend: n });
    return n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(h), d;
  }
  if (i.dtype === "complex64") {
    const u = qc({ inputs: { input: i }, backend: n }), h = Oa({ inputs: { x: u }, backend: n, attrs: { dtype: r } });
    return n.disposeIntermediateTensorInfo(u), h;
  }
  if (!q1(i.dtype, r)) {
    const u = ao({ inputs: { x: i }, backend: n });
    return { dataId: u.dataId, shape: u.shape, dtype: r };
  }
  const o = n.data.get(i.dataId).values, [a, c, l] = ED(o, i.shape, i.dtype, r);
  return n.makeTensorInfo(a, c, l);
}
const W9 = {
  kernelName: Gu,
  backendName: "cpu",
  kernelFunc: Oa
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ss(t, e, n, s) {
  return n == null ? ({ inputs: i, backend: r }) => {
    const { a: o, b: a } = i, c = r;
    nt([o, a], t);
    const l = c.data.get(o.dataId).values, u = c.data.get(a.dataId).values, h = o.dtype === "string" ? (
      // tslint:disable-next-line: no-any
      Fo(l)
    ) : l, d = o.dtype === "string" ? (
      // tslint:disable-next-line: no-any
      Fo(u)
    ) : u, f = s || o.dtype, [p, y] = e(o.shape, a.shape, h, d, f);
    return c.makeTensorInfo(y, f, p);
  } : ({ inputs: i, backend: r }) => {
    const { a: o, b: a } = i, c = r;
    if (o.dtype === "complex64" || a.dtype === "complex64") {
      const l = Oa({ inputs: { x: o }, backend: c, attrs: { dtype: "complex64" } }), u = c.data.get(l.dataId), h = u.complexTensorInfos.real, d = u.complexTensorInfos.imag, f = c.data.get(h.dataId).values, p = c.data.get(d.dataId).values, y = Oa({ inputs: { x: a }, backend: c, attrs: { dtype: "complex64" } }), g = c.data.get(y.dataId), m = g.complexTensorInfos.real, x = g.complexTensorInfos.imag, v = c.data.get(m.dataId).values, b = c.data.get(x.dataId).values, [w, S, _] = n(o.shape, a.shape, f, p, v, b), E = c.makeTensorInfo(_, "float32", w), I = c.makeTensorInfo(_, "float32", S), k = di({ inputs: { real: E, imag: I }, backend: c });
      return c.disposeIntermediateTensorInfo(l), c.disposeIntermediateTensorInfo(y), c.disposeIntermediateTensorInfo(E), c.disposeIntermediateTensorInfo(I), k;
    } else {
      const l = c.data.get(o.dataId).values, u = c.data.get(a.dataId).values, h = s || o.dtype, [d, f] = e(o.shape, a.shape, l, u, h);
      return c.makeTensorInfo(f, h, d);
    }
  };
}
function vT(t) {
  return (e, n, s, i, r, o) => {
    const a = bt(e, n), c = ue(a), l = a.length, u = ct(a), h = ls("float32", c), d = ls("float32", c), f = Vc(e, a), p = Vc(n, a), y = Lo(s, i), g = Lo(r, o), m = e.length, x = ct(e), v = n.length, b = ct(n);
    if (f.length + p.length === 0)
      for (let w = 0; w < h.length; w++) {
        const S = w % y.length, _ = w % g.length, E = t(y[S * 2], y[S * 2 + 1], g[_ * 2], g[_ * 2 + 1]);
        h[w] = E.real, d[w] = E.imag;
      }
    else
      for (let w = 0; w < h.length; w++) {
        const S = Jc(w, l, u), _ = S.slice(-m);
        f.forEach((L) => _[L] = 0);
        const E = br(_, m, x), I = S.slice(-v);
        p.forEach((L) => I[L] = 0);
        const k = br(I, v, b), M = t(y[E * 2], y[E * 2 + 1], g[k * 2], g[k * 2 + 1]);
        h[w] = M.real, d[w] = M.imag;
      }
    return [h, d, a];
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ND = Gn((t, e) => t + e), H9 = vT((t, e, n, s) => ({ real: t + n, imag: e + s })), Eu = ss(Qc, ND, H9), j9 = {
  kernelName: Qc,
  backendName: "cpu",
  kernelFunc: Eu
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wT(t, e, n, s, i) {
  const r = ue(s), o = vs(i, n);
  for (let a = 0; a < t.length; a++) {
    const c = t[a];
    if (c < 0)
      throw new Error("Input x must be non-negative!");
    c >= i || (r > 0 ? o[c] += e[a] : o[c] += 1);
  }
  return o;
}
function kD(t, e, n, s = !1) {
  const i = t.shape[0], r = t.shape[1], o = It([i, n], e.dtype);
  for (let a = 0; a < i; a++)
    for (let c = 0; c < r; c++) {
      const l = t.get(a, c);
      if (l < 0)
        throw new Error("Input x must be non-negative!");
      l >= n || (s ? o.set(1, a, l) : e.size > 0 ? o.set(o.get(a, l) + e.get(a, c), a, l) : o.set(o.get(a, l) + 1, a, l));
    }
  return o;
}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const AD = Gn((t, e) => t & e), q9 = ss(Hf, AD), X9 = {
  kernelName: Hf,
  backendName: "cpu",
  kernelFunc: q9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ho(t) {
  return (e, n, s) => {
    const i = $n(n, e.length);
    for (let r = 0; r < e.length; ++r)
      i[r] = t(e[r], s);
    return i;
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jt(t, e, n) {
  const s = ho(e);
  return Wa(t, s, n);
}
function Wa(t, e, n) {
  return ({ inputs: s, attrs: i, backend: r }) => {
    const { x: o } = s;
    nt(o, t);
    const a = r, c = a.data.get(o.dataId).values;
    let l;
    if (o.dtype === "string") {
      if (!Array.isArray(c))
        throw new Error("String tensor's value was not an instance of Array");
      l = Fo(c);
    } else
      l = c;
    const u = n || o.dtype, h = e(l, u, i);
    return a.makeTensorInfo(o.shape, u, h);
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const MD = ho((t) => Math.ceil(t)), K9 = Wa(Wu, MD), Y9 = {
  kernelName: Wu,
  backendName: "cpu",
  kernelFunc: K9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function RD(t, e, n, s) {
  const i = $n(n, ue(e));
  if (s && n !== "string") {
    let r = 0;
    t.forEach((o) => {
      const a = ue(o.shape);
      i.set(o.vals, r), r += a;
    });
  } else {
    let r = 0;
    t.forEach((o) => {
      const a = n === "string" ? Fo(o.vals) : o.vals;
      let c = 0;
      for (let l = 0; l < o.shape[0]; ++l) {
        const u = l * e[1] + r;
        for (let h = 0; h < o.shape[1]; ++h)
          i[u + h] = a[c++];
      }
      r += o.shape[1];
    });
  }
  return i;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const DD = Gn((t, e) => t === e ? 1 : 0), $D = ss(ep, DD, null, "bool"), Z9 = {
  kernelName: ep,
  backendName: "cpu",
  kernelFunc: $D
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const OD = ho((t) => Math.exp(t)), LD = Wa(Zu, OD, "float32"), J9 = {
  kernelName: Zu,
  backendName: "cpu",
  kernelFunc: LD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const FD = ho((t) => Math.expm1(t)), Q9 = Wa(Ju, FD), eY = {
  kernelName: Ju,
  backendName: "cpu",
  kernelFunc: Q9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const PD = ho((t) => Math.floor(t)), tY = Wa(Qu, PD), nY = {
  kernelName: Qu,
  backendName: "cpu",
  kernelFunc: tY
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const BD = Gn((t, e) => Math.floor(t / e)), sY = ss(eh, BD, null, "int32"), iY = {
  kernelName: eh,
  backendName: "cpu",
  kernelFunc: sY
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zD(t, e, n, s, i, r, o, a, c) {
  const l = It([s, r], n);
  for (let u = 0; u < s; u++) {
    const h = [];
    let d = 0;
    for (let f = 0; f < i; f++) {
      const p = t[u * i + f];
      d += p * o[f], h.push(p);
    }
    if (d < 0 || d >= c / r)
      throw new Error(`Invalid indices: ${h} does not index into ${a}`);
    for (let f = 0; f < r; f++)
      l.values[u * r + f] = e.get(...e.indexToLoc(d * r + f));
  }
  return l;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VD(t, e, n) {
  const s = It(n, t.dtype);
  for (let i = 0; i < s.size; ++i) {
    const o = s.indexToLoc(i).slice(), a = o[0], c = o[2], l = e.locToIndex([a, c]);
    o[2] = e.values[l];
    const u = t.locToIndex(o);
    0 <= u && u < t.values.length && (s.values[i] = t.values[u]);
  }
  return s;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const UD = Gn((t, e) => t > e ? 1 : 0), rY = ss(ip, UD, null, "bool"), oY = {
  kernelName: ip,
  backendName: "cpu",
  kernelFunc: rY
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const GD = Gn((t, e) => t >= e ? 1 : 0), aY = ss(th, GD, null, "bool"), cY = {
  kernelName: th,
  backendName: "cpu",
  kernelFunc: aY
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const WD = Gn((t, e) => t < e ? 1 : 0), lY = ss(op, WD, null, "bool"), uY = {
  kernelName: op,
  backendName: "cpu",
  kernelFunc: lY
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const HD = Gn((t, e) => t <= e ? 1 : 0), hY = ss(ap, HD, null, "bool"), dY = {
  kernelName: ap,
  backendName: "cpu",
  kernelFunc: hY
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jD(t, e, n) {
  const s = (e - t) / (n - 1), i = vs(n, "float32");
  i[0] = t;
  for (let r = 1; r < i.length; r++)
    i[r] = i[r - 1] + s;
  return i;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qD = ho((t) => Math.log(t)), fY = Wa(oh, qD), pY = {
  kernelName: oh,
  backendName: "cpu",
  kernelFunc: fY
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XD(t, e, n, s) {
  const i = ls(s, ue(n));
  for (let r = 0; r < i.length; ++r) {
    const o = r * e;
    let a = t[o];
    for (let c = 0; c < e; ++c) {
      const l = t[o + c];
      (Number.isNaN(l) || l > a) && (a = l);
    }
    i[r] = a;
  }
  return i;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KD = Gn((t, e) => Math.max(t, e)), mY = ss(ch, KD), gY = {
  kernelName: ch,
  backendName: "cpu",
  kernelFunc: mY
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const YD = Gn((t, e) => Math.min(t, e)), yY = ss(lh, YD), xY = {
  kernelName: lh,
  backendName: "cpu",
  kernelFunc: yY
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ST = Gn((t, e) => t * e), bY = vT((t, e, n, s) => ({
  real: t * n - e * s,
  imag: t * s + e * n
})), Ib = ss(hh, ST, bY), vY = {
  kernelName: hh,
  backendName: "cpu",
  kernelFunc: Ib
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ZD(t, e, n) {
  const s = Vo(-1, n);
  return ST([], e, s, t, n);
}
function wY(t) {
  const { inputs: e, backend: n } = t, { x: s } = e;
  nt(s, "neg");
  const i = n.data.get(s.dataId).values, [r, o] = ZD(i, s.shape, s.dtype);
  return n.makeTensorInfo(o, s.dtype, r);
}
const SY = {
  kernelName: xp,
  backendName: "cpu",
  kernelFunc: wY
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const JD = Gn((t, e) => t !== e ? 1 : 0), _Y = ss(bp, JD, null, "bool"), TY = {
  kernelName: bp,
  backendName: "cpu",
  kernelFunc: _Y
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _T(t, e, n, s, i) {
  const r = e.length, o = ue(e), a = ct(e), c = ct(i), l = ls(n, ue(i));
  for (let u = 0; u < o; ++u) {
    const h = Jc(u, r, a), d = new Array(h.length);
    for (let p = 0; p < d.length; p++)
      d[p] = h[s[p]];
    const f = br(d, r, c);
    l[f] = t[u];
  }
  return l;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oi(t) {
  const { inputs: e, attrs: n, backend: s } = t, { x: i } = e, { perm: r } = n;
  nt(i, "transpose");
  const o = i.shape.length, a = new Array(o);
  for (let h = 0; h < a.length; h++)
    a[h] = i.shape[r[h]];
  const c = s.data.get(i.dataId).values, l = _T(c, i.shape, i.dtype, r, a);
  return { dataId: s.write(l, a, i.dtype), shape: a, dtype: i.dtype };
}
const CY = {
  kernelName: wc,
  backendName: "cpu",
  kernelFunc: oi
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function QD(t, e, n, s) {
  const [i, r] = ds(t, s), o = ni(e, "int32"), a = vs(ue(i), o), c = ue(r);
  for (let l = 0; l < a.length; ++l) {
    const u = l * c;
    let h = 1;
    for (let d = 0; d < c; ++d)
      h *= n[u + d];
    a[l] = h;
  }
  return { outVals: a, outShape: i, outDtype: o };
}
function IY(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, keepDims: o } = s;
  nt(i, "prod");
  const a = i.shape.length, c = Rt(r, i.shape), l = An(c, a);
  let u = c, h = i;
  const d = [];
  l != null && (h = oi({ inputs: { x: i }, backend: n, attrs: { perm: l } }), d.push(h), u = Vn(u.length, a));
  const f = n.data.get(h.dataId).values, { outVals: p, outShape: y, outDtype: g } = QD(h.shape, h.dtype, f, u);
  let m = y;
  return o && (m = zn(y, c)), d.forEach((x) => n.disposeIntermediateTensorInfo(x)), n.makeTensorInfo(m, g, p);
}
const EY = {
  kernelName: Cp,
  backendName: "cpu",
  kernelFunc: IY
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NY(t, e, n) {
  t.forEach((s, i) => {
    if (s < 0 || s >= n) {
      const r = Jc(i, e.length, ct(e)).join(",");
      throw new Error(`indices[${r}] = ${s} is not in [0, ${n})`);
    }
  });
}
function kY(t, e) {
  for (let n = 0; n < t.length; ++n) {
    const s = t[n], i = n === t.length - 1 ? e : t[n + 1].length;
    if (s.length === 0)
      throw new Error("Ragged splits may not be empty");
    if (s[0] < 0)
      throw new Error("Ragged splits must be non-negative");
    if (s[s.length - 1] > i)
      throw new Error("Ragged splits must not point past values");
    for (let r = 1; r < s.length; ++r)
      if (s[r - 1] > s[r])
        throw new Error("Ragged splits must be sorted in ascending order");
  }
}
function AY(t, e, n, s) {
  const i = [];
  let r = 0;
  const o = e.length - 1 + n.length, a = new Array(o).fill(null).map(() => [0]);
  kY(n, s);
  let c = 1;
  for (let l = 0; l < e.length - 1; ++l) {
    c *= e[l];
    const u = e[l + 1];
    for (let h = 1; h < c + 1; ++h)
      a[l].push(h * u);
  }
  for (let l = 0; l < t.length; ++l) {
    let u = t[l], h = t[l] + 1;
    for (let d = 0; d < n.length; ++d) {
      const f = n[d], p = d + e.length - 1;
      if (p >= 0) {
        const y = a[p], g = y[y.length - 1] - f[u];
        for (let m = u; m < h; ++m)
          a[p].push(f[m + 1] + g);
      }
      u = f[u], h = f[h];
    }
    h !== u && (i.push([u, h]), r += h - u);
  }
  return { outSplits: a, valueSlices: i, numValues: r };
}
function MY(t) {
  const e = [];
  for (let n = 0; n < t.length; ++n) {
    const s = t[n].length, i = $n("int32", s);
    e.push(i), t[n].forEach((r, o) => i[o] = r);
  }
  return e;
}
function NI(t, e) {
  const n = t.slice(0, e);
  for (; n.length < e; )
    n.push(1);
  for (let s = e; s < t.length; s++)
    n[e - 1] *= t[s];
  return n;
}
function RY(t, e, n, s, i, r) {
  const o = NI(e, 2)[1], a = NI(r, 2)[1];
  let c = 0;
  for (const l of n)
    for (let u = l[0]; u < l[1]; ++u) {
      for (let h = 0; h < s; ++h)
        i[c * a + h] = t[u * o + h];
      ++c;
    }
}
function DY(t, e, n, s, i) {
  const r = e.slice();
  r[0] = i;
  const o = $n(n, ue(r)), a = t.length, c = a === 0 ? 0 : a / e[0];
  return RY(t, e, s, c, o, r), [o, r];
}
function e$(t, e, n, s, i, r, o, a) {
  if (t.length === 0)
    throw new Error("paramsNestedSplits must be non empty");
  if (e[0].length === 0)
    throw new Error("Split tensors must not be scalars");
  const c = e[0][0] - 1;
  if (NY(r, o, c), s.length === 0)
    throw new Error("params.rank must be nonzero");
  const l = s[0], { outSplits: u, valueSlices: h, numValues: d } = AY(r, o, t, l), f = MY(u), p = DY(n, s, i, h, d);
  return [f, p[0], p[1]];
}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kI = 2147483647;
function t$(t, e, n, s, i, r, o) {
  if (e.length > 1)
    throw new Error("starts must be a scalar or vector");
  if (i.length > 1)
    throw new Error("limits must be a scalar or vector");
  if (o.length > 1)
    throw new Error("deltas must be a scalar or vector");
  const a = e.length === 0, c = i.length === 0, l = o.length === 0, u = [];
  a || u.push(e[0]), c || u.push(i[0]), l || u.push(o[0]);
  for (let g = 1; g < u.length; ++g)
    if (u[g] !== u[g - 1])
      throw new Error("starts, limits, and deltas must have the same shape");
  const h = u.length === 0 ? 1 : u[0], d = $n("int32", h + 1);
  d[0] = 0;
  for (let g = 0; g < h; ++g) {
    const m = a ? t[0] : t[g], x = c ? s[0] : s[g], v = l ? r[0] : r[g];
    if (v === 0)
      throw new Error("Requires delta != 0");
    let b;
    if (v > 0 && x < m || v < 0 && x > m)
      b = 0;
    else if (b = Math.ceil(Math.abs((x - m) / v)), b > kI)
      throw new Error(`Requires ((limit - start) / delta) <= ${kI}`);
    d[g + 1] = d[g] + b;
  }
  const f = d[h], p = $n(n, f);
  let y = 0;
  for (let g = 0; g < h; ++g) {
    const m = d[g + 1] - d[g];
    let x = a ? t[0] : t[g];
    const v = l ? r[0] : r[g];
    for (let b = 0; b < m; ++b)
      p[y++] = x, x += v;
  }
  return [d, p];
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Ui = mr;
class Yy {
  constructor(e, n, s, i, r, o, a, c, l, u) {
    this.shape = e, this.shapeShape = n, this.values = s, this.valuesShape = i, this.valuesDType = r, this.defaultValue = o, this.defaultValueShape = a, this.rowPartitionValues = c, this.rowPartitionValuesShapes = l, this.rowPartitionTypes = OA(u), this.raggedRank = LA(this.rowPartitionTypes);
  }
  getRowPartitionTypeByDimension(e) {
    return this.rowPartitionTypes[0] === Ui.FIRST_DIM_SIZE ? this.rowPartitionTypes[e + 1] : this.rowPartitionTypes[e];
  }
  // Returns the relationship between dimension and dimension + 1.
  getRowPartitionTensor(e) {
    return this.rowPartitionTypes[0] === Ui.FIRST_DIM_SIZE ? this.rowPartitionValues[e + 1] : this.rowPartitionValues[e];
  }
  getMaxWidth(e) {
    const n = this.getRowPartitionTensor(e - 1);
    switch (this.getRowPartitionTypeByDimension(e - 1)) {
      case Ui.VALUE_ROWIDS:
        return Yy.getMaxWidthValueRowID(n);
      case Ui.ROW_SPLITS:
        return Yy.getMaxWidthRowSplit(n);
      default:
        throw new Error(`Cannot handle partition type ${Ui[this.getRowPartitionTypeByDimension(e - 1)]}`);
    }
  }
  static getMaxWidthRowSplit(e) {
    const n = e.length;
    if (n === 0 || n === 1)
      return 0;
    let s = 0;
    for (let i = 0; i < n - 1; ++i) {
      const r = e[i + 1] - e[i];
      r > s && (s = r);
    }
    return s;
  }
  static getMaxWidthValueRowID(e) {
    const n = e.length;
    if (n === 0)
      return 0;
    let s = 0, i = e[0], r = 0;
    for (let o = 1; o < n; ++o) {
      const a = e[o];
      a !== i && (i = a, r = Math.max(o - s, r), s = o);
    }
    return Math.max(n - s, r);
  }
  tensorShapeFromTensor(e, n, s = !0) {
    if (n.length === 0) {
      if (e[0] === -1)
        return [];
      throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.");
    }
    return MI(e, s);
  }
  calculateOutputSize(e) {
    const n = this.valuesShape, s = this.defaultValueShape;
    FA(s, n);
    const i = this.tensorShapeFromTensor(this.shape, this.shapeShape), o = $A(this.raggedRank, i, n);
    o[0] < 0 && (o[0] = e);
    for (let a = 1; a <= this.raggedRank; ++a)
      o[a] < 0 && (o[a] = this.getMaxWidth(a));
    return o;
  }
  /**
   * The outputIndex represents the index in the output tensor
   * where the first element of a particular dimension would be written.
   * If it is -1, it indicates that the index is out of scope.
   * Example, given firstDimension = 10, firstDimensionOutput = 6,
   * and outputIndexMultiplier = 100:
   * result = [0 100 200 300 400 500 -1 -1 -1 -1]
   * If firstDimensionOutput = 11 instead, then:
   * result = [0 100 200 300 400 500 600 700 800 900]
   */
  calculateFirstParentOutputIndex(e, n, s) {
    const i = Math.min(e, s), r = [];
    let o = 0;
    for (let a = 0; a < i; ++a, o += n)
      r.push(o);
    for (let a = i; a < e; ++a)
      r.push(-1);
    return A(r.length === e, () => "Final length of result must be equal to firstDimension."), r;
  }
  calculateOutputIndexRowSplit(e, n, s, i) {
    const r = e.length, o = [];
    for (let a = 0; a < r - 1; ++a) {
      const c = e[a + 1] - e[a];
      let l = Math.min(i, c), u = n[a];
      u === -1 && (l = 0);
      for (let h = 0; h < l; ++h)
        o.push(u), u += s;
      for (let h = 0; h < c - l; ++h)
        o.push(-1);
    }
    if (r > 0 && o.length !== e[r - 1])
      throw new Error("Invalid row split size.");
    return o;
  }
  // Calculate the output index of the first element of a list.
  // The parentOutputIndex is the same computation for the previous list.
  // -1 indicates an element or list that is out of range.
  // The outputIndexMultiplier is the number of output indices one moves
  // forward for each column.
  // E.g., given:
  // valueRowIds:[0 1 2 2 2 3 5 5 6]
  // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]
  // outputIndexMultiplier: 10
  // outputSize: 2
  // You get:
  // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]
  // result[0] = parentOutputIndex[valueRowIds[0]]
  // result[1] = parentOutputIndex[valueRowIds[1]]
  // result[2] = parentOutputIndex[valueRowIds[2]]
  // result[3] = parentOutputIndex[valueRowIds[2] + 10]
  // result[4] = -1 because it is the third element the size is 2.
  // result[5] = parentOutputIndex[valueRowIds[3]]
  // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1
  // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1
  // result[8] = parentOutputIndex[valueRowIds[7]]
  calculateOutputIndexValueRowID(e, n, s, i) {
    const r = e.length, o = [];
    if (r === 0)
      return [];
    let a = 0, c = e[0];
    if (c >= n.length)
      throw new Error(`Got currentValueRowId=${c}, which is not less than ${n.length}`);
    let l = n[c];
    o.push(l);
    for (let u = 1; u < r; ++u) {
      const h = e[u];
      if (h === c)
        l >= 0 && (++a, a < i ? l += s : l = -1);
      else {
        if (a = 0, c = h, h >= n.length)
          throw new Error(`Got nextValueRowId=${h} which is not less than ${n.length}`);
        l = n[h];
      }
      o.push(l);
    }
    if (o.length !== e.length)
      throw new Error("Invalid row ids.");
    return o;
  }
  calculateOutputIndex(e, n, s, i) {
    const r = this.getRowPartitionTensor(e), o = this.getRowPartitionTypeByDimension(e);
    switch (o) {
      case Ui.VALUE_ROWIDS:
        return this.calculateOutputIndexValueRowID(r, n, s, i);
      case Ui.ROW_SPLITS:
        if (r.length - 1 > n.length)
          throw new Error(`Row partition size is greater than output size: ${r.length - 1} > ${n.length}`);
        return this.calculateOutputIndexRowSplit(r, n, s, i);
      default:
        throw new Error(`Unsupported partition type: ${Ui[o]}`);
    }
  }
  getFirstDimensionSize() {
    const e = this.rowPartitionValues[0];
    if (this.rowPartitionTypes.length === 0)
      throw new Error("No row_partition_types given.");
    const n = this.rowPartitionTypes[0];
    switch (n) {
      case Ui.FIRST_DIM_SIZE:
        return e[0];
      case Ui.VALUE_ROWIDS:
        throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
      case Ui.ROW_SPLITS:
        return this.rowPartitionValuesShapes[0][0] - 1;
      default:
        throw new Error(`Cannot handle type ${Ui[n]}`);
    }
  }
  compute() {
    if (this.rowPartitionValues[0].length <= 0)
      throw new Error("Invalid first partition input. Tensor requires at least one element.");
    const n = this.getFirstDimensionSize(), s = this.calculateOutputSize(n), i = new Array(this.raggedRank + 1);
    i[i.length - 1] = 1;
    for (let c = i.length - 2; c >= 0; --c)
      i[c] = i[c + 1] * s[c + 1];
    const r = MI(s, !1), o = $n(this.valuesDType, ue(r));
    if (i[0] * s[0] > 0) {
      let c = this.calculateFirstParentOutputIndex(n, i[0], s[0]);
      for (let l = 1; l <= this.raggedRank; ++l)
        c = this.calculateOutputIndex(l - 1, c, i[l], s[l]);
      this.setOutput(this.raggedRank, c, o, r);
    }
    return [r, o];
  }
  setOutput(e, n, s, i) {
    if (s.length === 0)
      return;
    const r = this.values, o = s;
    let a = i.slice();
    a = a.slice(e + 1);
    const c = ue(a), l = n.length;
    let u = this.defaultValue;
    if (u.length !== c && u.length !== 1) {
      const p = this.defaultValueShape;
      Q(() => {
        const y = Y(u, p);
        u = Sc(y, a).dataSync();
      });
    }
    let h = 0, d = 0, f = 0;
    for (let p = 0; p <= l; ++p) {
      let y = p < l ? n[p] : -1;
      if (y === f) {
        ++f;
        continue;
      }
      if (d < f) {
        const g = r.subarray(h * c), m = o.subarray(d * c), x = (f - d) * c;
        AI(m, g, x);
      }
      if (p >= l) {
        const g = s.length;
        y = Math.floor(g / c);
      }
      if (y > f)
        if (this.defaultValue.length === 1)
          o.subarray(f * c, y * c).fill(this.defaultValue[0]), f = y;
        else
          for (; y > f; ) {
            const g = o.slice(f * c);
            AI(g, u, c), ++f;
          }
      y < 0 ? (h = p + 1, d = f) : (h = p, d = f, f = d + 1);
    }
  }
}
function AI(t, e, n) {
  for (let s = 0; s < n; s++)
    t[s] = e[s];
}
function MI(t, e) {
  const n = [];
  for (let s of t) {
    if (s < 0) {
      if (!e)
        throw new Error(`Dimension ${s} must be >= 0`);
      if (s < -1)
        throw new Error(`Dimension ${s} must be >= -1`);
      s = -1;
    }
    n.push(s);
  }
  return n;
}
function n$(t, e, n, s, i, r, o, a, c, l) {
  return new Yy(t, e, n, s, i, r, o, a, c, l).compute();
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s$(t, e, n, s) {
  const i = t === e, r = t < e && n < 0, o = e < t && n > 1;
  if (i || r || o)
    return vs(0, s);
  const a = Math.abs(Math.ceil((e - t) / n)), c = vs(a, s);
  e < t && n === 1 && (n = -1), c[0] = t;
  for (let l = 1; l < c.length; l++)
    c[l] = c[l - 1] + n;
  return c;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const i$ = ho((t) => 1 / Math.sqrt(t)), $Y = Wa(yh, i$), OY = {
  kernelName: yh,
  backendName: "cpu",
  kernelFunc: $Y
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yc(t, e, n, s, i, r, o, a, c, l) {
  const u = [s / i, i], h = t.values, d = e.values;
  if (s === 0)
    return It(n, e.dtype);
  const f = c instanceof Xn ? c : It(u, e.dtype);
  typeof c == "string" || typeof c == "number" ? f.values.fill(c) : typeof c == "boolean" && f.values.fill(+c);
  for (let p = 0; p < r; p++) {
    const y = [];
    let g = 0;
    for (let m = 0; m < o; m++) {
      const x = h[p * o + m];
      y.push(x), g += x * a[m];
    }
    if (g < 0 || g >= s / i)
      throw new Error(`Invalid indices: ${y} does not index into ${n}`);
    for (let m = 0; m < i; m++)
      l ? f.values[g * i + m] += d[p * i + m] : f.values[g * i + m] = e.rank === 0 ? d[0] : d[p * i + m];
  }
  return f;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const LY = ho((t) => 1 / (1 + Math.exp(-t))), r$ = Jt(Sh, (t) => 1 / (1 + Math.exp(-t))), FY = {
  kernelName: Sh,
  backendName: "cpu",
  kernelFunc: r$
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o$(t, e, n, s, i) {
  const r = N_(s, e, n), o = ue(n), a = ct(s);
  if (r) {
    const h = k_(e, a);
    return i === "string" ? t.slice(h, h + o) : t.subarray(h, h + o);
  }
  const c = i === "string" ? Fo(t) : t, l = It(s, i, c), u = It(n, i);
  for (let h = 0; h < u.size; ++h) {
    const d = u.indexToLoc(h), f = d.map((p, y) => p + e[y]);
    u.set(l.get(...f), ...d);
  }
  return i === "string" ? sM(u.values) : u.values;
}
function Xc(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { begin: r, size: o } = s;
  nt(i, "slice");
  const [a, c] = ub(i, r, o);
  I_(i, a, c);
  const l = n.data.get(i.dataId).values, u = o$(l, a, c, i.shape, i.dtype);
  return n.makeTensorInfo(c, i.dtype, u);
}
const PY = {
  kernelName: Mp,
  backendName: "cpu",
  kernelFunc: Xc
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function a$(t, e, n, s, i, r, o) {
  const a = e[0], c = r[0], l = new Array(c), u = new Array(a), h = e[1];
  if (c === 0) {
    if (a !== 0)
      throw new Error(WA(a));
    const g = $n(n, 0), m = $n(i, 0);
    return [
      g,
      [0, h],
      m,
      l,
      u
    ];
  }
  let d = !0, f = 0;
  const p = new Array(c).fill(0);
  for (let g = 0; g < a; ++g) {
    const m = t[g * h];
    if (m < 0)
      throw new Error(HA(g, m));
    if (m >= c)
      throw new Error(jA(g, m, c));
    ++p[m], d = d && m >= f, f = m;
  }
  let y = !0;
  for (let g = 0; g < c; ++g) {
    const m = p[g] === 0;
    l[g] = m, y = y && !m, p[g] = Math.max(p[g], 1), g > 0 && (p[g] += p[g - 1]);
  }
  if (y && d) {
    const g = t, m = s;
    for (let x = 0; x < a; ++x)
      u[x] = x;
    return [
      g,
      [a, h],
      m,
      l,
      u
    ];
  } else {
    const g = p[c - 1], m = $n(n, g * h), x = $n(i, g), v = new Array(c).fill(0);
    for (let b = 0; b < a; ++b) {
      const w = t[b * h], S = v[w], _ = (w === 0 ? 0 : p[w - 1]) + S;
      v[w]++;
      for (let E = 0; E < h; ++E)
        m[_ * h + E] = t[b * h + E];
      x[_] = s[b], u[b] = _;
    }
    for (let b = 0; b < c; ++b)
      if (v[b] === 0) {
        const S = b === 0 ? 0 : p[b - 1];
        m[S * h + 0] = b;
        for (let _ = 1; _ < h; ++_)
          m[S * h + _] = 0;
        x[S] = o;
      }
    return [
      m,
      [g, h],
      x,
      l,
      u
    ];
  }
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c$(t, e, n, s, i) {
  const r = ue(s), o = e[0], a = i.length, c = [];
  let l = 1, u = -1;
  for (let g = 0; g < a; ++g) {
    const m = i[g];
    if (m === -1) {
      if (u !== -1)
        throw new Error(qA(u, g));
      u = g, c.push(1);
    } else {
      if (m < 0)
        throw new Error(XA(g, m));
      l *= m, c.push(m);
    }
  }
  if (u !== -1) {
    if (l <= 0)
      throw new Error(KA());
    const g = Math.trunc(r / l);
    if (l * g !== r)
      throw new Error(YA(s, c));
    c[u] = g;
  }
  if (ue(c) !== r)
    throw new Error(ZA(s, c));
  const d = s.length, f = [];
  if (d > 0) {
    f[d - 1] = 1;
    for (let g = d - 2; g >= 0; --g)
      f[g] = f[g + 1] * s[g + 1];
  }
  const p = [];
  if (a > 0) {
    p[a - 1] = 1;
    for (let g = a - 2; g >= 0; --g)
      p[g] = p[g + 1] * c[g + 1];
  }
  const y = $n(n, o * a);
  for (let g = 0; g < o; ++g) {
    let m = 0;
    for (let x = 0; x < d; ++x)
      m += t[g * d + x] * f[x];
    for (let x = 0; x < a; ++x)
      y[g * a + x] = Math.trunc(m / p[x]), m %= p[x];
  }
  return [y, [o, a], c];
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TT(t, e, n, s, i, r = !1, o = 0) {
  const a = s.length, c = [e[0], t.length / e[0]], l = c[1], h = a > 0 ? i[a - 1] + 1 : 0;
  if (h < 0)
    throw new Error(e1());
  const d = e.slice();
  d[0] = h;
  const f = d.reduce((v, b) => v * b, 1), p = $n(n, f);
  if (a === 0)
    return h > 0 && p.fill(o), [p, d];
  if (h <= 0)
    throw new Error(e1());
  let y = 0, g = 1, m = 0, x = i[y];
  for (; ; ) {
    let v = 0;
    if (g < a) {
      if (v = i[g], x === v) {
        ++g;
        continue;
      }
      if (x >= v)
        throw new Error(JA());
    }
    if (x < 0 || x >= h)
      throw new Error(QA(x, h));
    x > m && p.fill(o, m * l, x * l);
    for (let b = y; b < g; ++b) {
      const w = s[b];
      if (w < 0 || w >= c[0])
        throw new Error(eM(b, s[b], c[0]));
      for (let S = 0; S < l; S++)
        p[x * l + S] += t[w * l + S];
    }
    if (r)
      for (let b = 0; b < l; b++)
        p[x * l + b] /= g - y;
    if (y = g, ++g, m = x + 1, x = v, g > a)
      break;
  }
  return m < h && p.fill(o, m * l, h * l), [p, d];
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const BY = ho((t) => Math.sqrt(t)), zY = Jt(Th, (t) => Math.sqrt(t)), VY = {
  kernelName: Th,
  backendName: "cpu",
  kernelFunc: zY
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const l$ = Gn((t, e) => {
  const n = t - e;
  return n * n;
}), UY = ss(Ch, l$), GY = {
  kernelName: Ch,
  backendName: "cpu",
  kernelFunc: UY
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const u$ = ho((t, e) => {
  const { pattern: n, replaceGlobal: s, rewrite: i } = e;
  return t.replace(new RegExp(n, s ? "g" : ""), i);
}), WY = Wa(Lp, u$), HY = {
  kernelName: Lp,
  backendName: "cpu",
  kernelFunc: WY
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function h$(t, e, n, s) {
  const i = It(t, e.dtype);
  for (let r = 0; r < i.size; r++) {
    const o = i.indexToLoc(r), a = new Array(o.length);
    for (let c = 0; c < a.length; c++)
      a[c] = o[c] * n[c] + s[c];
    i.set(e.get(...a), ...o);
  }
  return i;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class jY {
  constructor(e, n, s, i, r, o) {
    this.separator = jr(e), this.nGramWidths = n, this.leftPad = jr(s), this.rightPad = jr(i), this.padWidth = r, this.preserveShort = o;
  }
  getPadWidth(e) {
    return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1);
  }
  getNumNGrams(e, n) {
    const s = this.getPadWidth(n);
    return Math.max(0, e + 2 * s - n + 1);
  }
  createNGrams(e, n, s, i, r, o) {
    for (let a = 0; a < r; ++a) {
      const c = this.getPadWidth(o), l = Math.max(0, c - a), u = Math.max(0, c - (r - (a + 1))), h = o - (l + u), d = n + (l > 0 ? 0 : a - c);
      let f = 0;
      f += l * this.leftPad.length;
      for (let x = 0; x < h; ++x)
        f += e[d + x].length;
      f += u * this.rightPad.length;
      const p = l + u + h - 1;
      f += p * this.separator.length, s[i + a] = new Uint8Array(f);
      const y = s[i + a];
      let g = 0;
      const m = (x) => x.forEach((v) => y[g++] = v);
      for (let x = 0; x < l; ++x)
        m(this.leftPad), m(this.separator);
      for (let x = 0; x < h - 1; ++x)
        m(e[d + x]), m(this.separator);
      if (h > 0) {
        m(e[d + h - 1]);
        for (let x = 0; x < u; ++x)
          m(this.separator), m(this.rightPad);
      } else {
        for (let x = 0; x < u - 1; ++x)
          m(this.rightPad), m(this.separator);
        m(this.rightPad);
      }
    }
  }
  // Data and splits together form the definition of the ragged tensor,
  // where data is 1 dimensional and contains the values of the tensor
  // and splits denotes the indices at which each row starts.
  compute(e, n) {
    const s = e.length, i = n.length;
    if (i > 0) {
      let c = n[0];
      if (c !== 0)
        throw new Error(`First split value must be 0, got ${c}`);
      for (let l = 1; l < i; ++l) {
        let u = n[l] >= c;
        if (u = u && n[l] <= s, !u)
          throw new Error(`Invalid split value ${n[l]}, must be in [${c}, ${s}]`);
        c = n[l];
      }
      if (c !== s)
        throw new Error(`Last split value must be data size. Expected ${s}, got ${c}`);
    }
    const r = i - 1, o = $n("int32", i);
    if (s === 0 || i === 0) {
      const c = new Array(s);
      for (let l = 0; l <= r; ++l)
        o[l] = 0;
      return [c, o];
    }
    o[0] = 0;
    for (let c = 1; c <= r; ++c) {
      const l = n[c] - n[c - 1];
      let u = 0;
      this.nGramWidths.forEach((h) => {
        u += this.getNumNGrams(l, h);
      }), this.preserveShort && l > 0 && u === 0 && (u = 1), o[c] = o[c - 1] + u;
    }
    const a = new Array(o[r]);
    for (let c = 0; c < r; ++c) {
      const l = n[c];
      let u = o[c];
      if (this.nGramWidths.forEach((h) => {
        const d = n[c + 1] - n[c], f = this.getNumNGrams(d, h);
        this.createNGrams(e, l, a, u, f, h), u += f;
      }), this.preserveShort && u === o[c]) {
        const h = n[c + 1] - n[c];
        if (h === 0)
          continue;
        const d = h + 2 * this.padWidth, f = 1;
        this.createNGrams(e, l, a, u, f, d);
      }
    }
    return [a, o];
  }
}
function d$(t, e, n, s, i, r, o, a) {
  return new jY(n, s, i, r, o, a).compute(t, e);
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qY(t, e, n, s) {
  if (!t.length)
    return;
  if (e.length === 0) {
    for (let r = 0; r < t.length; ++r)
      s.push(t.subarray(r, r + 1));
    return;
  }
  if (e.length === 1) {
    const r = e[0];
    let o = t.indexOf(r);
    for (; o !== -1; ) {
      const a = t.subarray(0, o);
      (!n || a.length !== 0) && s.push(a), t = t.subarray(o + 1), o = t.indexOf(r);
    }
    (!n || t.length !== 0) && s.push(t);
    return;
  }
  let i = 0;
  for (let r = 0; r < t.length + 1; r++)
    if (r === t.length || e.indexOf(t[r]) !== -1) {
      const o = t.subarray(i, r);
      (!n || o.length !== 0) && s.push(o), i = r + 1;
    }
}
function f$(t, e, n) {
  const s = t.length, i = [];
  let r = 0, o = 0;
  const a = new Array(s);
  for (let d = 0; d < s; ++d) {
    const f = i.length;
    qY(t[d], e, n, i);
    const p = i.length - f;
    a[d] = p, r += p, o = Math.max(o, p);
  }
  const c = $n("int32", r * 2), l = new Array(r), u = [s, o];
  let h = 0;
  for (let d = 0; d < s; ++d)
    for (let f = 0; f < a[d]; ++f)
      c[h * 2] = d, c[h * 2 + 1] = f, l[h] = i[h], ++h;
  return [c, l, u];
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function p$(t, e) {
  const n = $n("int32", t.length);
  for (let s = 0; s < t.length; ++s)
    n[s] = WN(t[s]).modulo(e).getLowBitsUnsigned();
  return n;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const m$ = Gn((t, e) => t - e), XY = vT((t, e, n, s) => ({ real: t - n, imag: e - s })), CT = ss(Ih, m$, XY), KY = {
  kernelName: Ih,
  backendName: "cpu",
  kernelFunc: CT
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function g$(t, e) {
  const n = new Array(t.rank);
  for (let i = 0; i < n.length; i++)
    n[i] = t.shape[i] * e[i];
  const s = It(n, t.dtype);
  for (let i = 0; i < s.values.length; ++i) {
    const r = s.indexToLoc(i), o = new Array(t.rank);
    for (let c = 0; c < o.length; c++)
      o[c] = r[c] % t.shape[c];
    const a = t.locToIndex(o);
    s.values[i] = t.values[a];
  }
  return s;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const md = (t, e) => {
  const n = e.value - t.value;
  return n === 0 ? t.index - e.index : n;
};
function y$(t, e, n = 0, s = t.length - 1) {
  for (; s > n; ) {
    if (s - n > 600) {
      const a = s - n + 1, c = e - n + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), h = 0.5 * Math.sqrt(l * u * (a - u) / a) * Math.sign(c - a / 2), d = Math.max(n, Math.floor(e - c * u / a + h)), f = Math.min(s, Math.floor(e + (a - c) * u / a + h));
      y$(t, e, d, f);
    }
    const i = t[e];
    let r = n, o = s;
    for (To(t, n, e), md(t[s], i) > 0 && To(t, n, s); r < o; ) {
      for (To(t, r, o), r++, o--; md(t[r], i) < 0; )
        r = r + 1;
      for (; md(t[o], i) > 0; )
        o = o - 1;
    }
    md(t[n], i) === 0 ? To(t, n, o) : (o = o + 1, To(t, o, s)), o <= e && (n = o + 1), e <= o && (s = o - 1);
  }
}
function x$(t, e, n, s, i) {
  const r = e[e.length - 1], [o, a] = [t.length / r, r], c = ls(n, o * s), l = ls("int32", o * s);
  for (let h = 0; h < o; h++) {
    const d = h * a, f = t.subarray(d, d + a);
    let p = new Array(f.length);
    f.forEach((x, v) => p[v] = { value: x, index: v }), s < p.length && (y$(p, s), p = p.slice(0, s)), i && p.sort(md);
    const y = h * s, g = c.subarray(y, y + s), m = l.subarray(y, y + s);
    for (let x = 0; x < s; x++)
      g[x] = p[x].value, m[x] = p[x].index;
  }
  const u = e.slice();
  return u[u.length - 1] = s, [
    It(u, n, c),
    It(u, "int32", l)
  ];
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function b$(t, e, n, s) {
  const i = Rt(e, n)[0], r = [1, n[0], 1];
  for (let p = 0; p < i; p++)
    r[0] *= n[p];
  r[1] = n[i];
  for (let p = i + 1; p < n.length; p++)
    r[2] *= n[p];
  const o = /* @__PURE__ */ new Map(), a = new Int32Array(n[i]), c = new Xn(r, s, t), l = [], u = r[0] === 1 && r[2] === 1;
  for (let p = 0; p < n[i]; p++) {
    let y;
    if (u)
      y = t[p].toString();
    else {
      const m = [];
      for (let x = 0; x < r[0]; x++)
        for (let v = 0; v < r[2]; v++)
          m.push(c.get(x, p, v));
      y = m.join(",");
    }
    const g = o.get(y);
    if (g != null)
      a[p] = g;
    else {
      const m = o.size;
      o.set(y, m), a[p] = m, l.push(p);
    }
  }
  const h = r.slice();
  h[1] = o.size;
  const d = new Xn(h, s);
  l.forEach((p, y) => {
    for (let g = 0; g < r[0]; g++)
      for (let m = 0; m < r[2]; m++)
        d.set(c.get(g, p, m), g, y, m);
  });
  const f = n.slice();
  return f[i] = h[1], {
    outputValues: d.values,
    outputShape: f,
    indices: a
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const YY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addImpl: ND,
  bincountImpl: wT,
  bincountReduceImpl: kD,
  bitwiseAndImpl: AD,
  castImpl: ED,
  ceilImpl: MD,
  concatImpl: RD,
  equalImpl: DD,
  expImpl: OD,
  expm1Impl: FD,
  floorDivImpl: BD,
  floorImpl: PD,
  gatherNdImpl: zD,
  gatherV2Impl: VD,
  greaterEqualImpl: GD,
  greaterImpl: UD,
  lessEqualImpl: HD,
  lessImpl: WD,
  linSpaceImpl: jD,
  logImpl: qD,
  maxImpl: XD,
  maximumImpl: KD,
  minimumImpl: YD,
  multiplyImpl: ST,
  negImpl: ZD,
  notEqualImpl: JD,
  prodImpl: QD,
  raggedGatherImpl: e$,
  raggedRangeImpl: t$,
  raggedTensorToTensorImpl: n$,
  rangeImpl: s$,
  rsqrtImpl: i$,
  scatterImpl: yc,
  sigmoidImpl: LY,
  simpleAbsImpl: ID,
  sliceImpl: o$,
  sparseFillEmptyRowsImpl: a$,
  sparseReshapeImpl: c$,
  sparseSegmentReductionImpl: TT,
  sqrtImpl: BY,
  squaredDifferenceImpl: l$,
  staticRegexReplaceImpl: u$,
  stridedSliceImpl: h$,
  stringNGramsImpl: d$,
  stringSplitImpl: f$,
  stringToHashBucketFastImpl: p$,
  subImpl: m$,
  tileImpl: g$,
  topKImpl: x$,
  transposeImpl: _T,
  uniqueImpl: b$
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
sS(
  "cpu",
  () => new Cb(),
  1
  /* priority */
);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const v$ = Jt(Ku, (t) => t >= 0 ? t : Math.exp(t) - 1), ZY = {
  kernelName: Ku,
  backendName: "cpu",
  kernelFunc: v$
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function w$(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { alpha: r } = s;
  nt([i], "leakyRelu");
  const o = ue(i.shape), a = n.data.get(i.dataId).values, c = ls("float32", o);
  for (let l = 0; l < a.length; l++)
    c[l] = a[l] < 0 ? r * a[l] : a[l];
  return n.makeTensorInfo(i.shape, "float32", c);
}
const JY = {
  kernelName: rp,
  backendName: "cpu",
  kernelFunc: w$
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const QY = Gn((t, e) => t < 0 ? e * t : t);
function S$(t) {
  const { inputs: e, backend: n } = t, { x: s, alpha: i } = e;
  nt([s, i], "prelu");
  const r = n.data.get(s.dataId).values, o = n.data.get(i.dataId).values, [a, c] = QY(s.shape, i.shape, r, o, "float32");
  return n.makeTensorInfo(c, "float32", a);
}
const eZ = {
  kernelName: Tp,
  backendName: "cpu",
  kernelFunc: S$
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _$ = Jt(ph, (t) => Math.max(0, t)), tZ = {
  kernelName: ph,
  backendName: "cpu",
  kernelFunc: _$
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const T$ = Jt(mh, (t) => Math.min(Math.max(0, t), 6)), nZ = {
  kernelName: mh,
  backendName: "cpu",
  kernelFunc: T$
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zy(t, e, n, s, i) {
  if (n === "linear")
    return ao({ inputs: { x: e }, backend: t });
  if (n === "relu")
    return _$({ inputs: { x: e }, backend: t });
  if (n === "elu")
    return v$({ inputs: { x: e }, backend: t });
  if (n === "relu6")
    return T$({ inputs: { x: e }, backend: t });
  if (n === "prelu")
    return S$({ inputs: { x: e, alpha: s }, backend: t });
  if (n === "leakyrelu")
    return w$({ inputs: { x: e }, backend: t, attrs: { alpha: i } });
  if (n === "sigmoid")
    return r$({ inputs: { x: e }, backend: t });
  throw new Error(`Activation ${n} has not been implemented for the CPU backend.`);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fn(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { shape: r } = s, o = ue(i.shape), a = j1(r, o), c = ue(a);
  A(o === c, () => `The new shape (${a}) has ${c} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`), n.incRef(i.dataId);
  const l = n.data.get(i.dataId);
  if (l.complexTensorInfos != null) {
    const u = l.complexTensorInfos.real, h = l.complexTensorInfos.imag;
    u.shape = a, h.shape = a;
  }
  return { dataId: i.dataId, shape: a, dtype: i.dtype };
}
const sZ = {
  kernelName: Ip,
  backendName: "cpu",
  kernelFunc: fn
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function C$(t) {
  const { inputs: e, backend: n, attrs: s } = t, { a: i, b: r } = e, { transposeA: o, transposeB: a } = s;
  nt([i, r], "matMul");
  const c = i.shape.length, l = r.shape.length, u = o ? i.shape[c - 2] : i.shape[c - 1], h = a ? r.shape[l - 1] : r.shape[l - 2], d = o ? i.shape[c - 1] : i.shape[c - 2], f = a ? r.shape[l - 2] : r.shape[l - 1], p = i.shape.slice(0, -2), y = r.shape.slice(0, -2), g = ue(p), m = ue(y), v = bt(i.shape.slice(0, -2), r.shape.slice(0, -2)).concat([d, f]);
  A(u === h, () => `Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${i.shape} and ${r.shape} and transposeA=${o} and transposeB=${a} must match.`);
  const b = o ? [g, u, d] : [g, d, u], w = a ? [m, f, h] : [m, h, f], S = fn({ inputs: { x: i }, backend: n, attrs: { shape: b } }), _ = fn({ inputs: { x: r }, backend: n, attrs: { shape: w } }), E = o ? S.shape[1] : S.shape[2], I = o ? S.shape[2] : S.shape[1], k = a ? _.shape[1] : _.shape[2], M = Math.max(g, m), L = n.data.get(S.dataId).values, O = n.data.get(_.dataId).values, $ = ct(S.shape), D = ct(_.shape), [z, W, j] = o ? [$[0], 1, $[1]] : [$[0], $[1], 1], [J, ne, re] = a ? [1, D[1], D[0]] : [D[1], 1, D[0]], fe = I * k, ae = It([M, I, k], S.dtype), ve = ae.values, me = n.blockSize;
  for (let te = 0; te < M; te++) {
    const $e = te % g, _e = te % m;
    for (let ke = 0; ke < I; ke += me) {
      const Re = Math.min(ke + me, I);
      for (let ce = 0; ce < k; ce += me) {
        const xe = Math.min(ce + me, k);
        for (let we = 0; we < E; we += me) {
          const Pe = Math.min(we + me, E);
          for (let Me = ke; Me < Re; Me++)
            for (let Ge = ce; Ge < xe; Ge++) {
              let F = 0;
              for (let V = we; V < Pe; V++) {
                const Ae = (
                  // tslint:disable-next-line: max-line-length
                  L[$e * z + Me * W + V * j]
                ), ge = (
                  // tslint:disable-next-line: max-line-length
                  O[V * J + Ge * ne + _e * re]
                );
                F += Ae * ge;
              }
              ve[te * fe + (Me * k + Ge)] += F;
            }
        }
      }
    }
  }
  return n.disposeIntermediateTensorInfo(S), n.disposeIntermediateTensorInfo(_), n.makeTensorInfo(v, ae.dtype, ae.values);
}
const iZ = {
  kernelName: Gf,
  backendName: "cpu",
  kernelFunc: C$
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rZ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { a: i, b: r, bias: o, preluActivationWeights: a } = e, { transposeA: c, transposeB: l, activation: u, leakyreluAlpha: h } = s;
  let d, f, p;
  const y = [];
  d = C$({ inputs: { a: i, b: r }, attrs: { transposeA: c, transposeB: l }, backend: n }), o && (f = Eu({ inputs: { a: d, b: o }, backend: n }), y.push(d), d = f), u && (p = Zy(n, d, u, a, h), y.push(d), d = p);
  for (const m of y)
    n.disposeIntermediateTensorInfo(m);
  return d;
}
const oZ = {
  kernelName: hf,
  backendName: "cpu",
  kernelFunc: rZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const aZ = Jt(Lu, (t) => Math.acos(t)), cZ = {
  kernelName: Lu,
  backendName: "cpu",
  kernelFunc: aZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const lZ = Jt(Fu, (t) => Math.acosh(t)), uZ = {
  kernelName: Fu,
  backendName: "cpu",
  kernelFunc: lZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hZ(t) {
  const { inputs: e, backend: n } = t, s = e;
  nt(e, "addN");
  const i = s.map((a) => n.data.get(a.dataId).values), r = It(s[0].shape, s[0].dtype), o = r.values;
  for (let a = 0; a < s.length; a++) {
    const c = i[a];
    for (let l = 0; l < o.length; l++)
      o[l] += c[l];
  }
  return n.makeTensorInfo(r.shape, r.dtype, r.values);
}
const dZ = {
  kernelName: Pf,
  backendName: "cpu",
  kernelFunc: hZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fZ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, keepDims: o } = s;
  nt(i, "all");
  const a = Rt(r, i.shape);
  let c = a;
  const l = An(c, i.shape.length);
  let u = i;
  l != null && (u = oi({ inputs: { x: i }, backend: n, attrs: { perm: l } }), c = Vn(c.length, i.shape.length)), _s("all", c, u.shape.length);
  const [h, d] = ds(u.shape, c), f = ue(d), p = vs(ue(h), u.dtype), y = n.data.get(u.dataId).values;
  for (let m = 0; m < p.length; ++m) {
    const x = m * f;
    let v = y[x];
    for (let b = 0; b < f; ++b) {
      const w = y[x + b];
      v = v && w;
    }
    p[m] = v;
  }
  l != null && n.disposeIntermediateTensorInfo(u);
  const g = n.makeTensorInfo(h, u.dtype, p);
  if (o) {
    const m = zn(h, a), x = fn({ inputs: { x: g }, backend: n, attrs: { shape: m } });
    return n.disposeIntermediateTensorInfo(g), x;
  }
  return g;
}
const pZ = {
  kernelName: xx,
  backendName: "cpu",
  kernelFunc: fZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mZ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, keepDims: o } = s;
  nt(i, "any");
  const a = Rt(r, i.shape);
  let c = a;
  const l = An(c, i.shape.length);
  let u = i;
  l != null && (u = oi({ inputs: { x: i }, backend: n, attrs: { perm: l } }), c = Vn(c.length, i.shape.length)), _s("any", c, u.shape.length);
  const [h, d] = ds(u.shape, c), f = ue(d), p = vs(ue(h), u.dtype), y = n.data.get(u.dataId).values;
  for (let m = 0; m < p.length; ++m) {
    const x = m * f;
    let v = y[x];
    for (let b = 0; b < f; ++b) {
      const w = y[x + b];
      v = v || w;
    }
    p[m] = v;
  }
  l != null && n.disposeIntermediateTensorInfo(u);
  const g = n.makeTensorInfo(h, u.dtype, p);
  if (o) {
    const m = zn(h, a), x = fn({ inputs: { x: g }, backend: n, attrs: { shape: m } });
    return n.disposeIntermediateTensorInfo(g), x;
  }
  return g;
}
const gZ = {
  kernelName: bx,
  backendName: "cpu",
  kernelFunc: mZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yZ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r } = s;
  nt(i, "argMax");
  let o = Rt(r, i.shape);
  const a = An(o, i.shape.length);
  let c = i;
  const l = [];
  a != null && (c = oi({ inputs: { x: i }, backend: n, attrs: { perm: a } }), l.push(c), o = Vn(o.length, c.shape.length)), o = [o[0]], _s("argMax", o, c.shape.length);
  const [u, h] = ds(c.shape, o), d = ue(u), f = vs(d, "int32"), p = ue(h), y = n.data.get(c.dataId).values;
  for (let g = 0; g < f.length; ++g) {
    const m = g * p;
    let x = y[m], v = 0;
    for (let b = 0; b < p; ++b) {
      const w = y[m + b];
      w > x && (x = w, v = b);
    }
    f[g] = v;
  }
  return l.forEach((g) => n.disposeIntermediateTensorInfo(g)), n.makeTensorInfo(u, "int32", f);
}
const xZ = {
  kernelName: Bf,
  backendName: "cpu",
  kernelFunc: yZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bZ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r } = s;
  nt(i, "argMin");
  let o = Rt(r, i.shape);
  const a = An(o, i.shape.length);
  let c = i;
  const l = [];
  a != null && (c = oi({ inputs: { x: i }, backend: n, attrs: { perm: a } }), l.push(c), o = Vn(o.length, c.shape.length)), o = [o[0]], _s("argMin", o, c.shape.length);
  const [u, h] = ds(c.shape, o), d = ue(u), f = vs(d, "int32"), p = ue(h), y = n.data.get(c.dataId).values;
  for (let g = 0; g < f.length; ++g) {
    const m = g * p;
    let x = y[m], v = 0;
    for (let b = 0; b < p; ++b) {
      const w = y[m + b];
      w < x && (x = w, v = b);
    }
    f[g] = v;
  }
  return l.forEach((g) => n.disposeIntermediateTensorInfo(g)), n.makeTensorInfo(u, "int32", f);
}
const vZ = {
  kernelName: zf,
  backendName: "cpu",
  kernelFunc: bZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const wZ = Jt(Pu, (t) => Math.asin(t)), SZ = {
  kernelName: Pu,
  backendName: "cpu",
  kernelFunc: wZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _Z = Jt(Bu, (t) => Math.asinh(t)), TZ = {
  kernelName: Bu,
  backendName: "cpu",
  kernelFunc: _Z
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const CZ = Jt(zu, (t) => Math.atan(t)), IZ = {
  kernelName: zu,
  backendName: "cpu",
  kernelFunc: CZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const EZ = Gn((t, e) => Math.atan2(t, e)), NZ = ss(Uu, EZ), kZ = {
  kernelName: Uu,
  backendName: "cpu",
  kernelFunc: NZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const AZ = Jt(Vu, (t) => Math.atanh(t)), MZ = {
  kernelName: Vu,
  backendName: "cpu",
  kernelFunc: AZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function IT(t, e, n, s, i, r) {
  const o = i.strideHeight, a = i.strideWidth, c = i.dilationHeight, l = i.dilationWidth, u = i.effectiveFilterHeight, h = i.effectiveFilterWidth, d = i.padInfo.top, f = i.padInfo.left, p = r === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, y = It(i.outShape, n), g = y.values, m = i.outShape[1] * i.outShape[2] * i.outShape[3], x = i.outShape[2] * i.outShape[3], v = i.outShape[3];
  for (let b = 0; b < i.batchSize; ++b) {
    const w = b * m, S = b * s[0];
    for (let _ = 0; _ < i.inChannels; ++_)
      for (let E = 0; E < i.outHeight; ++E) {
        const I = E * o - d, k = Math.max(0, I), M = Math.min(i.inHeight, u + I), L = w + E * x;
        for (let O = 0; O < i.outWidth; ++O) {
          const $ = O * a - f, D = Math.max(0, $), z = Math.min(i.inWidth, h + $);
          let W = p, j = 0, J = 0;
          for (let re = k; re < M; re += c) {
            const fe = S + re * s[1];
            for (let ae = D; ae < z; ae += l) {
              const ve = fe + ae * s[2], me = t[ve + _];
              r === "max" && me > W ? W = me : r === "avg" && (j += me, J++);
            }
            if (isNaN(W))
              break;
          }
          const ne = L + O * v + _;
          g[ne] = r === "avg" ? j / J : W;
        }
      }
  }
  return y;
}
function I$(t, e, n, s, i = !1, r = !1) {
  const o = It(s.outShape, "int32"), a = s.strideHeight, c = s.strideWidth, l = s.dilationHeight, u = s.dilationWidth, h = s.effectiveFilterHeight, d = s.effectiveFilterWidth, f = s.padInfo.top, p = s.padInfo.left, y = It(e, n, t);
  for (let g = 0; g < s.batchSize; ++g)
    for (let m = 0; m < s.inChannels; ++m)
      for (let x = 0; x < s.outHeight; ++x) {
        const v = x * a - f;
        let b = v;
        for (; b < 0; )
          b += l;
        const w = Math.min(s.inHeight, h + v);
        for (let S = 0; S < s.outWidth; ++S) {
          const _ = S * c - p;
          let E = _;
          for (; E < 0; )
            E += u;
          const I = Math.min(s.inWidth, d + _);
          let k = Number.NEGATIVE_INFINITY, M = -1;
          for (let L = b; L < w; L += l) {
            const O = L - v;
            for (let $ = E; $ < I; $ += u) {
              const D = $ - _, z = y.get(g, L, $, m);
              z > k && (k = z, i ? M = r ? ((g * s.inHeight + L) * s.inWidth + $) * s.inChannels + m : (L * s.inWidth + $) * s.inChannels + m : M = O * d + D);
            }
          }
          o.set(M, g, x, S, m);
        }
      }
  return o;
}
function E$(t, e, n, s, i, r) {
  const o = i.strideDepth, a = i.strideHeight, c = i.strideWidth, l = i.dilationDepth, u = i.dilationHeight, h = i.dilationWidth, d = i.effectiveFilterDepth, f = i.effectiveFilterHeight, p = i.effectiveFilterWidth, y = i.padInfo.front, g = i.padInfo.top, m = i.padInfo.left, x = r === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, v = It(i.outShape, n), b = v.values, w = i.outShape[1] * i.outShape[2] * i.outShape[3] * i.outShape[4], S = i.outShape[2] * i.outShape[3] * i.outShape[4], _ = i.outShape[3] * i.outShape[4], E = i.outShape[4];
  for (let I = 0; I < i.batchSize; ++I) {
    const k = I * w, M = I * s[0];
    for (let L = 0; L < i.inChannels; ++L)
      for (let O = 0; O < i.outDepth; ++O) {
        const $ = O * o - y;
        let D = $;
        for (; D < 0; )
          D += l;
        const z = Math.min(i.inDepth, d + $), W = k + O * S;
        for (let j = 0; j < i.outHeight; ++j) {
          const J = j * a - g;
          let ne = J;
          for (; ne < 0; )
            ne += u;
          const re = Math.min(i.inHeight, f + J), fe = W + j * _;
          for (let ae = 0; ae < i.outWidth; ++ae) {
            const ve = ae * c - m;
            let me = ve;
            for (; me < 0; )
              me += h;
            const te = Math.min(i.inWidth, p + ve), $e = fe + ae * E;
            let _e = x, ke = 0, Re = 0;
            for (let xe = D; xe < z; xe += l) {
              const we = M + xe * s[1];
              for (let Pe = ne; Pe < re; Pe += u) {
                const Me = we + Pe * s[2];
                for (let Ge = me; Ge < te; Ge += h) {
                  const F = Me + Ge * s[3], V = t[F + L];
                  if (r === "max" && V > _e ? _e = V : r === "avg" && (ke += V, Re++), isNaN(_e))
                    break;
                }
                if (isNaN(_e))
                  break;
              }
              if (isNaN(_e))
                break;
            }
            const ce = $e + L;
            b[ce] = r === "avg" ? ke / Math.max(Re, 1) : _e;
          }
        }
      }
  }
  return v;
}
function RZ(t, e) {
  const n = It(e.outShape, "int32"), s = e.strideDepth, i = e.strideHeight, r = e.strideWidth, o = e.dilationDepth, a = e.dilationHeight, c = e.dilationWidth, l = e.effectiveFilterDepth, u = e.effectiveFilterHeight, h = e.effectiveFilterWidth, d = e.padInfo.front, f = e.padInfo.top, p = e.padInfo.left;
  for (let y = 0; y < e.batchSize; ++y)
    for (let g = 0; g < e.inChannels; ++g)
      for (let m = 0; m < e.outDepth; ++m) {
        const x = m * s - d;
        let v = x;
        for (; v < 0; )
          v += o;
        const b = Math.min(e.inDepth, l + x);
        for (let w = 0; w < e.outHeight; ++w) {
          const S = w * i - f;
          let _ = S;
          for (; _ < 0; )
            _ += a;
          const E = Math.min(e.inHeight, u + S);
          for (let I = 0; I < e.outWidth; ++I) {
            const k = I * r - p;
            let M = k;
            for (; M < 0; )
              M += c;
            const L = Math.min(e.inWidth, h + k);
            let O = Number.NEGATIVE_INFINITY, $ = -1;
            for (let D = v; D < b; D += o) {
              const z = D - x;
              for (let W = _; W < E; W += a) {
                const j = W - S;
                for (let J = M; J < L; J += c) {
                  const ne = J - k, re = t.get(y, D, W, J, g);
                  re >= O && (O = re, $ = z * u * h + j * u + ne);
                }
              }
            }
            n.set($, y, m, w, I, g);
          }
        }
      }
  return n;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DZ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e;
  nt(i, "avgPool");
  const { filterSize: r, strides: o, pad: a, dimRoundingMode: c } = s, l = 1;
  A(Ss(o, l), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);
  const u = ir(i.shape, r, o, l, a, c);
  let h;
  if (u.filterWidth === 1 && u.filterHeight === 1 && Bt(u.inShape, u.outShape))
    h = ao({ inputs: { x: i }, backend: n });
  else {
    const d = n.data.get(i.dataId).values, f = ct(i.shape), p = IT(d, i.shape, i.dtype, f, u, "avg");
    h = n.makeTensorInfo(u.outShape, i.dtype, p.values);
  }
  return h;
}
const $Z = {
  kernelName: Vf,
  backendName: "cpu",
  kernelFunc: DZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OZ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { filterSize: r, strides: o, pad: a, dimRoundingMode: c, dataFormat: l } = s;
  nt(i, "avgPool3d");
  const u = Uo(i.shape, r, o, 1, a, c, l), h = n.data.get(i.dataId).values, d = E$(h, i.shape, i.dtype, ct(i.shape), u, "avg");
  return n.makeTensorInfo(d.shape, "float32", d.values);
}
const LZ = {
  kernelName: Uf,
  backendName: "cpu",
  kernelFunc: OZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FZ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, input: r } = e, { filterSize: o, strides: a, pad: c, dimRoundingMode: l } = s;
  nt([i, r], "avgPool3DGrad");
  const u = Uo(r.shape, o, a, 1, c, l), h = u.strideDepth, d = u.strideHeight, f = u.strideWidth, p = u.filterDepth, y = u.filterHeight, g = u.filterWidth, m = u.dilationDepth, x = u.dilationHeight, v = u.dilationWidth, b = u.effectiveFilterDepth, w = u.effectiveFilterHeight, S = u.effectiveFilterWidth, _ = b - 1 - u.padInfo.front, E = S - 1 - u.padInfo.left, I = w - 1 - u.padInfo.top, k = It(r.shape, "float32"), M = 1 / (p * y * g), L = n.bufferSync(i);
  for (let O = 0; O < u.batchSize; ++O)
    for (let $ = 0; $ < u.inChannels; ++$)
      for (let D = 0; D < u.inDepth; ++D)
        for (let z = 0; z < u.inHeight; ++z)
          for (let W = 0; W < u.inWidth; ++W) {
            const j = D - _, J = z - I, ne = W - E;
            let re = 0;
            for (let fe = 0; fe < b; fe += m) {
              const ae = (j + fe) / h;
              if (!(ae < 0 || ae >= u.outDepth || Math.floor(ae) !== ae))
                for (let ve = 0; ve < w; ve += x) {
                  const me = (J + ve) / d;
                  if (!(me < 0 || me >= u.outHeight || Math.floor(me) !== me))
                    for (let te = 0; te < S; te += v) {
                      const $e = (ne + te) / f;
                      if ($e < 0 || $e >= u.outWidth || Math.floor($e) !== $e)
                        continue;
                      const _e = L.get(O, ae, me, $e, $);
                      re += _e;
                    }
                }
            }
            k.set(re * M, O, D, z, W, $);
          }
  return n.makeTensorInfo(k.shape, k.dtype, k.values);
}
const PZ = {
  kernelName: wx,
  backendName: "cpu",
  kernelFunc: FZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BZ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, input: r } = e, o = r;
  nt([i, r], "avgPoolGrad");
  const { filterSize: a, strides: c, pad: l } = s, u = ir(o.shape, a, c, 1, l), h = u.strideHeight, d = u.strideWidth, f = u.filterHeight, p = u.filterWidth, y = u.dilationHeight, g = u.dilationWidth, m = u.effectiveFilterHeight, x = u.effectiveFilterWidth, v = x - 1 - u.padInfo.left, b = m - 1 - u.padInfo.top, w = It(o.shape, "float32"), S = 1 / (f * p), _ = n.data.get(i.dataId).values, E = It(i.shape, "float32", _);
  for (let I = 0; I < u.batchSize; ++I)
    for (let k = 0; k < u.inChannels; ++k)
      for (let M = 0; M < u.inHeight; ++M)
        for (let L = 0; L < u.inWidth; ++L) {
          const O = M - b, $ = L - v;
          let D = 0;
          for (let z = 0; z < m; z += y) {
            const W = (O + z) / h;
            if (!(W < 0 || W >= u.outHeight || Math.floor(W) !== W))
              for (let j = 0; j < x; j += g) {
                const J = ($ + j) / d;
                if (J < 0 || J >= u.outWidth || Math.floor(J) !== J)
                  continue;
                const ne = E.get(I, W, J, k);
                D += ne;
              }
          }
          w.set(D * S, I, M, L, k);
        }
  return n.makeTensorInfo(w.shape, w.dtype, w.values);
}
const zZ = {
  kernelName: vx,
  backendName: "cpu",
  kernelFunc: BZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VZ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, scale: r, offset: o, mean: a, variance: c } = e;
  A(a.shape.length === c.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), A(o == null || a.shape.length === o.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), A(r == null || a.shape.length === r.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks."), nt([i, a, c, r, o], "batchNorm");
  let { varianceEpsilon: l } = s;
  l == null && (l = 1e-3);
  const u = n.data.get(i.dataId).values, h = n.data.get(a.dataId).values, d = n.data.get(c.dataId).values, f = r ? n.data.get(r.dataId).values : new Float32Array([1]), p = o ? n.data.get(o.dataId).values : new Float32Array([0]), y = new Float32Array(u.length), g = p.length, m = f.length, x = d.length, v = h.length;
  let b = 0, w = 0, S = 0, _ = 0;
  for (let E = 0; E < u.length; ++E)
    y[E] = p[b++] + (u[E] - h[w++]) * f[S++] / Math.sqrt(d[_++] + l), b >= g && (b = 0), w >= v && (w = 0), S >= m && (S = 0), _ >= x && (_ = 0);
  return n.makeTensorInfo(i.shape, i.dtype, y);
}
const UZ = {
  kernelName: np,
  backendName: "cpu",
  kernelFunc: VZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GZ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { blockShape: r, crops: o } = s;
  nt([i], "batchToSpaceND");
  const a = r.reduce((m, x) => m * x), c = um(i.shape, r, a), l = hm(c.length, r.length), u = dm(i.shape, r, a), h = O_(o, r.length), d = L_(u, o, r.length), f = fn({ inputs: { x: i }, backend: n, attrs: { shape: c } }), p = oi({ inputs: { x: f }, backend: n, attrs: { perm: l } }), y = fn({ inputs: { x: p }, backend: n, attrs: { shape: u } }), g = Xc({
    inputs: { x: y },
    backend: n,
    attrs: { begin: h, size: d }
  });
  return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(y), g;
}
const WZ = {
  kernelName: Wf,
  backendName: "cpu",
  kernelFunc: GZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HZ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, weights: r } = e, { size: o } = s, a = n.data.get(i.dataId).values, c = n.data.get(r.dataId).values, l = wT(a, c, r.dtype, r.shape, o);
  return n.makeTensorInfo([o], r.dtype, l);
}
const jZ = {
  kernelName: Sx,
  backendName: "cpu",
  kernelFunc: HZ
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qZ(t) {
  const { inputs: e, backend: n } = t, { s0: s, s1: i } = e, r = n.data.get(s.dataId).values, o = n.data.get(i.dataId).values, a = bt(Array.from(r), Array.from(o));
  return n.makeTensorInfo([a.length], "int32", Int32Array.from(a));
}
const XZ = {
  kernelName: _x,
  backendName: "cpu",
  kernelFunc: qZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KZ = Jt(Hu, (t, e) => {
  const n = e;
  return t > n.clipValueMax ? n.clipValueMax : t < n.clipValueMin ? n.clipValueMin : t;
}), YZ = {
  kernelName: Hu,
  backendName: "cpu",
  kernelFunc: KZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ZZ = (t) => {
  const { x: e } = t.inputs, n = t.backend, s = new Float32Array(ue(e.shape)), i = n.data.get(e.dataId), r = i.complexTensorInfos.real, o = i.complexTensorInfos.imag, a = n.data.get(r.dataId).values, c = n.data.get(o.dataId).values;
  for (let l = 0; l < a.length; l++) {
    const u = a[l], h = c[l];
    s[l] = Math.hypot(u, h);
  }
  return n.makeOutput(s, e.shape, "float32");
}, JZ = {
  kernelName: jf,
  backendName: "cpu",
  kernelFunc: ZZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nu(t) {
  const { inputs: e, backend: n } = t, { input: s } = e, i = n.data.get(s.dataId).complexTensorInfos.imag, r = n.data.get(i.dataId).values;
  return n.makeTensorInfo(i.shape, i.dtype, r);
}
const QZ = {
  kernelName: Gx,
  backendName: "cpu",
  kernelFunc: Nu
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ku(t) {
  const { inputs: e, backend: n, attrs: s } = t, { axis: i } = s, r = Rt(i, e[0].shape)[0], o = e.map((y) => y.shape);
  R_(o, r);
  let a = Xr(e.map((y) => y.shape), r);
  if (ue(a) === 0)
    return n.makeTensorInfo(a, e[0].dtype, []);
  const c = e.filter((y) => ue(y.shape) > 0);
  if (c.length === 1)
    return ao({ inputs: { x: c[0] }, backend: n });
  if (c[0].dtype === "complex64") {
    const y = c.map((b) => qc({ inputs: { input: b }, backend: n })), g = c.map((b) => Nu({ inputs: { input: b }, backend: n })), m = ku({ inputs: y, backend: n, attrs: { axis: r } }), x = ku({ inputs: g, backend: n, attrs: { axis: r } }), v = di({ inputs: { real: m, imag: x }, backend: n });
    return y.forEach((b) => n.disposeIntermediateTensorInfo(b)), g.forEach((b) => n.disposeIntermediateTensorInfo(b)), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(x), v;
  }
  const l = c.map((y) => {
    const m = [-1, ue(y.shape.slice(r))];
    return fn({ inputs: { x: y }, backend: n, attrs: { shape: m } });
  }), u = l.map((y) => ({ vals: n.data.get(y.dataId).values, shape: y.shape }));
  a = Xr(
    l.map((y) => y.shape),
    1
    /* axis */
  );
  const h = l[0].shape[0] === 1, d = RD(u, a, e[0].dtype, h), f = Xr(c.map((y) => y.shape), r), p = n.makeTensorInfo(f, e[0].dtype, d);
  return l.forEach((y) => n.disposeIntermediateTensorInfo(y)), p;
}
const eJ = {
  kernelName: qf,
  backendName: "cpu",
  kernelFunc: ku
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function N$(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, filter: r } = e, { strides: o, pad: a, dataFormat: c, dilations: l, dimRoundingMode: u } = s;
  nt([i, r], "conv2d");
  const h = Go(c), d = hs(i.shape, r.shape, o, l, a, u, !1, h), f = d.filterHeight, p = d.filterWidth, y = d.dilationHeight, g = d.dilationWidth, m = d.padInfo.left, x = d.padInfo.top, v = d.dataFormat === "channelsLast", b = new Xn(d.outShape, i.dtype), w = ct(i.shape), S = ct(r.shape), _ = w[0], E = v ? w[1] : w[2], I = v ? w[2] : 1, k = v ? 1 : w[1], M = b.strides[0], L = v ? b.strides[1] : b.strides[2], O = v ? b.strides[2] : 1, $ = v ? 1 : b.strides[1], D = n.data.get(i.dataId).values, z = n.data.get(r.dataId).values, W = b.values;
  for (let j = 0; j < d.batchSize; ++j) {
    const J = j * _, ne = j * M;
    for (let re = 0; re < d.outHeight; ++re) {
      const fe = ne + re * L, ae = re * d.strideHeight - x;
      for (let ve = 0; ve < f; ++ve) {
        const me = ae + ve * y;
        if (me < 0 || me >= d.inHeight)
          continue;
        const te = ve * S[0], $e = J + me * E;
        for (let _e = 0; _e < d.outWidth; ++_e) {
          const ke = fe + _e * O, Re = _e * d.strideWidth - m;
          for (let ce = 0; ce < p; ++ce) {
            const xe = Re + ce * g;
            if (xe < 0 || xe >= d.inWidth)
              continue;
            const we = te + ce * S[1], Pe = $e + xe * I;
            let Me = we;
            for (let Ge = 0; Ge < d.inChannels; ++Ge) {
              const F = D[Pe + Ge * k];
              for (let V = 0; V < d.outChannels; ++V)
                W[ke + V * $] += F * z[Me + V];
              Me += d.outChannels;
            }
          }
        }
      }
    }
  }
  return n.makeTensorInfo(b.shape, b.dtype, W);
}
const tJ = {
  kernelName: Xf,
  backendName: "cpu",
  kernelFunc: N$
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, dy: r } = e, { strides: o, pad: a, dataFormat: c, dimRoundingMode: l, filterShape: u } = s;
  nt([i, r], "conv2dBackpropFilter");
  const h = Go(c), d = hs(i.shape, u, o, 1, a, l, !1, h), { strideHeight: f, strideWidth: p, filterHeight: y, filterWidth: g } = d, m = d.dataFormat === "channelsLast", x = new Xn(d.filterShape, "float32"), v = d.padInfo.left, b = d.padInfo.top, w = n.data.get(i.dataId).values, S = n.data.get(r.dataId).values, _ = new Xn(i.shape, i.dtype, w), E = new Xn(r.shape, r.dtype, S);
  for (let I = 0; I < y; ++I) {
    const k = Math.max(0, Math.ceil((b - I) / f)), M = Math.min(d.outHeight, (d.inHeight + b - I) / f);
    for (let L = 0; L < g; ++L) {
      const O = Math.max(0, Math.ceil((v - L) / p)), $ = Math.min(d.outWidth, (d.inWidth + v - L) / p);
      for (let D = 0; D < d.inChannels; ++D)
        for (let z = 0; z < d.outChannels; ++z) {
          let W = 0;
          for (let j = 0; j < d.batchSize; ++j)
            for (let J = k; J < M; ++J) {
              const ne = I + J * f - b;
              for (let re = O; re < $; ++re) {
                const fe = L + re * p - v;
                m ? W += _.get(j, ne, fe, D) * E.get(j, J, re, z) : W += _.get(j, D, ne, fe) * E.get(j, z, J, re);
              }
            }
          x.set(W, I, L, D, z);
        }
    }
  }
  return n.makeTensorInfo(x.shape, x.dtype, x.values);
}
const sJ = {
  kernelName: Cx,
  backendName: "cpu",
  kernelFunc: nJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, filter: r } = e, { inputShape: o, strides: a, pad: c, dataFormat: l, dimRoundingMode: u } = s;
  nt([i, r], "conv2dBackpropInput");
  const h = ct(r.shape), d = ct(i.shape);
  let f = Go(l);
  const p = hs(o, r.shape, a, 1, c, u, !1, f), y = new Xn(p.inShape, "float32"), g = y.values, m = n.data.get(i.dataId).values, x = n.data.get(r.dataId).values, [v, b, w] = h, { batchSize: S, filterHeight: _, filterWidth: E, inChannels: I, inHeight: k, inWidth: M, outChannels: L, outHeight: O, outWidth: $, strideHeight: D, strideWidth: z } = p;
  f = p.dataFormat;
  const W = _ - 1 - p.padInfo.top, j = E - 1 - p.padInfo.left, J = f === "channelsLast", ne = y.strides[0], re = J ? y.strides[1] : y.strides[2], fe = J ? y.strides[2] : 1, ae = J ? 1 : y.strides[1], ve = d[0], me = J ? d[1] : d[2], te = J ? d[2] : 1, $e = J ? 1 : d[1];
  for (let _e = 0; _e < S; ++_e)
    for (let ke = 0; ke < I; ++ke)
      for (let Re = 0; Re < k; ++Re) {
        const ce = Re - W, xe = Math.max(0, Math.ceil(ce / D)), we = Math.min(O, (_ + ce) / D);
        for (let Pe = 0; Pe < M; ++Pe) {
          const Me = Pe - j, Ge = Math.max(0, Math.ceil(Me / z)), F = Math.min($, (E + Me) / z);
          let V = 0;
          for (let ge = xe; ge < we; ++ge) {
            const ee = ge * D - ce;
            for (let De = Ge; De < F; ++De) {
              const Fe = De * z - Me, tt = ve * _e + me * ge + te * De, X = v * (_ - 1 - ee) + b * (E - 1 - Fe) + w * ke;
              for (let pe = 0; pe < L; ++pe) {
                const Oe = m[tt + $e * pe], Ie = x[X + pe];
                V += Oe * Ie;
              }
            }
          }
          const Ae = ne * _e + re * Re + fe * Pe + ae * ke;
          g[Ae] = V;
        }
      }
  return n.makeTensorInfo(y.shape, y.dtype, y.values);
}
const rJ = {
  kernelName: Kf,
  backendName: "cpu",
  kernelFunc: iJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, filter: r } = e, { strides: o, pad: a, dilations: c } = s;
  nt([i, r], "conv3d");
  const l = Pa(i.shape, r.shape, o, c, a), { filterDepth: u, filterHeight: h, filterWidth: d, dilationDepth: f, dilationHeight: p, dilationWidth: y, padInfo: g } = l, m = g.front, x = g.left, v = g.top, b = new Xn(l.outShape, i.dtype), w = n.data.get(i.dataId).values, S = n.data.get(r.dataId).values, _ = b.values, E = ct(i.shape), I = ct(r.shape);
  for (let k = 0; k < l.batchSize; ++k) {
    const M = k * E[0], L = k * b.strides[0];
    for (let O = 0; O < l.outDepth; ++O) {
      const $ = L + O * b.strides[1], D = O * l.strideDepth - m;
      for (let z = 0; z < u; ++z) {
        const W = D + z * f;
        if (W < 0 || W >= l.inDepth)
          continue;
        const j = z * I[0], J = M + W * E[1];
        for (let ne = 0; ne < l.outHeight; ++ne) {
          const re = $ + ne * b.strides[2], fe = ne * l.strideHeight - v;
          for (let ae = 0; ae < h; ++ae) {
            const ve = fe + ae * p;
            if (ve < 0 || ve >= l.inHeight)
              continue;
            const me = j + ae * I[1], te = J + ve * E[2];
            for (let $e = 0; $e < l.outWidth; ++$e) {
              const _e = re + $e * l.outChannels, ke = $e * l.strideWidth - x;
              for (let Re = 0; Re < d; ++Re) {
                const ce = ke + Re * y;
                if (ce < 0 || ce >= l.inWidth)
                  continue;
                const xe = me + Re * I[2], we = te + ce * l.inChannels;
                let Pe = xe;
                for (let Me = 0; Me < l.inChannels; ++Me) {
                  const Ge = w[we + Me];
                  for (let F = 0; F < l.outChannels; ++F)
                    _[_e + F] += Ge * S[Pe + F];
                  Pe += l.outChannels;
                }
              }
            }
          }
        }
      }
    }
  }
  return n.makeTensorInfo(b.shape, b.dtype, b.values);
}
const aJ = {
  kernelName: Yf,
  backendName: "cpu",
  kernelFunc: oJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, dy: r } = e, { strides: o, pad: a, filterShape: c } = s;
  nt([i, r], "conv3dBackpropFilterV2");
  const l = ct(i.shape), u = ct(r.shape), h = Pa(i.shape, c, o, 1, a), d = h.strideDepth, f = h.strideHeight, p = h.strideWidth, y = h.filterDepth, g = h.filterHeight, m = h.filterWidth, x = new Xn(h.filterShape, "float32"), v = x.values, [b, w, S, _] = x.strides, E = n.data.get(r.dataId).values, [I, k, M, L] = u, O = n.data.get(i.dataId).values, [$, D, z, W] = l, j = h.padInfo.front, J = h.padInfo.left, ne = h.padInfo.top;
  for (let re = 0; re < y; ++re) {
    const fe = Math.max(0, Math.ceil((j - re) / d)), ae = Math.min(h.outDepth, (h.inDepth + j - re) / d), ve = re * b;
    for (let me = 0; me < g; ++me) {
      const te = Math.max(0, Math.ceil((ne - me) / f)), $e = Math.min(h.outHeight, (h.inHeight + ne - me) / f), _e = me * w + ve;
      for (let ke = 0; ke < m; ++ke) {
        const Re = Math.max(0, Math.ceil((J - ke) / p)), ce = Math.min(h.outWidth, (h.inWidth + J - ke) / p), xe = ke * S + _e;
        for (let we = 0; we < h.inChannels; ++we) {
          const Pe = we * _ + xe;
          for (let Me = 0; Me < h.outChannels; ++Me) {
            let Ge = 0;
            for (let F = 0; F < h.batchSize; ++F) {
              const V = F * $, Ae = F * I;
              for (let ge = fe; ge < ae; ++ge) {
                const De = (re + ge * d - j) * D + V, Fe = ge * k + Ae;
                for (let tt = te; tt < $e; ++tt) {
                  const pe = (me + tt * f - ne) * z + De, Oe = tt * M + Fe;
                  for (let Ie = Re; Ie < ce; ++Ie) {
                    const Ue = (ke + Ie * p - J) * W + pe, Ke = Ie * L + Oe;
                    Ge += O[Ue + we] * E[Ke + Me];
                  }
                }
              }
            }
            v[Pe + Me] = Ge;
          }
        }
      }
    }
  }
  return n.makeTensorInfo(x.shape, x.dtype, x.values);
}
const lJ = {
  kernelName: Ix,
  backendName: "cpu",
  kernelFunc: cJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, filter: r } = e, { pad: o, strides: a, inputShape: c } = s;
  nt([i], "conv3dBackpropInputV2");
  const l = ct(i.shape), u = ct(r.shape), h = Pa(c, r.shape, a, 1, o), d = new Xn(h.inShape, "float32"), f = d.values, [p, y, g, m] = d.strides, x = n.data.get(i.dataId).values, [v, b, w, S] = l, _ = n.data.get(r.dataId).values, [E, I, k, M] = u, { batchSize: L, filterDepth: O, filterHeight: $, filterWidth: D, inChannels: z, inDepth: W, inHeight: j, inWidth: J, outChannels: ne, outDepth: re, outHeight: fe, outWidth: ae, strideDepth: ve, strideHeight: me, strideWidth: te } = h, $e = O - 1 - h.padInfo.front, _e = $ - 1 - h.padInfo.top, ke = D - 1 - h.padInfo.left;
  for (let Re = 0; Re < L; ++Re)
    for (let ce = 0; ce < z; ++ce)
      for (let xe = 0; xe < W; ++xe) {
        const we = xe - $e, Pe = Math.max(0, Math.ceil(we / ve)), Me = Math.min(re, (O + we) / ve);
        for (let Ge = 0; Ge < j; ++Ge) {
          const F = Ge - _e, V = Math.max(0, Math.ceil(F / me)), Ae = Math.min(fe, ($ + F) / me);
          for (let ge = 0; ge < J; ++ge) {
            const ee = ge - ke, De = Math.max(0, Math.ceil(ee / te)), Fe = Math.min(ae, (D + ee) / te);
            let tt = 0;
            for (let X = Pe; X < Me; ++X) {
              const pe = X * ve - we;
              for (let Oe = V; Oe < Ae; ++Oe) {
                const Ie = Oe * me - F;
                for (let Be = De; Be < Fe; ++Be) {
                  const Ue = Be * te - ee, Ke = v * Re + b * X + w * Oe + S * Be, wt = E * (O - 1 - pe) + I * ($ - 1 - Ie) + k * (D - 1 - Ue) + M * ce;
                  for (let Yt = 0; Yt < ne; ++Yt) {
                    const St = x[Ke + Yt], Mr = _[wt + Yt];
                    tt += St * Mr;
                  }
                }
              }
            }
            f[p * Re + y * xe + g * Ge + m * ge + ce] = tt;
          }
        }
      }
  return n.makeTensorInfo(d.shape, d.dtype, d.values);
}
const hJ = {
  kernelName: Ex,
  backendName: "cpu",
  kernelFunc: uJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dJ = Jt(ju, (t) => Math.cos(t)), fJ = {
  kernelName: ju,
  backendName: "cpu",
  kernelFunc: dJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pJ = Jt(qu, (t) => Math.cosh(t)), mJ = {
  kernelName: qu,
  backendName: "cpu",
  kernelFunc: pJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { image: i, boxes: r, boxInd: o } = e, { cropSize: a, method: c, extrapolationValue: l } = s, [u, h, d, f] = i.shape, p = r.shape[0], [y, g] = a, m = It([p, y, g, f], "float32"), x = n.data.get(r.dataId).values, v = n.data.get(o.dataId).values, b = n.data.get(i.dataId).values, w = ct(i.shape), S = ct(m.shape);
  for (let _ = 0; _ < p; _++) {
    const E = _ * 4, I = x[E], k = x[E + 1], M = x[E + 2], L = x[E + 3], O = v[_];
    if (O >= u)
      continue;
    const $ = y > 1 ? (M - I) * (h - 1) / (y - 1) : 0, D = g > 1 ? (L - k) * (d - 1) / (g - 1) : 0;
    for (let z = 0; z < y; z++) {
      const W = y > 1 ? I * (h - 1) + z * $ : 0.5 * (I + M) * (h - 1);
      if (W < 0 || W > h - 1) {
        for (let j = 0; j < g; j++)
          for (let J = 0; J < f; J++) {
            const ne = J + j * S[2] + z * S[1] + _ * S[0];
            m.values[ne] = l;
          }
        continue;
      }
      if (c === "bilinear") {
        const j = Math.floor(W), J = Math.ceil(W), ne = W - j;
        for (let re = 0; re < g; re++) {
          const fe = g > 1 ? k * (d - 1) + re * D : 0.5 * (k + L) * (d - 1);
          if (fe < 0 || fe > d - 1) {
            for (let te = 0; te < f; te++) {
              const $e = te + re * S[2] + z * S[1] + _ * S[0];
              m.values[$e] = l;
            }
            continue;
          }
          const ae = Math.floor(fe), ve = Math.ceil(fe), me = fe - ae;
          for (let te = 0; te < f; te++) {
            let $e = te + ae * w[2] + j * w[1] + O * w[0];
            const _e = b[$e];
            $e = te + ve * w[2] + j * w[1] + O * w[0];
            const ke = b[$e];
            $e = te + ae * w[2] + J * w[1] + O * w[0];
            const Re = b[$e];
            $e = te + ve * w[2] + J * w[1] + O * w[0];
            const ce = b[$e], xe = _e + (ke - _e) * me, we = Re + (ce - Re) * me;
            $e = te + re * S[2] + z * S[1] + _ * S[0], m.values[$e] = xe + (we - xe) * ne;
          }
        }
      } else
        for (let j = 0; j < g; ++j) {
          const J = g > 1 ? k * (d - 1) + j * D : 0.5 * (k + L) * (d - 1);
          if (J < 0 || J > d - 1) {
            for (let fe = 0; fe < f; fe++) {
              const ae = fe + j * S[2] + z * S[1] + _ * S[0];
              m.values[ae] = l;
            }
            continue;
          }
          const ne = Math.round(J), re = Math.round(W);
          for (let fe = 0; fe < f; fe++) {
            const ae = fe + ne * w[2] + re * w[1] + O * w[0], ve = fe + j * S[2] + z * S[1] + _ * S[0];
            m.values[ve] = b[ae];
          }
        }
    }
  }
  return n.makeTensorInfo(m.shape, m.dtype, m.values);
}
const yJ = {
  kernelName: kx,
  backendName: "cpu",
  kernelFunc: gJ
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, exclusive: o, reverse: a } = s;
  nt(i, "cumprod");
  const c = An([r], i.shape.length);
  let l = i;
  c != null && (l = oi({ inputs: { x: i }, backend: n, attrs: { perm: c } }));
  const u = Vn(1, i.shape.length)[0];
  if (u !== l.shape.length - 1)
    throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length - 1} but got axis=${u}`);
  const h = ni(l.dtype, "int32"), d = yx(ue(l.shape), h), f = n.data.get(l.dataId).values, p = l.shape[l.shape.length - 1], y = a ? (m, x) => m + p - x - 1 : (m, x) => m + x;
  for (let m = 0; m < f.length; m += p)
    for (let x = 0; x < p; x++) {
      const v = y(m, x);
      if (x === 0)
        d[v] = o ? 1 : f[v];
      else {
        const b = y(m, x - 1);
        d[v] = o ? f[b] * d[b] : f[v] * d[b];
      }
    }
  const g = n.makeTensorInfo(l.shape, h, d);
  if (c != null) {
    const m = Ba(c), x = oi({ inputs: { x: g }, backend: n, attrs: { perm: m } });
    return n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(l), x;
  }
  return g;
}
const bJ = {
  kernelName: Nx,
  backendName: "cpu",
  kernelFunc: xJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, exclusive: o, reverse: a } = s;
  nt(i, "cumsum");
  const c = An([r], i.shape.length);
  let l = i;
  c != null && (l = oi({ inputs: { x: i }, backend: n, attrs: { perm: c } }));
  const u = Vn(1, i.shape.length)[0];
  if (u !== l.shape.length - 1)
    throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length - 1} but got axis=${u}`);
  const h = ni(l.dtype, "int32"), d = vs(ue(l.shape), h), f = n.data.get(l.dataId).values, p = l.shape[l.shape.length - 1], y = a ? (m, x) => m + p - x - 1 : (m, x) => m + x;
  for (let m = 0; m < f.length; m += p)
    for (let x = 0; x < p; x++) {
      const v = y(m, x);
      if (x === 0)
        d[v] = o ? 0 : f[v];
      else {
        const b = y(m, x - 1);
        d[v] = o ? f[b] + d[b] : f[v] + d[b];
      }
    }
  const g = n.makeTensorInfo(l.shape, h, d);
  if (c != null) {
    const m = Ba(c), x = oi({ inputs: { x: g }, backend: n, attrs: { perm: m } });
    return n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(l), x;
  }
  return g;
}
const wJ = {
  kernelName: Zf,
  backendName: "cpu",
  kernelFunc: vJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, weights: r } = e, { size: o, binaryOutput: a } = s;
  if (i.shape.length === 1) {
    const c = n.data.get(i.dataId).values, l = n.data.get(r.dataId).values, u = wT(c, l, r.dtype, r.shape, o);
    return n.makeTensorInfo([o], r.dtype, u);
  } else if (i.shape.length === 2) {
    const c = n.bufferSync(i), l = n.bufferSync(r), u = kD(c, l, o, a);
    return n.makeTensorInfo(u.shape, r.dtype, u.values);
  }
  throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`);
}
const _J = {
  kernelName: Ax,
  backendName: "cpu",
  kernelFunc: SJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { blockSize: r, dataFormat: o } = s;
  A(o === "NHWC", () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);
  const a = i.shape[0], c = i.shape[1], l = i.shape[2], u = i.shape[3], h = c * r, d = l * r, f = u / (r * r), p = n.data.get(i.dataId).values, y = new Float32Array(a * h * d * f);
  let g = 0;
  for (let m = 0; m < a; ++m)
    for (let x = 0; x < h; ++x) {
      const v = Math.floor(x / r), b = x % r;
      for (let w = 0; w < d; ++w) {
        const S = Math.floor(w / r), _ = w % r, E = (b * r + _) * f;
        for (let I = 0; I < f; ++I) {
          const M = I + E + u * (S + l * (v + c * m));
          y[g++] = p[M];
        }
      }
    }
  return n.makeTensorInfo([a, h, d, f], i.dtype, y);
}
const CJ = {
  kernelName: Mx,
  backendName: "cpu",
  kernelFunc: TJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function k$(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, filter: r } = e, { strides: o, pad: a, dilations: c, dimRoundingMode: l } = s;
  nt([i, r], "depthwiseConv2DNative");
  const u = ct(i.shape), h = ct(r.shape);
  let d = c;
  d == null && (d = [1, 1]), A(Ss(o, d), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);
  const f = hs(
    i.shape,
    r.shape,
    o,
    d,
    a,
    l,
    !0
    /* depthwise */
  ), { filterHeight: p, filterWidth: y, dilationHeight: g, dilationWidth: m, padInfo: x } = f, v = x.left, b = x.top, w = f.outChannels / f.inChannels, S = new Xn(f.outShape, i.dtype), _ = n.data.get(i.dataId).values, E = n.data.get(r.dataId).values, I = S.values;
  for (let k = 0; k < f.batchSize; ++k) {
    const M = k * u[0], L = k * S.strides[0];
    for (let O = 0; O < f.outHeight; ++O) {
      const $ = L + O * S.strides[1], D = O * f.strideHeight - b;
      for (let z = 0; z < p; ++z) {
        const W = D + z * g;
        if (W < 0 || W >= f.inHeight)
          continue;
        const j = z * h[0], J = M + W * u[1];
        for (let ne = 0; ne < f.outWidth; ++ne) {
          const re = $ + ne * S.strides[2], fe = ne * f.strideWidth - v;
          for (let ae = 0; ae < y; ++ae) {
            const ve = fe + ae * m;
            if (ve < 0 || ve >= f.inWidth)
              continue;
            const me = j + ae * h[1], te = J + ve * f.inChannels;
            let $e = re, _e = me;
            for (let ke = 0; ke < f.inChannels; ++ke) {
              const Re = _[te + ke];
              for (let ce = 0; ce < w; ++ce)
                I[$e + ce] += Re * E[_e + ce];
              $e += w, _e += w;
            }
          }
        }
      }
    }
  }
  return n.makeTensorInfo(S.shape, S.dtype, S.values);
}
const IJ = {
  kernelName: Jf,
  backendName: "cpu",
  kernelFunc: k$
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function EJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, dy: r } = e, { strides: o, dilations: a, pad: c, dimRoundingMode: l, filterShape: u } = s;
  nt([i, r], "depthwiseConv2dNativeBackpropFilter");
  const h = hs(
    i.shape,
    u,
    o,
    a,
    c,
    l,
    !0
    /* depthwise */
  ), { strideHeight: d, strideWidth: f, filterHeight: p, filterWidth: y } = h, g = new Xn(h.filterShape, "float32"), m = h.padInfo.left, x = h.padInfo.top, v = h.outChannels / h.inChannels, b = n.data.get(i.dataId).values, w = new Xn(i.shape, i.dtype, b), S = n.data.get(r.dataId).values, _ = new Xn(r.shape, r.dtype, S);
  for (let E = 0; E < p; ++E) {
    const I = Math.max(0, Math.ceil((x - E) / d)), k = Math.min(h.outHeight, (h.inHeight + x - E) / d);
    for (let M = 0; M < y; ++M) {
      const L = Math.max(0, Math.ceil((m - M) / f)), O = Math.min(h.outWidth, (h.inWidth + m - M) / f);
      for (let $ = 0; $ < h.outChannels; ++$) {
        const D = Math.trunc($ / v), z = $ % v;
        let W = 0;
        for (let j = 0; j < h.batchSize; ++j)
          for (let J = I; J < k; ++J) {
            const ne = E + J * d - x;
            for (let re = L; re < O; ++re) {
              const fe = M + re * f - m;
              W += w.get(j, ne, fe, D) * _.get(j, J, re, $);
            }
          }
        g.set(W, E, M, D, z);
      }
    }
  }
  return n.makeTensorInfo(g.shape, g.dtype, g.values);
}
const NJ = {
  kernelName: Rx,
  backendName: "cpu",
  kernelFunc: EJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, filter: r } = e, { strides: o, dilations: a, pad: c, dimRoundingMode: l, inputShape: u } = s;
  nt([i, r], "depthwiseConv2DNativeBackpropInput");
  const h = ct(i.shape), d = ct(r.shape), f = hs(
    u,
    r.shape,
    o,
    a,
    c,
    l,
    !0
    /* depthwise */
  ), p = new Xn(f.inShape, "float32"), y = p.values, [g, m, x] = p.strides, v = n.data.get(i.dataId).values, [b, w, S] = h, _ = n.data.get(r.dataId).values, [E, I, k] = d, { batchSize: M, filterHeight: L, filterWidth: O, inChannels: $, inHeight: D, inWidth: z, outChannels: W, outHeight: j, outWidth: J, strideHeight: ne, strideWidth: re } = f, fe = L - 1 - f.padInfo.top, ae = O - 1 - f.padInfo.left, ve = W / $;
  for (let me = 0; me < M; ++me)
    for (let te = 0; te < $; ++te)
      for (let $e = 0; $e < D; ++$e) {
        const _e = $e - fe, ke = Math.max(0, Math.ceil(_e / ne)), Re = Math.min(j, (L + _e) / ne);
        for (let ce = 0; ce < z; ++ce) {
          const xe = ce - ae, we = Math.max(0, Math.ceil(xe / re)), Pe = Math.min(J, (O + xe) / re);
          let Me = 0;
          for (let Ge = ke; Ge < Re; ++Ge) {
            const F = Ge * ne - _e;
            for (let V = we; V < Pe; ++V) {
              const Ae = V * re - xe, ge = b * me + w * Ge + S * V, ee = E * (L - 1 - F) + I * (O - 1 - Ae) + k * te;
              for (let De = 0; De < ve; ++De) {
                const Fe = te * ve + De, tt = v[ge + Fe], X = _[ee + De];
                Me += tt * X;
              }
            }
          }
          y[g * me + m * $e + x * ce + te] = Me;
        }
      }
  return n.makeTensorInfo(p.shape, p.dtype, p.values);
}
const AJ = {
  kernelName: Dx,
  backendName: "cpu",
  kernelFunc: kJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function MJ(t) {
  const { inputs: e, backend: n } = t, { x: s } = e, i = ue(s.shape), r = n.data.get(s.dataId).values, o = It([i, i], s.dtype), a = o.values;
  for (let l = 0; l < r.length; l++)
    a[l * i + l] = r[l];
  const c = [...s.shape, ...s.shape];
  return n.makeTensorInfo(c, o.dtype, o.values);
}
const RJ = {
  kernelName: $x,
  backendName: "cpu",
  kernelFunc: MJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const DJ = {
  kernelName: Qf,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, backend: e, attrs: n }) => {
    const { x: s, filter: i } = t, { strides: r, pad: o, dilations: a } = n, c = e, l = c.data.get(s.dataId).values, u = s.shape.length, h = c.data.get(i.dataId).values, d = i.shape.length, { batchSize: f, inHeight: p, inWidth: y, inChannels: g, outHeight: m, outWidth: x, padInfo: v, strideHeight: b, strideWidth: w, filterHeight: S, filterWidth: _, dilationHeight: E, dilationWidth: I, outShape: k } = Gp(s.shape, i.shape, r, o, "NHWC", a), M = ue(k), L = k.length, O = $n(s.dtype, M);
    for (let D = 0; D < f; ++D)
      for (let z = 0; z < m; ++z) {
        const W = z * b - v.top;
        for (let j = 0; j < x; ++j) {
          const J = j * w - v.left;
          for (let ne = 0; ne < g; ++ne) {
            let re = Number.MIN_SAFE_INTEGER;
            for (let ae = 0; ae < S; ++ae) {
              const ve = W + ae * E;
              if (ve >= 0 && ve < p)
                for (let me = 0; me < _; ++me) {
                  const te = J + me * I;
                  if (te >= 0 && te < y) {
                    const $e = br([D, ve, te, ne], u, ct(s.shape)), _e = br([ae, me, ne], d, ct(i.shape)), ke = l[$e] + h[_e];
                    ke > re && (re = ke);
                  }
                }
            }
            const fe = br([D, z, j, ne], L, ct(k));
            O[fe] = re;
          }
        }
      }
    return { dataId: c.write(La(O, s.dtype), k, s.dtype), shape: k, dtype: s.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $J = {
  kernelName: Ry,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, backend: e, attrs: n }) => {
    const { x: s, filter: i, dy: r } = t, { strides: o, pad: a, dilations: c } = n, l = e, u = Ai(s.shape, l.data.get(s.dataId).values), h = Ai(i.shape, l.data.get(i.dataId).values), { batchSize: d, inHeight: f, inWidth: p, inChannels: y, outHeight: g, outWidth: m, padInfo: x, strideHeight: v, strideWidth: b, filterHeight: w, filterWidth: S, dilationHeight: _, dilationWidth: E, outShape: I } = Gp(s.shape, i.shape, o, a, "NHWC", c);
    A(r.rank === I.length, () => `Error in ${Ry}, dy must have the same rank as output ${I.length}, but got ${r.rank}`);
    const k = Ai(I, l.data.get(r.dataId).values), M = X1(i.shape, i.dtype);
    for (let O = 0; O < d; ++O)
      for (let $ = 0; $ < g; ++$) {
        const D = $ * v - x.top;
        for (let z = 0; z < m; ++z) {
          const W = z * b - x.left;
          for (let j = 0; j < y; ++j) {
            let J = Number.MIN_SAFE_INTEGER, ne = 0, re = 0;
            for (let fe = 0; fe < w; ++fe) {
              const ae = D + fe * _;
              if (ae >= 0 && ae < f)
                for (let ve = 0; ve < S; ++ve) {
                  const me = W + ve * E;
                  if (me >= 0 && me < p) {
                    const te = u[O][ae][me][j] + h[fe][ve][j];
                    te > J && (J = te, ne = fe, re = ve);
                  }
                }
            }
            M[ne][re][j] += k[O][$][z][j];
          }
        }
      }
    return { dataId: l.write(La(M, s.dtype), i.shape, i.dtype), shape: i.shape, dtype: i.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const OJ = {
  kernelName: My,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, backend: e, attrs: n }) => {
    const { x: s, filter: i, dy: r } = t, { strides: o, pad: a, dilations: c } = n, l = e, u = Ai(s.shape, l.data.get(s.dataId).values), h = Ai(i.shape, l.data.get(i.dataId).values), { batchSize: d, inHeight: f, inWidth: p, inChannels: y, outHeight: g, outWidth: m, padInfo: x, strideHeight: v, strideWidth: b, filterHeight: w, filterWidth: S, dilationHeight: _, dilationWidth: E, outShape: I } = Gp(s.shape, i.shape, o, a, "NHWC", c);
    A(r.rank === I.length, () => `Error in ${My}, dy must have the same rank as output ${I.length}, but got ${r.rank}`);
    const k = Ai(I, l.data.get(r.dataId).values), M = X1(s.shape, s.dtype);
    for (let O = 0; O < d; ++O)
      for (let $ = 0; $ < g; ++$) {
        const D = $ * v - x.top;
        for (let z = 0; z < m; ++z) {
          const W = z * b - x.left;
          for (let j = 0; j < y; ++j) {
            let J = Number.MIN_SAFE_INTEGER, ne = D < 0 ? 0 : D, re = W < 0 ? 0 : W;
            for (let fe = 0; fe < w; ++fe) {
              const ae = D + fe * _;
              if (ae >= 0 && ae < f)
                for (let ve = 0; ve < S; ++ve) {
                  const me = W + ve * E;
                  if (me >= 0 && me < p) {
                    const te = u[O][ae][me][j] + h[fe][ve][j];
                    te > J && (J = te, ne = ae, re = me);
                  }
                }
            }
            M[O][ne][re][j] += k[O][$][z][j];
          }
        }
      }
    return { dataId: l.write(La(M, s.dtype), s.shape, s.dtype), shape: s.shape, dtype: s.dtype };
  }
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { image: i } = e, { canvas: r, options: o } = s, { contextOptions: a, imageOptions: c } = o || {}, l = (c == null ? void 0 : c.alpha) || 1, u = (a == null ? void 0 : a.contextType) || "2d";
  if (u !== "2d")
    throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);
  const h = r.getContext(u, (a == null ? void 0 : a.contextAttributes) || {});
  if (h == null)
    throw new Error(`Could not get the context with ${u} type.`);
  const [d, f] = i.shape.slice(0, 2), p = i.shape.length === 2 ? 1 : i.shape[2], y = n.data.get(i.dataId).values, g = i.dtype === "float32" ? 255 : 1, m = new Uint8ClampedArray(f * d * 4);
  for (let v = 0; v < d * f; ++v) {
    const b = [0, 0, 0, 255 * l];
    for (let S = 0; S < p; S++) {
      const _ = y[v * p + S];
      if (i.dtype === "float32") {
        if (_ < 0 || _ > 1)
          throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${_}.`);
      } else if (i.dtype === "int32" && (_ < 0 || _ > 255))
        throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${_}.`);
      p === 1 ? (b[0] = _ * g, b[1] = _ * g, b[2] = _ * g) : b[S] = _ * g;
    }
    const w = v * 4;
    m[w + 0] = Math.round(b[0]), m[w + 1] = Math.round(b[1]), m[w + 2] = Math.round(b[2]), m[w + 3] = Math.round(b[3]);
  }
  r.width = f, r.height = d;
  const x = new ImageData(m, f, d);
  return h.putImageData(x, 0, 0), i;
}
const FJ = {
  kernelName: Ox,
  backendName: "cpu",
  kernelFunc: LJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wm(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, keepDims: o } = s;
  nt(i, "sum");
  let a;
  i.dtype === "bool" ? a = Oa({ inputs: { x: i }, backend: n, attrs: { dtype: "int32" } }) : a = ao({ inputs: { x: i }, backend: n });
  const c = a.shape.length, l = Rt(r, a.shape), u = An(l, c);
  let h = l, d = a;
  u != null && (d = oi({ inputs: { x: a }, backend: n, attrs: { perm: u } }), h = Vn(h.length, c)), _s("sum", h, d.shape.length);
  const [f, p] = ds(d.shape, h), y = ni(d.dtype, "int32");
  let g = Ky(n, f, y);
  const m = ue(p), x = n.data.get(g.dataId).values, v = n.data.get(d.dataId).values;
  for (let b = 0; b < x.length; ++b) {
    const w = b * m;
    let S = 0;
    for (let _ = 0; _ < m; ++_)
      S += v[w + _];
    x[b] = S;
  }
  if (o) {
    const b = zn(g.shape, l), w = g;
    g = fn({ inputs: { x: g }, backend: n, attrs: { shape: b } }), n.disposeIntermediateTensorInfo(w);
  }
  return n.disposeIntermediateTensorInfo(a), u != null && n.disposeIntermediateTensorInfo(d), g;
}
const PJ = {
  kernelName: Rp,
  backendName: "cpu",
  kernelFunc: wm
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BJ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { equation: i } = s, r = e, { allDims: o, summedDims: a, idDims: c } = W_(i, r.length);
  j_(o.length, c, r);
  const { path: l, steps: u } = q_(a, c), h = u.length;
  let d = null, f = o.length;
  const p = [];
  for (let y = 0; y < h; ++y) {
    for (const g of u[y]) {
      const { permutationIndices: m, expandDims: x } = H_(f, c[g]);
      let v;
      X_(m) ? v = r[g] : (v = oi({ inputs: { x: r[g] }, backend: n, attrs: { perm: m } }), p.push(v));
      const b = v.shape.slice();
      for (let w = 0; w < x.length; ++w)
        b.splice(x[w], 0, 1);
      Bt(v.shape, b) || (v = fn({ inputs: { x: v }, backend: n, attrs: { shape: b } }), p.push(v)), d === null ? d = v : (d = Ib({ inputs: { a: v, b: d }, backend: n }), p.push(d));
    }
    y < h - 1 && (l[y] >= 0 && (d = wm({
      inputs: { x: d },
      backend: n,
      attrs: {
        axis: l[y] - (o.length - f),
        keepDims: !1
      }
    }), p.push(d)), f--);
  }
  for (const y of p)
    y !== d && n.disposeIntermediateTensorInfo(y);
  return d;
}
const zJ = {
  kernelName: Lx,
  backendName: "cpu",
  kernelFunc: BJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VJ(t) {
  const { inputs: e, backend: n } = t, { dy: s, y: i } = e;
  nt([s, i], "eluGrad");
  const r = new Float32Array(ue(i.shape)), o = n.data.get(i.dataId).values, a = n.data.get(s.dataId).values;
  for (let c = 0; c < o.length; ++c) {
    const l = o[c];
    l >= 0 ? r[c] = a[c] : r[c] = a[c] * (l + 1);
  }
  return n.makeTensorInfo(i.shape, "float32", r);
}
const UJ = {
  kernelName: Fx,
  backendName: "cpu",
  kernelFunc: VJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const GJ = F_, WJ = P_, HJ = B_, jJ = z_, qJ = V_, XJ = U_, KJ = Jt(Yu, (t) => {
  const e = Math.sign(t), n = Math.abs(t), s = 1 / (1 + GJ * n);
  return e * (1 - ((((XJ * s + qJ) * s + jJ) * s + HJ) * s + WJ) * s * Math.exp(-n * n));
}), YJ = {
  kernelName: Yu,
  backendName: "cpu",
  kernelFunc: KJ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jy(t) {
  const { inputs: e, backend: n, attrs: s } = t, { input: i } = e, { dim: r } = s, o = i.shape.length, a = i.shape.slice();
  let c = r;
  return r < 0 && (A(-(o + 1) <= r, () => `Axis must be in the interval [${-(o + 1)}, ${o}]`), c = o + r + 1), a.splice(c, 0, 1), fn({ inputs: { x: i }, backend: n, attrs: { shape: a } });
}
const ZJ = {
  kernelName: tp,
  backendName: "cpu",
  kernelFunc: Jy
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const JJ = Gn((t, e) => t / e), ET = ss(Xu, JJ), S1 = {
  kernelName: Xu,
  backendName: "cpu",
  kernelFunc: ET
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function A$(t, e, n) {
  const s = t.shape, i = s[0], r = s[1], o = n.data.get(t.dataId), a = o.complexTensorInfos.real, c = o.complexTensorInfos.imag, l = [i, r], u = ue(l), h = ls("float32", u), d = ls("float32", u);
  for (let g = 0; g < i; g++) {
    const m = Xc({
      inputs: { x: a },
      backend: n,
      attrs: { begin: [g, 0], size: [1, r] }
    }), x = Xc({
      inputs: { x: c },
      backend: n,
      attrs: { begin: [g, 0], size: [1, r] }
    }), v = di({ inputs: { real: m, imag: x }, backend: n }), { real: b, imag: w } = QJ(v, e, n), S = Lo(b, w);
    for (let _ = 0; _ < r; _++) {
      const E = G_(S, _);
      h[g * r + _] = E.real, d[g * r + _] = E.imag;
    }
    n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(x), n.disposeIntermediateTensorInfo(v);
  }
  const f = n.makeTensorInfo(l, "float32", h), p = n.makeTensorInfo(l, "float32", d), y = di({ inputs: { real: f, imag: p }, backend: n });
  return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(p), y;
}
function QJ(t, e, n) {
  const s = ue(t.shape), i = n.data.get(t.dataId), r = n.data.get(i.complexTensorInfos.real.dataId).values, o = n.data.get(i.complexTensorInfos.imag.dataId).values;
  if (eQ(s)) {
    const a = _1(r, o, s, e, n), c = [t.shape[0], t.shape[1]];
    if (e) {
      const l = n.makeTensorInfo(c, "float32", a.real), u = n.makeTensorInfo(c, "float32", a.imag), h = n.makeTensorInfo([], "float32", Vo(s, "float32")), d = ao({ inputs: { x: h }, backend: n }), f = S1.kernelFunc({ inputs: { a: l, b: h }, backend: n }), p = S1.kernelFunc({ inputs: { a: u, b: d }, backend: n }), y = n.data.get(f.dataId).values, g = n.data.get(p.dataId).values;
      return n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(p), { real: y, imag: g };
    }
    return a;
  } else {
    const a = Lo(r, o), c = tQ(a, s, e);
    return PA(c);
  }
}
function eQ(t) {
  return (t & t - 1) === 0;
}
function _1(t, e, n, s, i) {
  if (n === 1)
    return { real: t, imag: e };
  const r = Lo(t, e), o = n / 2, a = BA(r), c = a.real, l = a.imag, u = [c.length], h = i.makeTensorInfo(u, "float32", c), d = i.makeTensorInfo(u, "float32", l), f = di({ inputs: { real: h, imag: d }, backend: i }), p = zA(r), y = p.real, g = p.imag, m = [y.length], x = i.makeTensorInfo(m, "float32", y), v = i.makeTensorInfo(m, "float32", g), b = di({ inputs: { real: x, imag: v }, backend: i }), w = _1(c, l, o, s, i), S = w.real, _ = w.imag, E = [S.length], I = i.makeTensorInfo(E, "float32", S), k = i.makeTensorInfo(E, "float32", _), M = di({
    inputs: { real: I, imag: k },
    backend: i
  }), L = _1(y, g, o, s, i), O = L.real, $ = L.imag, D = [O.length], z = i.makeTensorInfo(D, "float32", O), W = i.makeTensorInfo(D, "float32", $), j = di({ inputs: { real: z, imag: W }, backend: i }), J = UA(n, s), ne = [J.real.length], re = i.makeTensorInfo(ne, "float32", J.real), fe = i.makeTensorInfo(ne, "float32", J.imag), ae = di({ inputs: { real: re, imag: fe }, backend: i }), ve = Ib({ inputs: { a: ae, b: j }, backend: i }), me = Eu({
    inputs: { a: M, b: ve },
    backend: i
  }), te = CT({
    inputs: { a: M, b: ve },
    backend: i
  }), $e = qc({ inputs: { input: me }, backend: i }), _e = qc({ inputs: { input: te }, backend: i }), ke = Nu({ inputs: { input: me }, backend: i }), Re = Nu({ inputs: { input: te }, backend: i }), ce = ku({
    inputs: [$e, _e],
    backend: i,
    attrs: { axis: 0 }
  }), xe = ku({
    inputs: [ke, Re],
    backend: i,
    attrs: { axis: 0 }
  }), we = i.data.get(ce.dataId).values, Pe = i.data.get(xe.dataId).values;
  return i.disposeIntermediateTensorInfo(h), i.disposeIntermediateTensorInfo(d), i.disposeIntermediateTensorInfo(f), i.disposeIntermediateTensorInfo(x), i.disposeIntermediateTensorInfo(v), i.disposeIntermediateTensorInfo(b), i.disposeIntermediateTensorInfo(I), i.disposeIntermediateTensorInfo(k), i.disposeIntermediateTensorInfo(M), i.disposeIntermediateTensorInfo(z), i.disposeIntermediateTensorInfo(W), i.disposeIntermediateTensorInfo(j), i.disposeIntermediateTensorInfo(re), i.disposeIntermediateTensorInfo(fe), i.disposeIntermediateTensorInfo(ae), i.disposeIntermediateTensorInfo(ve), i.disposeIntermediateTensorInfo(me), i.disposeIntermediateTensorInfo(te), i.disposeIntermediateTensorInfo($e), i.disposeIntermediateTensorInfo(ke), i.disposeIntermediateTensorInfo(_e), i.disposeIntermediateTensorInfo(Re), i.disposeIntermediateTensorInfo(ce), i.disposeIntermediateTensorInfo(xe), { real: we, imag: Pe };
}
function tQ(t, e, n) {
  const s = new Float32Array(e * 2);
  for (let i = 0; i < e; i++) {
    let r = 0, o = 0;
    for (let a = 0; a < e; a++) {
      const c = GA(i * a, e, n), l = G_(t, a);
      r += l.real * c.real - l.imag * c.imag, o += l.real * c.imag + l.imag * c.real;
    }
    n && (r /= e, o /= e), VA(s, r, o, i);
  }
  return s;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nQ(t) {
  const { inputs: e, backend: n } = t, { input: s } = e, i = ue(s.shape), r = s.shape[s.shape.length - 1], o = i / r, a = fn({
    inputs: { x: s },
    backend: n,
    attrs: { shape: [o, r] }
  }), c = A$(a, !1, n), l = fn({ inputs: { x: c }, backend: n, attrs: { shape: s.shape } });
  return n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(c), l;
}
const sQ = {
  kernelName: Px,
  backendName: "cpu",
  kernelFunc: nQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NT(t) {
  const { backend: e, attrs: n } = t, { shape: s, value: i, dtype: r } = n, o = r || Zc(i), a = $n(o, ue(s));
  return rQ(a, i, o), e.makeTensorInfo(s, o, a);
}
const iQ = {
  kernelName: Bx,
  backendName: "cpu",
  kernelFunc: NT
};
function rQ(t, e, n) {
  t.fill(e);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const oQ = {
  kernelName: zx,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, attrs: e, backend: n }) => {
    const { image: s } = t, i = n, r = ls(s.dtype, ue(s.shape)), [o, a, c, l] = s.shape, u = i.data.get(s.dataId).values;
    for (let d = 0; d < o; d++) {
      const f = d * c * a * l;
      for (let p = 0; p < a; p++) {
        const y = p * (c * l);
        for (let g = 0; g < c; g++) {
          const m = g * l;
          for (let x = 0; x < l; x++) {
            const v = Math.round(c - g - 1), b = f + y + m + x;
            let w = u[b];
            if (v >= 0 && v < c) {
              const S = v * l, _ = f + y + S + x;
              w = u[_];
            }
            r[b] = w;
          }
        }
      }
    }
    return { dataId: i.write(r, s.shape, s.dtype), shape: s.shape, dtype: s.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aQ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, filter: r, bias: o, preluActivationWeights: a } = e, { strides: c, pad: l, dataFormat: u, dilations: h, dimRoundingMode: d, activation: f, leakyreluAlpha: p } = s;
  let y = N$({
    inputs: { x: i, filter: r },
    backend: n,
    attrs: { strides: c, pad: l, dataFormat: u, dilations: h, dimRoundingMode: d }
  });
  if (o) {
    const g = y;
    if (u === "NCHW" && o.shape.length === 1 && o.shape[0] !== 1) {
      const m = fn({ inputs: { x: o }, backend: n, attrs: { shape: [o.shape[0], 1, 1] } });
      y = Eu({ inputs: { a: y, b: m }, backend: n }), n.disposeIntermediateTensorInfo(m);
    } else
      y = Eu({ inputs: { a: y, b: o }, backend: n });
    n.disposeIntermediateTensorInfo(g);
  }
  if (f) {
    const g = y;
    if (u === "NCHW" && f === "prelu" && a.shape.length === 1 && a.shape[0] !== 1) {
      const m = fn({
        inputs: { x: a },
        backend: n,
        attrs: { shape: [a.shape[0], 1, 1] }
      });
      y = Zy(n, y, f, m, p), n.disposeIntermediateTensorInfo(m);
    } else
      y = Zy(n, y, f, a, p);
    n.disposeIntermediateTensorInfo(g);
  }
  return y;
}
const cQ = {
  kernelName: df,
  backendName: "cpu",
  kernelFunc: aQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lQ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, filter: r, bias: o, preluActivationWeights: a } = e, { strides: c, pad: l, dataFormat: u, dilations: h, dimRoundingMode: d, activation: f, leakyreluAlpha: p } = s;
  let y = k$({
    inputs: { x: i, filter: r },
    backend: n,
    attrs: { strides: c, pad: l, dataFormat: u, dilations: h, dimRoundingMode: d }
  });
  if (o) {
    const g = y;
    y = Eu({ inputs: { a: y, b: o }, backend: n }), n.disposeIntermediateTensorInfo(g);
  }
  if (f) {
    const g = y;
    y = Zy(n, y, f, a, p), n.disposeIntermediateTensorInfo(g);
  }
  return y;
}
const uQ = {
  kernelName: ff,
  backendName: "cpu",
  kernelFunc: lQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hQ(t) {
  const { inputs: e, backend: n } = t, { params: s, indices: i } = e, r = ue(s.shape), o = i.shape, a = o[o.length - 1], [c, l, u, h] = lb(s, i);
  if (l === 0)
    return n.makeTensorInfo(c, s.dtype, []);
  const d = n.data.get(i.dataId).values, f = n.bufferSync(s), p = zD(d, f, s.dtype, l, a, u, h, s.shape, r);
  return n.makeTensorInfo(c, s.dtype, p.values);
}
const dQ = {
  kernelName: Vx,
  backendName: "cpu",
  kernelFunc: hQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fQ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, indices: r } = e, { axis: o, batchDims: a } = s;
  nt([i, r], "gatherV2");
  const c = Rt(o, i.shape)[0], l = n.data.get(r.dataId).values, u = i.shape[c];
  for (let b = 0; b < l.length; ++b) {
    const w = l[b];
    A(w <= u - 1 && w >= 0, () => `GatherV2: the index value ${w} is not in [0, ${u - 1}]`);
  }
  let h = a;
  a == null && (h = 0);
  const d = ue(r.shape), f = Y_(i, r, c, h), p = fn({
    inputs: { x: i },
    backend: n,
    attrs: {
      shape: [
        f.batchSize,
        f.outerSize,
        f.dimSize,
        f.sliceSize
      ]
    }
  }), y = fn({
    inputs: { x: r },
    backend: n,
    attrs: { shape: [f.batchSize, d / f.batchSize] }
  }), g = [
    f.batchSize,
    f.outerSize,
    d / f.batchSize,
    f.sliceSize
  ], m = n.bufferSync(y), x = n.bufferSync(p), v = VD(x, m, g);
  return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(y), n.makeTensorInfo(f.outputShape, v.dtype, v.values);
}
const pQ = {
  kernelName: sp,
  backendName: "cpu",
  kernelFunc: fQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mQ(t) {
  const { inputs: e, backend: n } = t, { input: s } = e, i = ue(s.shape), r = s.shape[s.shape.length - 1], o = i / r, a = fn({
    inputs: { x: s },
    backend: n,
    attrs: { shape: [o, r] }
  }), c = A$(a, !0, n), l = fn({ inputs: { x: c }, backend: n, attrs: { shape: s.shape } });
  return n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(c), l;
}
const gQ = {
  kernelName: Ux,
  backendName: "cpu",
  kernelFunc: mQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const yQ = Jt(sh, (t) => Number.isFinite(t) ? 1 : 0, "bool"), xQ = {
  kernelName: sh,
  backendName: "cpu",
  kernelFunc: yQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const bQ = Jt(ih, (t) => Math.abs(t) === 1 / 0 ? 1 : 0, "bool"), vQ = {
  kernelName: ih,
  backendName: "cpu",
  kernelFunc: bQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const wQ = Jt(rh, (t) => Number.isNaN(t) ? 1 : 0, "bool"), SQ = {
  kernelName: rh,
  backendName: "cpu",
  kernelFunc: wQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _Q(t) {
  const { backend: e, attrs: n } = t, { start: s, stop: i, num: r } = n, o = jD(s, i, r);
  return e.makeTensorInfo([o.length], "float32", o);
}
const TQ = {
  kernelName: Wx,
  backendName: "cpu",
  kernelFunc: _Q
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const CQ = Jt(ah, (t) => Math.log1p(t)), IQ = {
  kernelName: ah,
  backendName: "cpu",
  kernelFunc: CQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const EQ = Gn((t, e) => t && e), NQ = ss(cp, EQ, null, "bool"), kQ = {
  kernelName: cp,
  backendName: "cpu",
  kernelFunc: NQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const AQ = Jt(lp, (t) => t ? 0 : 1, "bool"), MQ = {
  kernelName: lp,
  backendName: "cpu",
  kernelFunc: AQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const RQ = Gn((t, e) => t || e), DQ = ss(up, RQ, null, "bool"), $Q = {
  kernelName: up,
  backendName: "cpu",
  kernelFunc: DQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OQ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { depthRadius: r, bias: o, alpha: a, beta: c } = s;
  nt(i, "LRN");
  const l = i.shape[3], u = l - 1, h = n.data.get(i.dataId).values, d = ue(i.shape), f = new Float32Array(d);
  function p(y) {
    const g = y % l;
    let m = y - g + Math.max(0, g - r);
    const x = y - g + Math.min(g + r, u);
    let v = 0;
    for (; m <= x; m++) {
      const b = h[m];
      v += b * b;
    }
    return v;
  }
  for (let y = 0; y < d; y++) {
    const g = p(y), m = h[y] * Math.pow(o + a * g, -c);
    f[y] = m;
  }
  return n.makeTensorInfo(i.shape, i.dtype, f);
}
const LQ = {
  kernelName: hp,
  backendName: "cpu",
  kernelFunc: OQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FQ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, y: r, dy: o } = e, { depthRadius: a, bias: c, alpha: l, beta: u } = s;
  nt(o, "LRNGrad");
  const h = ue(o.shape), d = o.shape[3], f = n.data.get(o.dataId).values, p = n.data.get(i.dataId).values, y = n.data.get(r.dataId).values, g = new Float32Array(h), m = h;
  for (let x = 0; x < m; x++) {
    const v = x % d, b = x - v + Math.max(0, v - a), w = x - v + Math.min(d, v + a + 1);
    let S = 0;
    for (let _ = b; _ < w; _++)
      S += Math.pow(p[_], 2);
    S = l * S + c;
    for (let _ = b; _ < w; _++) {
      let E = -2 * l * u * p[_] * y[x] / S;
      x === _ && (E += Math.pow(S, -u)), E *= f[x], g[_] += E;
    }
  }
  return n.makeTensorInfo(o.shape, i.dtype, g);
}
const PQ = {
  kernelName: Hx,
  backendName: "cpu",
  kernelFunc: FQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function M$(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { reductionIndices: r, keepDims: o } = s, a = n;
  let c = i.shape;
  const l = c.length, u = Rt(r, c);
  let h = u;
  const d = An(h, l);
  let f = a.data.get(i.dataId).values;
  if (d != null) {
    const b = new Array(l);
    for (let w = 0; w < b.length; w++)
      b[w] = c[d[w]];
    f = _T(f, c, i.dtype, d, b), h = Vn(h.length, l), c = b;
  }
  nt(i, "max"), _s("max", h, l);
  const [p, y] = ds(c, h), g = ue(y), m = XD(f, g, p, i.dtype), x = a.write(m, p, i.dtype);
  let v = p;
  return o && (v = zn(p, u)), { dataId: x, shape: v, dtype: i.dtype };
}
const BQ = {
  kernelName: dp,
  backendName: "cpu",
  kernelFunc: M$
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zQ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e;
  nt(i, "maxPool");
  const { filterSize: r, strides: o, pad: a, dimRoundingMode: c } = s, l = 1;
  A(Ss(o, l), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);
  const u = ir(i.shape, r, o, l, a, c);
  let h;
  if (u.filterWidth === 1 && u.filterHeight === 1 && Bt(u.inShape, u.outShape))
    h = ao({ inputs: { x: i }, backend: n });
  else {
    const d = n.data.get(i.dataId).values, f = ct(i.shape), p = IT(d, i.shape, i.dtype, f, u, "max");
    h = n.makeTensorInfo(u.outShape, i.dtype, p.values);
  }
  return h;
}
const VQ = {
  kernelName: fp,
  backendName: "cpu",
  kernelFunc: zQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UQ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { filterSize: r, strides: o, pad: a, dimRoundingMode: c, dataFormat: l } = s;
  nt(i, "maxPool3d");
  const u = Uo(i.shape, r, o, 1, a, c, l), h = n.data.get(i.dataId).values, d = E$(h, i.shape, i.dtype, ct(i.shape), u, "max");
  return n.makeTensorInfo(d.shape, "float32", d.values);
}
const GQ = {
  kernelName: pp,
  backendName: "cpu",
  kernelFunc: UQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function WQ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, input: r } = e, { filterSize: o, strides: a, pad: c, dimRoundingMode: l } = s;
  nt([i, r], "maxPool3DGrad");
  const u = Uo(r.shape, o, a, 1, c, l), h = n.bufferSync(r), d = RZ(h, u), f = u.strideDepth, p = u.strideHeight, y = u.strideWidth, g = u.dilationDepth, m = u.dilationHeight, x = u.dilationWidth, v = u.effectiveFilterDepth, b = u.effectiveFilterHeight, w = u.effectiveFilterWidth, S = v - 1 - u.padInfo.front, _ = w - 1 - u.padInfo.left, E = b - 1 - u.padInfo.top, I = It(r.shape, "float32"), k = n.bufferSync(i);
  for (let M = 0; M < u.batchSize; ++M)
    for (let L = 0; L < u.inChannels; ++L)
      for (let O = 0; O < u.inDepth; ++O)
        for (let $ = 0; $ < u.inHeight; ++$)
          for (let D = 0; D < u.inWidth; ++D) {
            const z = O - S, W = $ - E, j = D - _;
            let J = 0;
            for (let ne = 0; ne < v; ne += g) {
              const re = (z + ne) / f;
              if (!(re < 0 || re >= u.outDepth || Math.floor(re) !== re))
                for (let fe = 0; fe < b; fe += m) {
                  const ae = (W + fe) / p;
                  if (!(ae < 0 || ae >= u.outHeight || Math.floor(ae) !== ae))
                    for (let ve = 0; ve < w; ve += x) {
                      const me = (j + ve) / y;
                      if (me < 0 || me >= u.outWidth || Math.floor(me) !== me)
                        continue;
                      const te = v * b * w - 1 - d.get(M, re, ae, me, L), $e = ne * b * w + fe * w + ve, _e = te === $e ? 1 : 0;
                      if (_e === 0)
                        continue;
                      const ke = k.get(M, re, ae, me, L);
                      J += ke * _e;
                    }
                }
            }
            I.set(J, M, O, $, D, L);
          }
  return n.makeTensorInfo(I.shape, I.dtype, I.values);
}
const HQ = {
  kernelName: qx,
  backendName: "cpu",
  kernelFunc: WQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jQ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, input: r, output: o } = e, a = r;
  nt([r, o], "maxPoolGrad");
  const { filterSize: c, strides: l, pad: u, dimRoundingMode: h } = s, d = ir(a.shape, c, l, 1, u, h), f = n.data.get(a.dataId).values, p = It(d.outShape, a.dtype, I$(f, a.shape, a.dtype, d).values), y = d.strideHeight, g = d.strideWidth, m = d.dilationHeight, x = d.dilationWidth, v = d.effectiveFilterHeight, b = d.effectiveFilterWidth, w = b - 1 - d.padInfo.left, S = v - 1 - d.padInfo.top, _ = It(a.shape, "float32"), E = n.data.get(i.dataId).values, I = It(i.shape, "float32", E);
  for (let k = 0; k < d.batchSize; ++k)
    for (let M = 0; M < d.inChannels; ++M)
      for (let L = 0; L < d.inHeight; ++L)
        for (let O = 0; O < d.inWidth; ++O) {
          const $ = L - S, D = O - w;
          let z = 0;
          for (let W = 0; W < v; W += m) {
            const j = ($ + W) / y;
            if (!(j < 0 || j >= d.outHeight || Math.floor(j) !== j))
              for (let J = 0; J < b; J += x) {
                const ne = (D + J) / g;
                if (ne < 0 || ne >= d.outWidth || Math.floor(ne) !== ne)
                  continue;
                const re = v * b - 1 - p.get(k, j, ne, M), fe = W * b + J, ae = re === fe ? 1 : 0;
                if (ae === 0)
                  continue;
                const ve = I.get(k, j, ne, M);
                z += ve * ae;
              }
          }
          _.set(z, k, L, O, M);
        }
  return n.makeTensorInfo(_.shape, _.dtype, _.values);
}
const qQ = {
  kernelName: jx,
  backendName: "cpu",
  kernelFunc: jQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XQ(t, e, n, s, i) {
  const r = ct(e), o = IT(t, e, n, r, i, "max"), a = I$(t, e, n, i, !0, s);
  return [o.values, a.values];
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KQ = {
  kernelName: Xx,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, attrs: e, backend: n }) => {
    const { x: s } = t, { filterSize: i, strides: r, pad: o, includeBatchInIndex: a } = e, c = n;
    nt(s, "MaxPoolWithArgmax");
    const l = c.data.get(s.dataId).values, u = ir(s.shape, i, r, [1, 1], o), [h, d] = XQ(l, s.shape, s.dtype, a, u), f = c.write(h, u.outShape, s.dtype), p = c.write(d, u.outShape, s.dtype);
    return [
      { dataId: f, shape: u.outShape, dtype: s.dtype },
      { dataId: p, shape: u.outShape, dtype: "int32" }
    ];
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YQ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, keepDims: o } = s, a = Rt(r, i.shape), l = ds(i.shape, a)[1], u = ue(l), h = [], d = n.makeTensorInfo([], "float32", new Float32Array([u]));
  h.push(d);
  const f = Oa({ inputs: { x: i }, backend: n, attrs: { dtype: "float32" } });
  h.push(f);
  const p = ET({ inputs: { a: f, b: d }, backend: n });
  h.push(p);
  const y = wm({ inputs: { x: p }, backend: n, attrs: { axis: r, keepDims: o } });
  return h.forEach((g) => n.disposeIntermediateTensorInfo(g)), y;
}
const ZQ = {
  kernelName: mp,
  backendName: "cpu",
  kernelFunc: YQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JQ(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, keepDims: o } = s;
  nt(i, "min");
  const a = Rt(r, i.shape);
  let c = a;
  const l = An(c, i.shape.length);
  let u = i;
  l != null && (u = oi({ inputs: { x: i }, backend: n, attrs: { perm: l } }), c = Vn(c.length, i.shape.length)), _s("min", c, u.shape.length);
  const [h, d] = ds(u.shape, c), f = ue(d), p = vs(ue(h), u.dtype), y = n.data.get(u.dataId).values;
  for (let m = 0; m < p.length; ++m) {
    const x = m * f;
    let v = y[x];
    for (let b = 0; b < f; ++b) {
      const w = y[x + b];
      (Number.isNaN(w) || w < v) && (v = w);
    }
    p[m] = v;
  }
  l != null && n.disposeIntermediateTensorInfo(u);
  const g = n.makeTensorInfo(h, u.dtype, p);
  if (o) {
    const m = zn(h, a), x = fn({ inputs: { x: g }, backend: n, attrs: { shape: m } });
    return n.disposeIntermediateTensorInfo(g), x;
  }
  return g;
}
const QQ = {
  kernelName: gp,
  backendName: "cpu",
  kernelFunc: JQ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { paddings: r, mode: o } = s;
  nt(i, "mirrorPad");
  const a = r.map(
    (v, b) => v[0] + i.shape[b] + v[1]
    /* afterPad */
  ), c = r.map((v) => v[0]), l = r.map((v, b) => v[0] + i.shape[b]), u = o === "reflect" ? 0 : 1, h = n.data.get(i.dataId).values, d = i.shape.length, f = ct(i.shape), p = ue(a), y = a.length, g = ct(a), m = ls(i.dtype, p);
  for (let v = 0; v < p; v++) {
    let b = Jc(v, y, g);
    for (let S = 0; S < y; S++)
      b[S] < c[S] ? b[S] = c[S] * 2 - b[S] - u : b[S] >= l[S] && (b[S] = (l[S] - 1) * 2 - b[S] + u);
    b = b.map((S, _) => S - c[_]);
    const w = br(b, d, f);
    m[v] = h[w];
  }
  return { dataId: n.write(m, a, i.dtype), shape: a, dtype: i.dtype };
}
const tee = {
  kernelName: yp,
  backendName: "cpu",
  kernelFunc: eee
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nee = Gn((t, e) => {
  const n = t % e;
  return t < 0 && e < 0 || t >= 0 && e >= 0 ? n : (n + e) % e;
}), see = ss(uh, nee), iee = {
  kernelName: uh,
  backendName: "cpu",
  kernelFunc: see
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R$(t) {
  const { inputs: e, backend: n, attrs: s } = t, { logits: i } = e, { dim: r } = s, o = i.shape.length;
  let a = r;
  if (a === -1 && (a = o - 1), a !== o - 1)
    throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);
  const c = Rt([a], i.shape), l = M$({
    inputs: { x: i },
    backend: n,
    attrs: { reductionIndices: c, keepDims: !1 }
  }), u = zn(l.shape, c), h = fn({ inputs: { x: l }, backend: n, attrs: { shape: u } }), d = CT({ inputs: { a: i, b: h }, backend: n }), f = LD({ inputs: { x: d }, backend: n }), p = wm({ inputs: { x: f }, backend: n, attrs: { axis: c, keepDims: !1 } }), y = fn({ inputs: { x: p }, backend: n, attrs: { shape: u } }), g = ET({ inputs: { a: f, b: y }, backend: n });
  return n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(y), g;
}
const ree = {
  kernelName: Op,
  backendName: "cpu",
  kernelFunc: R$
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { logits: i } = e, { numSamples: r, seed: o, normalized: a } = s;
  nt(i, "multinomial");
  const c = a ? i : R$({ inputs: { logits: i }, backend: n, attrs: { dim: -1 } }), l = c.shape[0], u = c.shape[1], h = n.data.get(c.dataId).values, d = [l, r], f = vs(ue(d), "int32");
  for (let p = 0; p < l; ++p) {
    const y = p * u, g = new Float32Array(u - 1);
    g[0] = h[y];
    for (let v = 1; v < g.length; ++v)
      g[v] = g[v - 1] + h[y + v];
    const m = B0.alea(o.toString()), x = p * r;
    for (let v = 0; v < r; ++v) {
      const b = m();
      f[x + v] = g.length;
      for (let w = 0; w < g.length; w++)
        if (b < g[w]) {
          f[x + v] = w;
          break;
        }
    }
  }
  return a || n.disposeIntermediateTensorInfo(c), n.makeTensorInfo(d, "int32", f);
}
const aee = {
  kernelName: Kx,
  backendName: "cpu",
  kernelFunc: oee
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cee = rb;
function lee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { boxes: i, scores: r } = e, { maxOutputSize: o, iouThreshold: a, scoreThreshold: c } = s;
  nt(i, "NonMaxSuppression");
  const l = n.data.get(i.dataId).values, u = n.data.get(r.dataId).values, { selectedIndices: h } = cee(l, u, o, a, c);
  return n.makeTensorInfo([h.length], "int32", new Int32Array(h));
}
const uee = {
  kernelName: Yx,
  backendName: "cpu",
  kernelFunc: lee
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const hee = ob;
function dee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { boxes: i, scores: r } = e, { maxOutputSize: o, iouThreshold: a, scoreThreshold: c, padToMaxOutputSize: l } = s;
  nt(i, "NonMaxSuppressionPadded");
  const u = n.data.get(i.dataId).values, h = n.data.get(r.dataId).values, { selectedIndices: d, validOutputs: f } = hee(u, h, o, a, c, l);
  return [
    n.makeTensorInfo([d.length], "int32", new Int32Array(d)),
    n.makeTensorInfo([], "int32", new Int32Array([f]))
  ];
}
const fee = {
  kernelName: Zx,
  backendName: "cpu",
  kernelFunc: dee
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pee = ab;
function mee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { boxes: i, scores: r } = e, { maxOutputSize: o, iouThreshold: a, scoreThreshold: c, softNmsSigma: l } = s;
  nt(i, "NonMaxSuppressionWithScore");
  const u = n.data.get(i.dataId).values, h = n.data.get(r.dataId).values, d = o, f = a, p = c, y = l, { selectedIndices: g, selectedScores: m } = pee(u, h, d, f, p, y);
  return [
    n.makeTensorInfo([g.length], "int32", new Int32Array(g)),
    n.makeTensorInfo([m.length], "float32", new Float32Array(m))
  ];
}
const gee = {
  kernelName: Jx,
  backendName: "cpu",
  kernelFunc: mee
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { indices: i } = e, { dtype: r, depth: o, onValue: a, offValue: c } = s;
  nt(i, "oneHot");
  const l = ue(i.shape), u = new Float32Array(l * o);
  u.fill(c);
  const h = n.data.get(i.dataId).values;
  for (let d = 0; d < l; ++d)
    h[d] >= 0 && h[d] < o && (u[d * o + h[d]] = a);
  return n.makeTensorInfo([...i.shape, o], r, u);
}
const xee = {
  kernelName: wp,
  backendName: "cpu",
  kernelFunc: yee
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qy(t) {
  const { inputs: e, backend: n } = t, { x: s } = e;
  if (s.dtype === "string")
    throw new Error("zerosLike is not supported for string tensors");
  if (s.dtype === "complex64") {
    const i = qc({ inputs: { input: s }, backend: n }), r = Qy({ inputs: { x: i }, backend: n }), o = Nu({ inputs: { input: s }, backend: n }), a = Qy({ inputs: { x: o }, backend: n }), c = di({ inputs: { real: r, imag: a }, backend: n });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(r), n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(a), c;
  } else
    return NT({ backend: n, attrs: { shape: s.shape, value: 0, dtype: s.dtype } });
}
const bee = {
  kernelName: Bp,
  backendName: "cpu",
  kernelFunc: Qy
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function D$(t) {
  const { inputs: e, backend: n } = t, { x: s } = e;
  if (s.dtype === "string")
    throw new Error("onesLike is not supported for string tensors");
  if (s.dtype === "complex64") {
    const i = qc({ inputs: { input: s }, backend: n }), r = D$({ inputs: { x: i }, backend: n }), o = Nu({ inputs: { input: s }, backend: n }), a = Qy({ inputs: { x: o }, backend: n }), c = di({ inputs: { real: r, imag: a }, backend: n });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(r), n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(a), c;
  } else
    return NT({ backend: n, attrs: { shape: s.shape, value: 1, dtype: s.dtype } });
}
const vee = {
  kernelName: vp,
  backendName: "cpu",
  kernelFunc: D$
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $$(t) {
  const { inputs: e, backend: n, attrs: s } = t, { axis: i } = s;
  if (e.length === 1)
    return Jy({ inputs: { input: e[0] }, backend: n, attrs: { dim: i } });
  const r = e[0].shape, o = e[0].dtype;
  e.forEach((u) => {
    ws(r, u.shape, "All tensors passed to stack must have matching shapes"), A(o === u.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  const a = [], c = e.map((u) => {
    const h = Jy({ inputs: { input: u }, backend: n, attrs: { dim: i } });
    return a.push(h), h;
  }), l = ku({ inputs: c, backend: n, attrs: { axis: i } });
  return a.forEach((u) => n.disposeIntermediateTensorInfo(u)), l;
}
const wee = {
  kernelName: Sp,
  backendName: "cpu",
  kernelFunc: $$
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function See(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { paddings: r, constantValue: o } = s;
  nt(i, "pad");
  const a = r.map(
    (x, v) => x[0] + i.shape[v] + x[1]
    /* afterPad */
  ), c = r.map((x) => x[0]), l = n.data.get(i.dataId).values, u = ue(i.shape), h = i.shape.length, d = ct(i.shape), f = ue(a), p = a.length, y = ct(a), g = ls(i.dtype, f);
  o !== 0 && g.fill(o);
  for (let x = 0; x < u; x++) {
    const b = Jc(x, h, d).map((S, _) => S + c[_]), w = br(b, p, y);
    g[w] = l[x];
  }
  return { dataId: n.write(g, a, i.dtype), shape: a, dtype: i.dtype };
}
const O$ = {
  kernelName: _p,
  backendName: "cpu",
  kernelFunc: See
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _ee = Gn((t, e) => Math.pow(t, e)), Tee = ss(dh, _ee), Cee = {
  kernelName: dh,
  backendName: "cpu",
  kernelFunc: Tee
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Iee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { paramsNestedSplits: i, paramsDenseValues: r, indices: o } = e, a = i.map((g) => n.data.get(g.dataId).values), c = i.map((g) => g.shape), l = n.data.get(r.dataId).values, u = n.data.get(o.dataId).values, [h, d, f] = e$(a, c, l, r.shape, r.dtype, u, o.shape), p = h.map((g) => n.makeTensorInfo([g.length], "int32", g)), y = n.makeTensorInfo(f, r.dtype, d);
  return p.concat([y]);
}
const Eee = {
  kernelName: Qx,
  backendName: "cpu",
  kernelFunc: Iee
};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nee(t) {
  const { inputs: e, backend: n } = t, { starts: s, limits: i, deltas: r } = e, o = n.data.get(s.dataId).values, a = n.data.get(i.dataId).values, c = n.data.get(r.dataId).values, [l, u] = t$(o, s.shape, s.dtype, a, i.shape, c, r.shape), h = n.makeTensorInfo([l.length], "int32", l), d = n.makeTensorInfo([u.length], s.dtype, u);
  return [h, d];
}
const kee = {
  kernelName: e0,
  backendName: "cpu",
  kernelFunc: Nee
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Aee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { shape: i, values: r, defaultValue: o, rowPartitionTensors: a } = e, { rowPartitionTypes: c } = s, l = n.data.get(i.dataId).values, u = n.data.get(r.dataId).values, h = n.data.get(o.dataId).values, d = a.map((g) => n.data.get(g.dataId).values), f = a.map((g) => g.shape), [p, y] = n$(l, i.shape, u, r.shape, r.dtype, h, o.shape, d, f, c);
  return n.makeTensorInfo(p, r.dtype, y);
}
const Mee = {
  kernelName: t0,
  backendName: "cpu",
  kernelFunc: Aee
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ree(t) {
  const { backend: e, attrs: n } = t, { start: s, stop: i, dtype: r, step: o } = n, a = s$(s, i, o, r);
  return e.makeTensorInfo([a.length], r, a);
}
const Dee = {
  kernelName: n0,
  backendName: "cpu",
  kernelFunc: Ree
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $ee = Jt(fh, (t) => 1 / t), Oee = {
  kernelName: fh,
  backendName: "cpu",
  kernelFunc: $ee
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Lee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { images: i } = e, { alignCorners: r, halfPixelCenters: o, size: a } = s;
  nt(i, "resizeBilinear");
  const c = ct(i.shape), [l, u] = a, [h, d, f, p] = i.shape, y = n.data.get(i.dataId).values, g = new Float32Array(ue([h, l, u, p])), m = [
    r && l > 1 ? d - 1 : d,
    r && u > 1 ? f - 1 : f
  ], x = [
    r && l > 1 ? l - 1 : l,
    r && u > 1 ? u - 1 : u
  ];
  let v = 0;
  const b = m[0] / x[0], w = m[1] / x[1];
  for (let S = 0; S < h; S++)
    for (let _ = 0; _ < l; _++) {
      let E;
      o ? E = b * (_ + 0.5) - 0.5 : E = b * _;
      const I = Math.max(0, Math.floor(E)), k = E - I, M = Math.min(d - 1, Math.ceil(E)), L = S * c[0] + I * c[1], O = S * c[0] + M * c[1];
      for (let $ = 0; $ < u; $++) {
        let D;
        o ? D = w * ($ + 0.5) - 0.5 : D = w * $;
        const z = Math.max(0, Math.floor(D)), W = D - z, j = Math.min(f - 1, Math.ceil(D)), J = L + z * c[2], ne = O + z * c[2], re = L + j * c[2], fe = O + j * c[2];
        for (let ae = 0; ae < p; ae++) {
          const ve = y[J + ae], me = y[ne + ae], te = y[re + ae], $e = y[fe + ae], _e = ve + (te - ve) * W, ke = me + ($e - me) * W, Re = _e + (ke - _e) * k;
          g[v++] = Re;
        }
      }
    }
  return n.makeTensorInfo([h, l, u, p], "float32", g);
}
const Fee = {
  kernelName: Np,
  backendName: "cpu",
  kernelFunc: Lee
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Pee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { images: i, dy: r } = e, { alignCorners: o } = s;
  nt([r, i], "resizeBilinearGrad");
  const a = ct(i.shape), [c, l, u, h] = i.shape, [, d, f] = r.shape, p = new Float32Array(c * l * u * h), y = [
    o && d > 1 ? l - 1 : l,
    o && f > 1 ? u - 1 : u
  ], g = [
    o && d > 1 ? d - 1 : d,
    o && f > 1 ? f - 1 : f
  ], m = y[0] / g[0], x = y[1] / g[1], v = n.data.get(r.dataId).values;
  let b = 0;
  for (let w = 0; w < c; w++) {
    const S = w * a[0];
    for (let _ = 0; _ < d; _++) {
      const E = _ * m, I = Math.floor(E), k = Math.min(Math.ceil(E), l - 1), M = S + I * a[1], L = S + k * a[1], O = E - I, $ = 1 - O;
      for (let D = 0; D < f; D++) {
        const z = D * x, W = Math.floor(z), j = Math.min(Math.ceil(z), u - 1), J = z - W, ne = 1 - J, re = M + W * a[2], fe = M + j * a[2], ae = L + W * a[2], ve = L + j * a[2], me = $ * ne, te = $ * J, $e = O * ne, _e = O * J;
        for (let ke = 0; ke < h; ke++) {
          const Re = v[b++];
          p[re + ke] += Re * me, p[fe + ke] += Re * te, p[ae + ke] += Re * $e, p[ve + ke] += Re * _e;
        }
      }
    }
  }
  return n.makeTensorInfo([c, u, l, h], "float32", p);
}
const Bee = {
  kernelName: r0,
  backendName: "cpu",
  kernelFunc: Pee
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { images: i } = e, { alignCorners: r, halfPixelCenters: o, size: a } = s;
  nt(i, "resizeNearestNeighbor");
  const c = ct(i.shape), [l, u] = a, [h, d, f, p] = i.shape, y = n.data.get(i.dataId).values, g = new Float32Array(h * l * u * p), m = [
    r && l > 1 ? d - 1 : d,
    r && u > 1 ? f - 1 : f
  ], x = [
    r && l > 1 ? l - 1 : l,
    r && u > 1 ? u - 1 : u
  ], v = m[0] / x[0], b = m[1] / x[1];
  let w = 0;
  for (let S = 0; S < h; S++) {
    const _ = S * c[0];
    for (let E = 0; E < l; E++) {
      const I = o ? v * (E + 0.5) : v * E;
      let k = Math.min(d - 1, r ? Math.round(I) : Math.floor(I));
      o && (k = Math.max(0, k));
      const M = _ + k * c[1];
      for (let L = 0; L < u; L++) {
        const O = o ? b * (L + 0.5) : b * L;
        let $ = Math.min(f - 1, r ? Math.round(O) : Math.floor(O));
        o && ($ = Math.max(0, $));
        const D = M + $ * c[2];
        for (let z = 0; z < p; z++) {
          const W = y[D + z];
          g[w++] = W;
        }
      }
    }
  }
  return n.makeTensorInfo([h, l, u, p], i.dtype, g);
}
const Vee = {
  kernelName: Ep,
  backendName: "cpu",
  kernelFunc: zee
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Uee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { images: i, dy: r } = e, { alignCorners: o } = s;
  nt([r, i], "resizeNearestNeighborGrad");
  const a = ct(i.shape), c = ct(r.shape), [l, u, h, d] = i.shape, [, f, p] = r.shape, y = new Float32Array(l * u * h * d), g = n.data.get(r.dataId).values, m = [
    o && f > 1 ? u - 1 : u,
    o && p > 1 ? h - 1 : h
  ], x = [
    o && f > 1 ? f - 1 : f,
    o && p > 1 ? p - 1 : p
  ], v = m[0] / x[0], b = m[1] / x[1], w = 1 / v, S = 1 / b, _ = Math.ceil(w) * 2 + 2, E = Math.ceil(S) * 2 + 2;
  for (let I = 0; I < l; I++) {
    const k = I * a[0];
    for (let M = 0; M < u; M++) {
      const L = k + M * a[1], O = Math.floor(M * w), $ = Math.floor(O - _ / 2);
      for (let D = 0; D < h; D++) {
        const z = L + D * a[2], W = Math.floor(D * S), j = Math.floor(W - E / 2);
        for (let J = 0; J < d; J++) {
          let ne = 0;
          for (let re = 0; re < _; re++) {
            const fe = re + $;
            if (fe < 0 || fe >= f)
              continue;
            const ae = k + fe * c[1], ve = fe * v, me = Math.min(u - 1, o ? Math.round(ve) : Math.floor(ve));
            if (M === me)
              for (let te = 0; te < E; te++) {
                const $e = te + j;
                if ($e < 0 || $e >= p)
                  continue;
                const _e = ae + $e * c[2], ke = $e * b, Re = Math.min(h - 1, o ? Math.round(ke) : Math.floor(ke));
                D === Re && (ne += g[_e + J]);
              }
          }
          y[z + J] = ne;
        }
      }
    }
  }
  return n.makeTensorInfo(i.shape, i.dtype, y);
}
const Gee = {
  kernelName: i0,
  backendName: "cpu",
  kernelFunc: Uee
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Wee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { dims: r } = s;
  nt(i, "reverse");
  const o = i.shape.length, a = Rt(r, i.shape);
  if (o === 0)
    return ao({ inputs: { x: i }, backend: n });
  const c = new Xn(i.shape, i.dtype), l = n.bufferSync(i);
  for (let u = 0; u < c.size; u++) {
    const h = c.indexToLoc(u), d = h.slice();
    a.forEach((f) => d[f] = i.shape[f] - 1 - d[f]), c.set(l.get(...d), ...h);
  }
  return n.makeTensorInfo(c.shape, c.dtype, c.values);
}
const Hee = {
  kernelName: kp,
  backendName: "cpu",
  kernelFunc: Wee
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jee = {
  kernelName: S0,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, attrs: e, backend: n }) => {
    const { image: s } = t, { radians: i, fillValue: r, center: o } = e, a = n, c = ls(s.dtype, ue(s.shape)), [l, u, h, d] = s.shape, [f, p] = $_(o, u, h), y = 255, g = Math.sin(i), m = Math.cos(i), x = a.data.get(s.dataId).values;
    for (let b = 0; b < l; b++) {
      const w = b * h * u * d;
      for (let S = 0; S < u; S++) {
        const _ = S * (h * d);
        for (let E = 0; E < h; E++) {
          const I = E * d;
          for (let k = 0; k < d; k++) {
            const M = [l, S, E, k], L = M[2], O = M[1];
            let $ = (L - f) * m - (O - p) * g, D = (L - f) * g + (O - p) * m;
            $ = Math.round($ + f), D = Math.round(D + p);
            let z = r;
            if (typeof r != "number" && (k === 3 ? z = y : z = r[k]), $ >= 0 && $ < h && D >= 0 && D < u) {
              const j = D * (h * d), J = $ * d, ne = w + j + J + k;
              z = x[ne];
            }
            const W = w + _ + I + k;
            c[W] = z;
          }
        }
      }
    }
    return { dataId: a.write(c, s.shape, s.dtype), shape: s.shape, dtype: s.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qee = Jt(gh, (t) => {
  const e = Math.floor(t);
  return t - e < 0.5 ? Math.floor(t) : t - e > 0.5 ? Math.ceil(t) : e % 2 === 0 ? e : e + 1;
}), Xee = {
  kernelName: gh,
  backendName: "cpu",
  kernelFunc: qee
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Kee(t) {
  const { inputs: e, backend: n, attrs: s } = t, { indices: i, updates: r } = e, { shape: o } = s, { sliceRank: a, numUpdates: c, sliceSize: l, strides: u, outputSize: h } = Ua(r, i, o), d = !0, f = n.bufferSync(i), p = n.bufferSync(r), y = yc(f, p, o, h, l, c, a, u, 0, d);
  return n.makeTensorInfo(o, y.dtype, y.values);
}
const Yee = {
  kernelName: o0,
  backendName: "cpu",
  kernelFunc: Kee
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zee(t, e) {
  let n = 0, s = t.length, i = 0;
  for (; n < s; )
    i = Math.floor((n + s) / 2), t[i] < e ? n = i + 1 : s = i;
  return s;
}
function Jee(t, e) {
  let n = 0, s = t.length, i = 0;
  for (; n < s; )
    i = Math.floor((n + s) / 2), t[i] <= e ? n = i + 1 : s = i;
  return s;
}
function Qee(t, e, n, s, i, r) {
  const o = $n("int32", n * i);
  for (let a = 0; a < n; ++a) {
    const c = t.slice(a * s, (a + 1) * s), l = a * i;
    for (let u = 0; u < i; ++u)
      o[l + u] = r === "left" ? Zee(c, e[u + l]) : Jee(c, e[u + l]);
  }
  return o;
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ete(t) {
  const { inputs: e, backend: n, attrs: s } = t, { sortedSequence: i, values: r } = e, { side: o } = s, a = n.data.get(i.dataId).values, c = n.data.get(r.dataId).values, l = Qee(a, c, i.shape[0], i.shape[1], r.shape[1], o);
  return n.makeTensorInfo(r.shape, "int32", l);
}
const tte = {
  kernelName: c0,
  backendName: "cpu",
  kernelFunc: ete
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nte(t) {
  const { inputs: e, backend: n } = t, { condition: s, t: i, e: r } = e;
  nt([s, i, r], "select");
  const o = s.shape.length, a = n.data.get(s.dataId).values, c = n.data.get(i.dataId).values, l = n.data.get(r.dataId).values, u = ni(i.dtype, r.dtype), h = vs(ue(i.shape), u);
  let d = 0;
  const f = o === 0 || o > 1 || i.shape.length === 1 ? 1 : ue(i.shape.slice(1));
  for (let p = 0; p < a.length; p++)
    for (let y = 0; y < f; y++)
      a[p] === 1 ? h[d++] = c[p] : h[d++] = l[p];
  return n.makeTensorInfo(i.shape, u, h);
}
const ste = {
  kernelName: Ap,
  backendName: "cpu",
  kernelFunc: nte
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ite = db, rte = fb, ote = Jt(xh, (t) => t >= 0 ? rte * t : ite * (Math.exp(t) - 1)), ate = {
  kernelName: xh,
  backendName: "cpu",
  kernelFunc: ote
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cte = Jt(wh, (t) => t < 0 ? -1 : t > 0 ? 1 : 0), lte = {
  kernelName: wh,
  backendName: "cpu",
  kernelFunc: cte
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ute = Jt(bh, (t) => Math.sin(t)), hte = {
  kernelName: bh,
  backendName: "cpu",
  kernelFunc: ute
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dte = Jt(vh, (t) => Math.sinh(t)), fte = {
  kernelName: vh,
  backendName: "cpu",
  kernelFunc: dte
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pte = 11920928955078125e-23, RI = Math.log(pte) + 2, mte = Jt(_h, (t) => {
  const e = t > -RI, n = t < RI, s = Math.exp(t);
  let i;
  return n ? i = s : e ? i = t : i = Math.log(1 + s), i;
}), gte = {
  kernelName: _h,
  backendName: "cpu",
  kernelFunc: mte
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yte(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { blockShape: r, paddings: o } = s;
  nt([i], "spaceToBatchND");
  const a = ue(r), c = [[0, 0]];
  c.push(...o);
  for (let S = 1 + r.length; S < i.shape.length; ++S)
    c.push([0, 0]);
  const l = O$.kernelFunc({
    inputs: { x: i },
    backend: n,
    attrs: { paddings: c, constantValue: 0 }
  }), u = um(l.shape, r, a, !1), h = hm(u.length, r.length, !1), d = dm(l.shape, r, a, !1), y = fn({ inputs: { x: l }, backend: n, attrs: { shape: u } }), x = oi({ inputs: { x: y }, backend: n, attrs: { perm: h } }), w = fn({ inputs: { x }, backend: n, attrs: { shape: d } });
  return n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(x), w;
}
const xte = {
  kernelName: Dp,
  backendName: "cpu",
  kernelFunc: yte
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bte(t) {
  const { inputs: e, backend: n } = t, { indices: s, values: i, denseShape: r, defaultValue: o } = e;
  if (r.shape.length !== 1)
    throw new Error(`Dense shape must be a vector, saw:
        ${r.shape}`);
  if (s.shape.length !== 2)
    throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);
  if (i.shape.length !== 1)
    throw new Error(`Values must be a vector, saw:
        ${i.shape}`);
  if (o.shape.length !== 0)
    throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);
  const a = n.data.get(s.dataId).values, c = n.data.get(i.dataId).values, l = n.data.get(r.dataId).values, u = n.data.get(o.dataId).values[0], [h, d, f, p, y] = a$(a, s.shape, s.dtype, c, i.dtype, l, u);
  return [
    n.makeTensorInfo(d, s.dtype, h),
    n.makeTensorInfo([d[0]], i.dtype, f),
    n.makeTensorInfo([p.length], "bool", new Uint8Array(p.map((g) => Number(g)))),
    n.makeTensorInfo([y.length], s.dtype, new Int32Array(y))
  ];
}
const vte = {
  kernelName: l0,
  backendName: "cpu",
  kernelFunc: bte
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wte(t) {
  const { inputs: e, backend: n } = t, { inputIndices: s, inputShape: i, newShape: r } = e;
  if (s.shape.length !== 2)
    throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);
  if (i.shape.length !== 1)
    throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);
  if (r.shape.length !== 1)
    throw new Error(`Target shape should be a vector but received shape ${r.shape}`);
  const o = Array.from(n.data.get(i.dataId).values), a = n.data.get(s.dataId).values, c = Array.from(n.data.get(r.dataId).values), [l, u, h] = c$(a, s.shape, s.dtype, o, c);
  return [
    n.makeTensorInfo(u, s.dtype, l),
    n.makeTensorInfo([h.length], r.dtype, new Int32Array(h))
  ];
}
const Ste = {
  kernelName: u0,
  backendName: "cpu",
  kernelFunc: wte
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _te(t) {
  const { inputs: e, backend: n } = t, { data: s, indices: i, segmentIds: r } = e;
  if (s.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (i.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);
  if (r.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
          ${r.shape}`);
  if (i.shape[0] !== r.shape[0])
    throw new Error("segmentIds and indices should have same size.");
  const o = n.data.get(s.dataId).values, a = n.data.get(i.dataId).values, c = n.data.get(r.dataId).values, [l, u] = TT(o, s.shape, s.dtype, a, c, !0);
  return n.makeTensorInfo(u, s.dtype, l);
}
const Tte = {
  kernelName: h0,
  backendName: "cpu",
  kernelFunc: _te
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Cte(t) {
  const { inputs: e, backend: n } = t, { data: s, indices: i, segmentIds: r } = e;
  if (s.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (i.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);
  if (r.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
         ${r.shape}`);
  if (i.shape[0] !== r.shape[0])
    throw new Error("segmentIds and indices should have same size.");
  const o = n.data.get(s.dataId).values, a = n.data.get(i.dataId).values, c = n.data.get(r.dataId).values, [l, u] = TT(o, s.shape, s.dtype, a, c);
  return n.makeTensorInfo(u, s.dtype, l);
}
const Ite = {
  kernelName: d0,
  backendName: "cpu",
  kernelFunc: Cte
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ete(t) {
  const { inputs: e, backend: n, attrs: s } = t, { sparseIndices: i, sparseValues: r, defaultValue: o } = e, { outputShape: a } = s, { sliceRank: c, numUpdates: l, sliceSize: u, strides: h, outputSize: d } = Ua(r, i, a), f = !1, p = n.bufferSync(i);
  let y;
  switch (r.dtype) {
    case "bool": {
      const g = n.bufferSync(r), m = !!n.data.get(o.dataId).values[0];
      y = yc(p, g, a, d, u, l, c, h, m, f);
      break;
    }
    case "float32": {
      const g = n.bufferSync(r), m = n.data.get(o.dataId).values[0];
      y = yc(p, g, a, d, u, l, c, h, m, f);
      break;
    }
    case "int32": {
      const g = n.bufferSync(r), m = n.data.get(o.dataId).values[0];
      y = yc(p, g, a, d, u, l, c, h, m, f);
      break;
    }
    case "string": {
      const g = n.bufferSync(r), m = Ro(n.data.get(o.dataId).values[0]);
      y = yc(p, g, a, d, u, l, c, h, m, f);
      break;
    }
    default:
      throw new Error(`Unsupported type ${r.dtype}`);
  }
  return n.makeTensorInfo(a, y.dtype, y.values);
}
const Nte = {
  kernelName: f0,
  backendName: "cpu",
  kernelFunc: Ete
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kte(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { numOrSizeSplits: r, axis: o } = s, a = Rt(o, i.shape)[0], c = K_(i, r, a), l = new Array(i.shape.length).fill(0), u = i.shape.slice();
  return c.map((h) => {
    const d = [...u];
    d[a] = h;
    const f = Xc({ inputs: { x: i }, backend: n, attrs: { begin: l, size: d } });
    return l[a] += h, f;
  });
}
const Ate = {
  kernelName: $p,
  backendName: "cpu",
  kernelFunc: kte
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Mte = {
  kernelName: p0,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, backend: e }) => {
    const { x: n } = t, s = e;
    nt(n, "square");
    const i = s.data.get(n.dataId).values, r = new Float32Array(i.length);
    for (let a = 0; a < i.length; ++a) {
      const c = i[a];
      r[a] = c * c;
    }
    return { dataId: s.write(r, n.shape, n.dtype), shape: n.shape, dtype: n.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Rte = Jt(Ah, (t, e) => {
  const n = e;
  return isNaN(t) ? NaN : t > 0 ? 1 : n.alpha;
}), Dte = {
  kernelName: Ah,
  backendName: "cpu",
  kernelFunc: Rte
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $te(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { begin: r, end: o, strides: a, beginMask: c, endMask: l, ellipsisMask: u, newAxisMask: h, shrinkAxisMask: d } = s;
  nt(i, "stridedSlice");
  const { finalShapeSparse: f, finalShape: p, isIdentity: y, sliceDim0: g, isSimpleSlice: m, begin: x, end: v, strides: b } = A_(i.shape, r, o, a, c, l, u, h, d);
  let w;
  if (y)
    w = fn({ inputs: { x: i }, backend: n, attrs: { shape: p } });
  else if (g || m) {
    A(i.shape.length >= 1, () => `Input must have rank at least 1, got: ${i.shape.length}`);
    const S = E_(x, v, b), _ = Xc({ inputs: { x: i }, backend: n, attrs: { begin: x, size: S } });
    w = fn({ inputs: { x: _ }, backend: n, attrs: { shape: p } }), n.disposeIntermediateTensorInfo(_);
  } else {
    const S = n.bufferSync(i), _ = h$(f, S, b, x);
    w = n.makeTensorInfo(p, _.dtype, _.values);
  }
  return w;
}
const Ote = {
  kernelName: m0,
  backendName: "cpu",
  kernelFunc: $te
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Lte(t) {
  const { inputs: e, backend: n, attrs: s } = t, { separator: i, nGramWidths: r, leftPad: o, rightPad: a, padWidth: c, preserveShortSequences: l } = s, { data: u, dataSplits: h } = e, d = n.data.get(u.dataId).values, f = n.data.get(h.dataId).values, [p, y] = d$(d, f, i, r, o, a, c, l);
  return [
    n.makeTensorInfo([p.length], "string", p),
    n.makeTensorInfo(h.shape, "int32", y)
  ];
}
const Fte = {
  kernelName: g0,
  backendName: "cpu",
  kernelFunc: Lte
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Pte(t) {
  const { inputs: e, backend: n, attrs: s } = t, { skipEmpty: i } = s, { input: r, delimiter: o } = e;
  if (r.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (r.shape.length !== 1)
    throw new Error(`Input must be a vector, got shape: ${r.shape}`);
  if (o.shape.length !== 0)
    throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);
  const a = n.data.get(r.dataId).values, c = n.data.get(o.dataId).values[0], [l, u, h] = f$(a, c, i), d = u.length;
  return [
    n.makeTensorInfo([d, 2], "int32", l),
    n.makeTensorInfo([d], "string", u),
    n.makeTensorInfo([2], "int32", new Int32Array(h))
  ];
}
const Bte = {
  kernelName: y0,
  backendName: "cpu",
  kernelFunc: Pte
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zte(t) {
  const { inputs: e, backend: n, attrs: s } = t, { numBuckets: i } = s, { input: r } = e;
  if (r.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (i <= 0)
    throw new Error("Number of buckets must be at least 1");
  const o = n.data.get(r.dataId).values, a = p$(o, i);
  return n.makeTensorInfo(r.shape, "int32", a);
}
const Vte = {
  kernelName: x0,
  backendName: "cpu",
  kernelFunc: zte
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ute = Jt(Eh, (t) => Math.tan(t)), Gte = {
  kernelName: Eh,
  backendName: "cpu",
  kernelFunc: Ute
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Wte = Jt(Nh, (t) => Math.tanh(t)), Hte = {
  kernelName: Nh,
  backendName: "cpu",
  kernelFunc: Wte
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jte(t) {
  const { inputs: e, backend: n } = t, { tensor: s, indices: i, updates: r } = e, { sliceRank: o, numUpdates: a, sliceSize: c, strides: l, outputSize: u } = Ua(r, i, s.shape), h = !1, d = n.bufferSync(i), f = n.bufferSync(r), p = n.bufferSync(s), y = yc(d, f, s.shape, u, c, a, o, l, p, h);
  return n.makeTensorInfo(s.shape, y.dtype, y.values);
}
const qte = {
  kernelName: a0,
  backendName: "cpu",
  kernelFunc: jte
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xte(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { reps: r } = s;
  nt(i, "tile");
  const o = g$(n.bufferSync(i), r);
  return n.makeTensorInfo(o.shape, o.dtype, o.values);
}
const Kte = {
  kernelName: kh,
  backendName: "cpu",
  kernelFunc: Xte
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yte(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { k: r, sorted: o } = s;
  nt(i, "topk");
  const a = n.data.get(i.dataId).values, [c, l] = x$(a, i.shape, i.dtype, r, o);
  return [
    n.makeTensorInfo(c.shape, c.dtype, c.values),
    n.makeTensorInfo(l.shape, l.dtype, l.values)
  ];
}
const Zte = {
  kernelName: b0,
  backendName: "cpu",
  kernelFunc: Yte
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jte(t) {
  const { inputs: e, attrs: n, backend: s } = t, { image: i, transforms: r } = e, { interpolation: o, fillMode: a, fillValue: c, outputShape: l } = n, [u, h, d, f] = i.shape, [p, y] = l ?? [h, d], g = [u, p, y, f], m = ct(i.shape), x = m[0], v = m[1], b = m[2], w = ct(g), S = w[0], _ = w[1], E = w[2], I = ls(i.dtype, ue(g));
  I.fill(c);
  const k = s.data.get(i.dataId).values, M = s.data.get(r.dataId).values;
  for (let O = 0; O < u; ++O) {
    const $ = r.shape[0] === 1 ? M : M.subarray(O * 8, O * 8 + 8);
    for (let D = 0; D < p; ++D)
      for (let z = 0; z < y; ++z)
        for (let W = 0; W < f; ++W) {
          let j;
          const J = $[6] * z + $[7] * D + 1;
          if (J === 0)
            continue;
          const ne = ($[0] * z + $[1] * D + $[2]) / J, re = ($[3] * z + $[4] * D + $[5]) / J, fe = DI(ne, d, a), ae = DI(re, h, a);
          switch (o) {
            case "nearest":
              j = ine(k, h, d, x, v, b, O, ae, fe, W, c);
              break;
            case "bilinear":
              j = rne(k, h, d, x, v, b, O, ae, fe, W, c);
              break;
            default:
              throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`);
          }
          const ve = O * S + D * _ + z * E + W;
          I[ve] = j;
        }
    return s.makeTensorInfo(g, i.dtype, I);
  }
  return { dataId: s.write(I, g, i.dtype), shape: i.shape, dtype: i.dtype };
}
const Qte = {
  kernelName: v0,
  backendName: "cpu",
  kernelFunc: Jte
};
function DI(t, e, n) {
  switch (n) {
    case "reflect":
      return ene(t, e);
    case "wrap":
      return tne(t, e);
    case "nearest":
      return sne(t, e);
    case "constant":
    default:
      return nne(t);
  }
}
function ene(t, e) {
  let n = t;
  if (n < 0)
    if (e <= 1)
      n = 0;
    else {
      const s = 2 * e;
      n < s && (n = s * Math.trunc(-n / s) + n), n = n < -e ? n + s : -n - 1;
    }
  else if (n > e - 1)
    if (e <= 1)
      n = 0;
    else {
      const s = 2 * e;
      n -= s * Math.trunc(n / s), n >= e && (n = s - n - 1);
    }
  return _a(0, n, e - 1);
}
function tne(t, e) {
  let n = t;
  if (n < 0)
    if (e <= 1)
      n = 0;
    else {
      const s = e - 1;
      n += e * (Math.trunc(-n / s) + 1);
    }
  else if (n > e - 1)
    if (e <= 1)
      n = 0;
    else {
      const s = e - 1;
      n -= e * Math.trunc(n / s);
    }
  return _a(0, n, e - 1);
}
function nne(t, e) {
  return t;
}
function sne(t, e) {
  return _a(0, t, e - 1);
}
function gd(t, e, n, s, i, r, o, a, c, l, u) {
  const h = o * s + a * i + c * r + l;
  return 0 <= a && a < e && 0 <= c && c < n ? t[h] : u;
}
function ine(t, e, n, s, i, r, o, a, c, l, u) {
  const h = Math.round(a), d = Math.round(c);
  return gd(t, e, n, s, i, r, o, h, d, l, u);
}
function rne(t, e, n, s, i, r, o, a, c, l, u) {
  const h = Math.floor(a), d = Math.floor(c), f = h + 1, p = d + 1, y = (p - c) * gd(t, e, n, s, i, r, o, h, d, l, u) + (c - d) * gd(t, e, n, s, i, r, o, h, p, l, u), g = (p - c) * gd(t, e, n, s, i, r, o, f, d, l, u) + (c - d) * gd(t, e, n, s, i, r, o, f, p, l, u);
  return (f - a) * y + (a - h) * g;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function one(t) {
  const { inputs: e, attrs: n, backend: s } = t, { axis: i } = n, { x: r } = e;
  nt(r, "unique");
  const o = s.data.get(r.dataId).values, { outputValues: a, outputShape: c, indices: l } = b$(o, i, r.shape, r.dtype);
  return [
    s.makeTensorInfo(c, r.dtype, a),
    s.makeTensorInfo([l.length], "int32", l)
  ];
}
const ane = {
  kernelName: w0,
  backendName: "cpu",
  kernelFunc: one
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cne(t) {
  const { inputs: e, backend: n, attrs: s } = t, { value: i } = e;
  let { axis: r } = s;
  r < 0 && (r += i.shape.length);
  const o = i.shape.length, a = i.shape[r], c = new Array(o - 1);
  let l = 0;
  for (let f = 0; f < o; f++)
    f !== r && (c[l++] = i.shape[f]);
  const u = new Array(o).fill(0), h = i.shape.slice();
  h[r] = 1;
  const d = new Array(a);
  for (let f = 0; f < d.length; f++) {
    u[r] = f;
    const p = Xc({ inputs: { x: i }, backend: n, attrs: { begin: u, size: h } });
    d[f] = fn({ inputs: { x: p }, backend: n, attrs: { shape: c } }), n.disposeIntermediateTensorInfo(p);
  }
  return d;
}
const lne = {
  kernelName: Fp,
  backendName: "cpu",
  kernelFunc: cne
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function une(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, segmentIds: r } = e, { numSegments: o } = s;
  nt(i, "unsortedSegmentSum");
  const a = i.shape.length, c = r.shape.length, l = [], u = [], h = a - c;
  let d = r;
  for (let p = 0; p < h; ++p) {
    const y = Jy({ inputs: { input: d }, backend: n, attrs: { dim: p + 1 } });
    d = y, u.push(y);
  }
  for (let p = 0; p < o; ++p) {
    const y = Vo(p, "int32"), g = n.makeTensorInfo([], "int32", y), m = $D({ inputs: { a: g, b: d }, backend: n }), x = Oa({ inputs: { x: m }, backend: n, attrs: { dtype: "float32" } }), v = Ib({ inputs: { a: x, b: i }, backend: n }), b = wm({ inputs: { x: v }, backend: n, attrs: { axis: 0, keepDims: !1 } });
    l.push(b), u.push(g), u.push(m), u.push(x), u.push(v), u.push(b);
  }
  const f = $$({ inputs: l, backend: n, attrs: { axis: 0 } });
  return u.forEach((p) => n.disposeIntermediateTensorInfo(p)), f;
}
const hne = {
  kernelName: Pp,
  backendName: "cpu",
  kernelFunc: une
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dne = [
  oZ,
  z9,
  cZ,
  uZ,
  j9,
  dZ,
  pZ,
  gZ,
  xZ,
  vZ,
  SZ,
  TZ,
  IZ,
  kZ,
  MZ,
  $Z,
  LZ,
  PZ,
  zZ,
  iZ,
  UZ,
  WZ,
  jZ,
  X9,
  XZ,
  W9,
  Y9,
  YZ,
  V9,
  JZ,
  eJ,
  tJ,
  sJ,
  rJ,
  aJ,
  lJ,
  hJ,
  fJ,
  mJ,
  yJ,
  bJ,
  wJ,
  _J,
  CJ,
  IJ,
  NJ,
  AJ,
  RJ,
  DJ,
  $J,
  OJ,
  FJ,
  zJ,
  ZY,
  UJ,
  Z9,
  YJ,
  J9,
  ZJ,
  eY,
  sQ,
  iQ,
  oQ,
  nY,
  iY,
  cQ,
  uQ,
  dQ,
  pQ,
  oY,
  cY,
  U9,
  gQ,
  QZ,
  xQ,
  vQ,
  SQ,
  JY,
  uY,
  dY,
  TQ,
  pY,
  IQ,
  kQ,
  MQ,
  $Q,
  LQ,
  PQ,
  BQ,
  gY,
  VQ,
  GQ,
  HQ,
  qQ,
  KQ,
  ZQ,
  QQ,
  xY,
  tee,
  iee,
  aee,
  vY,
  SY,
  uee,
  fee,
  gee,
  TY,
  xee,
  vee,
  wee,
  O$,
  Cee,
  eZ,
  EY,
  Eee,
  kee,
  Mee,
  Dee,
  G9,
  S1,
  Oee,
  tZ,
  nZ,
  sZ,
  Fee,
  Bee,
  Vee,
  Gee,
  Hee,
  jee,
  Xee,
  OY,
  Yee,
  tte,
  ste,
  ate,
  FY,
  lte,
  hte,
  fte,
  PY,
  ree,
  gte,
  xte,
  vte,
  Ste,
  Tte,
  Ite,
  Nte,
  Ate,
  VY,
  Mte,
  GY,
  HY,
  Dte,
  Ote,
  Fte,
  Bte,
  Vte,
  KY,
  PJ,
  Gte,
  Hte,
  qte,
  Kte,
  Zte,
  Qte,
  CY,
  ane,
  lne,
  hne,
  bee
];
for (const t of dne)
  _0(t);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pc = {}, wg = {
  alpha: !1,
  antialias: !1,
  premultipliedAlpha: !1,
  preserveDrawingBuffer: !1,
  depth: !1,
  stencil: !1,
  failIfMajorPerformanceCaveat: !0
};
function fne(t, e) {
  pc[t] = e;
}
function Ir(t, e) {
  if (!(t in pc) || e != null) {
    const s = mne(t, e);
    if (s !== null)
      pc[t] = s;
    else
      return console.log("Could not get context for WebGL version", t), null;
  }
  const n = pc[t];
  return n == null || n.isContextLost() ? (delete pc[t], Ir(t)) : (n.disable(n.DEPTH_TEST), n.disable(n.STENCIL_TEST), n.disable(n.BLEND), n.disable(n.DITHER), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SAMPLE_COVERAGE), n.enable(n.SCISSOR_TEST), n.enable(n.CULL_FACE), n.cullFace(n.BACK), pc[t]);
}
function pne(t) {
  if (!ie().getBool("IS_SAFARI") && typeof OffscreenCanvas < "u" && t === 2)
    return new OffscreenCanvas(300, 150);
  if (typeof document < "u")
    return document.createElement("canvas");
  throw new Error("Cannot create a canvas in this context");
}
function mne(t, e) {
  if (t !== 1 && t !== 2)
    throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
  const n = e ?? pne(t);
  return n.addEventListener("webglcontextlost", (s) => {
    s.preventDefault(), delete pc[t];
  }, !1), ie().getBool("SOFTWARE_WEBGL_ENABLED") && (wg.failIfMajorPerformanceCaveat = !1), t === 1 ? (
    // tslint:disable-next-line
    n.getContext("webgl", wg) || n.getContext("experimental-webgl", wg)
  ) : n.getContext("webgl2", wg);
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var If;
(function(t) {
  t[t.DENSE = 0] = "DENSE", t[t.SHARED_BATCH = 1] = "SHARED_BATCH";
})(If || (If = {}));
var ki;
(function(t) {
  t[t.RENDER = 0] = "RENDER", t[t.UPLOAD = 1] = "UPLOAD", t[t.PIXELS = 2] = "PIXELS", t[t.DOWNLOAD = 3] = "DOWNLOAD";
})(ki || (ki = {}));
var gs;
(function(t) {
  t[t.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", t[t.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", t[t.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", t[t.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", t[t.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
})(gs || (gs = {}));
function Sm(t, e) {
  return [e, t];
}
function gne(t, e) {
  return t * e;
}
function Sg(t) {
  const e = ue(t), n = Math.ceil(e / 4);
  return Ny(n);
}
function Bh(t, e) {
  return [
    Math.max(1, Math.ceil(e / 2)),
    Math.max(1, Math.ceil(t / 2))
  ];
}
function yne(t, e) {
  const [n, s] = Bh(t, e);
  return n * s * 4;
}
function kT(t, e) {
  const n = t;
  let s, i, r, o, a, c, l, u, h, d;
  return ie().getNumber("WEBGL_VERSION") === 2 ? (s = n.R32F, i = n.R16F, r = n.RGBA16F, o = n.RGBA32F, a = n.RED, l = 4, u = 1, h = n.HALF_FLOAT, d = n.FLOAT, c = n.RGBA8) : (s = t.RGBA, i = t.RGBA, r = t.RGBA, o = n.RGBA, a = t.RGBA, l = 4, u = 4, h = e != null ? e.HALF_FLOAT_OES : null, d = t.FLOAT, c = t.RGBA), {
    internalFormatFloat: s,
    internalFormatHalfFloat: i,
    internalFormatPackedHalfFloat: r,
    internalFormatPackedFloat: o,
    textureFormatFloat: a,
    downloadTextureFormat: c,
    downloadUnpackNumChannels: l,
    defaultNumChannels: u,
    textureTypeHalfFloat: h,
    textureTypeFloat: d
  };
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function He(t, e) {
  const n = e();
  return ie().getBool("DEBUG") && xne(t), n;
}
function xne(t) {
  const e = t.getError();
  if (e !== t.NO_ERROR)
    throw new Error("WebGL Error: " + Sne(t, e));
}
const bne = 596e-10, vne = 65504;
function wne(t) {
  return !!(ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || t === 0 || bne < Math.abs(t) && Math.abs(t) < vne);
}
function Sne(t, e) {
  switch (e) {
    case t.NO_ERROR:
      return "NO_ERROR";
    case t.INVALID_ENUM:
      return "INVALID_ENUM";
    case t.INVALID_VALUE:
      return "INVALID_VALUE";
    case t.INVALID_OPERATION:
      return "INVALID_OPERATION";
    case t.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";
    case t.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case t.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";
    default:
      return `Unknown error code ${e}`;
  }
}
function _g(t, e) {
  return qo(t, () => t.getExtension(e), 'Extension "' + e + '" not supported on this browser.');
}
function _ne(t, e) {
  const n = qo(t, () => t.createShader(t.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
  if (He(t, () => t.shaderSource(n, e)), He(t, () => t.compileShader(n)), t.getShaderParameter(n, t.COMPILE_STATUS) === !1)
    throw console.log(t.getShaderInfoLog(n)), new Error("Failed to compile vertex shader.");
  return n;
}
function Tne(t, e) {
  const n = qo(t, () => t.createShader(t.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
  if (He(t, () => t.shaderSource(n, e)), He(t, () => t.compileShader(n)), ie().get("ENGINE_COMPILE_ONLY"))
    return n;
  if (t.getShaderParameter(n, t.COMPILE_STATUS) === !1)
    throw L$(e, t.getShaderInfoLog(n)), new Error("Failed to compile fragment shader.");
  return n;
}
const Cne = /ERROR: [0-9]+:([0-9]+):/g;
function L$(t, e) {
  const n = Cne.exec(e);
  if (n == null) {
    console.log(`Couldn't parse line number in error: ${e}`), console.log(t);
    return;
  }
  const s = +n[1], i = t.split(`
`), r = i.length.toString().length + 2, o = i.map((h, d) => vc((d + 1).toString(), r) + h);
  let a = 0;
  for (let h = 0; h < o.length; h++)
    a = Math.max(o[h].length, a);
  const c = o.slice(0, s - 1), l = o.slice(s - 1, s), u = o.slice(s);
  console.log(c.join(`
`)), console.log(e.split(`
`)[0]), console.log(`%c ${vc(l[0], a)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(u.join(`
`));
}
function Ine(t) {
  return qo(t, () => t.createProgram(), "Unable to create WebGLProgram.");
}
function Ene(t, e) {
  if (He(t, () => t.linkProgram(e)), !ie().get("ENGINE_COMPILE_ONLY") && t.getProgramParameter(e, t.LINK_STATUS) === !1)
    throw console.log(t.getProgramInfoLog(e)), new Error("Failed to link vertex and fragment shaders.");
}
function Nv(t, e) {
  if (He(t, () => t.validateProgram(e)), t.getProgramParameter(e, t.VALIDATE_STATUS) === !1)
    throw console.log(t.getProgramInfoLog(e)), new Error("Shader program validation failed.");
}
function Nne(t, e) {
  const n = qo(t, () => t.createBuffer(), "Unable to create WebGLBuffer");
  return He(t, () => t.bindBuffer(t.ARRAY_BUFFER, n)), He(t, () => t.bufferData(t.ARRAY_BUFFER, e, t.STATIC_DRAW)), n;
}
function kne(t, e) {
  const n = qo(t, () => t.createBuffer(), "Unable to create WebGLBuffer");
  return He(t, () => t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n)), He(t, () => t.bufferData(t.ELEMENT_ARRAY_BUFFER, e, t.STATIC_DRAW)), n;
}
function Ane(t) {
  return qo(t, () => t.createTexture(), "Unable to create WebGLTexture.");
}
function Mne(t, e) {
  const n = ie().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (t <= 0 || e <= 0) {
    const s = `[${t}x${e}]`;
    throw new Error("Requested texture size " + s + " is invalid.");
  }
  if (t > n || e > n) {
    const s = `[${t}x${e}]`, i = `[${n}x${n}]`;
    throw new Error("Requested texture size " + s + " greater than WebGL maximum on this browser / GPU " + i + ".");
  }
}
function Rne(t) {
  return qo(t, () => t.createFramebuffer(), "Unable to create WebGLFramebuffer.");
}
function $I(t, e, n, s, i, r, o) {
  const a = t.getAttribLocation(e, n);
  return a === -1 ? !1 : (He(t, () => t.bindBuffer(t.ARRAY_BUFFER, s)), He(t, () => t.vertexAttribPointer(a, i, t.FLOAT, !1, r, o)), He(t, () => t.enableVertexAttribArray(a)), !0);
}
function Dne(t, e, n) {
  Pne(t, n), He(t, () => t.activeTexture(t.TEXTURE0 + n)), He(t, () => t.bindTexture(t.TEXTURE_2D, e));
}
function $ne(t, e, n) {
  return qo(t, () => t.getUniformLocation(e, n), 'uniform "' + n + '" not present in program.');
}
function One(t, e, n) {
  return t.getUniformLocation(e, n);
}
function Lne(t, e, n, s) {
  He(t, () => Dne(t, e, s)), He(t, () => t.uniform1i(n, s));
}
function kv(t, e, n) {
  He(t, () => t.bindFramebuffer(t.FRAMEBUFFER, n)), He(t, () => t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0));
}
function OI(t, e) {
  He(t, () => t.bindFramebuffer(t.FRAMEBUFFER, e)), He(t, () => t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0));
}
function Tg(t) {
  const e = t.checkFramebufferStatus(t.FRAMEBUFFER);
  if (e !== t.FRAMEBUFFER_COMPLETE)
    throw new Error("Error binding framebuffer: " + Fne(t, e));
}
function Fne(t, e) {
  switch (e) {
    case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    case t.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";
    default:
      return `unknown error ${e}`;
  }
}
function qo(t, e, n) {
  const s = He(t, () => e());
  if (s == null)
    throw new Error(n);
  return s;
}
function Pne(t, e) {
  const n = t.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, s = e + t.TEXTURE0;
  if (s < t.TEXTURE0 || s > n) {
    const i = `[gl.TEXTURE0, gl.TEXTURE${n}]`;
    throw new Error(`textureUnit must be in ${i}.`);
  }
}
function Au(t, e = 2) {
  return ue(t.slice(0, t.length - e));
}
function Mu(t) {
  if (t.length === 0)
    throw Error("Cannot get rows and columns of an empty shape array.");
  return [
    t.length > 1 ? t[t.length - 2] : 1,
    t[t.length - 1]
  ];
}
function Cg(t) {
  let e = [1, 1, 1];
  return t.length === 0 || t.length === 1 && t[0] === 1 || (e = [Au(t), ...Mu(t)]), e;
}
function Bne(t, e = !1) {
  let n = ie().getNumber("WEBGL_MAX_TEXTURE_SIZE"), s = ie().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
  s === 1 / 0 && ie().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE") && (s = n / 2), e && (n = n * 2, s = s * 2, t = t.map((a, c) => c >= t.length - 2 ? gx(t[c]) : t[c]), t.length === 1 && (t = [2, t[0]])), t.length !== 2 && (t = zo(t).newShape);
  let i = ue(t), r = null;
  t.length <= 1 && i <= n ? r = [1, i] : t.length === 2 && t[0] <= n && t[1] <= n ? r = t : t.length === 3 && t[0] * t[1] <= n && t[2] <= n ? r = [t[0] * t[1], t[2]] : t.length === 3 && t[0] <= n && t[1] * t[2] <= n ? r = [t[0], t[1] * t[2]] : t.length === 4 && t[0] * t[1] * t[2] <= n && t[3] <= n ? r = [t[0] * t[1] * t[2], t[3]] : t.length === 4 && t[0] <= n && t[1] * t[2] * t[3] <= n && (r = [t[0], t[1] * t[2] * t[3]]);
  const o = r != null && Math.max(...r) > s && Math.min(...r) <= (e ? 2 : 1) && Math.min(...r) > 0;
  if (r == null || o)
    if (e) {
      const a = Au(t);
      let c = 2, l = 2;
      t.length && ([c, l] = Mu(t)), i = a * (c / 2) * (l / 2), r = Ny(i).map((u) => u * 2);
    } else
      r = Ny(i);
  return r;
}
function Ig(t) {
  return t % 2 === 0;
}
function ex(t, e) {
  if (t = t.slice(-2), e = e.slice(-2), Bt(t, e) || !t.length || !e.length || t[0] === 0 || t[1] === 0 || e[0] === 0 || e[1] === 0)
    return !0;
  if (t.length !== e.length) {
    const n = t[t.length - 1], s = e[e.length - 1];
    if (n === s || Ig(n) && Ig(s) && (t[0] === 1 || e[0] === 1))
      return !0;
  }
  return t[1] === e[1] && Ig(t[0]) && Ig(e[0]);
}
let Av, Mv;
function zne(t) {
  if (Av == null) {
    const e = Ir(t);
    Av = e.getParameter(e.MAX_TEXTURE_SIZE);
  }
  return Av;
}
function Vne(t) {
  if (Mv == null) {
    const e = Ir(t);
    Mv = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
  }
  return Math.min(16, Mv);
}
function Une(t) {
  if (t === 0)
    return 0;
  let e;
  const n = Ir(t);
  return Yi(n, "EXT_disjoint_timer_query_webgl2") && t === 2 ? e = 2 : Yi(n, "EXT_disjoint_timer_query") ? e = 1 : e = 0, e;
}
function Yi(t, e) {
  return t.getExtension(e) != null;
}
function LI(t) {
  try {
    if (Ir(t) != null)
      return !0;
  } catch (e) {
    return console.log("Error when getting WebGL context: ", e), !1;
  }
  return !1;
}
function Gne(t) {
  if (t === 0)
    return !1;
  const e = Ir(t);
  if (t === 1) {
    if (!Yi(e, "OES_texture_float"))
      return !1;
  } else if (!Yi(e, "EXT_color_buffer_float"))
    return !1;
  return T1(e);
}
function Wne(t) {
  if (t === 0)
    return !1;
  const e = Ir(t);
  if (t === 1) {
    if (!Yi(e, "OES_texture_float") || !Yi(e, "WEBGL_color_buffer_float"))
      return !1;
  } else {
    if (Yi(e, "EXT_color_buffer_float"))
      return T1(e);
    const s = "EXT_color_buffer_half_float";
    if (Yi(e, s)) {
      const i = e.getExtension(s);
      return Hne(e, i);
    }
    return !1;
  }
  return T1(e);
}
function T1(t) {
  const e = kT(t), n = t.createTexture();
  t.bindTexture(t.TEXTURE_2D, n);
  const s = 1, i = 1;
  t.texImage2D(t.TEXTURE_2D, 0, e.internalFormatFloat, s, i, 0, e.textureFormatFloat, e.textureTypeFloat, null);
  const r = t.createFramebuffer();
  t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);
  const o = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
  return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(n), t.deleteFramebuffer(r), o;
}
function Hne(t, e) {
  const n = kT(t, e), s = t.createTexture();
  t.bindTexture(t.TEXTURE_2D, s);
  const i = 1, r = 1;
  t.texImage2D(t.TEXTURE_2D, 0, n.internalFormatHalfFloat, i, r, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
  const o = t.createFramebuffer();
  t.bindFramebuffer(t.FRAMEBUFFER, o), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, s, 0);
  const a = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
  return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(s), t.deleteFramebuffer(o), a;
}
function jne(t) {
  return t !== 2 ? !1 : Ir(t).fenceSync != null;
}
function _m(t, e) {
  Array.isArray(t) || (t = [t]), t.forEach((n) => {
    n != null && A(n.dtype !== "complex64", () => `${e} does not support complex64 tensors in the WebGL backend.`);
  });
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const rt = ie();
rt.registerFlag("HAS_WEBGL", () => rt.getNumber("WEBGL_VERSION") > 0);
rt.registerFlag("WEBGL_VERSION", () => LI(2) ? 2 : LI(1) ? 1 : 0);
rt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => !1);
rt.registerFlag("WEBGL_BUFFER_SUPPORTED", () => rt.get("WEBGL_VERSION") === 2);
rt.registerFlag("WEBGL_CPU_FORWARD", () => !0);
rt.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => !1);
rt.registerFlag("WEBGL_PACK", () => rt.getBool("HAS_WEBGL"));
rt.registerFlag("WEBGL_PACK_NORMALIZATION", () => rt.getBool("WEBGL_PACK"));
rt.registerFlag("WEBGL_PACK_CLIP", () => rt.getBool("WEBGL_PACK"));
rt.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => rt.getBool("WEBGL_PACK"));
rt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => rt.getBool("WEBGL_PACK"));
rt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => rt.getBool("WEBGL_PACK"));
rt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => rt.getBool("WEBGL_PACK"));
rt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => rt.getBool("WEBGL_PACK"));
rt.registerFlag("WEBGL_PACK_REDUCE", () => rt.getBool("WEBGL_PACK"));
rt.registerFlag("WEBGL_LAZILY_UNPACK", () => rt.getBool("WEBGL_PACK"));
rt.registerFlag("WEBGL_CONV_IM2COL", () => rt.getBool("WEBGL_PACK"));
rt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE", () => rt.getBool("WEBGL_PACK"));
rt.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => zne(rt.getNumber("WEBGL_VERSION")));
rt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => Vne(rt.getNumber("WEBGL_VERSION")));
rt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
  const t = rt.getNumber("WEBGL_VERSION");
  return t === 0 ? 0 : Une(t);
});
rt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => rt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !eS());
rt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => Gne(rt.getNumber("WEBGL_VERSION")));
rt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => rt.getBool("WEBGL_FORCE_F16_TEXTURES") ? !1 : rt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));
rt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => Wne(rt.getNumber("WEBGL_VERSION")));
rt.registerFlag("WEBGL_FENCE_API_ENABLED", () => jne(rt.getNumber("WEBGL_VERSION")));
rt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => rt.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0);
rt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => -1, (t) => {
  if (typeof t != "number")
    throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);
  if (t < 0 && t !== -1)
    throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`);
});
rt.registerFlag("WEBGL_FLUSH_THRESHOLD", () => eS() ? 1 : -1, (t) => {
  if (typeof t != "number")
    throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);
  if (t < 0 && t !== -1)
    throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`);
});
rt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128);
rt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => !1);
rt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5);
rt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);
rt.registerFlag("WEBGL_EXP_CONV", () => !1);
rt.registerFlag("SOFTWARE_WEBGL_ENABLED", () => rt.getBool("IS_TEST"));
rt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", () => 1 / 0);
rt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", () => !1);
rt.registerFlag("WEBGL2_ISNAN_CUSTOM", () => !1);
rt.registerFlag("ENGINE_COMPILE_ONLY", () => !1);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qs() {
  let t, e, n, s, i, r, o, a, c, l;
  return ie().getNumber("WEBGL_VERSION") === 2 ? (t = "#version 300 es", e = "in", n = "out", s = "in", i = "texture", r = "outputColor", o = "out vec4 outputColor;", a = ie().getBool("WEBGL2_ISNAN_CUSTOM") ? `
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    ` : "", c = "", l = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `) : (t = "", e = "attribute", n = "varying", s = "varying", i = "texture2D", r = "gl_FragColor", o = "", a = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `, c = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `, l = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `), {
    version: t,
    attribute: e,
    varyingVs: n,
    varyingFs: s,
    texture2D: i,
    output: r,
    defineOutput: o,
    defineSpecialNaN: a,
    defineSpecialInf: c,
    defineRound: l
  };
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ll(t, e, n = "index") {
  const s = ct(e);
  return s.map((i, r) => {
    const o = `int ${t[r]} = ${n} / ${i}`, a = r === s.length - 1 ? `int ${t[r + 1]} = ${n} - ${t[r]} * ${i}` : `index -= ${t[r]} * ${i}`;
    return `${o}; ${a};`;
  }).join("");
}
function Eb(t, e, n = "index") {
  const s = ct(e);
  return s.map((i, r) => {
    const o = `int ${t[r]} = ${n} / outShapeStrides[${r}]`, a = r === s.length - 1 ? `int ${t[r + 1]} = ${n} - ${t[r]} * outShapeStrides[${r}]` : `index -= ${t[r]} * outShapeStrides[${r}]`;
    return `${o}; ${a};`;
  }).join("");
}
function qne(t, e) {
  const n = t.length, s = t.map((r) => `${e}[${r}]`), i = new Array(n - 1);
  i[n - 2] = s[n - 1];
  for (let r = n - 3; r >= 0; --r)
    i[r] = `(${i[r + 1]} * ${s[r + 1]})`;
  return i;
}
function Xne(t, e, n = "index") {
  const s = t.map((r, o) => o), i = qne(s, e);
  return i.map((r, o) => {
    const a = `int ${t[o]} = ${n} / ${i[o]}`, c = o === i.length - 1 ? `int ${t[o + 1]} = ${n} - ${t[o]} * ${i[o]}` : `index -= ${t[o]} * ${i[o]}`;
    return `${a}; ${c};`;
  }).join("");
}
function AT(t) {
  const e = ct(t).map((n) => n.toString());
  return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`;
}
function MT() {
  return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`;
}
const F$ = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const { getBroadcastDims: P$ } = iM;
function Kne(t, e, n) {
  const s = [];
  if (t.forEach((f) => {
    const p = ue(f.shapeInfo.logicalShape);
    if (f.shapeInfo.isUniform ? s.push(`uniform float ${f.name}${p > 1 ? `[${p}]` : ""};`) : (s.push(`uniform sampler2D ${f.name};`), s.push(`uniform int offset${f.name};`)), n.enableShapeUniforms) {
      const { uniformShape: y } = RT(n.packedInputs, f.shapeInfo.logicalShape, f.shapeInfo.texShape);
      switch (y.length) {
        case 1:
          s.push(`uniform int ${f.name}Shape;`);
          break;
        case 2:
          s.push(`uniform ivec2 ${f.name}Shape;`);
          break;
        case 3:
          s.push(`uniform ivec3 ${f.name}Shape;`);
          break;
        case 4:
          s.push(`uniform ivec4 ${f.name}Shape;`);
          break;
      }
      s.push(`uniform ivec2 ${f.name}TexShape;`);
    }
  }), n.enableShapeUniforms) {
    switch (e.logicalShape.length) {
      case 1:
        s.push("uniform int outShape;");
        break;
      case 2:
        s.push("uniform ivec2 outShape;"), s.push("uniform int outShapeStrides;");
        break;
      case 3:
        s.push("uniform ivec3 outShape;"), s.push("uniform ivec2 outShapeStrides;");
        break;
      case 4:
        s.push("uniform ivec4 outShape;"), s.push("uniform ivec3 outShapeStrides;");
        break;
    }
    s.push("uniform ivec2 outTexShape;");
  }
  n.customUniforms && n.customUniforms.forEach((f) => {
    s.push(`uniform ${f.type} ${f.name}${f.arrayIndex ? `[${f.arrayIndex}]` : ""};`);
  });
  const i = s.join(`
`), r = t.map((f) => Yne(f, e, n.packedInputs, n.enableShapeUniforms)).join(`
`), o = e.texShape, a = qs(), c = Qne(a);
  let l, u, h = nse(a);
  return e.isPacked ? (l = Zne(e.logicalShape, o, n.enableShapeUniforms), u = tse(a)) : (l = Jne(e.logicalShape, o, n.enableShapeUniforms), u = ese(a)), n.packedInputs && (h += ose), [
    h,
    c,
    u,
    i,
    l,
    r,
    n.userCode
  ].join(`
`);
}
function zh(t, e = !1) {
  const n = t.shapeInfo.logicalShape;
  switch (n.length) {
    case 0:
      return xse(t, e);
    case 1:
      return vse(t, e);
    case 2:
      return Sse(t, e);
    case 3:
      return Tse(t, e);
    case 4:
      return Ise(t, e);
    case 5:
      return Ese(t);
    case 6:
      return Nse(t);
    default:
      throw new Error(`${n.length}-D input sampling is not yet supported`);
  }
}
function B$(t, e) {
  switch (t.shapeInfo.logicalShape.length) {
    case 0:
      return yse(t);
    case 1:
      return bse(t, e);
    case 2:
      return wse(t, e);
    case 3:
      return _se(t, e);
    default:
      return Cse(t, e);
  }
}
function Yne(t, e, n = !1, s) {
  let i = "";
  n ? i += B$(t, s) : i += zh(t, s);
  const r = t.shapeInfo.logicalShape, o = e.logicalShape;
  return r.length <= o.length && (n ? i += kse(t, e) : i += Ase(t, e)), i;
}
function Zne(t, e, n) {
  switch (t.length) {
    case 0:
      return z$();
    case 1:
      return ase(t, e, n);
    case 2:
      return mse(t, e, n);
    case 3:
      return lse(t, e, n);
    default:
      return hse(t, e, n);
  }
}
function Jne(t, e, n) {
  switch (t.length) {
    case 0:
      return z$();
    case 1:
      return cse(t, e, n);
    case 2:
      return gse(t, e, n);
    case 3:
      return use(t, e, n);
    case 4:
      return dse(t, e, n);
    case 5:
      return fse(t, e);
    case 6:
      return pse(t, e);
    default:
      throw new Error(`${t.length}-D output sampling is not yet supported`);
  }
}
function Qne(t) {
  return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `;
}
function ese(t) {
  return `
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `;
}
function tse(t) {
  return `
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `;
}
function nse(t) {
  return `${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${sse}
    ${ise}
    ${rse}
  `;
}
const sse = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, ise = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, rse = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, ose = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
function z$() {
  return `
    int getOutputCoords() {
      return 0;
    }
  `;
}
function ase(t, e, n) {
  const s = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
  return s[0] === 1 ? n ? `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    ` : s[1] === 1 ? n ? `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    ` : n ? `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `;
}
function cse(t, e, n) {
  return e[0] === 1 ? n ? `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    ` : e[1] === 1 ? n ? `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    ` : n ? `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `;
}
function lse(t, e, n) {
  if (n)
    return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
  const s = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)], i = Math.ceil(t[2] / 2), r = i * Math.ceil(t[1] / 2);
  return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `;
}
function use(t, e, n) {
  if (n)
    return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Eb(["r", "c", "d"], t)}
    return ivec3(r, c, d);
  }
`;
  const s = ll(["r", "c", "d"], t);
  return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `;
}
function hse(t, e, n) {
  if (n)
    return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
  const s = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)], i = Math.ceil(t[t.length - 1] / 2), r = i * Math.ceil(t[t.length - 2] / 2);
  let o = r, a = "", c = "b, r, c";
  for (let l = 2; l < t.length - 1; l++)
    o *= t[t.length - l - 1], a = `
      int b${l} = index / ${o};
      index -= b${l} * ${o};
    ` + a, c = `b${l}, ` + c;
  return `
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${t.length}(${c});
    }
  `;
}
function dse(t, e, n) {
  if (n)
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Eb(["r", "c", "d", "d2"], t)}
      return ivec4(r, c, d, d2);
    }
  `;
  const s = ll(["r", "c", "d", "d2"], t);
  return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `;
}
function fse(t, e) {
  const n = ll(["r", "c", "d", "d2", "d3"], t);
  return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
}
function pse(t, e) {
  const n = ll(["r", "c", "d", "d2", "d3", "d4"], t);
  return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
}
function mse(t, e, n) {
  const s = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
  if (Bt(t, e))
    return n ? `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;
  const i = Math.ceil(t[1] / 2);
  return n ? `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `;
}
function gse(t, e, n) {
  return Bt(t, e) ? n ? `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    ` : t[1] === 1 ? n ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : t[0] === 1 ? n ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    ` : n ? `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `;
}
function ul(t) {
  return `offset${t}`;
}
function yse(t) {
  const e = t.name, n = "get" + e.charAt(0).toUpperCase() + e.slice(1), s = qs();
  return `
    vec4 ${n}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `;
}
function xse(t, e) {
  const n = t.name, s = "get" + n.charAt(0).toUpperCase() + n.slice(1);
  if (t.shapeInfo.isUniform)
    return `float ${s}() {return ${n};}`;
  const [i, r] = t.shapeInfo.texShape;
  if (i === 1 && r === 1)
    return `
      float ${s}() {
        return sampleTexture(${n}, halfCR);
      }
    `;
  const o = ul(n);
  if (e)
    return `
    float ${s}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});
      return sampleTexture(${n}, uv);
    }
  `;
  const [a, c] = t.shapeInfo.texShape;
  return `
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${c}, ${o});
      return sampleTexture(${n}, uv);
    }
  `;
}
function bse(t, e) {
  const n = t.name, s = "get" + n.charAt(0).toUpperCase() + n.slice(1), i = t.shapeInfo.texShape, r = qs();
  if (e)
    return `
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${r.texture2D}(${n}, uv);
    }
  `;
  const o = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
  return `
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${r.texture2D}(${n}, uv);
    }
  `;
}
function vse(t, e) {
  const n = t.name, s = "get" + n.charAt(0).toUpperCase() + n.slice(1);
  if (t.shapeInfo.isUniform)
    return `
      float ${s}(int index) {
        ${Vh(t)}
      }
    `;
  const i = t.shapeInfo.texShape, r = i[0], o = i[1];
  if (o === 1 && r === 1)
    return `
      float ${s}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;
  const a = ul(n);
  return o === 1 ? e ? `
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    ` : `
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${r}.0);
        return sampleTexture(${n}, uv);
      }
    ` : r === 1 ? e ? `
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    ` : `
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    ` : e ? `
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${a});
      return sampleTexture(${n}, uv);
    }
  ` : `
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${r}, ${o}, index + ${a});
      return sampleTexture(${n}, uv);
    }
  `;
}
function wse(t, e) {
  const n = t.shapeInfo.logicalShape, s = t.name, i = "get" + s.charAt(0).toUpperCase() + s.slice(1), r = t.shapeInfo.texShape, o = r[0], a = r[1], c = qs();
  if (r != null && Bt(n, r))
    return e ? `
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${c.texture2D}(${s}, uv);
      }
    ` : `
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${c.texture2D}(${s}, uv);
      }
    `;
  if (e)
    return `
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `;
  const l = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)], u = Math.ceil(n[1] / 2);
  return `
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${l[0]}, ${l[1]}, row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `;
}
function Sse(t, e) {
  const n = t.shapeInfo.logicalShape, s = t.name, i = "get" + s.charAt(0).toUpperCase() + s.slice(1), r = t.shapeInfo.texShape;
  if (r != null && Bt(n, r)) {
    if (e)
      return `
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;
    const d = r[0], f = r[1];
    return `
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `;
  }
  const { newShape: o, keptDims: a } = zo(n), c = o;
  if (c.length < n.length) {
    const d = Uh(t, c), f = ["row", "col"];
    return `
      ${zh(d, e)}
      float ${i}(int row, int col) {
        return ${i}(${Gh(f, a)});
      }
    `;
  }
  if (t.shapeInfo.isUniform)
    return `
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Vh(t)}
      }
    `;
  const l = r[0], u = r[1], h = ul(s);
  return u === 1 ? e ? `
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    ` : `
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${s}, uv);
    }
  ` : l === 1 ? e ? `
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    ` : `
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  ` : e ? `
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    ` : `
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${h};
    vec2 uv = uvFromFlat(${l}, ${u}, index);
    return sampleTexture(${s}, uv);
  }
`;
}
function _se(t, e) {
  const n = t.shapeInfo.logicalShape, s = t.name, i = "get" + s.charAt(0).toUpperCase() + s.slice(1), r = t.shapeInfo.texShape, o = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)];
  if (n[0] === 1) {
    const d = n.slice(1), f = [1, 2], p = Uh(t, d), y = ["b", "row", "col"];
    return `
        ${B$(p, e)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${Gh(y, f)});
        }
      `;
  }
  const a = qs();
  if (e)
    return `
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;
  const c = o[0], l = o[1], u = Math.ceil(n[2] / 2), h = u * Math.ceil(n[1] / 2);
  return `
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${l}, ${h}, ${u}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;
}
function Tse(t, e) {
  const n = t.shapeInfo.logicalShape, s = t.name, i = "get" + s.charAt(0).toUpperCase() + s.slice(1), r = n[1] * n[2], o = n[2], { newShape: a, keptDims: c } = zo(n), l = a;
  if (l.length < n.length) {
    const y = Uh(t, l), g = ["row", "col", "depth"];
    return `
        ${zh(y, e)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${Gh(g, c)});
        }
      `;
  }
  if (t.shapeInfo.isUniform)
    return `
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${r}, ${o}, 1)));
        ${Vh(t)}
      }
    `;
  const u = t.shapeInfo.texShape, h = u[0], d = u[1], f = t.shapeInfo.flatOffset;
  if (d === r && f == null)
    return e ? `
      float ${i}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    ` : `
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${s}, uv);
        }
      `;
  if (d === o && f == null)
    return e ? `
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    ` : `
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `;
  const p = ul(s);
  return e ? `
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${p};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    ` : `
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r} + col * ${o} + depth + ${p};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${s}, uv);
      }
  `;
}
function Cse(t, e) {
  const n = t.name, s = "get" + n.charAt(0).toUpperCase() + n.slice(1), i = qs();
  if (e)
    return `
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${n}, uv);
    }
  `;
  const r = t.shapeInfo.logicalShape, o = r.length, a = t.shapeInfo.texShape, c = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)], l = c[0], u = c[1], h = Math.ceil(r[o - 1] / 2);
  let d = h * Math.ceil(r[o - 2] / 2), f = "int b, int row, int col", p = `b * ${d} + (row / 2) * ${h} + (col / 2)`;
  for (let y = 2; y < o - 1; y++)
    f = `int b${y}, ` + f, d *= r[o - y - 1], p = `b${y} * ${d} + ` + p;
  return `
    vec4 ${s}(${f}) {
      int index = ${p};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${l});
      return ${i.texture2D}(${n}, uv);
    }
  `;
}
function Ise(t, e) {
  const n = t.shapeInfo.logicalShape, s = t.name, i = "get" + s.charAt(0).toUpperCase() + s.slice(1), r = n[3], o = n[2] * r, a = n[1] * o, { newShape: c, keptDims: l } = zo(n);
  if (c.length < n.length) {
    const x = Uh(t, c), v = ["row", "col", "depth", "depth2"];
    return `
      ${zh(x, e)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${Gh(v, l)});
      }
    `;
  }
  if (t.shapeInfo.isUniform)
    return `
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${r}, 1)));
        ${Vh(t)}
      }
    `;
  const u = t.shapeInfo.flatOffset, h = t.shapeInfo.texShape, d = h[0], f = h[1], p = `int stride2 = ${s}Shape[3];`, y = `int stride1 = ${s}Shape[2] * stride2;`, g = `int stride0 = ${s}Shape[1] * stride1;`;
  if (f === a && u == null)
    return e ? `
      float ${i}(int row, int col, int depth, int depth2) {
        ${p}
        ${y}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    ` : `
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;
  if (f === r && u == null)
    return e ? `
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    ` : `
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1] * n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;
  const m = ul(s);
  return e ? `
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${p}
      ${y}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${m});
      return sampleTexture(${s}, uv);
    }
  ` : `
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${r} + depth2;
      vec2 uv = uvFromFlat(${d}, ${f}, index + ${m});
      return sampleTexture(${s}, uv);
    }
  `;
}
function Ese(t) {
  const e = t.shapeInfo.logicalShape, n = t.name, s = "get" + n.charAt(0).toUpperCase() + n.slice(1), i = e[4], r = e[3] * i, o = e[2] * r, a = e[1] * o, { newShape: c, keptDims: l } = zo(e);
  if (c.length < e.length) {
    const y = Uh(t, c), g = ["row", "col", "depth", "depth2", "depth3"];
    return `
      ${zh(y)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Gh(g, l)});
      }
    `;
  }
  if (t.shapeInfo.isUniform)
    return `
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${r}, ${i})) +
          depth3;
        ${Vh(t)}
      }
    `;
  const u = t.shapeInfo.flatOffset, h = t.shapeInfo.texShape, d = h[0], f = h[1];
  if (f === a && u == null)
    return `
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${r}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;
  if (f === i && u == null)
    return `
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1] * e[2] * e[3]},
               ${e[2] * e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;
  const p = ul(n);
  return `
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${r} +
          depth2 * ${i} + depth3 + ${p};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `;
}
function Nse(t) {
  const e = t.shapeInfo.logicalShape, n = t.name, s = "get" + n.charAt(0).toUpperCase() + n.slice(1), { newShape: i, keptDims: r } = zo(e);
  if (i.length < e.length) {
    const g = Uh(t, i), m = ["row", "col", "depth", "depth2", "depth3", "depth4"];
    return `
      ${zh(g)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Gh(m, r)});
      }
    `;
  }
  const o = e[5], a = e[4] * o, c = e[3] * a, l = e[2] * c, u = e[1] * l;
  if (t.shapeInfo.isUniform)
    return `
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${l}, ${c}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Vh(t)}
      }
    `;
  const h = t.shapeInfo.flatOffset, d = t.shapeInfo.texShape, f = d[0], p = d[1];
  if (p === u && h == null)
    return `
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${c}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;
  if (p === o && h == null)
    return `
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1] * e[2] * e[3] * e[4]},
               ${e[2] * e[3] * e[4]},
               ${e[3] * e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;
  const y = ul(n);
  return `
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${l} + depth * ${c} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${y};
      vec2 uv = uvFromFlat(${f}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `;
}
function Vh(t) {
  const e = t.name, n = ue(t.shapeInfo.logicalShape);
  return n < 2 ? `return ${e};` : `
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `;
}
function kse(t, e) {
  const n = t.name, s = n.charAt(0).toUpperCase() + n.slice(1), i = "get" + s + "AtOutCoords", r = t.shapeInfo.logicalShape.length, o = e.logicalShape.length, a = P$(t.shapeInfo.logicalShape, e.logicalShape), c = rn(o), l = o - r;
  let u;
  const h = ["x", "y", "z", "w", "u", "v"];
  r === 0 ? u = "" : o < 2 && a.length >= 1 ? u = "coords = 0;" : u = a.map((x) => `coords.${h[x + l]} = 0;`).join(`
`);
  let d = "";
  o < 2 && r > 0 ? d = "coords" : d = t.shapeInfo.logicalShape.map((x, v) => `coords.${h[v + l]}`).join(", ");
  let f = "return outputValue;";
  const y = ue(t.shapeInfo.logicalShape) === 1, m = ue(e.logicalShape) === 1;
  if (r === 1 && !y && !m)
    f = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
  else if (y && !m)
    o === 1 ? f = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      ` : f = `
        return vec4(outputValue.x);
      `;
  else if (a.length) {
    const x = r - 2, v = r - 1;
    a.indexOf(x) > -1 && a.indexOf(v) > -1 ? f = "return vec4(outputValue.x);" : a.indexOf(x) > -1 ? f = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : a.indexOf(v) > -1 && (f = "return vec4(outputValue.xx, outputValue.zz);");
  }
  return `
    vec4 ${i}() {
      ${c} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${s}(${d});
      ${f}
    }
  `;
}
function Ase(t, e) {
  const n = t.name, s = n.charAt(0).toUpperCase() + n.slice(1), i = "get" + s + "AtOutCoords", r = e.texShape, o = t.shapeInfo.texShape, a = t.shapeInfo.logicalShape.length, c = e.logicalShape.length;
  if (!t.shapeInfo.isUniform && a === c && t.shapeInfo.flatOffset == null && Bt(o, r))
    return `
      float ${i}() {
        return sampleTexture(${n}, resultUV);
      }
    `;
  const l = rn(c), u = P$(t.shapeInfo.logicalShape, e.logicalShape), h = c - a;
  let d;
  const f = ["x", "y", "z", "w", "u", "v"];
  a === 0 ? d = "" : c < 2 && u.length >= 1 ? d = "coords = 0;" : d = u.map((y) => `coords.${f[y + h]} = 0;`).join(`
`);
  let p = "";
  return c < 2 && a > 0 ? p = "coords" : p = t.shapeInfo.logicalShape.map((y, g) => `coords.${f[g + h]}`).join(", "), `
    float ${i}() {
      ${l} coords = getOutputCoords();
      ${d}
      return get${s}(${p});
    }
  `;
}
function rn(t) {
  if (t <= 1)
    return "int";
  if (t === 2)
    return "ivec2";
  if (t === 3)
    return "ivec3";
  if (t === 4)
    return "ivec4";
  if (t === 5)
    return "ivec5";
  if (t === 6)
    return "ivec6";
  throw Error(`GPU for rank ${t} is not yet supported`);
}
function RT(t, e, n) {
  const { newShape: s, keptDims: i } = zo(e), r = e.length, o = t && r === 3 && e[0] === 1, a = o ? e.slice(1) : s, c = !t && r > 1 && !Bt(e, n) && s.length < r || o;
  return { useSqueezeShape: c, uniformShape: c ? a : e, keptDims: i };
}
function Uh(t, e) {
  const n = JSON.parse(JSON.stringify(t));
  return n.shapeInfo.logicalShape = e, n;
}
function Gh(t, e) {
  return e.map((n) => t[n]).join(", ");
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mse(t, e, n, s) {
  const i = n.map((u, h) => {
    const d = {
      logicalShape: u.shape,
      texShape: u.isUniform ? null : u.texData.texShape,
      isUniform: u.isUniform,
      isPacked: u.isUniform ? !1 : u.texData.isPacked,
      flatOffset: null
    };
    return u.texData != null && u.texData.slice != null && u.texData.slice.flatOffset > 0 && (d.flatOffset = u.texData.slice.flatOffset), { name: e.variableNames[h], shapeInfo: d };
  }), r = i.map((u) => u.shapeInfo), o = {
    logicalShape: s.shape,
    texShape: s.texData.texShape,
    isUniform: !1,
    isPacked: s.texData.isPacked,
    flatOffset: null
  }, a = Kne(i, o, e), c = Tne(t.gl, a), l = t.createProgram(c);
  return ie().get("ENGINE_COMPILE_ONLY") ? {
    program: e,
    fragmentShader: c,
    source: a,
    webGLProgram: l,
    inShapeInfos: r,
    outShapeInfo: o,
    variablesLocations: null,
    customUniformLocations: null,
    infLoc: null,
    nanLoc: null,
    outShapeLocation: null,
    outShapeStridesLocation: null,
    outTexShapeLocation: null
  } : (t.buildVao(l), Object.assign({
    program: e,
    fragmentShader: c,
    source: a,
    webGLProgram: l,
    inShapeInfos: r,
    outShapeInfo: o
  }, V$(t, e, l)));
}
function V$(t, e, n) {
  const s = [], i = [];
  let r, o, a, c = null, l = null;
  l = t.getUniformLocation(n, "NAN", !1), ie().getNumber("WEBGL_VERSION") === 1 && (c = t.getUniformLocation(n, "INFINITY", !1));
  const u = !1;
  for (const h of e.variableNames) {
    const d = {
      name: h,
      uniform: t.getUniformLocation(n, h, u),
      offset: t.getUniformLocation(n, `offset${h}`, u)
    };
    e.enableShapeUniforms && (d.shape = t.getUniformLocation(n, `${h}Shape`, u), d.texShape = t.getUniformLocation(n, `${h}TexShape`, u)), s.push(d);
  }
  if (e.enableShapeUniforms && (r = t.getUniformLocation(n, "outShape", u), a = t.getUniformLocation(n, "outShapeStrides", u), o = t.getUniformLocation(n, "outTexShape", u)), e.customUniforms)
    for (const h of e.customUniforms)
      i.push(t.getUniformLocation(n, h.name, u));
  return {
    variablesLocations: s,
    customUniformLocations: i,
    infLoc: c,
    nanLoc: l,
    outShapeLocation: r,
    outShapeStridesLocation: a,
    outTexShapeLocation: o
  };
}
function FI(t, e) {
  if (t.length !== e.length)
    throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);
  t.forEach((n, s) => {
    const i = n.logicalShape, r = e[s], o = r.shape;
    if (!Bt(i, o))
      throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${o} must match`);
    if (n.isUniform && r.isUniform)
      return;
    const a = n.texShape, c = r.isUniform ? null : r.texData.texShape;
    if (!Bt(a, c))
      throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${c} must match`);
  });
}
function Rse(t, e, n, s, i) {
  e.program.enableShapeUniforms || (FI(e.inShapeInfos, n), FI([e.outShapeInfo], [s]));
  const r = s.texData.texture, o = s.texData.texShape;
  s.texData.isPacked ? t.setOutputPackedMatrixTexture(r.texture, o[0], o[1]) : t.setOutputMatrixTexture(r.texture, o[0], o[1]), t.setProgram(e.webGLProgram), t.bindVertexArray(e.webGLProgram.vao), ie().getNumber("WEBGL_VERSION") === 1 && e.infLoc !== null && t.gl.uniform1f(e.infLoc, 1 / 0), e.nanLoc !== null && t.gl.uniform1f(e.nanLoc, NaN);
  for (let c = 0; c < n.length; ++c) {
    const l = n[c], { uniform: u, offset: h, shape: d, texShape: f } = e.variablesLocations[c];
    if (d) {
      const { uniformShape: p } = RT(e.program.packedInputs, l.shape, l.texData.texShape);
      switch (p.length) {
        case 1:
          t.gl.uniform1iv(d, new Int32Array(p));
          break;
        case 2:
          t.gl.uniform2iv(d, new Int32Array(p));
          break;
        case 3:
          t.gl.uniform3iv(d, new Int32Array(p));
          break;
        case 4:
          t.gl.uniform4iv(d, new Int32Array(p));
          break;
      }
    }
    if (f && t.gl.uniform2i(f, l.texData.texShape[0], l.texData.texShape[1]), u != null) {
      if (l.isUniform) {
        if (ue(l.shape) < 2)
          t.gl.uniform1f(u, l.uniformValues[0]);
        else {
          let p = l.uniformValues;
          p instanceof Float32Array || (p = new Float32Array(p)), t.gl.uniform1fv(u, p);
        }
        continue;
      }
      l.texData.slice != null && h != null && t.gl.uniform1i(h, l.texData.slice.flatOffset), t.setInputMatrixTexture(l.texData.texture.texture, u, c);
    }
  }
  const a = e.outShapeLocation;
  if (a)
    switch (s.shape.length) {
      case 1:
        t.gl.uniform1iv(a, new Int32Array(s.shape));
        break;
      case 2:
        t.gl.uniform2iv(a, new Int32Array(s.shape));
        break;
      case 3:
        t.gl.uniform3iv(a, new Int32Array(s.shape));
        break;
      case 4:
        t.gl.uniform4iv(a, new Int32Array(s.shape));
        break;
    }
  if (e.outShapeStridesLocation) {
    const c = ct(s.shape);
    switch (s.shape.length) {
      case 2:
        t.gl.uniform1iv(e.outShapeStridesLocation, new Int32Array(c));
        break;
      case 3:
        t.gl.uniform2iv(e.outShapeStridesLocation, new Int32Array(c));
        break;
      case 4:
        t.gl.uniform3iv(e.outShapeStridesLocation, new Int32Array(c));
        break;
    }
  }
  if (e.outTexShapeLocation && t.gl.uniform2i(e.outTexShapeLocation, s.texData.texShape[0], s.texData.texShape[1]), e.program.customUniforms && i)
    for (let c = 0; c < e.program.customUniforms.length; ++c) {
      const l = e.program.customUniforms[c], u = e.customUniformLocations[c], h = i[c];
      if (l.type === "float")
        t.gl.uniform1fv(u, h);
      else if (l.type === "vec2")
        t.gl.uniform2fv(u, h);
      else if (l.type === "vec3")
        t.gl.uniform3fv(u, h);
      else if (l.type === "vec4")
        t.gl.uniform4fv(u, h);
      else if (l.type === "int")
        t.gl.uniform1iv(u, h);
      else if (l.type === "ivec2")
        t.gl.uniform2iv(u, h);
      else if (l.type === "ivec3")
        t.gl.uniform3iv(u, h);
      else if (l.type === "ivec4")
        t.gl.uniform4iv(u, h);
      else
        throw Error(`uniform type ${l.type} is not supported yet.`);
    }
  t.executeProgram();
}
function Dse(t, e, n) {
  let s = "";
  e.concat(n).forEach((o) => {
    const a = o.texData != null && o.texData.slice != null && o.texData.slice.flatOffset > 0;
    if (t.enableShapeUniforms && !o.isUniform) {
      const c = o.texData.texShape, { useSqueezeShape: l, uniformShape: u, keptDims: h } = RT(t.packedInputs, o.shape, c);
      let d = "", f = "", p = "";
      if (u.length === 1 && t.packedInputs) {
        const w = [Math.ceil(c[0] / 2), Math.ceil(c[1] / 2)];
        d = `${w[0] > 1}_${w[1] > 1}`;
      } else if (u.length === 2 && !t.packedInputs)
        f = `${u[0] > 1}_${u[1] > 1}`;
      else if (u.length > 2 && !t.packedInputs) {
        const w = ct(u);
        p = `${w[0] === c[1]}_${w[w.length - 1] === c[1]}`;
      }
      const y = o.shape.length, g = u.length === 2 && Bt(o.shape, c), m = ue(o.shape) === 1, x = Vc(o.shape, n.shape), v = !t.packedInputs && y === n.shape.length && Bt(c, n.texData.texShape), b = t.packedInputs || u.length > 2 ? "" : `${c[0] > 1}_${c[1] > 1}`;
      s += `${y}_${v}_${l ? h : ""}_${u.length}_${m}_${x}_${g}_${d}_${f}_${p}_${b}_${a}`;
    } else {
      const c = o.isUniform ? "uniform" : o.texData.texShape;
      s += `${o.shape}_${c}_${a}`;
    }
  });
  const i = t.userCode;
  let r = t.constructor.name;
  return r += "_" + s + "_" + i + `${ie().getNumber("WEBGL_VERSION")}`, r;
}
function As(t) {
  return ie().getBool("WEBGL_USE_SHAPES_UNIFORMS") && t <= 4;
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class $se {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = If.DENSE, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const n = qs();
    this.outputShape = e, this.enableShapeUniforms = As(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? Eb(["r", "c", "d"], e) : ll(["r", "c", "d"], e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Ose {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = If.DENSE, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const n = qs();
    this.outputShape = e, this.enableShapeUniforms = As(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? Eb(["r", "c", "d"], e) : ll(["r", "c", "d"], e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Lse {
  constructor(e) {
    this.variableNames = ["A"], this.outTexUsage = ki.DOWNLOAD;
    const n = qs();
    this.outputShape = e, this.userCode = `
      ${F$}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Fse {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = ki.DOWNLOAD;
    const n = qs();
    this.outputShape = e, this.userCode = `
      ${F$}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Pse = {
  R: 0,
  G: 1,
  B: 2,
  A: 3
};
class PI {
  constructor(e, n = !1, s = "RGBA") {
    this.variableNames = ["A"], this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const i = qs();
    this.outputShape = e, this.enableShapeUniforms = As(this.outputShape.length);
    let r = "result";
    n && (r = "floor(result * 255. + 0.5)");
    let o = "";
    for (let a = 0; a < s.length; a++) {
      const c = s[a];
      o += `
          if(offset == ${a}) {
            result = values[${Pse[c]}];
          }`;
    }
    this.userCode = `
      ${this.enableShapeUniforms ? MT() : AT(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${o}
        }
        ${i.output} = vec4(${r}, 0., 0., 0.);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Bse {
  constructor(e, n = !1) {
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const s = qs();
    this.outputShape = e, this.enableShapeUniforms = As(this.outputShape.length);
    let i = "", r = "result";
    n && (r = "floor(result * 255. + 0.5)");
    for (let o = 0; o <= 1; o++)
      for (let a = 0; a <= 1; a++) {
        const c = o * 2 + a;
        i += `
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms ? "outShape[2]" : `${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms ? "outShape[1]" : `${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${c}] = values[0];
            } else if (offset == 1) {
              result[${c}] = values[1];
            } else if (offset == 2) {
              result[${c}] = values[2];
            } else {
              result[${c}] = values[3];
            }
          }
        }
        `;
      }
    this.userCode = `
        ${this.enableShapeUniforms ? MT() : AT(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${s.output} = ${r};
        }
    `;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zse(t) {
  const e = qs(), n = `${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
  return _ne(t, n);
}
function Vse(t) {
  const e = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
  return Nne(t, e);
}
function Use(t) {
  const e = new Uint16Array([0, 1, 2, 2, 1, 3]);
  return kne(t, e);
}
function Tm(t, e, n, s, i, r) {
  Mne(e, n);
  const o = Ane(t), a = t.TEXTURE_2D;
  return He(t, () => t.bindTexture(a, o)), He(t, () => t.texParameteri(a, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE)), He(t, () => t.texParameteri(a, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE)), He(t, () => t.texParameteri(a, t.TEXTURE_MIN_FILTER, t.NEAREST)), He(t, () => t.texParameteri(a, t.TEXTURE_MAG_FILTER, t.NEAREST)), ie().getNumber("WEBGL_VERSION") === 1 ? He(t, () => t.texImage2D(a, 0, s, e, n, 0, i, r, null)) : He(t, () => t.texStorage2D(a, 1, s, e, n)), He(t, () => t.bindTexture(t.TEXTURE_2D, null)), { texture: o, texShape: [n, e] };
}
function U$(t) {
  return t.internalFormatFloat;
}
function Gse(t, e, n, s) {
  const [i, r] = Sm(e, n);
  return Tm(t, i, r, U$(s), s.textureFormatFloat, t.FLOAT);
}
function G$(t) {
  return t.internalFormatHalfFloat;
}
function Wse(t, e, n, s) {
  const [i, r] = Sm(e, n);
  return Tm(t, i, r, G$(s), s.textureFormatFloat, s.textureTypeHalfFloat);
}
function W$(t) {
  return t.downloadTextureFormat;
}
function Hse(t, e, n, s) {
  const [i, r] = Sm(e, n);
  return Tm(t, i, r, W$(s), t.RGBA, t.UNSIGNED_BYTE);
}
function H$(t) {
  return t.internalFormatPackedFloat;
}
function jse(t, e, n, s) {
  const [i, r] = Bh(e, n);
  return Tm(t, i, r, H$(s), t.RGBA, t.FLOAT);
}
function j$(t) {
  return t.internalFormatPackedHalfFloat;
}
function qse(t, e, n, s) {
  const [i, r] = Bh(e, n);
  return Tm(t, i, r, j$(s), t.RGBA, s.textureTypeHalfFloat);
}
function Xse(t, e, n) {
  return He(t, () => t.bindBuffer(t.ARRAY_BUFFER, n)), $I(t, e, "clipSpacePos", n, 3, 20, 0) && $I(t, e, "uv", n, 2, 20, 12);
}
function Kse(t, e, n, s, i, r) {
  He(t, () => t.bindTexture(t.TEXTURE_2D, e));
  let o, a, c;
  i instanceof Uint8Array ? (o = new Uint8Array(n * s * 4), a = t.UNSIGNED_BYTE, c = t.RGBA) : (o = new Float32Array(n * s * 4), a = t.FLOAT, c = r.internalFormatPackedFloat), o.set(i), ie().getNumber("WEBGL_VERSION") === 2 ? He(t, () => t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, n, s, t.RGBA, a, o)) : He(t, () => t.texImage2D(t.TEXTURE_2D, 0, c, n, s, 0, t.RGBA, a, o)), He(t, () => t.bindTexture(t.TEXTURE_2D, null));
}
function Yse(t, e, n) {
  He(t, () => t.bindTexture(t.TEXTURE_2D, e)), n.data instanceof Uint8Array ? ie().getNumber("WEBGL_VERSION") === 2 ? He(t, () => t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, n.width, n.height, t.RGBA, t.UNSIGNED_BYTE, n.data)) : He(t, () => t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, n.width, n.height, 0, t.RGBA, t.UNSIGNED_BYTE, n.data)) : ie().getNumber("WEBGL_VERSION") === 2 ? He(t, () => t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, t.RGBA, t.UNSIGNED_BYTE, n)) : He(t, () => t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, n)), He(t, () => t.bindTexture(t.TEXTURE_2D, null));
}
function Zse(t, e, n, s) {
  const i = t.createBuffer();
  He(t, () => t.bindBuffer(t.PIXEL_PACK_BUFFER, i));
  const a = 4 * 4 * e * n;
  return He(t, () => t.bufferData(t.PIXEL_PACK_BUFFER, a, t.STREAM_READ)), He(t, () => t.readPixels(0, 0, n, e, t.RGBA, t.FLOAT, 0)), He(t, () => t.bindBuffer(t.PIXEL_PACK_BUFFER, null)), i;
}
function Jse(t, e, n) {
  const s = t, i = new Float32Array(n);
  return s.bindBuffer(s.PIXEL_PACK_BUFFER, e), s.getBufferSubData(s.PIXEL_PACK_BUFFER, 0, i), s.bindBuffer(s.PIXEL_PACK_BUFFER, null), i;
}
function Qse(t, e, n, s) {
  const [i, r] = Sm(e, n), o = 4, a = new Uint8Array(gne(e * n, o));
  return He(t, () => t.readPixels(0, 0, i, r, s.downloadTextureFormat, t.UNSIGNED_BYTE, a)), new Float32Array(a.buffer);
}
function eie(t, e, n, s, i, r, o, a) {
  const c = t, l = new Float32Array(yne(r, o));
  return c.bindBuffer(c.PIXEL_PACK_BUFFER, e), c.getBufferSubData(c.PIXEL_PACK_BUFFER, 0, l), c.bindBuffer(c.PIXEL_PACK_BUFFER, null), l;
}
function tie(t, e, n) {
  const s = new Float32Array(e * n * 4);
  return He(t, () => t.readPixels(0, 0, n, e, t.RGBA, t.FLOAT, s)), s;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Rv {
  constructor(e) {
    this.outputTexture = null, this.program = null, this.disposed = !1, this.itemsToPoll = [];
    const n = ie().getNumber("WEBGL_VERSION");
    if (e != null ? (this.gl = e, fne(n, e)) : this.gl = Ir(n), e = this.gl, ie().getNumber("WEBGL_VERSION") === 2) {
      const r = e;
      this.createVertexArray = () => He(r, () => r.createVertexArray()), this.bindVertexArray = (o) => He(r, () => r.bindVertexArray(o)), this.deleteVertexArray = (o) => He(r, () => r.deleteVertexArray(o)), this.getVertexArray = () => He(r, () => r.getParameter(r.VERTEX_ARRAY_BINDING));
    } else if (e != null) {
      const r = e.getExtension("OES_vertex_array_object");
      if (r == null)
        throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
      this.createVertexArray = () => He(e, () => r.createVertexArrayOES()), this.bindVertexArray = (o) => He(e, () => r.bindVertexArrayOES(o)), this.deleteVertexArray = (o) => He(e, () => r.deleteVertexArrayOES(o)), this.getVertexArray = () => He(e, () => e.getParameter(r.VERTEX_ARRAY_BINDING_OES));
    }
    let s = "WEBGL_color_buffer_float";
    const i = "EXT_color_buffer_half_float";
    if (this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile"), ie().getNumber("WEBGL_VERSION") === 1) {
      const r = "OES_texture_float", o = "OES_texture_half_float";
      if (this.textureFloatExtension = _g(this.gl, r), Yi(this.gl, o))
        this.textureHalfFloatExtension = _g(this.gl, o);
      else if (ie().get("WEBGL_FORCE_F16_TEXTURES"))
        throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      if (this.colorBufferFloatExtension = this.gl.getExtension(s), Yi(this.gl, i))
        this.colorBufferHalfFloatExtension = _g(this.gl, i);
      else if (ie().get("WEBGL_FORCE_F16_TEXTURES"))
        throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
    } else if (s = "EXT_color_buffer_float", Yi(this.gl, s))
      this.colorBufferFloatExtension = this.gl.getExtension(s);
    else if (Yi(this.gl, i))
      this.colorBufferHalfFloatExtension = this.gl.getExtension(i);
    else
      throw new Error("GL context does not support color renderable floats");
    this.vertexBuffer = Vse(this.gl), this.indexBuffer = Use(this.gl), this.framebuffer = Rne(this.gl), this.textureConfig = kT(this.gl, this.textureHalfFloatExtension);
  }
  get debug() {
    return ie().getBool("DEBUG");
  }
  dispose() {
    if (this.disposed)
      return;
    this.program != null && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), this.outputTexture != null && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
    const e = this.gl;
    He(e, () => e.finish()), He(e, () => e.bindFramebuffer(e.FRAMEBUFFER, null)), He(e, () => e.deleteFramebuffer(this.framebuffer)), He(e, () => e.bindBuffer(e.ARRAY_BUFFER, null)), He(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null)), He(e, () => e.deleteBuffer(this.indexBuffer)), this.disposed = !0;
  }
  createFloat32MatrixTexture(e, n) {
    return this.throwIfDisposed(), Gse(this.gl, e, n, this.textureConfig);
  }
  createFloat16MatrixTexture(e, n) {
    return this.throwIfDisposed(), Wse(this.gl, e, n, this.textureConfig);
  }
  createUnsignedBytesMatrixTexture(e, n) {
    return this.throwIfDisposed(), Hse(this.gl, e, n, this.textureConfig);
  }
  uploadPixelDataToTexture(e, n) {
    this.throwIfDisposed(), Yse(this.gl, e, n);
  }
  uploadDenseMatrixToTexture(e, n, s, i) {
    this.throwIfDisposed(), Kse(this.gl, e, n, s, i, this.textureConfig);
  }
  createFloat16PackedMatrixTexture(e, n) {
    return this.throwIfDisposed(), qse(this.gl, e, n, this.textureConfig);
  }
  createPackedMatrixTexture(e, n) {
    return this.throwIfDisposed(), jse(this.gl, e, n, this.textureConfig);
  }
  deleteMatrixTexture(e) {
    this.throwIfDisposed(), this.outputTexture === e && (OI(this.gl, this.framebuffer), this.outputTexture = null), He(this.gl, () => this.gl.deleteTexture(e));
  }
  downloadByteEncodedFloatMatrixFromOutputTexture(e, n, s) {
    return this.downloadMatrixDriver(e, () => Qse(this.gl, n, s, this.textureConfig));
  }
  downloadPackedMatrixFromBuffer(e, n, s, i, r, o) {
    return eie(this.gl, e, n, s, i, r, o, this.textureConfig);
  }
  downloadFloat32MatrixFromBuffer(e, n) {
    return Jse(this.gl, e, n);
  }
  createBufferFromTexture(e, n, s) {
    this.bindTextureToFrameBuffer(e);
    const i = Zse(this.gl, n, s, this.textureConfig);
    return this.unbindTextureToFrameBuffer(), i;
  }
  createAndWaitForFence() {
    const e = this.createFence(this.gl);
    return this.pollFence(e);
  }
  createFence(e) {
    let n, s;
    if (ie().getBool("WEBGL_FENCE_API_ENABLED")) {
      const i = e, r = i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE, 0);
      e.flush(), s = () => {
        const o = i.clientWaitSync(r, 0, 0);
        return o === i.ALREADY_SIGNALED || o === i.CONDITION_SATISFIED;
      }, n = r;
    } else
      ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (n = this.beginQuery(), this.endQuery(), s = () => this.isQueryAvailable(n, ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : s = () => !0;
    return { query: n, isFencePassed: s };
  }
  downloadMatrixFromPackedTexture(e, n, s) {
    return this.downloadMatrixDriver(e, () => tie(this.gl, n, s));
  }
  createProgram(e) {
    this.throwIfDisposed();
    const n = this.gl;
    this.vertexShader == null && (this.vertexShader = zse(n));
    const s = Ine(n);
    He(n, () => n.attachShader(s, this.vertexShader)), He(n, () => n.attachShader(s, e)), Ene(n, s);
    const i = Object.assign(s, { vao: this.createVertexArray() });
    return this.debug && Nv(n, i), i;
  }
  buildVao(e) {
    this.setProgram(e), this.bindVertexArray(e.vao);
    const n = this.gl;
    He(n, () => n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, this.indexBuffer)), Xse(n, e, this.vertexBuffer);
  }
  deleteProgram(e) {
    this.throwIfDisposed(), e === this.program && (this.program = null), e != null && (He(this.gl, () => this.gl.deleteProgram(e)), this.deleteVertexArray(e.vao));
  }
  setProgram(e) {
    this.throwIfDisposed(), this.program = e, this.program != null && this.debug && Nv(this.gl, this.program), He(this.gl, () => this.gl.useProgram(e));
  }
  getUniformLocation(e, n, s = !0) {
    return this.throwIfDisposed(), s ? $ne(this.gl, e, n) : One(this.gl, e, n);
  }
  getAttributeLocation(e, n) {
    return this.throwIfDisposed(), He(this.gl, () => this.gl.getAttribLocation(e, n));
  }
  getUniformLocationNoThrow(e, n) {
    return this.throwIfDisposed(), this.gl.getUniformLocation(e, n);
  }
  setInputMatrixTexture(e, n, s) {
    this.throwIfDisposed(), this.throwIfNoProgram(), Lne(this.gl, e, n, s);
  }
  setOutputMatrixTexture(e, n, s) {
    this.setOutputMatrixTextureDriver(e, s, n);
  }
  setOutputPackedMatrixTexture(e, n, s) {
    this.throwIfDisposed();
    const [i, r] = Bh(n, s);
    this.setOutputMatrixTextureDriver(e, i, r);
  }
  setOutputMatrixWriteRegion(e, n, s, i) {
    this.setOutputMatrixWriteRegionDriver(s, e, i, n);
  }
  setOutputPackedMatrixWriteRegion(e, n, s, i) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }
  debugValidate() {
    this.program != null && Nv(this.gl, this.program), Tg(this.gl);
  }
  executeProgram() {
    this.throwIfDisposed(), this.throwIfNoProgram();
    const e = this.gl;
    if (this.debug) {
      const n = this.getVertexArray();
      console.assert(n === this.program.vao, "VAO changed between setProgram and executeProgram!"), this.debugValidate();
    }
    He(e, () => e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0));
  }
  blockUntilAllProgramsCompleted() {
    this.throwIfDisposed(), He(this.gl, () => this.gl.finish());
  }
  getQueryTimerExtension() {
    return this.disjointQueryTimerExtension == null && (this.disjointQueryTimerExtension = _g(this.gl, ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
  }
  getQueryTimerExtensionWebGL2() {
    return this.getQueryTimerExtension();
  }
  getQueryTimerExtensionWebGL1() {
    return this.getQueryTimerExtension();
  }
  beginQuery() {
    if (ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      const s = this.gl, i = this.getQueryTimerExtensionWebGL2(), r = s.createQuery();
      return s.beginQuery(i.TIME_ELAPSED_EXT, r), r;
    }
    const e = this.getQueryTimerExtensionWebGL1(), n = e.createQueryEXT();
    return e.beginQueryEXT(e.TIME_ELAPSED_EXT, n), n;
  }
  endQuery() {
    if (ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      const n = this.gl, s = this.getQueryTimerExtensionWebGL2();
      n.endQuery(s.TIME_ELAPSED_EXT);
      return;
    }
    const e = this.getQueryTimerExtensionWebGL1();
    e.endQueryEXT(e.TIME_ELAPSED_EXT);
  }
  async waitForQueryAndGetTime(e) {
    return await Dw(() => this.disposed || // while testing contexts are created / disposed
    // in rapid succession, so without this check we
    // may poll for the query timer indefinitely
    this.isQueryAvailable(e, ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))), this.getQueryTime(e, ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
  }
  getQueryTime(e, n) {
    if (n === 0)
      return null;
    if (n === 2) {
      const s = this.gl;
      return s.getQueryParameter(e, s.QUERY_RESULT) / 1e6;
    } else {
      const s = this.getQueryTimerExtensionWebGL1();
      return s.getQueryObjectEXT(e, s.QUERY_RESULT_EXT) / 1e6;
    }
  }
  isQueryAvailable(e, n) {
    if (n === 0)
      return !0;
    if (n === 2) {
      const s = this.gl, i = this.getQueryTimerExtensionWebGL2(), r = s.getQueryParameter(e, s.QUERY_RESULT_AVAILABLE);
      return this.disjoint == null && (this.disjoint = this.gl.getParameter(i.GPU_DISJOINT_EXT)), r && !this.disjoint;
    } else {
      const s = this.getQueryTimerExtensionWebGL1(), i = s.getQueryObjectEXT(e, s.QUERY_RESULT_AVAILABLE_EXT);
      return this.disjoint == null && (this.disjoint = this.gl.getParameter(s.GPU_DISJOINT_EXT)), i && !this.disjoint;
    }
  }
  pollFence(e) {
    return new Promise((n) => {
      this.addItemToPoll(() => e.isFencePassed(), () => n());
    });
  }
  pollItems() {
    const e = nie(this.itemsToPoll.map((n) => n.isDoneFn));
    for (let n = 0; n <= e; ++n) {
      const { resolveFn: s } = this.itemsToPoll[n];
      s();
    }
    this.itemsToPoll = this.itemsToPoll.slice(e + 1);
  }
  addItemToPoll(e, n) {
    if (this.itemsToPoll.push({ isDoneFn: e, resolveFn: n }), this.itemsToPoll.length > 1)
      return;
    let s;
    "setTimeoutCustom" in ie().platform && (s = ie().platform.setTimeoutCustom.bind(ie().platform)), Dw(() => (this.pollItems(), this.itemsToPoll.length === 0), () => 0, null, s);
  }
  bindTextureToFrameBuffer(e) {
    this.throwIfDisposed(), kv(this.gl, e, this.framebuffer), this.debug && Tg(this.gl);
  }
  unbindTextureToFrameBuffer() {
    this.outputTexture != null ? (kv(this.gl, this.outputTexture, this.framebuffer), this.debug && Tg(this.gl)) : OI(this.gl, this.framebuffer);
  }
  downloadMatrixDriver(e, n) {
    this.bindTextureToFrameBuffer(e);
    const s = n();
    return this.unbindTextureToFrameBuffer(), s;
  }
  setOutputMatrixTextureDriver(e, n, s) {
    this.throwIfDisposed();
    const i = this.gl;
    kv(i, e, this.framebuffer), this.debug && Tg(i), this.outputTexture = e, He(i, () => i.viewport(0, 0, n, s)), He(i, () => i.scissor(0, 0, n, s));
  }
  setOutputMatrixWriteRegionDriver(e, n, s, i) {
    this.throwIfDisposed(), He(this.gl, () => this.gl.scissor(e, n, s, i));
  }
  throwIfDisposed() {
    if (this.disposed)
      throw new Error("Attempted to use disposed GPGPUContext.");
  }
  throwIfNoProgram() {
    if (this.program == null)
      throw new Error("No GPU program is currently set.");
  }
}
function nie(t) {
  let e = 0;
  for (; e < t.length && t[e](); ++e)
    ;
  return e - 1;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const { addImpl: sie, bincountImpl: q$, bincountReduceImpl: iie, bitwiseAndImpl: rie, castImpl: oie, ceilImpl: aie, concatImpl: cie, equalImpl: lie, expImpl: uie, expm1Impl: hie, floorImpl: die, gatherNdImpl: fie, gatherV2Impl: pie, greaterImpl: mie, greaterEqualImpl: gie, lessImpl: yie, lessEqualImpl: xie, linSpaceImpl: bie, logImpl: vie, maxImpl: wie, maximumImpl: Sie, minimumImpl: _ie, multiplyImpl: Tie, negImpl: Cie, notEqualImpl: Iie, prodImpl: Eie, raggedGatherImpl: Nie, raggedRangeImpl: kie, raggedTensorToTensorImpl: Aie, rangeImpl: Mie, rsqrtImpl: Rie, scatterImpl: Die, sigmoidImpl: $ie, simpleAbsImpl: X$, sliceImpl: Oie, sparseFillEmptyRowsImpl: Lie, sparseReshapeImpl: Fie, sparseSegmentReductionImpl: K$, sqrtImpl: Pie, staticRegexReplaceImpl: Bie, stridedSliceImpl: zie, stringNGramsImpl: Vie, stringSplitImpl: Uie, stringToHashBucketFastImpl: Gie, subImpl: Wie, tileImpl: Hie, topKImpl: jie, transposeImpl: DT, uniqueImpl: qie } = YY;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Y$(t, e) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, e).map((n) => `${t}.${n}`);
}
function zs(t, e) {
  return e === 1 ? [t] : Y$(t, e);
}
function Xie(t, e) {
  if (t === 1)
    return "rc";
  let n = "";
  for (let s = 0; s < t; s++)
    n += e[s], s < t - 1 && (n += ",");
  return n;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Kie {
  constructor(e) {
    if (this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = e, this.rank = e.length, this.enableShapeUniforms = As(this.outputShape.length), this.rank === 0)
      this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
    else {
      const n = zs("rc", this.rank), s = rn(this.rank), i = this.getOutOfBoundsCondition(n), r = this.getSetup(n), o = this.getOutput(n);
      this.userCode = `
        void main() {
          ${s} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${o}));
          }
        }
      `;
    }
  }
  getSourceCoordsArr(e) {
    const n = [];
    for (let s = 0; s <= 1; s++)
      for (let i = 0; i <= 1; i++) {
        let r = `${s === 0 ? "r" : "rp1"}, ${i === 0 ? "c" : "cp1"}`;
        for (let o = 2; o < this.rank; o++)
          r = `${e[e.length - 1 - o]},` + r;
        n.push(r);
      }
    return n;
  }
  getOutOfBoundsCondition(e) {
    if (this.rank === 1)
      return `rc > ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]}`;
    let n = "";
    for (let s = this.rank - 2; s < this.rank; s++)
      n += `${e[s]} >= ${this.enableShapeUniforms ? `outShape[${s}]` : this.outputShape[s]}`, s < this.rank - 1 && (n += "||");
    return n;
  }
  getSetup(e) {
    if (this.rank === 1)
      return "";
    const n = e.slice(-2), s = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1], i = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
    return `
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${i};
    `;
  }
  getOutput(e) {
    const n = this.getSourceCoordsArr(e);
    return this.rank === 1 ? `getA(rc), (rc + 1 >= ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0` : `getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Z$ {
  constructor(e, n) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{ name: "inputShape", type: "ivec3" }], this.outputShape = e, this.enableShapeUniforms = As(this.outputShape.length);
    let s = "";
    for (let i = 0; i < 4; i++) {
      let r = "thisRC = rc;";
      i % 2 === 1 && (r += "thisRC.z += 1;"), i > 1 && (r += "thisRC.y += 1;"), s += `
        ${r}
        ${i > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i > 0 ? "}" : ""}
      `;
    }
    this.userCode = `
      ${Yie(n, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? MT() : AT(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : e[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : e[2]};

        ${s}

        setOutput(result);
      }
    `;
  }
}
function Yie(t, e) {
  return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e ? Xne(["r", "c", "d"], "inputShape") : ll(["r", "c", "d"], t)}
      return ivec3(r, c, d);
    }
  `;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Zie {
  constructor(e) {
    this.gpgpu = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.usedTextures = {}, this.logEnabled = !1;
  }
  acquireTexture(e, n, s) {
    const i = zI(n, s), r = VI(e, i, s);
    r in this.freeTextures || (this.freeTextures[r] = []), r in this.usedTextures || (this.usedTextures[r] = []);
    const o = BI(e, i, this.gpgpu.gl, this.gpgpu.textureConfig, s);
    if (this.freeTextures[r].length > 0) {
      this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= o, this.log();
      const c = this.freeTextures[r].pop();
      return this.usedTextures[r].push(c), c;
    }
    let a;
    return i === gs.PACKED_2X2_FLOAT32 ? a = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : i === gs.PACKED_2X2_FLOAT16 ? a = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]) : i === gs.UNPACKED_FLOAT32 ? a = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : i === gs.UNPACKED_FLOAT16 ? a = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : i === gs.PACKED_4X1_UNSIGNED_BYTE && (a = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), this.usedTextures[r].push(a), this.numUsedTextures++, this._numBytesAllocated += o, this.log(), a;
  }
  releaseTexture(e, n, s, i) {
    if (this.freeTextures == null)
      return;
    const r = zI(s, i), o = VI(n, r, i);
    o in this.freeTextures || (this.freeTextures[o] = []);
    const a = BI(n, r, this.gpgpu.gl, this.gpgpu.textureConfig, i), c = ie().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");
    c !== -1 && this._numBytesAllocated > c ? (this.gpgpu.deleteMatrixTexture(e.texture), this._numBytesAllocated -= a) : (this.freeTextures[o].push(e), this.numFreeTextures++, this._numBytesFree += a), this.numUsedTextures--;
    const l = this.usedTextures[o], u = l && l.indexOf(e);
    if (u == null || u < 0)
      throw new Error("Cannot release a texture that was never provided by this texture manager");
    l[u] = l[l.length - 1], l.pop(), this.log();
  }
  log() {
    if (!this.logEnabled)
      return;
    const e = this.numFreeTextures + this.numUsedTextures;
    console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${e})`);
    const n = this._numBytesFree / this._numBytesAllocated;
    console.log(`Bytes allocated: ${this._numBytesAllocated}`), console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * n)}%)`);
  }
  get numBytesAllocated() {
    return this._numBytesAllocated;
  }
  get numBytesFree() {
    return this._numBytesFree;
  }
  getNumUsedTextures() {
    return this.numUsedTextures;
  }
  getNumFreeTextures() {
    return this.numFreeTextures;
  }
  dispose() {
    if (this.freeTextures != null) {
      for (const e in this.freeTextures)
        this.freeTextures[e].forEach((n) => {
          this.gpgpu.deleteMatrixTexture(n.texture);
        });
      for (const e in this.usedTextures)
        this.usedTextures[e].forEach((n) => {
          this.gpgpu.deleteMatrixTexture(n.texture);
        });
      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0;
    }
  }
}
function Jie(t, e) {
  const n = t;
  if (e === n.R32F)
    return 4;
  if (e === n.R16F)
    return 2;
  if (e === n.RGBA32F)
    return 16;
  if (e === t.RGBA)
    return 16;
  if (e === n.RGBA16F)
    return 8;
  if (e === n.RGBA8)
    return 4;
  throw new Error(`Unknown internal format ${e}`);
}
function BI(t, e, n, s, i) {
  const r = Qie(e, s);
  let o;
  if (i) {
    const [c, l] = Bh(t[0], t[1]);
    o = c * l;
  } else {
    const [c, l] = Sm(t[0], t[1]);
    o = c * l;
  }
  const a = Jie(n, r);
  return o * a;
}
function Qie(t, e) {
  switch (t) {
    case gs.PACKED_2X2_FLOAT32:
      return H$(e);
    case gs.PACKED_2X2_FLOAT16:
      return j$(e);
    case gs.UNPACKED_FLOAT32:
      return U$(e);
    case gs.UNPACKED_FLOAT16:
      return G$(e);
    case gs.PACKED_4X1_UNSIGNED_BYTE:
      return W$(e);
    default:
      throw new Error(`Unknown physical texture type ${t}`);
  }
}
function ere(t) {
  return ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t ? gs.PACKED_2X2_FLOAT32 : gs.UNPACKED_FLOAT32 : t ? gs.PACKED_2X2_FLOAT16 : gs.UNPACKED_FLOAT16;
}
function zI(t, e) {
  if (t === ki.UPLOAD)
    return gs.PACKED_2X2_FLOAT32;
  if (t === ki.RENDER || t == null)
    return ere(e);
  if (t === ki.DOWNLOAD || t === ki.PIXELS)
    return gs.PACKED_4X1_UNSIGNED_BYTE;
  throw new Error(`Unknown logical texture type ${t}`);
}
function VI(t, e, n) {
  return `${t[0]}_${t[1]}_${e}_${n}`;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Hr {
  constructor(e, n) {
    this.variableNames = ["A"], this.outputShape = e, this.enableShapeUniforms = As(this.outputShape.length), this.userCode = `
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
  }
}
const or = "if (isnan(x)) return x;", tre = "return x;", UI = "return abs(x);", nre = "return (x >= 0.0) ? x : (exp(x) - 1.0);", sre = or + `
  return (x < 0.0) ? 0.0 : x;
`, ire = or + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`, ia = "return x;", rre = "return 1.0 / (1.0 + exp(-1.0 * x));";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ore = "return x;", are = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`, cre = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, lre = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, ure = "return 1.0 / (1.0 + exp(-1.0 * x));";
class ua {
  constructor(e, n) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.enableShapeUniforms = As(this.outputShape.length), this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class hre {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = e, this.enableShapeUniforms = As(this.outputShape.length);
    const n = e.length, s = zs("rc", n), i = rn(n), r = Xie(n, s), o = s.slice(-2), a = n <= 1 ? "rc" : `vec2(${o.join(",")})`;
    this.userCode = `
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${a}));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dre = Q0, fre = 1e-7, pre = 1e-4, Eg = {};
function mre(t) {
  return t in Eg || (Eg[t] = {}), Eg[t];
}
const gre = ie().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"), yre = 600;
function xre() {
  return ie().global.screen == null ? 1024 : ie().global.screen.height * ie().global.screen.width * window.devicePixelRatio * yre / 1024 / 1024;
}
class Nb extends mx {
  nextDataId() {
    return Nb.nextDataId++;
  }
  constructor(e) {
    if (super(), this.pendingRead = /* @__PURE__ */ new WeakMap(), this.pendingDisposal = /* @__PURE__ */ new WeakSet(), this.dataRefCount = /* @__PURE__ */ new WeakMap(), this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.lastGlFlushTime = 0, this.warnedAboutMemory = !1, this.pendingDeletes = 0, this.disposed = !1, !ie().getBool("HAS_WEBGL"))
      throw new Error("WebGL is not supported on this device");
    let n;
    if (e != null) {
      if (e instanceof Rv)
        n = e;
      else {
        const s = Ir(ie().getNumber("WEBGL_VERSION"), e);
        n = new Rv(s);
      }
      this.binaryCache = {}, this.gpgpuCreatedLocally = !1;
    } else {
      const s = Ir(ie().getNumber("WEBGL_VERSION"));
      n = new Rv(s), this.binaryCache = mre(ie().getNumber("WEBGL_VERSION")), this.gpgpuCreatedLocally = !0;
    }
    this.gpgpu = n, this.canvas = this.gpgpu.gl.canvas, this.textureManager = new Zie(this.gpgpu), this.numMBBeforeWarning = xre(), this.texData = new W1(this, ui());
  }
  numDataIds() {
    return this.texData.numDataIds() - this.pendingDeletes;
  }
  // Writes a new entry to the data store with a WebGL texture, and registers it
  // to the texture manager.
  writeTexture(e, n, s, i, r, o) {
    const a = this.makeTensorInfo(n, s), c = this.texData.get(a.dataId);
    c.isPacked = !1, c.texture = { texture: e, texShape: [i, r] }, c.texShape = [i, r];
    const l = Cg(n), u = new PI(l, !1, o), h = this.runWebGLProgram(u, [a], s, [[i, r]]);
    return h.shape = n, c.texture = null, this.disposeIntermediateTensorInfo(a), h.dataId;
  }
  write(e, n, s) {
    if ((ie().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || ie().getBool("DEBUG")) && this.checkNumericalProblems(e), s === "complex64" && e != null)
      throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    const i = { id: this.nextDataId() };
    return this.texData.set(i, { shape: n, dtype: s, values: e, usage: ki.UPLOAD, refCount: 1 }), i;
  }
  /** Return refCount of a `TensorData`. */
  refCount(e) {
    return this.texData.has(e) ? this.texData.get(e).refCount : 0;
  }
  /** Increase refCount of a `TextureData`. */
  incRef(e) {
    const n = this.texData.get(e);
    n.refCount++;
  }
  /** Decrease refCount of a `TextureData`. */
  decRef(e) {
    if (this.texData.has(e)) {
      const n = this.texData.get(e);
      n.refCount--;
    }
  }
  move(e, n, s, i, r) {
    if (ie().getBool("DEBUG") && this.checkNumericalProblems(n), i === "complex64")
      throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.texData.set(e, { shape: s, dtype: i, values: n, usage: ki.UPLOAD, refCount: r });
  }
  disposeIntermediateTensorInfo(e) {
    this.disposeData(e.dataId);
  }
  readSync(e) {
    const n = this.texData.get(e), { values: s, dtype: i, complexTensorInfos: r, slice: o, shape: a, isPacked: c } = n;
    if (o != null) {
      let d;
      c ? d = new ua(a, ia) : d = new Hr(a, ia);
      const f = this.runWebGLProgram(d, [{ dataId: e, shape: a, dtype: i }], i), p = this.readSync(f.dataId);
      return this.disposeIntermediateTensorInfo(f), p;
    }
    if (s != null)
      return this.convertAndCacheOnCPU(e);
    if (i === "string")
      return s;
    const l = this.activeTimers != null;
    let u;
    l && (u = Ls());
    let h;
    if (i === "complex64") {
      const d = this.readSync(r.real.dataId), f = this.readSync(r.imag.dataId);
      h = Lo(d, f);
    } else
      h = this.getValuesFromTexture(e);
    return l && (this.downloadWaitMs += Ls() - u), this.convertAndCacheOnCPU(e, h);
  }
  async read(e) {
    if (this.pendingRead.has(e)) {
      const p = this.pendingRead.get(e);
      return new Promise((y) => p.push(y));
    }
    const n = this.texData.get(e), { values: s, shape: i, slice: r, dtype: o, complexTensorInfos: a, isPacked: c } = n;
    if (r != null) {
      let p;
      c ? p = new ua(i, ia) : p = new Hr(i, ia);
      const y = this.runWebGLProgram(p, [{ dataId: e, shape: i, dtype: o }], o), g = this.read(y.dataId);
      return this.disposeIntermediateTensorInfo(y), g;
    }
    if (s != null)
      return this.convertAndCacheOnCPU(e);
    if (ie().getBool("DEBUG") && !ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && ie().getNumber("WEBGL_VERSION") === 2)
      throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
    let l = null, u;
    if (o !== "complex64" && ie().get("WEBGL_BUFFER_SUPPORTED")) {
      u = this.decode(e);
      const p = this.texData.get(u.dataId);
      l = this.gpgpu.createBufferFromTexture(p.texture.texture, ...Sg(i));
    }
    this.pendingRead.set(e, []), o !== "complex64" && await this.gpgpu.createAndWaitForFence();
    let h;
    if (o === "complex64") {
      const p = await Promise.all([
        this.read(a.real.dataId),
        this.read(a.imag.dataId)
      ]), y = p[0], g = p[1];
      h = Lo(y, g);
    } else if (l == null)
      h = this.getValuesFromTexture(e);
    else {
      const p = ue(i);
      h = this.gpgpu.downloadFloat32MatrixFromBuffer(l, p);
    }
    if (u != null && this.disposeIntermediateTensorInfo(u), l != null) {
      const p = this.gpgpu.gl;
      He(p, () => p.deleteBuffer(l));
    }
    const d = this.convertAndCacheOnCPU(e, h), f = this.pendingRead.get(e);
    return this.pendingRead.delete(e), f.forEach((p) => p(d)), this.pendingDisposal.has(e) && (this.pendingDisposal.delete(e), this.disposeData(e) && ui().removeDataId(e, this), this.pendingDeletes--), d;
  }
  /**
   * Read tensor to a new texture that is densely packed for ease of use.
   * @param dataId The source tensor.
   * @param options
   *     customTexShape: Optional. If set, will use the user defined texture
   *     shape to create the texture.
   */
  readToGPU(e, n = {}) {
    const s = this.texData.get(e), { values: i, shape: r, slice: o, dtype: a, isPacked: c, texture: l } = s;
    if (a === "complex64")
      throw new Error("Does not support reading texture for complex64 dtype.");
    if (o != null) {
      let f;
      c ? f = new ua(r, ia) : f = new Hr(r, ia);
      const p = this.runWebGLProgram(f, [{ dataId: e, shape: r, dtype: a }], a), y = this.readToGPU(p, n);
      return this.disposeIntermediateTensorInfo(p), y;
    }
    if (l == null)
      throw i != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
    const u = this.decode(e, n.customTexShape), h = ui().makeTensorFromTensorInfo(u), d = this.texData.get(u.dataId);
    return Object.assign({ tensorRef: h }, d.texture);
  }
  bufferSync(e) {
    const n = this.readSync(e.dataId);
    if (e.dtype === "string")
      try {
        const s = n.map((i) => Ro(i));
        return It(e.shape, e.dtype, s);
      } catch {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    return It(e.shape, e.dtype, n);
  }
  checkNumericalProblems(e) {
    if (e != null)
      for (let n = 0; n < e.length; n++) {
        const s = e[n];
        if (!wne(s))
          throw ie().getBool("WEBGL_RENDER_FLOAT32_CAPABLE") ? Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`) : Error(`The value ${s} cannot be represented on this device.`);
      }
  }
  getValuesFromTexture(e) {
    const { shape: n, dtype: s, isPacked: i } = this.texData.get(e), r = ue(n);
    if (ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      const d = this.decode(e), f = this.texData.get(d.dataId), p = this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture, ...Sg(n)).subarray(0, r);
      return this.disposeIntermediateTensorInfo(d), p;
    }
    const o = ie().getBool("WEBGL_PACK") && i === !0, a = o ? Cg(n) : n, c = o ? new Fse(a) : new Lse(a), l = this.runWebGLProgram(c, [{ shape: a, dtype: s, dataId: e }], "float32"), u = this.texData.get(l.dataId), h = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture, u.texShape[0], u.texShape[1]).subarray(0, r);
    return this.disposeIntermediateTensorInfo(l), h;
  }
  timerAvailable() {
    return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
  }
  time(e) {
    const n = this.activeTimers, s = [];
    let i = !1;
    this.programTimersStack == null ? (this.programTimersStack = s, i = !0) : this.activeTimers.push(s), this.activeTimers = s, e();
    const r = no(this.activeTimers.map((c) => c.query)).filter((c) => c != null), o = no(this.activeTimers.map((c) => c.name)).filter((c) => c != null);
    this.activeTimers = n, i && (this.programTimersStack = null);
    const a = {
      uploadWaitMs: this.uploadWaitMs,
      downloadWaitMs: this.downloadWaitMs,
      kernelMs: null,
      wallMs: null
      // will be filled by the engine
    };
    return (async () => {
      if (ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        const c = await Promise.all(r);
        a.kernelMs = SN(c), a.getExtraProfileInfo = () => c.map((l, u) => ({ name: o[u], ms: l })).map((l) => `${l.name}: ${l.ms}`).join(", ");
      } else
        a.kernelMs = {
          error: "WebGL query timers are not supported in this environment."
        };
      return this.uploadWaitMs = 0, this.downloadWaitMs = 0, a;
    })();
  }
  memory() {
    return {
      unreliable: !1,
      numBytesInGPU: this.numBytesInGPU,
      numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
      numBytesInGPUFree: this.textureManager.numBytesFree
    };
  }
  startTimer() {
    return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : { startMs: Ls(), endMs: null };
  }
  endTimer(e) {
    return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), e) : (e.endMs = Ls(), e);
  }
  async getQueryTime(e) {
    if (ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)
      return this.gpgpu.waitForQueryAndGetTime(e);
    const n = e;
    return n.endMs - n.startMs;
  }
  /**
   * Decrease the RefCount on the dataId and dispose the memory if the dataId
   * has 0 refCount. If there are pending read on the data, the disposal would
   * added to the pending delete queue. Return true if the dataId is removed
   * from backend or the backend does not contain the dataId, false if the
   * dataId is not removed. Memory may or may not be released even when dataId
   * is removed, which also depends on dataRefCount, see `releaseGPU`.
   * @param dataId
   * @oaram force Optional, remove the data regardless of refCount
   */
  disposeData(e, n = !1) {
    if (this.pendingDisposal.has(e))
      return !1;
    if (!this.texData.has(e))
      return !0;
    if (n ? this.texData.get(e).refCount = 0 : this.texData.get(e).refCount--, !n && this.texData.get(e).refCount > 0)
      return !1;
    if (this.pendingRead.has(e))
      return this.pendingDisposal.add(e), this.pendingDeletes++, !1;
    this.releaseGPUData(e);
    const { complexTensorInfos: s } = this.texData.get(e);
    return s != null && (this.disposeData(s.real.dataId, n), this.disposeData(s.imag.dataId, n)), this.texData.delete(e), !0;
  }
  releaseGPUData(e) {
    const { texture: n, dtype: s, texShape: i, usage: r, isPacked: o, slice: a } = this.texData.get(e), c = a && a.origDataId || e, l = this.dataRefCount.get(c);
    l > 1 ? this.dataRefCount.set(c, l - 1) : (this.dataRefCount.delete(c), n != null && (this.numBytesInGPU -= this.computeBytes(i, s), this.textureManager.releaseTexture(n, i, r, o)));
    const u = this.texData.get(e);
    u.texture = null, u.texShape = null, u.isPacked = !1, u.slice = null;
  }
  getTexture(e) {
    return this.uploadToGPU(e), this.texData.get(e).texture.texture;
  }
  /**
   * Returns internal information for the specific data bucket. Used in unit
   * tests.
   */
  getDataInfo(e) {
    return this.texData.get(e);
  }
  /*
  Tests whether all the inputs to an op are small and on the CPU. This heuristic
  determines when it would be faster to execute a kernel on the CPU. WebGL
  kernels opt into running this check and forwarding when appropriate.
  TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more
  sustainable strategy for optimizing backend execution of ops.
   */
  shouldExecuteOnCPU(e, n = gre) {
    return ie().getBool("WEBGL_CPU_FORWARD") && e.every((s) => this.texData.get(s.dataId).texture == null && ue(s.shape) < n);
  }
  getGPGPUContext() {
    return this.gpgpu;
  }
  where(e) {
    Ei("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    const n = e.dataSync();
    return dre(e.shape, n);
  }
  packedUnaryOp(e, n, s) {
    const i = new ua(e.shape, n), r = this.compileAndRun(i, [e], s);
    return ui().makeTensorFromTensorInfo(r);
  }
  // TODO(msoulanille) remove this once the backend has been modularized
  // a copy is needed here to break a circular dependency.
  // Also remove the op from unary_op.
  abs(e) {
    if (this.shouldExecuteOnCPU([e]) && e.dtype !== "complex64") {
      const i = X$(this.texData.get(e.dataId).values);
      return this.makeOutput(e.shape, e.dtype, i);
    }
    if (ie().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(e, UI, e.dtype);
    const n = new Hr(e.shape, UI), s = this.compileAndRun(n, [e]);
    return ui().makeTensorFromTensorInfo(s);
  }
  makeTensorInfo(e, n, s) {
    let i;
    if (n === "string" && s != null && s.length > 0 && Wr(s[0])) {
      const r = s.map((o) => jr(o));
      i = this.write(r, e, n);
    } else
      i = this.write(s, e, n);
    return this.texData.get(i).usage = null, { dataId: i, shape: e, dtype: n };
  }
  makeOutput(e, n, s) {
    return ui().makeTensorFromTensorInfo(this.makeTensorInfo(e, n, s), this);
  }
  unpackTensor(e) {
    const n = new hre(e.shape);
    return this.runWebGLProgram(n, [e], e.dtype);
  }
  packTensor(e) {
    const n = new Kie(e.shape), s = !0;
    return this.runWebGLProgram(n, [e], e.dtype, null, s);
  }
  packedReshape(e, n) {
    const s = [
      Au(e.shape),
      ...Mu(e.shape)
    ], i = {
      dtype: e.dtype,
      shape: s,
      dataId: e.dataId
    }, r = [
      Au(n),
      ...Mu(n)
    ], o = new Z$(r, s), a = !0, c = [s], l = this.runWebGLProgram(o, [i], e.dtype, c, a);
    return { dataId: l.dataId, shape: n, dtype: l.dtype };
  }
  decode(e, n) {
    const s = this.texData.get(e), { isPacked: i, shape: r, dtype: o } = s;
    if (n != null) {
      const d = ue(r), f = n[0] * n[1] * 4;
      A(d <= f, () => "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");
    }
    const a = Cg(r);
    let c;
    i ? c = new Ose(a) : c = new $se(a);
    const l = !0, u = [n ?? Sg(a)], h = this.runWebGLProgram(c, [{ shape: a, dtype: o, dataId: e }], o, u, l, n);
    return { dtype: o, shape: r, dataId: h.dataId };
  }
  runWebGLProgram(e, n, s, i, r = !1, o) {
    const a = this.makeTensorInfo(e.outputShape, s), c = this.texData.get(a.dataId);
    if (e.packedOutput && (c.isPacked = !0), e.outPackingScheme === If.DENSE) {
      const m = o ?? Sg(e.outputShape);
      c.texShape = m.map((x) => x * 2);
    }
    if (e.outTexUsage != null && (c.usage = e.outTexUsage), ue(a.shape) === 0)
      return c.values = ls(a.dtype, 0), a;
    const l = [], u = n.map((m) => {
      if (m.dtype === "complex64")
        throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      let x = this.texData.get(m.dataId);
      if (x.texture == null) {
        if (!e.packedInputs && ue(m.shape) <= ie().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))
          return {
            shape: m.shape,
            texData: null,
            isUniform: !0,
            uniformValues: x.values
          };
        e.packedInputs && (x.isPacked = !0, x.shape = m.shape);
      }
      if (this.uploadToGPU(m.dataId), !!x.isPacked != !!e.packedInputs)
        m = x.isPacked ? this.unpackTensor(m) : this.packTensor(m), l.push(m), x = this.texData.get(m.dataId);
      else if (x.isPacked && !ex(x.shape, m.shape)) {
        const v = m, b = m.shape;
        m.shape = x.shape, m = this.packedReshape(m, b), l.push(m), x = this.texData.get(m.dataId), v.shape = b;
      }
      return { shape: m.shape, texData: x, isUniform: !1 };
    });
    this.uploadToGPU(a.dataId);
    const h = { shape: a.shape, texData: c, isUniform: !1 }, d = Dse(e, u, h), f = this.getAndSaveBinary(d, () => Mse(this.gpgpu, e, u, h)), p = this.activeTimers != null;
    let y;
    p && (y = this.startTimer()), ie().get("ENGINE_COMPILE_ONLY") || Rse(this.gpgpu, f, u, h, i), l.forEach((m) => this.disposeIntermediateTensorInfo(m)), p && (y = this.endTimer(y), this.activeTimers.push({ name: e.constructor.name, query: this.getQueryTime(y) }));
    const g = ie().getNumber("WEBGL_FLUSH_THRESHOLD");
    if (g > 0) {
      const m = Ls();
      m - this.lastGlFlushTime > g && (this.gpgpu.gl.flush(), this.lastGlFlushTime = m);
    }
    if (!ie().getBool("WEBGL_LAZILY_UNPACK") && c.isPacked && r === !1) {
      const m = this.unpackTensor(a);
      return this.disposeIntermediateTensorInfo(a), m;
    }
    return a;
  }
  compileAndRun(e, n, s, i, r = !1) {
    return s = s || n[0].dtype, this.runWebGLProgram(e, n, s, i, r);
  }
  getAndSaveBinary(e, n) {
    return e in this.binaryCache || (this.binaryCache[e] = n()), this.binaryCache[e];
  }
  getTextureManager() {
    return this.textureManager;
  }
  dispose() {
    this.disposed || (ie().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach((n) => {
      this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram), delete this.binaryCache[n];
    }), this.textureManager.dispose(), this.canvas != null && typeof HTMLCanvasElement < "u" && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0);
  }
  floatPrecision() {
    return this.floatPrecisionValue == null && (this.floatPrecisionValue = Q(() => {
      if (!ie().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
        const e = ie().getBool("DEBUG");
        ie().set("DEBUG", !1);
        const n = this.abs(ot(1e-8)).dataSync()[0];
        if (ie().set("DEBUG", e), n > 0)
          return 32;
      }
      return 16;
    })), this.floatPrecisionValue;
  }
  /** Returns the smallest representable number.  */
  epsilon() {
    return this.floatPrecision() === 32 ? fre : pre;
  }
  uploadToGPU(e) {
    const n = this.texData.get(e), { shape: s, dtype: i, values: r, texture: o, usage: a, isPacked: c } = n;
    if (o != null)
      return;
    const l = this.activeTimers != null;
    let u;
    l && (u = Ls());
    let h = n.texShape;
    if (h == null && (h = Bne(s, c), n.texShape = h), r != null) {
      const d = Cg(s);
      let f, p = h[1], y = h[0];
      const g = r instanceof Uint8Array || r instanceof Uint8ClampedArray;
      (c || !g) && ([p, y] = Bh(h[0], h[1])), c ? f = new Bse(d, g) : f = new PI(d, g);
      const m = g ? [y, p] : h, x = this.makeTensorInfo(m, i), v = this.texData.get(x.dataId);
      g ? v.usage = ki.PIXELS : v.usage = ki.UPLOAD, v.texShape = m, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId), p, y, r);
      const b = [[y, p]], w = !0, S = this.runWebGLProgram(f, [x], i, b, w), _ = this.texData.get(S.dataId);
      n.texShape = _.texShape, n.isPacked = _.isPacked, n.usage = _.usage, ie().get("ENGINE_COMPILE_ONLY") ? this.disposeData(S.dataId) : (n.texture = _.texture, n.values = null, this.texData.delete(S.dataId)), this.disposeIntermediateTensorInfo(x), l && (this.uploadWaitMs += Ls() - u);
    } else {
      const d = this.acquireTexture(h, a, i, c);
      n.texture = d;
    }
  }
  convertAndCacheOnCPU(e, n) {
    const s = this.texData.get(e), { dtype: i } = s;
    return n != null && (s.values = bre(n, i)), s.values;
  }
  acquireTexture(e, n, s, i) {
    if (this.numBytesInGPU += this.computeBytes(e, s), !this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
      const r = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
      this.warnedAboutMemory = !0, console.warn(`High memory usage in GPU: ${r} MB, most likely due to a memory leak`);
    }
    return this.textureManager.acquireTexture(e, n, i);
  }
  computeBytes(e, n) {
    return e[0] * e[1] * uf(n);
  }
  checkCompileCompletion() {
    for (const [, e] of Object.entries(this.binaryCache))
      this.checkCompletion_(e);
  }
  async checkCompileCompletionAsync() {
    const e = [];
    if (this.gpgpu.parallelCompilationExtension) {
      for (const [, n] of Object.entries(this.binaryCache))
        e.push(this.checkCompletionAsync_(n));
      return Promise.all(e);
    } else {
      for (const [, n] of Object.entries(this.binaryCache)) {
        const s = new Promise((i) => {
          try {
            this.checkCompletion_(n), i(!0);
          } catch (r) {
            throw r;
          }
        });
        e.push(s);
      }
      return Promise.all(e);
    }
  }
  async checkCompletionAsync_(e) {
    return this.gpgpu.gl.getProgramParameter(e.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR) ? this.checkCompletion_(e) : (await M_(), this.checkCompletionAsync_(e));
  }
  checkCompletion_(e) {
    if (this.gpgpu.gl.getProgramParameter(e.webGLProgram, this.gpgpu.gl.LINK_STATUS) === !1)
      throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)), this.gpgpu.gl.getShaderParameter(e.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === !1 ? (L$(e.source, this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)), new Error("Failed to compile fragment shader.")) : new Error("Failed to link vertex and fragment shaders.");
    return !0;
  }
  getUniformLocations() {
    for (const e of Object.values(this.binaryCache)) {
      this.gpgpu.buildVao(e.webGLProgram);
      const { variablesLocations: n, customUniformLocations: s, infLoc: i, nanLoc: r, outShapeLocation: o, outShapeStridesLocation: a, outTexShapeLocation: c } = V$(this.gpgpu, e.program, e.webGLProgram);
      e.variablesLocations = n, e.customUniformLocations = s, e.infLoc = i, e.nanLoc = r, e.outShapeLocation = o, e.outShapeStridesLocation = a, e.outTexShapeLocation = c;
    }
  }
  /**
   * Create a TF.js tensor out of an existing WebGL texture. A new texture will
   * be created.
   */
  createTensorFromGPUData(e, n, s) {
    e.channels = e.channels || "RGBA";
    const { texture: i, height: r, width: o, channels: a } = e, c = ui().backend;
    if (!c.gpgpu.gl.isTexture(i))
      throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");
    const l = c.writeTexture(i, n, s, r, o, a);
    return ui().makeTensorFromDataId(l, n, s, c);
  }
}
Nb.nextDataId = 0;
function bre(t, e) {
  if (e === "float32" || e === "complex64")
    return t;
  if (e === "int32" || e === "bool") {
    const n = e === "int32" ? new Int32Array(t.length) : new Uint8Array(t.length);
    for (let s = 0; s < n.length; ++s)
      n[s] = Math.round(t[s]);
    return n;
  } else
    throw new Error(`Unknown dtype ${e}`);
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
tS() && sS(
  "webgl",
  () => new Nb(),
  2
  /* priority */
);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $T = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
class Kc {
  constructor(e, n, s) {
    this.variableNames = ["A", "B"], this.outputShape = bt(n, s), this.enableShapeUniforms = As(this.outputShape.length), this.userCode = `
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const hl = `
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;
class Wh {
  constructor(e, n, s, i = !1) {
    this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = bt(n, s);
    const r = this.outputShape.length;
    this.enableShapeUniforms = As(r);
    let o = "";
    if (i)
      if (r === 0 || ue(this.outputShape) === 1)
        o = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
      else if (o = `
          ${rn(r)} coords = getOutputCoords();
        `, r === 1)
        this.enableShapeUniforms ? o += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          ` : o += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
      else {
        const c = zs("coords", r);
        this.enableShapeUniforms ? o += `
            bool nextRowOutOfBounds =
              (${c[r - 2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${c[r - 1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          ` : o += `
            bool nextRowOutOfBounds =
              (${c[r - 2]} + 1) >= ${this.outputShape[r - 2]};
            bool nextColOutOfBounds =
              (${c[r - 1]} + 1) >= ${this.outputShape[r - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
      }
    this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Si(t) {
  const { inputs: e, backend: n } = t, { x: s } = e;
  return n.incRef(s.dataId), { dataId: s.dataId, shape: s.shape, dtype: s.dtype };
}
const vre = {
  kernelName: nh,
  backendName: "webgl",
  kernelFunc: Si
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ha(t) {
  const { inputs: e, backend: n } = t, { real: s, imag: i } = e, r = n.makeTensorInfo(s.shape, "complex64"), o = n.texData.get(r.dataId), a = Si({ inputs: { x: s }, backend: n }), c = Si({ inputs: { x: i }, backend: n });
  return o.complexTensorInfos = { real: a, imag: c }, r;
}
const wre = {
  kernelName: Tx,
  backendName: "webgl",
  kernelFunc: Ha
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const J$ = "return (a < 0.) ? b * a : a;", Q$ = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
function Sre(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { alpha: r } = s, o = n.makeTensorInfo([], "float32", Vo(r, "float32")), a = ie().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Wh(Q$, i.shape, o.shape) : new Kc(J$, i.shape, o.shape), c = n.runWebGLProgram(a, [i, o], "float32");
  return n.disposeIntermediateTensorInfo(o), c;
}
const _re = {
  kernelName: rp,
  backendName: "webgl",
  kernelFunc: Sre
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const eO = "return (a < 0.) ? b * a : a;", tO = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
function Tre(t) {
  const { inputs: e, backend: n } = t, { x: s, alpha: i } = e, r = ie().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Wh(tO, s.shape, i.shape) : new Kc(eO, s.shape, i.shape);
  return n.runWebGLProgram(r, [s, i], "float32");
}
const Cre = {
  kernelName: Tp,
  backendName: "webgl",
  kernelFunc: Tre
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Hh = "if (isnan(x)) return x;";
function Wt({ opSnippet: t, packedOpSnippet: e, cpuKernelImpl: n, dtype: s }) {
  return ({ inputs: i, backend: r }) => {
    const { x: o } = i, a = r, c = s || o.dtype;
    if (a.shouldExecuteOnCPU([o]) && n != null) {
      const h = a.texData.get(o.dataId), d = n(h.values, c);
      return a.makeTensorInfo(o.shape, c, d);
    }
    const l = ie().getBool("WEBGL_PACK_UNARY_OPERATIONS") && e != null;
    let u;
    return l ? u = new ua(o.shape, e) : u = new Hr(o.shape, t), a.runWebGLProgram(u, [o], c);
  };
}
function Cs({ opSnippet: t, packedOpSnippet: e, checkOutOfBounds: n = !1, supportsComplex: s = !1, cpuKernelImpl: i, dtype: r }) {
  return ({ inputs: o, backend: a }) => {
    const { a: c, b: l } = o, u = a;
    if (s && c.dtype === "complex64") {
      const p = u.texData.get(c.dataId), y = u.texData.get(l.dataId), [g, m] = [
        [p.complexTensorInfos.real, y.complexTensorInfos.real],
        [p.complexTensorInfos.imag, y.complexTensorInfos.imag]
      ].map((v) => {
        const [b, w] = v, S = {
          dataId: b.dataId,
          dtype: b.dtype,
          shape: c.shape
        }, _ = {
          dataId: w.dataId,
          dtype: w.dtype,
          shape: l.shape
        }, E = new Kc(t, c.shape, l.shape);
        return u.runWebGLProgram(E, [S, _], ni(b.dtype, w.dtype));
      }), x = Ha({ inputs: { real: g, imag: m }, backend: u });
      return u.disposeIntermediateTensorInfo(g), u.disposeIntermediateTensorInfo(m), x;
    }
    const h = r || ni(c.dtype, l.dtype);
    if ((c.dtype === "string" || l.dtype === "string" || u.shouldExecuteOnCPU([c, l])) && i != null) {
      const p = u.texData.get(c.dataId).values, y = u.texData.get(l.dataId).values, g = c.dtype === "string" ? (
        // tslint:disable-next-line: no-any
        Fo(p)
      ) : p, m = c.dtype === "string" ? (
        // tslint:disable-next-line: no-any
        Fo(y)
      ) : y, [x, v] = i(c.shape, l.shape, g, m, h), b = u.makeTensorInfo(v, h), w = u.texData.get(b.dataId);
      return w.values = x, b;
    }
    const d = ie().getBool("WEBGL_PACK_BINARY_OPERATIONS") && e != null;
    let f;
    return d ? f = new Wh(e, c.shape, l.shape, n) : f = new Kc(t, c.shape, l.shape), u.runWebGLProgram(f, [c, l], h);
  };
}
function Ef(t, e = !1) {
  if (t === "linear")
    return e ? ore : tre;
  if (t === "relu")
    return e ? cre : sre;
  if (t === "elu")
    return e ? are : nre;
  if (t === "relu6")
    return e ? lre : ire;
  if (t === "prelu")
    return e ? tO : eO;
  if (t === "leakyrelu")
    return e ? Q$ : J$;
  if (t === "sigmoid")
    return e ? ure : rre;
  throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class nO {
  constructor(e, n, s, i = !1, r = !1, o = !1, a = null, c = !1, l = !1) {
    this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = s, this.enableShapeUniforms = As(this.outputShape.length);
    const u = i ? e[1] : e[2], h = Math.ceil(u / 2), d = i ? "i * 2, rc.y" : "rc.y, i * 2", f = r ? "rc.z, i * 2" : "i * 2, rc.z", p = i ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], y = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
    let g = "", m = "";
    a && (c ? g = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }` : l ? g = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }` : g = `vec4 activation(vec4 x) {
          ${a}
        }`, m = "result = activation(result);");
    const x = o ? "result += getBiasAtOutCoords();" : "";
    o && this.variableNames.push("bias"), c && this.variableNames.push("preluActivationWeights"), l && this.variableNames.push("leakyreluAlpha");
    let v = "rc.x", b = "rc.x";
    e[0] < n[0] ? v = `imod(rc.x, ${e[0]})` : n[0] < e[0] && (b = `imod(rc.x, ${n[0]})`), this.userCode = `
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${v};
        int batchB = ${b};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${y[0]});
          result += (${p[1]} * ${y[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${m}

        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const GI = {
  REAL: "return areal * breal - aimag * bimag;",
  IMAG: "return areal * bimag + aimag * breal;"
};
class WI {
  constructor(e, n, s) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = bt(n, s), this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const HI = "return a * b;";
function OT(t) {
  const { inputs: e, backend: n } = t, { a: s, b: i } = e, r = ni(s.dtype, i.dtype);
  if (s.dtype === "complex64") {
    const a = n.texData.get(s.dataId), c = n.texData.get(i.dataId), l = new WI(GI.REAL, s.shape, i.shape), u = new WI(GI.IMAG, s.shape, i.shape), h = [
      {
        dataId: a.complexTensorInfos.real.dataId,
        dtype: a.complexTensorInfos.real.dtype,
        shape: s.shape
      },
      {
        dataId: a.complexTensorInfos.imag.dataId,
        dtype: a.complexTensorInfos.imag.dtype,
        shape: s.shape
      },
      {
        dataId: c.complexTensorInfos.real.dataId,
        dtype: c.complexTensorInfos.real.dtype,
        shape: i.shape
      },
      {
        dataId: c.complexTensorInfos.imag.dataId,
        dtype: c.complexTensorInfos.imag.dtype,
        shape: i.shape
      }
    ], d = n.runWebGLProgram(l, h, "float32"), f = n.runWebGLProgram(u, h, "float32"), p = Ha({ inputs: { real: d, imag: f }, backend: n });
    return n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(f), p;
  }
  if (n.shouldExecuteOnCPU([s, i])) {
    const a = n.texData.get(s.dataId), c = n.texData.get(i.dataId), [l, u] = Tie(s.shape, i.shape, a.values, c.values, r), h = n.makeTensorInfo(u, r), d = n.texData.get(h.dataId);
    return d.values = l, h;
  }
  let o;
  return ie().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? o = new Wh(HI, s.shape, i.shape) : o = new Kc(HI, s.shape, i.shape), n.runWebGLProgram(o, [s, i], r);
}
const Ire = {
  kernelName: hh,
  backendName: "webgl",
  kernelFunc: OT
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ere(t, e, n) {
  const s = [
    Au(t.shape),
    ...Mu(t.shape)
  ], i = {
    dtype: t.dtype,
    shape: s,
    dataId: t.dataId
  }, r = [
    Au(e),
    ...Mu(e)
  ], o = new Z$(r, s), a = !0, c = [s], l = n.runWebGLProgram(o, [i], t.dtype, c, a);
  return { dataId: l.dataId, shape: e, dtype: l.dtype };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ze(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { shape: r } = s, o = n, a = ue(i.shape), c = j1(r, a), l = ue(c);
  A(a === l, () => `The new shape (${c}) has ${l} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);
  const u = o.texData.get(i.dataId);
  return u.isPacked && !ex(i.shape, c) && !(u.texture !== null && ex(u.shape, c)) ? Ere(i, c, o) : (o.incRef(i.dataId), { dataId: i.dataId, shape: c, dtype: i.dtype });
}
const Nre = {
  kernelName: Ip,
  backendName: "webgl",
  kernelFunc: ze
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class jI {
  constructor(e, n) {
    this.variableNames = ["x"];
    const { windowSize: s, batchSize: i, inSize: r, outSize: o } = e;
    this.outputShape = [i, o];
    const a = Math.floor(s / 4) * 4, c = s % 4;
    let l = "sumValue += dot(values, ones);";
    if (n != null) {
      const h = 1 / n;
      l = `sumValue += dot(values * ${Lc(h) ? h.toPrecision(2) : h}, ones);`;
    }
    let u = "";
    r % s > 0 && (u = `
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `), this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${c === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${c === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${c === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class kre {
  constructor(e, n) {
    this.variableNames = ["x"];
    const { windowSize: s, batchSize: i, inSize: r, outSize: o } = e;
    this.outputShape = [i, o];
    let a = "0.0", c = "";
    n === "prod" ? a = "1.0" : n === "min" ? (a = "1.0 / 1e-20", c = "min") : n === "max" && (a = "-1.0 / 1e-20", c = "max");
    let l = `${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    n === "sum" ? l = "sumValue" : n === "prod" ? l = "prodValue" : n === "all" ? l = "allValue" : n === "any" && (l = "anyValue");
    const u = Math.floor(s / 4) * 4, h = s % 4;
    let d = `
      if (${n === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${n === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${c}(values, minMaxValue);
        if (${n === "min"} || ${n === "max"}) {
          minMaxValue = ${c}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `, f = "vec4";
    n === "all" ? (a = "1.0", d = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `, f = "bvec4") : n === "any" && (a = "0.0", d = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `, f = "bvec4");
    let p = "";
    r % s > 0 && (p = `
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `), this.userCode = `
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h === 1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h === 2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h === 3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Are(t) {
  const e = [];
  for (; e.length === 0 || e[e.length - 1].outSize !== 1; ) {
    const n = e.length ? e[e.length - 1].outSize : t[1], s = hb(n);
    e.push({
      inSize: n,
      windowSize: s,
      outSize: Math.ceil(n / s)
    });
  }
  return e;
}
function dl(t, e, n, s) {
  const i = Are(t.shape);
  let r = t;
  for (let o = 0; o < i.length; o++) {
    const { inSize: a, windowSize: c, outSize: l } = i[o];
    let u, h;
    n === "mean" ? u = o === 0 ? new jI({ windowSize: c, inSize: a, batchSize: t.shape[0], outSize: l }, a) : new jI({ windowSize: c, inSize: a, batchSize: t.shape[0], outSize: l }) : u = new kre({ windowSize: c, inSize: a, batchSize: t.shape[0], outSize: l }, n), h = r, r = s.runWebGLProgram(u, [r], e), h.dataId !== t.dataId && s.disposeIntermediateTensorInfo(h);
  }
  return r;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Mre {
  constructor(e, n) {
    this.variableNames = ["A"];
    const s = new Array(e.length);
    for (let o = 0; o < s.length; o++)
      s[o] = e[n[o]];
    this.outputShape = s, this.rank = s.length;
    const i = rn(this.rank), r = Rre(n);
    this.userCode = `
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `;
  }
}
function Rre(t) {
  const e = t.length;
  if (e > 6)
    throw Error(`Transpose for rank ${e} is not yet supported`);
  const n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], s = new Array(e);
  for (let i = 0; i < t.length; i++)
    s[t[i]] = n[i];
  return s.join();
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Dre {
  constructor(e, n) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;
    const s = new Array(e.length);
    for (let u = 0; u < s.length; u++)
      s[u] = e[n[u]];
    if (this.outputShape = s, this.rank = s.length, this.rank > 6)
      throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
    const i = rn(this.rank), r = Y$("rc", this.rank), o = new Array(this.rank);
    for (let u = 0; u < n.length; u++)
      o[n[u]] = r[u];
    const a = `vec2(${o.slice(-2).join()})`, c = `++${r[this.rank - 1]} < ${s[this.rank - 1]}`, l = `getChannel(getA(${o.join()}), ${a})`;
    this.userCode = `
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${c}) {
        result[1] = ${l};
      }
      --${r[this.rank - 1]};
      if(++${r[this.rank - 2]} < ${s[this.rank - 2]}) {
        result[2] = ${l};
        if(${c}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kb(t, e, n) {
  const s = ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Dre(t.shape, e) : new Mre(t.shape, e);
  return n.runWebGLProgram(s, [t], t.dtype);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $re(t, e, n, s) {
  const i = e, r = t.shape.length, o = Rt(i, t.shape);
  let a = o;
  const c = An(a, r), l = c != null;
  let u = t;
  l && (u = kb(t, c, s), a = Vn(a.length, r)), _s("sum", a, r);
  const [h, d] = ds(u.shape, a);
  let f = h;
  n && (f = zn(h, o));
  const p = ue(d), g = ue(t.shape) / p, m = ze({ inputs: { x: u }, attrs: { shape: [g, p] }, backend: s }), x = T0(t.dtype), v = dl(m, x, "sum", s), b = ze({ inputs: { x: v }, attrs: { shape: f }, backend: s });
  return s.disposeIntermediateTensorInfo(m), s.disposeIntermediateTensorInfo(v), l && s.disposeIntermediateTensorInfo(u), b;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ab(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, keepDims: o } = s;
  return $re(i, r, o, n);
}
const Ore = {
  kernelName: Rp,
  backendName: "webgl",
  kernelFunc: Ab
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ws(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { perm: r } = s, o = n, a = i.shape.length, c = new Array(a);
  for (let u = 0; u < c.length; u++)
    c[u] = i.shape[r[u]];
  let l;
  if (o.shouldExecuteOnCPU([i])) {
    const h = o.texData.get(i.dataId).values, d = DT(h, i.shape, i.dtype, r, c);
    l = o.makeTensorInfo(c, i.dtype);
    const f = o.texData.get(l.dataId);
    f.values = d;
  } else
    l = kb(i, r, o);
  return l;
}
const Lre = {
  kernelName: wc,
  backendName: "webgl",
  kernelFunc: Ws
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sO = 1e3;
function tx({ a: t, b: e, transposeA: n, transposeB: s, backend: i, bias: r = null, preluActivationWeights: o = null, leakyreluAlpha: a = 0, activation: c = null }) {
  const l = t.shape.length, u = e.shape.length, h = n ? t.shape[l - 2] : t.shape[l - 1], d = s ? e.shape[u - 1] : e.shape[u - 2], f = n ? t.shape[l - 1] : t.shape[l - 2], p = s ? e.shape[u - 2] : e.shape[u - 1], y = t.shape.slice(0, -2), g = e.shape.slice(0, -2), m = ue(y), x = ue(g), b = bt(t.shape.slice(0, -2), e.shape.slice(0, -2)).concat([f, p]);
  A(h === d, () => `Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${s} must match.`);
  const w = n ? [m, h, f] : [m, f, h], S = s ? [x, p, d] : [x, d, p], _ = ze({ inputs: { x: t }, backend: i, attrs: { shape: w } }), E = ze({ inputs: { x: e }, backend: i, attrs: { shape: S } }), I = [_, E], k = Math.max(m, x), M = n ? _.shape[1] : _.shape[2], L = r != null, O = o != null, $ = c === "leakyrelu", D = c != null ? Ef(c, !0) : null, z = L || O || $ || D != null;
  let W;
  if ((f === 1 || p === 1) && M > sO && z === !1) {
    let J = _, ne = E;
    n && (J = Ws({ inputs: { x: _ }, backend: i, attrs: { perm: [0, 2, 1] } }), I.push(J)), s && (ne = Ws({ inputs: { x: E }, backend: i, attrs: { perm: [0, 2, 1] } }), I.push(ne));
    const re = p !== 1, fe = p === 1;
    let ae = J;
    re && (ae = ze({
      inputs: { x: J },
      backend: i,
      attrs: { shape: [k, M, 1] }
    }), I.push(ae));
    const ve = p === 1 ? 2 : 1;
    let me = ne;
    fe && (me = ze({
      inputs: { x: ne },
      backend: i,
      attrs: { shape: [k, 1, M] }
    }), I.push(me));
    const te = OT({ inputs: { a: ae, b: me }, backend: i });
    W = Ab({ inputs: { x: te }, backend: i, attrs: { axis: ve, keepDims: !0 } }), I.push(te);
  } else {
    const J = ni(t.dtype, e.dtype), ne = new nO(w, S, [k, f, p], n, s, L, D, O, $), re = [_, E];
    if (r != null && re.push(r), O && re.push(o), $) {
      const fe = i.makeTensorInfo([], "float32", Vo(a, "float32"));
      re.push(fe), I.push(fe);
    }
    W = i.runWebGLProgram(ne, re, J);
  }
  const j = ze({ inputs: { x: W }, backend: i, attrs: { shape: b } });
  I.push(W);
  for (const J of I)
    i.disposeIntermediateTensorInfo(J);
  return j;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fre(t) {
  const { inputs: e, backend: n, attrs: s } = t, { a: i, b: r, bias: o, preluActivationWeights: a } = e, { transposeA: c, transposeB: l, activation: u, leakyreluAlpha: h } = s;
  return tx({
    a: i,
    b: r,
    transposeA: c,
    transposeB: l,
    backend: n,
    bias: o,
    preluActivationWeights: a,
    leakyreluAlpha: h,
    activation: u
  });
}
const Pre = {
  kernelName: hf,
  backendName: "webgl",
  kernelFunc: Fre
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qI = "return abs(x);";
function Bre(t) {
  const { inputs: e, backend: n } = t, { x: s } = e;
  if (n.shouldExecuteOnCPU([s]) && s.dtype !== "complex64") {
    const r = n.texData.get(s.dataId), o = X$(r.values);
    return n.makeTensorInfo(s.shape, s.dtype, o);
  }
  let i;
  return ie().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? i = new ua(s.shape, qI) : i = new Hr(s.shape, qI), n.runWebGLProgram(i, [s], s.dtype);
}
const zre = {
  kernelName: Ff,
  backendName: "webgl",
  kernelFunc: Bre
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Vre = or + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`, Ure = Wt({ opSnippet: Vre }), Gre = {
  kernelName: Lu,
  backendName: "webgl",
  kernelFunc: Ure
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Wre = or + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`, Hre = Wt({ opSnippet: Wre }), jre = {
  kernelName: Fu,
  backendName: "webgl",
  kernelFunc: Hre
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const XI = "return a + b;", qre = Cs({
  opSnippet: XI,
  packedOpSnippet: XI,
  supportsComplex: !0,
  cpuKernelImpl: sie
}), Xre = {
  kernelName: Qc,
  backendName: "webgl",
  kernelFunc: qre
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Kre {
  constructor(e, n) {
    this.outputShape = [], this.outputShape = e, this.variableNames = n.map((r, o) => `T${o}`);
    const s = [];
    this.variableNames.forEach((r) => {
      s.push(`float v${r} = get${r}AtOutCoords();`);
    });
    const i = this.variableNames.map((r) => `v${r}`).join(" + ");
    this.userCode = `
      void main() {
        ${s.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Yre {
  constructor(e, n) {
    this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.variableNames = n.map((r, o) => `T${o}`);
    const s = [];
    this.variableNames.forEach((r) => {
      s.push(`vec4 v${r} = get${r}AtOutCoords();`);
    });
    const i = this.variableNames.map((r) => `v${r}`).join(" + ");
    this.userCode = `
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ug(t) {
  const { inputs: e, backend: n } = t, s = e;
  if (s.length === 1)
    return Si({ inputs: { x: s[0] }, backend: n });
  if (s.length > ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
    const c = Math.floor(s.length / 2), l = Ug({ inputs: s.slice(0, c), backend: n }), u = Ug({ inputs: s.slice(c), backend: n });
    return Ug({ inputs: [l, u], backend: n });
  }
  const i = s.map((c) => c.dtype).reduce((c, l) => ni(c, l)), r = s.map((c) => c.shape), a = ie().getBool("WEBGL_PACK") ? new Yre(s[0].shape, r) : new Kre(s[0].shape, r);
  return n.runWebGLProgram(a, s, i);
}
const Zre = {
  kernelName: Pf,
  backendName: "webgl",
  kernelFunc: Ug
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jre(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, keepDims: o } = s, a = i.shape.length, c = Rt(r, i.shape);
  let l = c;
  const u = An(l, a);
  let h = i;
  u != null && (h = Ws({ inputs: { x: i }, backend: n, attrs: { perm: u } }), l = Vn(l.length, a)), _s("all", l, a);
  const [d, f] = ds(h.shape, l), p = ue(f), y = ze({ inputs: { x: h }, backend: n, attrs: { shape: [-1, p] } }), g = dl(y, y.dtype, "all", n);
  let m;
  if (o) {
    const x = zn(d, c);
    m = ze({ inputs: { x: g }, backend: n, attrs: { shape: x } });
  } else
    m = ze({ inputs: { x: g }, backend: n, attrs: { shape: d } });
  return n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(g), u != null && n.disposeIntermediateTensorInfo(h), m;
}
const Qre = {
  kernelName: xx,
  backendName: "webgl",
  kernelFunc: Jre
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eoe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, keepDims: o } = s, a = i.shape.length, c = Rt(r, i.shape);
  let l = c;
  const u = An(l, a);
  let h = i;
  u != null && (h = Ws({ inputs: { x: i }, backend: n, attrs: { perm: u } }), l = Vn(l.length, a)), _s("any", l, a);
  const [d, f] = ds(h.shape, l), p = ue(f), y = ze({ inputs: { x: h }, backend: n, attrs: { shape: [-1, p] } }), g = dl(y, y.dtype, "any", n);
  let m;
  if (o) {
    const x = zn(d, c);
    m = ze({ inputs: { x: g }, backend: n, attrs: { shape: x } });
  } else
    m = ze({ inputs: { x: g }, backend: n, attrs: { shape: d } });
  return n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(g), u != null && n.disposeIntermediateTensorInfo(h), m;
}
const toe = {
  kernelName: bx,
  backendName: "webgl",
  kernelFunc: eoe
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class noe {
  constructor(e, n, s) {
    this.variableNames = ["A"];
    const { windowSize: i, batchSize: r, outSize: o } = e;
    s || this.variableNames.push("bestIndicesA"), this.outputShape = [r, o];
    const a = n === "max" ? ">" : "<", c = s ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${c};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class soe {
  constructor(e, n, s, i) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, A(e.length > 2, () => `Packed arg${s.charAt(0).toUpperCase() + s.slice(1)} supports only inputs with rank above 2.`);
    const r = e[e.length - 1], o = Math.ceil(r / n);
    this.outputShape = e.slice(0, -1), o > 1 && this.outputShape.push(o), i || this.variableNames.push("bestIndicesA");
    const a = this.outputShape, c = a.length, l = rn(c), u = zs("coords", c);
    let h, d;
    if (o === 1) {
      d = c + 1;
      const E = rn(d);
      h = `
        ${E} sourceLocR = ${E}(${u.join()}, 0);
        ++${u[c - 1]};
        ${E} sourceLocG = ${E}(${u.join()}, 0);
        ++${u[c - 2]};
        ${E} sourceLocA = ${E}(${u.join()}, 0);
        --${u[c - 1]};
        ${E} sourceLocB = ${E}(${u.join()}, 0);
        --${u[c - 2]};`;
    } else
      d = c, h = `
        ${l} sourceLocR = coords;
        ++${u[c - 1]};
        ${l} sourceLocG = coords;
        ++${u[c - 2]};
        ${l} sourceLocA = coords;
        --${u[c - 1]};
        ${l} sourceLocB = coords;
        --${u[c - 2]};`;
    const f = ["x", "y", "z", "w", "u", "v"].slice(0, d), p = "." + f[d - 1], y = f.map((E) => "int " + E), g = zs("sourceLocR", d - 1).concat("inIdx.r"), m = zs("sourceLocG", d - 1).concat("inIdx.g"), x = zs("sourceLocB", d - 1).concat("inIdx.b"), v = zs("sourceLocA", d - 1).concat("inIdx.a"), b = s === "max" ? "greaterThan" : "lessThan", w = i ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${v.join()})));`, S = `vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${m.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`, _ = i ? "" : `
      float getBestIndicesAChannel(${y.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;
    this.userCode = `
      float getAChannel(${y.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${_}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${u[c - 1]} < ${a[c - 1] - 1};
        bool hasNextRow = ${u[c - 2]} < ${a[c - 2] - 1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${S};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${w}
          vec4 candidate = ${S};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iO(t, e, n, s = null) {
  let i = e.shape[0], r = e.shape[1];
  s != null && (i = s.shape[0], r = s.shape[1]);
  const o = hb(r), a = { windowSize: o, inSize: r, batchSize: i, outSize: Math.ceil(r / o) }, c = new noe(a, n, s == null), l = [e];
  s != null && l.push(s);
  const u = t.runWebGLProgram(c, l, "int32");
  if (u.shape[1] === 1)
    return u;
  const h = iO(t, e, n, u);
  return t.disposeIntermediateTensorInfo(u), h;
}
function rO(t, e, n, s = null) {
  const i = s != null ? s.shape : e.shape, r = i[i.length - 1], o = hb(r), a = new soe(i, o, n, s == null), c = s == null ? [e] : [e, s], l = t.runWebGLProgram(a, c, "int32");
  if (l.shape.length === e.shape.length) {
    const u = rO(t, e, n, l);
    return t.disposeIntermediateTensorInfo(l), u;
  }
  return l;
}
function oO(t, e, n, s) {
  const i = [n];
  if (_s("arg" + s.charAt(0).toUpperCase() + s.slice(1), i, e.shape.length), !ie().getBool("WEBGL_PACK_REDUCE") || e.shape.length <= 2) {
    const r = [], o = t.texData.get(e.dataId), a = o !== null && o.isPacked;
    let c = e;
    a && (c = t.unpackTensor(e), r.push(c));
    const [l, u] = ds(c.shape, i), h = ue(u), d = ze({ inputs: { x: c }, backend: t, attrs: { shape: [-1, h] } });
    r.push(d);
    const f = iO(t, d, s);
    r.push(f);
    const p = ze({ inputs: { x: f }, backend: t, attrs: { shape: l } });
    return r.forEach((y) => t.disposeIntermediateTensorInfo(y)), p;
  }
  return rO(t, e, s);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ioe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r } = s;
  let o = Rt(r, i.shape);
  const a = An(o, i.shape.length);
  let c = i;
  const l = [];
  a != null && (c = Ws({ inputs: { x: i }, backend: n, attrs: { perm: a } }), l.push(c), o = Vn(o.length, c.shape.length)), _s("argMax", [o[0]], c.shape.length);
  const u = oO(n, c, o[0], "max");
  return l.forEach((h) => n.disposeIntermediateTensorInfo(h)), u;
}
const roe = {
  kernelName: Bf,
  backendName: "webgl",
  kernelFunc: ioe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ooe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r } = s;
  let o = Rt(r, i.shape);
  const a = An(o, i.shape.length);
  let c = i;
  const l = [];
  a != null && (c = Ws({ inputs: { x: i }, backend: n, attrs: { perm: a } }), l.push(c), o = Vn(o.length, c.shape.length)), _s("argMin", [o[0]], c.shape.length);
  const u = oO(n, c, o[0], "min");
  return l.forEach((h) => n.disposeIntermediateTensorInfo(h)), u;
}
const aoe = {
  kernelName: zf,
  backendName: "webgl",
  kernelFunc: ooe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const coe = or + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`, loe = Wt({ opSnippet: coe }), uoe = {
  kernelName: Pu,
  backendName: "webgl",
  kernelFunc: loe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const hoe = or + "return log(x + sqrt(x * x + 1.0));", doe = Wt({ opSnippet: hoe }), foe = {
  kernelName: Bu,
  backendName: "webgl",
  kernelFunc: doe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const poe = or + `
  return atan(x);
`, moe = Wt({ opSnippet: poe }), goe = {
  kernelName: zu,
  backendName: "webgl",
  kernelFunc: moe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const yoe = $T + `
  return atan(a, b);
`, xoe = `
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + hl + `
  return result;
`, boe = Cs({ opSnippet: yoe, packedOpSnippet: xoe }), voe = {
  kernelName: Uu,
  backendName: "webgl",
  kernelFunc: boe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const woe = or + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`, Soe = Wt({ opSnippet: woe }), _oe = {
  kernelName: Vu,
  backendName: "webgl",
  kernelFunc: Soe
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Nf {
  constructor(e, n, s, i = !1, r = !1) {
    if (this.variableNames = ["x"], n === "avg" && s)
      throw new Error("Cannot compute positions for average pool.");
    const o = e.filterWidth, a = e.strideHeight, c = e.strideWidth, l = e.dilationHeight, u = e.dilationWidth, h = e.effectiveFilterHeight, d = e.effectiveFilterWidth, f = e.padInfo.top, p = e.padInfo.left;
    this.outputShape = e.outShape;
    const y = n === "avg", g = `((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`, m = `(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;
    let x = "0.0";
    if (y || (x = "-1.0 / 1e-20"), s) {
      const E = ">=";
      this.userCode = `
        const ivec2 strides = ivec2(${a}, ${c});
        const ivec2 pads = ivec2(${f}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${E} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i ? r ? g : m : `wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
      return;
    }
    const v = "max";
    let b = `${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    n === "avg" && (b = "avgValue / max(count, 1.0)");
    const w = Math.floor(o / 4) * 4, S = o % 4, _ = `
      if (${y}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec2 strides = ivec2(${a}, ${c});
      const ivec2 pads = ivec2(${f}, ${p});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${w}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${_}
          }

          int xC = xCCorner + ${w};
          if (${S === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${S === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${S === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${_}
          }
        }
        setOutput(${b});
      }
    `;
  }
}
class LT {
  constructor(e, n, s, i = !1, r = !1) {
    if (this.variableNames = ["x"], n === "avg" && s)
      throw new Error("Cannot compute positions for average pool.");
    const o = e.filterWidth, a = e.strideDepth, c = e.strideHeight, l = e.strideWidth, u = e.dilationDepth, h = e.dilationHeight, d = e.dilationWidth, f = e.effectiveFilterDepth, p = e.effectiveFilterHeight, y = e.effectiveFilterWidth, g = e.padInfo.front, m = e.padInfo.top, x = e.padInfo.left;
    this.outputShape = e.outShape;
    const v = n === "avg";
    let b = "0.0";
    if (v || (b = "-1.0 / 1e-20"), s) {
      const k = ">=";
      this.userCode = `
        const ivec3 strides =
            ivec3(${a}, ${c}, ${l});
        const ivec3 pads = ivec3(${g}, ${m}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${y};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${k} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i ? r ? `(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch` : `((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch` : `wD * ${p} * ${y} +
                      wR * ${y} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
      return;
    }
    const w = "max";
    let S = `${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    n === "avg" && (S = "avgValue / max(count, 1.0)");
    const _ = Math.floor(o / 4) * 4, E = o % 4, I = `
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec3 strides =
        ivec3(${a}, ${c}, ${l});
      const ivec3 pads = ivec3(${g}, ${m}, ${x});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${_}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${I}
            }

            int xC = xCCorner + ${_};
            if (${E === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${I}
            } else if (${E === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${I}
            } else if (${E === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${I}
            }
          }
        }
        setOutput(${S});
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Toe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e;
  _m(i, "avgPool");
  const { filterSize: r, strides: o, pad: a, dimRoundingMode: c } = s, l = 1;
  A(Ss(o, l), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);
  const u = ir(i.shape, r, o, l, a, c);
  if (u.filterWidth === 1 && u.filterHeight === 1 && Bt(u.inShape, u.outShape))
    return Si({ inputs: { x: i }, backend: n });
  const h = new Nf(u, "avg", !1);
  return n.runWebGLProgram(h, [i], "float32");
}
const Coe = {
  kernelName: Vf,
  backendName: "webgl",
  kernelFunc: Toe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ioe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { filterSize: r, strides: o, pad: a, dimRoundingMode: c, dataFormat: l } = s, u = [1, 1, 1], h = Uo(i.shape, r, o, u, a, c, l), d = new LT(h, "avg", !1);
  return n.runWebGLProgram(d, [i], "float32");
}
const Eoe = {
  kernelName: Uf,
  backendName: "webgl",
  kernelFunc: Ioe
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Noe {
  constructor(e) {
    this.variableNames = ["dy"], this.outputShape = e.inShape;
    const n = e.filterHeight, s = e.filterWidth, i = e.strideHeight, r = e.strideWidth, o = e.dilationHeight, a = e.dilationWidth, c = e.effectiveFilterHeight, l = e.effectiveFilterWidth, u = c - 1 - e.padInfo.top, h = l - 1 - e.padInfo.left, d = 1 / (n * s);
    this.userCode = `
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
class koe {
  constructor(e) {
    this.variableNames = ["dy"], this.outputShape = e.inShape;
    const n = e.filterDepth, s = e.filterHeight, i = e.filterWidth, r = e.strideDepth, o = e.strideHeight, a = e.strideWidth, c = e.dilationDepth, l = e.dilationHeight, u = e.dilationWidth, h = e.effectiveFilterDepth, d = e.effectiveFilterHeight, f = e.effectiveFilterWidth, p = h - 1 - e.padInfo.front, y = d - 1 - e.padInfo.top, g = f - 1 - e.padInfo.left, m = 1 / (n * s * i);
    this.userCode = `
      const ivec3 pads = ivec3(${p}, ${y}, ${g});
      const float avgMultiplier = float(${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Aoe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, input: r } = e, o = r, { filterSize: a, strides: c, pad: l, dimRoundingMode: u } = s, h = [1, 1, 1], d = Uo(o.shape, a, c, h, l, u), f = new koe(d);
  return n.runWebGLProgram(f, [i], o.dtype);
}
const Moe = {
  kernelName: wx,
  backendName: "webgl",
  kernelFunc: Aoe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Roe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, input: r } = e, o = r;
  _m([i, r], "avgPoolGrad");
  const { filterSize: a, strides: c, pad: l } = s, u = ir(o.shape, a, c, 1, l), h = new Noe(u);
  return n.runWebGLProgram(h, [i], o.dtype);
}
const Doe = {
  kernelName: vx,
  backendName: "webgl",
  kernelFunc: Roe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $oe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { a: i, b: r } = e, { transposeA: o, transposeB: a } = s;
  return tx({ a: i, b: r, transposeA: o, transposeB: a, backend: n });
}
const Ooe = {
  kernelName: Gf,
  backendName: "webgl",
  kernelFunc: $oe
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Loe {
  constructor(e, n, s, i, r, o) {
    this.outputShape = [], this.variableNames = ["x", "mean", "variance"], bt(e, n), bt(e, s);
    let a = "0.0";
    i != null && (bt(e, i), this.variableNames.push("offset"), a = "getOffsetAtOutCoords()");
    let c = "1.0";
    r != null && (bt(e, r), this.variableNames.push("scale"), c = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${c};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Foe {
  constructor(e, n, s, i, r, o) {
    this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], bt(e, n), bt(e, s);
    let a = "vec4(0.0)";
    i != null && (bt(e, i), this.variableNames.push("offset"), a = "getOffsetAtOutCoords()");
    let c = "vec4(1.0)";
    r != null && (bt(e, r), this.variableNames.push("scale"), c = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = `
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${c};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Poe = ({ inputs: t, backend: e, attrs: n }) => {
  const { x: s, mean: i, variance: r, offset: o, scale: a } = t;
  A(i.shape.length === r.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), A(o == null || i.shape.length === o.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), A(a == null || i.shape.length === a.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
  let { varianceEpsilon: c } = n;
  c == null && (c = 1e-3);
  const l = [s, i, r];
  let u = null;
  o != null && (u = o.shape, l.push(o));
  let h = null;
  a != null && (h = a.shape, l.push(a));
  const d = ie().getBool("WEBGL_PACK_NORMALIZATION") ? new Foe(s.shape, i.shape, r.shape, u, h, c) : new Loe(s.shape, i.shape, r.shape, u, h, c);
  return e.runWebGLProgram(d, l, l[0].dtype);
}, Boe = {
  kernelName: np,
  backendName: "webgl",
  kernelFunc: Poe
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class zoe {
  constructor(e) {
    this.variableNames = ["source"], this.outputShape = e, this.rank = e.length;
    const n = rn(this.rank);
    this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
    const s = Voe(this.rank);
    let i;
    const r = e.map((o, a) => `sourceLoc.${C1[a]} = start[${a}] + coords.${C1[a]};`);
    i = `
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${r.join(`
`)}
      `, this.userCode = `
      void main() {
        ${i}
        setOutput(getSource(${s}));
      }
    `;
  }
}
const C1 = ["x", "y", "z", "w", "u", "v"];
function Voe(t) {
  if (t === 1)
    return "sourceLoc";
  if (t <= 6)
    return C1.slice(0, t).map((e) => "sourceLoc." + e).join(",");
  throw Error(`Slicing for rank ${t} is not yet supported`);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Uoe {
  constructor(e) {
    this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.rank = e.length, this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
    const n = rn(this.rank), s = zs("coords", this.rank), i = zs("sourceLoc", this.rank), r = this.rank === 1 ? "sourceLoc" : `vec2(${i.slice(-2).join()})`, o = `getChannel(getSource(${i.join()}), ${r})`, a = `
      result.x = ${o};
      if (++${s[this.rank - 1]} < ${e[this.rank - 1]}) {
        ++${i[this.rank - 1]};
        result.y = ${o};
        --${i[this.rank - 1]};
      }
    `, c = this.rank === 1 ? "" : `
      --${s[this.rank - 1]};
      if (++${s[this.rank - 2]} < ${e[this.rank - 2]}) {
        ++${i[this.rank - 2]};
        result.z = ${o};
        if (++${s[this.rank - 1]} < ${e[this.rank - 1]}) {
          ++${i[this.rank - 1]};
          result.w = ${o};
        }
      }
    `, l = this.rank <= 4 ? `sourceLoc = coords +
            ${n}(${e.map((u, h) => `start[${h}]`).join()});` : e.map((u, h) => `${i[h]} = ${s[h]} + start[${h}];`).join(`
`);
    this.userCode = `
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${c}
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Goe(t, e, n, s) {
  const i = s.texData.get(t.dataId), r = s.makeTensorInfo(n, t.dtype), o = s.texData.get(r.dataId);
  Object.assign(o, i), o.refCount = 1, o.shape = n, o.dtype = t.dtype;
  let a = k_(e, ct(t.shape));
  i.slice && (a += i.slice.flatOffset), o.slice = {
    flatOffset: a,
    // Point to the original dataId, which is used to do ref counting.
    origDataId: i.slice && i.slice.origDataId || t.dataId
  };
  const c = s.dataRefCount.get(o.slice.origDataId) || 1;
  return s.dataRefCount.set(o.slice.origDataId, c + 1), r;
}
function jh(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { begin: r, size: o } = s, [a, c] = ub(i, r, o);
  if (I_(i, a, c), ue(c) === 0)
    return n.makeTensorInfo(c, i.dtype, []);
  if (n.shouldExecuteOnCPU([i]) || i.dtype === "string") {
    const h = n.texData.get(i.dataId), d = Oie(h.values, a, c, i.shape, i.dtype);
    return n.makeTensorInfo(c, i.dtype, d);
  }
  const { isPacked: l } = n.texData.get(i.dataId), u = N_(i.shape, a, c);
  if (l || !u) {
    const h = ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Uoe(c) : new zoe(c), d = [a];
    return n.runWebGLProgram(h, [i], i.dtype, d);
  }
  return n.uploadToGPU(i.dataId), Goe(i, a, c, n);
}
const Woe = {
  kernelName: Mp,
  backendName: "webgl",
  kernelFunc: jh
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Hoe = (t) => {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { blockShape: r, crops: o } = s;
  A(i.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
  const a = r.reduce((x, v) => x * v), c = um(i.shape, r, a), l = hm(c.length, r.length), u = dm(i.shape, r, a), h = O_(o, r.length), d = L_(u, o, r.length), f = [], p = ze({ inputs: { x: i }, backend: n, attrs: { shape: c } }), y = Ws({ inputs: { x: p }, backend: n, attrs: { perm: l } }), g = ze({
    inputs: { x: y },
    backend: n,
    attrs: { shape: u }
  }), m = jh({
    inputs: { x: g },
    backend: n,
    attrs: { begin: h, size: d }
  });
  return f.push(p), f.push(y), f.push(g), f.forEach((x) => n.disposeIntermediateTensorInfo(x)), m;
}, joe = {
  kernelName: Wf,
  backendName: "webgl",
  kernelFunc: Hoe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qoe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, weights: r } = e, { size: o } = s, a = n.readSync(i.dataId), c = n.readSync(r.dataId), l = q$(a, c, r.dtype, r.shape, o);
  return n.makeTensorInfo([o], r.dtype, l);
}
const Xoe = {
  kernelName: Sx,
  backendName: "webgl",
  kernelFunc: qoe
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Koe = `
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`, Yoe = `
  return float(int(a.r) & int(b.r));
`;
function Zoe(t) {
  const { inputs: e, backend: n } = t, { a: s, b: i } = e, r = ie().getBool("WEBGL_PACK_BINARY_OPERATIONS"), o = ie().getNumber("WEBGL_VERSION");
  if (n.shouldExecuteOnCPU([s, i]) || o === 1) {
    const c = n.texData.get(s.dataId).values, l = n.texData.get(i.dataId).values, [u, h] = rie(s.shape, i.shape, c, l, s.dtype), d = n.makeTensorInfo(h, s.dtype), f = n.texData.get(d.dataId);
    return f.values = u, d;
  }
  let a;
  return r ? a = new Wh(Koe, s.shape, i.shape, !1) : a = new Kc(Yoe, s.shape, i.shape), n.runWebGLProgram(a, [s, i], s.dtype);
}
const Joe = {
  kernelName: Hf,
  backendName: "webgl",
  kernelFunc: Zoe
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qoe(t) {
  const { inputs: e, backend: n } = t, { s0: s, s1: i } = e, r = n.readSync(s.dataId), o = n.readSync(i.dataId), a = bt(Array.from(r), Array.from(o));
  return n.makeTensorInfo([a.length], "int32", Int32Array.from(a));
}
const eae = {
  kernelName: _x,
  backendName: "webgl",
  kernelFunc: Qoe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const tae = "return float(a != b);", aO = Cs({ opSnippet: tae, cpuKernelImpl: Iie, dtype: "bool" }), nae = {
  kernelName: bp,
  backendName: "webgl",
  kernelFunc: aO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Cm(t) {
  const { inputs: e, backend: n } = t, { input: s } = e, i = n.texData.get(s.dataId);
  return Si({ inputs: { x: i.complexTensorInfos.real }, backend: n });
}
const sae = {
  kernelName: s0,
  backendName: "webgl",
  kernelFunc: Cm
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const iae = "return float(int(x));";
function rae(t, e) {
  const n = new Hr(t.shape, iae), s = e.runWebGLProgram(n, [t], "int32");
  return { dataId: s.dataId, shape: s.shape, dtype: s.dtype };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function I1(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { dtype: r } = s;
  if (r === "complex64") {
    if (i.dtype === "complex64")
      return Si({ inputs: { x: i }, backend: n });
    const o = qn(i.shape), a = I1({ inputs: { x: i }, backend: n, attrs: { dtype: "float32" } }), c = Ha({ inputs: { real: a, imag: o }, backend: n });
    return o.dispose(), n.disposeIntermediateTensorInfo(a), c;
  }
  if (i.dtype === "complex64") {
    const o = Cm({ inputs: { input: i }, backend: n }), a = I1({ inputs: { x: o }, backend: n, attrs: { dtype: r } });
    return n.disposeIntermediateTensorInfo(o), a;
  }
  if (!q1(i.dtype, r)) {
    const o = Si({ inputs: { x: i }, backend: n });
    return { dataId: o.dataId, shape: o.shape, dtype: r };
  }
  if (n.shouldExecuteOnCPU([i])) {
    const o = n.texData.get(i.dataId).values, [a, c, l] = oie(o, i.shape, i.dtype, r);
    return n.makeTensorInfo(a, c, l);
  }
  if (r === "int32")
    return rae(i, n);
  if (r === "bool") {
    const o = n.makeTensorInfo([], "bool", ls("bool", 1)), c = aO({ inputs: { a: i, b: o }, backend: n });
    return n.disposeIntermediateTensorInfo(o), c;
  }
  throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${r}`);
}
const oae = {
  kernelName: Gu,
  backendName: "webgl",
  kernelFunc: I1
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KI = "return ceil(x);", aae = Wt({ opSnippet: KI, packedOpSnippet: KI, cpuKernelImpl: aie }), cae = {
  kernelName: Wu,
  backendName: "webgl",
  kernelFunc: aae
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class lae {
  constructor(e) {
    this.variableNames = ["A"], this.customUniforms = [
      { name: "minVal", type: "float" },
      { name: "maxVal", type: "float" }
    ], this.outputShape = e, this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class uae {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [
      { name: "minVal", type: "float" },
      { name: "maxVal", type: "float" }
    ], this.outputShape = e, this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hae(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { clipValueMin: r, clipValueMax: o } = s;
  let a;
  ie().getBool("WEBGL_PACK_CLIP") ? a = new uae(i.shape) : a = new lae(i.shape);
  const c = [[r], [o]];
  return n.runWebGLProgram(a, [i], i.dtype, c);
}
const dae = {
  kernelName: Hu,
  backendName: "webgl",
  kernelFunc: hae
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class fae {
  constructor(e) {
    this.variableNames = ["real", "imag"], this.outputShape = e, this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YI(t, e) {
  return {
    dataId: e.dataId,
    dtype: e.dtype,
    shape: t.shape
  };
}
function pae(t) {
  const { inputs: e, backend: n } = t, { x: s } = e, i = n.texData.get(s.dataId), r = new fae(s.shape), o = [
    YI(s, i.complexTensorInfos.real),
    YI(s, i.complexTensorInfos.imag)
  ];
  return n.runWebGLProgram(r, o, o[0].dtype);
}
const mae = {
  kernelName: jf,
  backendName: "webgl",
  kernelFunc: pae
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class gae {
  // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().
  constructor(e) {
    this.outputShape = [], this.outputShape = Xr(
      e,
      1
      /* axis */
    ), this.variableNames = e.map((o, a) => `T${a}`);
    const n = new Array(e.length - 1);
    n[0] = e[0][1];
    for (let o = 1; o < n.length; o++)
      n[o] = n[o - 1] + e[o][1];
    const s = [`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];
    for (let o = 1; o < n.length; o++) {
      const a = n[o - 1];
      s.push(`else if (yC < ${n[o]}) setOutput(getT${o}(yR, yC-${a}));`);
    }
    const i = n.length, r = n[n.length - 1];
    s.push(`else setOutput(getT${i}(yR, yC-${r}));`), this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class yae {
  constructor(e, n) {
    this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = Xr(e, n);
    const s = this.outputShape, i = s.length, r = rn(i), o = zs("coords", i), a = ["x", "y", "z", "w", "u", "v"].slice(0, i);
    this.variableNames = e.map((y, g) => `T${g}`);
    const c = new Array(e.length - 1);
    c[0] = e[0][n];
    for (let y = 1; y < c.length; y++)
      c[y] = c[y - 1] + e[y][n];
    const l = a[n], u = a.slice(-2), h = a.join();
    let d = `if (${l} < ${c[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;
    for (let y = 1; y < c.length; y++) {
      const g = c[y - 1];
      d += `
        if (${l} < ${c[y]}  && ${l} >= ${c[y - 1]}) {
          return getChannel(
            getT${y}(${Ng(a, l, g)}),
            vec2(${Ng(u, l, g)}));
        }`;
    }
    const f = c.length, p = c[c.length - 1];
    d += `
        return getChannel(
          getT${f}(${Ng(a, l, p)}),
          vec2(${Ng(u, l, p)}));`, this.userCode = `
      float getValue(${a.map((y) => "int " + y)}) {
        ${d}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[i - 1]} = ${o[i - 1]} + 1;
        if (${o[i - 1]} < ${s[i - 1]}) {
          result.g = getValue(${o});
        }

        ${o[i - 2]} = ${o[i - 2]} + 1;
        if (${o[i - 2]} < ${s[i - 2]}) {
          result.a = getValue(${o});
        }

        ${o[i - 1]} = ${o[i - 1]} - 1;
        if (${o[i - 2]} < ${s[i - 2]} &&
            ${o[i - 1]} < ${s[i - 1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `;
  }
}
function Ng(t, e, n) {
  const s = t.indexOf(e);
  return t.map((r, o) => o === s ? `${r} - ${n}` : r).join();
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mb(t) {
  const { inputs: e, backend: n } = t, { input: s } = e, i = n.texData.get(s.dataId);
  return Si({ inputs: { x: i.complexTensorInfos.imag }, backend: n });
}
const xae = {
  kernelName: Gx,
  backendName: "webgl",
  kernelFunc: Mb
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yd(t, e, n) {
  const s = t[0].dtype;
  if (s === "complex64") {
    const f = t.map((x) => Cm({ inputs: { input: x }, backend: n })), p = t.map((x) => Mb({ inputs: { input: x }, backend: n })), y = yd(f, e, n), g = yd(p, e, n), m = Ha({ inputs: { real: y, imag: g }, backend: n });
    return f.forEach((x) => n.disposeIntermediateTensorInfo(x)), p.forEach((x) => n.disposeIntermediateTensorInfo(x)), n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(g), m;
  }
  let i = n.shouldExecuteOnCPU(t);
  if (s === "string" && (i = !0), i) {
    const f = t.map((b) => {
      const S = [-1, ue(b.shape.slice(e))];
      return ze({ inputs: { x: b }, backend: n, attrs: { shape: S } });
    }), p = f.map((b) => ({ vals: n.readSync(b.dataId), shape: b.shape })), y = Xr(
      f.map((b) => b.shape),
      1
      /* axis */
    ), g = f[0].shape[0] === 1, m = cie(p, y, s, g), x = Xr(t.map((b) => b.shape), e), v = n.makeTensorInfo(x, s, m);
    return f.forEach((b) => n.disposeIntermediateTensorInfo(b)), v;
  }
  const r = t.filter((f) => ue(f.shape) > 0), o = ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && r[0].shape.length > 1;
  if (r.length === 1) {
    const f = o ? new Hr(t[0].shape, ia) : new ua(t[0].shape, ia);
    return n.runWebGLProgram(f, t, s);
  }
  const a = ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
  if (r.length > a) {
    const f = [];
    for (let y = 0; y < r.length; y += a) {
      const g = r.slice(y, y + a);
      f.push(yd(g, e, n));
    }
    const p = yd(f, e, n);
    for (const y of f)
      n.disposeIntermediateTensorInfo(y);
    return p;
  }
  if (o) {
    const f = new yae(r.map((p) => p.shape), e);
    return n.runWebGLProgram(f, r, s);
  }
  const { tensors2D: c, outShape: l } = bae(r, e, n), u = new gae(c.map((f) => f.shape)), h = n.runWebGLProgram(u, c, s);
  c.forEach((f) => n.disposeIntermediateTensorInfo(f));
  const d = ze({ inputs: { x: h }, attrs: { shape: l }, backend: n });
  return n.disposeIntermediateTensorInfo(h), d;
}
function bae(t, e, n) {
  const s = Xr(t.map((r) => r.shape), e);
  return { tensors2D: t.map((r) => ze({
    inputs: { x: r },
    attrs: { shape: [-1, ue(r.shape.slice(e))] },
    backend: n
  })), outShape: s };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cO(t) {
  const { inputs: e, backend: n, attrs: s } = t, { axis: i } = s, r = Rt(i, e[0].shape)[0], o = e.map((l) => l.shape);
  R_(o, r);
  const a = Xr(e.map((l) => l.shape), r);
  if (ue(a) === 0)
    return n.makeTensorInfo(a, e[0].dtype, []);
  const c = e.filter((l) => ue(l.shape) > 0);
  return c.length === 1 ? Si({ inputs: { x: c[0] }, backend: n }) : yd(c, r, n);
}
const vae = {
  kernelName: qf,
  backendName: "webgl",
  kernelFunc: cO
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class lO {
  constructor(e, n = !1, s = null, i = !1, r = !1) {
    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    const o = e.padInfo.top, a = e.padInfo.left, c = e.strideHeight, l = e.strideWidth, u = e.dilationHeight, h = e.dilationWidth, d = e.filterHeight, f = e.filterWidth, p = Math.floor(e.inChannels / 4) * 4, y = e.inChannels % 4, g = e.dataFormat === "channelsLast", m = g ? 1 : 2, x = g ? 2 : 3, v = g ? 3 : 1;
    let b = "", w = "";
    s && (i ? b = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }` : r ? b = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }` : b = `
          float activation(float x) {
            ${s}
          }
        `, w = "result = activation(result);");
    const S = n ? "result += getBiasAtOutCoords();" : "";
    n && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${b}

      const ivec2 strides = ivec2(${c}, ${l});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${v}];

        ivec2 xRCCorner =
            ivec2(coords[${m}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${y === 1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${y === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${y === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${S}
        ${w}
        setOutput(result);
      }
    `;
  }
}
class wae {
  constructor(e) {
    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    const n = e.padInfo.front, s = e.padInfo.top, i = e.padInfo.left, r = e.strideDepth, o = e.strideHeight, a = e.strideWidth, c = e.dilationDepth, l = e.dilationHeight, u = e.dilationWidth, h = e.filterDepth, d = e.filterHeight, f = e.filterWidth, p = Math.floor(e.inChannels / 4) * 4, y = e.inChannels % 4;
    this.userCode = `
      const ivec3 strides = ivec3(${r}, ${o}, ${a});
      const ivec3 pads = ivec3(${n}, ${s}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${c};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${y === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${y === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${y === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class uO {
  constructor(e, n = !1, s = null, i = !1, r = !1) {
    this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [
      { name: "pads", type: "ivec2" },
      { name: "strides", type: "ivec2" },
      { name: "dilations", type: "ivec2" },
      { name: "inDims", type: "ivec2" }
    ], this.outputShape = e.outShape, this.enableShapeUniforms = As(this.outputShape.length);
    const o = e.padInfo.left, a = e.strideWidth, c = e.dilationWidth, l = e.filterHeight, u = e.filterWidth, h = u;
    let d = `
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;
    for (let g = 0; g < u; g++)
      d += `
           vec4 xTexelC${g * 2};
           int xTexelC${g * 2}Ready;
           vec4 xTexelC${g * 2 + 1};
           int xTexelC${g * 2 + 1}Ready;
           vec4 xC${g};`;
    d += `
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;
    for (let g = 0; g < u; g++)
      d += `
           xTexelC${g * 2} = vec4(0.0);
           xTexelC${g * 2}Ready = 0;
           xTexelC${g * 2 + 1} = vec4(0.0);
           xTexelC${g * 2 + 1}Ready = 0;
           xC${g} = vec4(0.0);`;
    d += `
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;
    for (let g = 0; g < (h + 1) / 2; g++) {
      const m = g * 2;
      if (d += `
           xC = xCCorner + ${m * c};
           `, a === 1) {
        if (m < u && (o % 2 === 1 ? (d += `
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }
               `, c === 1 && m > 0 ? d += `
                 xC${m} = vec4(xTexelC${m - 2}.zw, xTexelC${m}.xy);
                 ` : d += `
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${m} = vec4(previous.zw, xTexelC${m}.xy);
                   } else {
                     xC${m} = vec4(0.0, 0.0, xTexelC${m}.xy);
                   }
                   `) : d += `
                 if (xC >= 0 && xC < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 xC${m} = xTexelC${m};
                 `, m + 1 < u)) {
          const x = o % 2 === 0 ? gx(c) : c;
          c % 2 === 0 && o % 2 === 1 || c % 2 !== 0 && o % 2 !== 1 ? (d += `
                   xCOffset = xC + imod(pads[1], 2) + ${x};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m + 1}Ready == 0) {
                     xTexelC${m + 1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${m + 1}.zw = vec2(0.0);
                     }
                     xTexelC${m + 1}Ready = 1;
                   }
                   `, c > 1 ? d += `
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${m + 1} = vec4(previous.zw, xTexelC${m + 1}.xy);
                     } else {
                      xC${m + 1} = vec4(0.0, 0.0, xTexelC${m + 1}.xy);
                     }
                     ` : d += `
                     xC${m + 1} = vec4(xTexelC${m}.zw, xTexelC${m + 1}.xy);
                     `) : x === 1 ? d += `
                     xC${m + 1} = xTexelC${m};
                     ` : d += `
                     xCOffset = xC + ${x};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m + 1}Ready == 0) {
                       xTexelC${m + 1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${m + 1}.zw = vec2(0.0);
                       }
                       xTexelC${m + 1}Ready = 1;
                     }

                     xC${m + 1} = xTexelC${m + 1};
                     `;
        }
      } else
        m < u && (o % 2 === 1 ? (d += `
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${m + 1}Ready == 0) {
                   xTexelC${m + 1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${m + 1}.zw = vec2(0.0);
                   }
                   xTexelC${m + 1}Ready = 1;
                 }

                 xC${m} = vec4(xTexelC${m}.zw, xTexelC${m + 1}.zw);
               `, m + 1 < u && (d += `
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${m + 1} = vec4(xTexelC${m + 1}.xy, final.xy);
                 `)) : (d += `
                 if(xC >= 0 && xC < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m + 1}Ready == 0) {
                   xTexelC${m + 1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m + 1}.zw = vec2(0.);
                   }
                   xTexelC${m + 1}Ready = 1;
                 }

                 xC${m} = vec4(
                   xTexelC${m}.xy, xTexelC${m + 1}.xy);
               `, m + 1 < u && (d += `
                   xC${m + 1} = vec4(xTexelC${m}.zw, xTexelC${m + 1}.zw);
                 `)));
      m < u && (d += `
             wTexel = getW(r, ${m}, d1, d2);
             dotProd += xC${m}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${m}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `, m + 1 < u && (d += `
               wTexel = getW(r, ${m + 1}, d1, d2);
               dotProd += xC${m + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${m + 1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `));
    }
    d += `
     }
   `, d += `
     }
   `, d += `
     }
   `;
    let f = "", p = "";
    s && (i ? f = `vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }` : r ? f = `vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }` : f = `vec4 activation(vec4 x) {
           ${s}
         }`, p = "result = activation(result);");
    const y = n ? "result += getBiasAtOutCoords();" : "";
    n && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = `
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${y}
         ${p}
         setOutput(result);
       }
     `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Sae {
  constructor(e, n) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [
      { name: "inputShape", type: "ivec4" },
      { name: "pad", type: "ivec2" },
      { name: "stride", type: "ivec2" },
      { name: "dilation", type: "ivec2" },
      { name: "inChannels", type: "int" },
      { name: "itemsPerBlockRow", type: "int" },
      { name: "outWidth", type: "int" }
    ], this.outputShape = e, this.enableShapeUniforms = As(this.outputShape.length);
    const { dataFormat: s } = n, i = qs(), r = s === "channelsLast", o = r ? 1 : 2, a = r ? 2 : 3, c = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : `if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;
    let l = "";
    for (let u = 0; u <= 1; u++)
      for (let h = 0; h <= 1; h++)
        l += `
          blockIndex = rc.z + ${h};
          pos = rc.y + ${u};

          ${c}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${u * 2 + h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u * 2 + h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
    this.userCode = `
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${i.output} = result;
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nx(t, e) {
  const n = t.length;
  return n >= 3 ? e ? [
    ...t.slice(0, -3),
    t[n - 3] * t[n - 2],
    t[n - 1]
    /* channel */
  ] : [
    ...t.slice(0, -3),
    t[n - 3],
    t[n - 2] * t[n - 1]
    /* height * width */
  ] : !e && n === 1 && t[0] > 1 ? [t[0], 1] : null;
}
function hO({ x: t, filter: e, convInfo: n, backend: s, bias: i = null, preluActivationWeights: r = null, leakyreluAlpha: o = 0, activation: a = null }) {
  const c = t.shape, l = s.texData.get(t.dataId), u = n.inChannels, h = c[0] * c[1] * c[2], d = n.outChannels, f = n.dataFormat === "channelsLast", p = !1, y = !1;
  let g;
  const m = [];
  if (r != null) {
    const b = nx(r.shape, f);
    b != null && (r = ze({
      inputs: { x: r },
      backend: s,
      attrs: { shape: b }
    }), m.push(r));
  }
  if (i != null) {
    const b = nx(i.shape, f);
    b != null && (i = ze({ inputs: { x: i }, backend: s, attrs: { shape: b } }), m.push(i));
  }
  if (!((h === 1 || d === 1) && u > sO) && l.isPacked && f && l.texture != null && c[2] % 2 !== 0 && Bt(l.shape.slice(-3), c.slice(-3))) {
    const b = c[0] * c[1] * (c[2] + 1), w = {
      dataId: t.dataId,
      shape: [1, b, n.inChannels],
      dtype: t.dtype
    }, S = l.shape;
    l.shape = l.shape.slice(), l.shape[l.shape.length - 2]++, A(ex(l.shape, w.shape), () => `packed reshape ${l.shape} to ${w.shape} isn't free`);
    const _ = ze({
      inputs: { x: e },
      backend: s,
      attrs: { shape: [1, n.inChannels, n.outChannels] }
    });
    m.push(_);
    const E = tx({
      a: w,
      b: _,
      backend: s,
      transposeA: p,
      transposeB: y,
      bias: i,
      activation: a,
      preluActivationWeights: r,
      leakyreluAlpha: o
    }), I = s.texData.get(E.dataId);
    A(I.isPacked, () => "batchMatMul result is expected to be packed"), l.shape = S, I.shape = n.outShape, g = Si({ inputs: { x: E }, backend: s }), g.shape = n.outShape, m.push(E);
  } else {
    const b = n.outHeight * n.outWidth, w = ze({
      inputs: { x: t },
      backend: s,
      attrs: {
        shape: f ? [n.batchSize, b, n.inChannels] : [n.batchSize, n.inChannels, b]
      }
    }), S = ze({
      inputs: { x: e },
      backend: s,
      attrs: { shape: [1, n.inChannels, n.outChannels] }
    }), _ = tx({
      a: f ? w : S,
      b: f ? S : w,
      transposeA: !f,
      transposeB: y,
      backend: s,
      bias: i,
      activation: a,
      preluActivationWeights: r,
      leakyreluAlpha: o
    });
    g = ze({ inputs: { x: _ }, backend: s, attrs: { shape: n.outShape } }), m.push(w), m.push(S), m.push(_);
  }
  for (const b of m)
    s.disposeIntermediateTensorInfo(b);
  return g;
}
function dO({ x: t, filter: e, convInfo: n, backend: s, bias: i = null, preluActivationWeights: r = null, leakyreluAlpha: o = 0, activation: a = null }) {
  const { filterWidth: c, filterHeight: l, inChannels: u, outWidth: h, outHeight: d, dataFormat: f } = n, p = f === "channelsLast", y = c * l * u, g = d * h, m = [n.batchSize, y, g], x = !0, v = !1, b = [];
  if (r != null) {
    const j = nx(r.shape, p);
    j != null && (r = ze({
      inputs: { x: r },
      backend: s,
      attrs: { shape: j }
    }), b.push(r));
  }
  if (i != null) {
    const j = nx(i.shape, p);
    j != null && (i = ze({ inputs: { x: i }, backend: s, attrs: { shape: j } }), b.push(i));
  }
  const w = ze({
    inputs: { x: e },
    backend: s,
    attrs: { shape: [1, y, ue(e.shape) / y] }
  });
  b.push(w);
  const S = new Sae(m, n), _ = [
    t.shape,
    [n.padInfo.top, n.padInfo.left],
    [n.strideHeight, n.strideWidth],
    [n.dilationHeight, n.dilationWidth],
    [n.inChannels],
    [n.filterWidth * n.inChannels],
    [n.outWidth]
  ], E = s.runWebGLProgram(S, [t], "float32", _), I = ze({ inputs: { x: E }, backend: s, attrs: { shape: m } });
  b.push(E), b.push(I);
  const k = i != null, M = r != null, L = a === "leakyrelu", O = a ? Ef(a, !0) : null, $ = new nO(p ? I.shape : w.shape, p ? w.shape : I.shape, p ? [n.batchSize, g, n.outChannels] : [n.batchSize, n.outChannels, g], x, v, k, O, M, L), D = p ? [I, w] : [w, I];
  if (i && D.push(i), M && D.push(r), L) {
    const j = s.makeTensorInfo([], "float32", Vo(o, "float32"));
    D.push(j), b.push(j);
  }
  const z = s.runWebGLProgram($, D, "float32"), W = ze({ inputs: { x: z }, backend: s, attrs: { shape: n.outShape } });
  b.push(z);
  for (const j of b)
    s.disposeIntermediateTensorInfo(j);
  return W;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _ae(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, filter: r } = e, { strides: o, pad: a, dataFormat: c, dilations: l, dimRoundingMode: u } = s, h = Go(c), d = hs(i.shape, r.shape, o, l, a, u, !1, h);
  let f;
  if (d.filterHeight === 1 && d.filterWidth === 1 && d.dilationHeight === 1 && d.dilationWidth === 1 && d.strideHeight === 1 && d.strideWidth === 1 && (d.padInfo.type === "SAME" || d.padInfo.type === "VALID"))
    f = hO({ x: i, filter: r, convInfo: d, backend: n });
  else if (d.strideWidth <= 2 && h === "channelsLast" && ie().getBool("WEBGL_EXP_CONV")) {
    const y = new uO(d), g = [
      [d.padInfo.top, d.padInfo.left],
      [d.strideHeight, d.strideWidth],
      [d.dilationHeight, d.dilationWidth],
      [d.inHeight, d.inWidth]
    ];
    f = n.runWebGLProgram(y, [i, r], "float32", g);
  } else if (ie().getBool("WEBGL_CONV_IM2COL"))
    f = dO({ x: i, filter: r, convInfo: d, backend: n });
  else {
    const y = new lO(d);
    f = n.runWebGLProgram(y, [i, r], "float32");
  }
  const p = ze({ inputs: { x: f }, backend: n, attrs: { shape: d.outShape } });
  return n.disposeIntermediateTensorInfo(f), p;
}
const Tae = {
  kernelName: Xf,
  backendName: "webgl",
  kernelFunc: _ae
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Cae {
  constructor(e) {
    this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
    const n = e.strideHeight, s = e.strideWidth, i = e.padInfo.top, r = e.padInfo.left, o = e.dataFormat === "channelsLast";
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o ? `float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);` : `float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
class Iae {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
    const n = e.filterHeight, s = e.filterWidth, i = e.strideHeight, r = e.strideWidth, o = e.dataFormat === "channelsLast", a = n - 1 - e.padInfo.top, c = s - 1 - e.padInfo.left, l = o ? 1 : 2, u = o ? 2 : 3, h = o ? 3 : 1;
    this.userCode = `
      const ivec2 pads = ivec2(${a}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
class Eae {
  constructor(e) {
    this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
    const n = e.strideDepth, s = e.strideHeight, i = e.strideWidth, r = e.padInfo.front, o = e.padInfo.top, a = e.padInfo.left;
    this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${r};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
class Nae {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
    const n = e.filterDepth, s = e.filterHeight, i = e.filterWidth, r = e.strideDepth, o = e.strideHeight, a = e.strideWidth, c = n - 1 - e.padInfo.front, l = s - 1 - e.padInfo.top, u = i - 1 - e.padInfo.left;
    this.userCode = `
      const ivec3 pads = ivec3(${c}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kae(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, dy: r } = e, { strides: o, pad: a, dataFormat: c, dimRoundingMode: l, filterShape: u } = s, h = Go(c), d = hs(i.shape, u, o, 1, a, l, !1, h), f = new Cae(d);
  return n.runWebGLProgram(f, [i, r], "float32");
}
const Aae = {
  kernelName: Cx,
  backendName: "webgl",
  kernelFunc: kae
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Mae {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [
      { name: "strides", type: "vec2" }
    ], this.outputShape = e.inShape, this.enableShapeUniforms = As(this.outputShape.length);
    const n = e.filterHeight, s = e.filterWidth, i = n - 1 - e.padInfo.top, r = s - 1 - e.padInfo.left;
    this.userCode = `
      const ivec2 pads = ivec2(${i}, ${r});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Rae(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, filter: r } = e, { inputShape: o, strides: a, pad: c, dataFormat: l, dimRoundingMode: u } = s, h = Go(l), d = hs(o, r.shape, a, 1, c, u, !1, h);
  if (ie().getBool("WEBGL_PACK_CONV2DTRANSPOSE") && h === "channelsLast") {
    const f = [
      [d.strideHeight, d.strideWidth]
    ], p = new Mae(d);
    return n.runWebGLProgram(p, [i, r], "float32", f);
  } else {
    const f = new Iae(d);
    return n.runWebGLProgram(f, [i, r], "float32");
  }
}
const Dae = {
  kernelName: Kf,
  backendName: "webgl",
  kernelFunc: Rae
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $ae(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, filter: r } = e, { strides: o, pad: a, dilations: c } = s, l = Pa(i.shape, r.shape, o, c, a), u = new wae(l);
  return n.runWebGLProgram(u, [i, r], "float32");
}
const Oae = {
  kernelName: Yf,
  backendName: "webgl",
  kernelFunc: $ae
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Lae(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, dy: r } = e, { strides: o, pad: a, filterShape: c } = s, l = Pa(i.shape, c, o, 1, a), u = new Eae(l);
  return n.runWebGLProgram(u, [i, r], "float32");
}
const Fae = {
  kernelName: Ix,
  backendName: "webgl",
  kernelFunc: Lae
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Pae(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, filter: r } = e, { pad: o, strides: a, inputShape: c } = s, l = Pa(c, r.shape, a, 1, o), u = new Nae(l);
  return n.runWebGLProgram(u, [i, r], "float32");
}
const Bae = {
  kernelName: Ex,
  backendName: "webgl",
  kernelFunc: Pae
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const zae = Hh + `
  return cos(x);
`, Vae = `
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${hl}
  return result;
`, Uae = Wt({ opSnippet: zae, packedOpSnippet: Vae }), Gae = {
  kernelName: ju,
  backendName: "webgl",
  kernelFunc: Uae
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Wae = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`, Hae = Wt({ opSnippet: Wae }), jae = {
  kernelName: qu,
  backendName: "webgl",
  kernelFunc: Hae
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class qae {
  constructor(e, n, s, i, r) {
    this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
    const [o, a, c, l] = e, [u] = n, [h, d] = s;
    this.outputShape = [u, h, d, l];
    const f = i === "bilinear" ? 1 : 0, [p, y] = [`${a - 1}.0`, `${c - 1}.0`], [g, m, x] = h > 1 ? [
      `${(a - 1) / (h - 1)}`,
      "(y2-y1) * height_ratio",
      `y1*${p} + float(y)*(height_scale)`
    ] : [
      "0.0",
      "0.0",
      `0.5 * (y1+y2) * ${p}`
    ], [v, b, w] = d > 1 ? [
      `${(c - 1) / (d - 1)}`,
      "(x2-x1) * width_ratio",
      `x1*${y} + float(x)*(width_scale)`
    ] : [
      "0.0",
      "0.0",
      `0.5 * (x1+x2) * ${y}`
    ];
    this.userCode = `
      const float height_ratio = float(${g});
      const float width_ratio = float(${v});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${m};
        float width_scale = ${b};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${w};
        if( in_x < 0.0 || in_x > ${y} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Xae = (t) => {
  const { inputs: e, backend: n, attrs: s } = t, { image: i, boxes: r, boxInd: o } = e, { cropSize: a, method: c, extrapolationValue: l } = s, u = new qae(i.shape, r.shape, a, c, l);
  return n.runWebGLProgram(u, [i, r, o], "float32");
}, Kae = {
  kernelName: kx,
  backendName: "webgl",
  kernelFunc: Xae
};
var kf;
(function(t) {
  t.Prod = "*", t.Sum = "+";
})(kf || (kf = {}));
class ZI {
  constructor(e, n, s, i) {
    this.op = e, this.outputShape = n, this.variableNames = ["x"], this.customUniforms = [{ name: "index", type: "float" }];
    const r = this.outputShape.length, o = this.op === kf.Prod ? "1.0" : "0.0", a = s ? o : `getX(${JI(r, "coords", this.op)})`, c = this.outputShape[this.outputShape.length - 1];
    let l = "", u = "";
    s ? (l = i ? `end != ${c - 1}` : "end != 0", u = i ? "end + 1" : "end - 1") : (l = i ? `end + pow2 < ${c}` : "end >= pow2", u = i ? "end + pow2" : "end - pow2"), this.userCode = `
      void main() {
        ${rn(r)} coords = getOutputCoords();
        int end = ${QI(r, "coords", this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${QI(r, "coords", this.op)} = idx;
          val ${this.op}= getX(${JI(r, "coords", this.op)});
        }
        setOutput(val);
      }
    `;
  }
}
function JI(t, e, n) {
  if (t === 1)
    return `${e}`;
  if (t === 2)
    return `${e}.x, ${e}.y`;
  if (t === 3)
    return `${e}.x, ${e}.y, ${e}.z`;
  if (t === 4)
    return `${e}.x, ${e}.y, ${e}.z, ${e}.w`;
  throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`);
}
function QI(t, e, n) {
  if (t === 1)
    return `${e}`;
  if (t === 2)
    return `${e}.y`;
  if (t === 3)
    return `${e}.z`;
  if (t === 4)
    return `${e}.w`;
  throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`);
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fO(t, e, n, s, i, r) {
  const o = e.shape.length, a = An([s], o);
  let c = e;
  a != null && (c = Ws({ inputs: { x: e }, backend: n, attrs: { perm: a } }));
  const l = Vn(1, o)[0];
  if (l !== o - 1)
    throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length - 1} but got axis=${s}`);
  const u = c.shape[l];
  let h = Si({ inputs: { x: c }, backend: n });
  for (let d = 0; d <= Math.ceil(Math.log2(u)) - 1; d++) {
    const f = new ZI(t, c.shape, !1, r), p = [[d]], y = h;
    h = n.runWebGLProgram(f, [h], h.dtype, p), n.disposeIntermediateTensorInfo(y);
  }
  if (i) {
    const d = new ZI(t, c.shape, i, r), f = h;
    h = n.runWebGLProgram(d, [h], h.dtype), n.disposeIntermediateTensorInfo(f);
  }
  if (a != null) {
    const d = Ba(a), f = Ws({ inputs: { x: h }, backend: n, attrs: { perm: d } });
    return n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(c), f;
  }
  return h;
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yae(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, exclusive: o, reverse: a } = s;
  return fO(kf.Prod, i, n, r, o, a);
}
const Zae = {
  kernelName: Nx,
  backendName: "webgl",
  kernelFunc: Yae
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jae(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, exclusive: o, reverse: a } = s;
  return fO(kf.Sum, i, n, r, o, a);
}
const Qae = {
  kernelName: Zf,
  backendName: "webgl",
  kernelFunc: Jae
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ece(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, weights: r } = e, { size: o, binaryOutput: a } = s;
  if (i.shape.length === 1) {
    const c = n.readSync(i.dataId), l = n.readSync(r.dataId), u = q$(c, l, r.dtype, r.shape, o);
    return n.makeTensorInfo([o], r.dtype, u);
  } else if (i.shape.length === 2) {
    const c = n.bufferSync(i), l = n.bufferSync(r), u = iie(c, l, o, a);
    return n.makeTensorInfo(u.shape, r.dtype, u.values);
  }
  throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`);
}
const tce = {
  kernelName: Ax,
  backendName: "webgl",
  kernelFunc: ece
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class nce {
  constructor(e, n, s) {
    this.variableNames = ["x"], this.outputShape = [], this.outputShape = e, this.blockSize = n, this.dataFormat = s, this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
  }
  getHeightCoordString() {
    return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
  }
  getWidthCoordString() {
    return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
  }
  getDepthCoordString() {
    return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
  }
  getOutputDepthSize() {
    return this.dataFormat === "NHWC" ? this.outputShape[3] : this.outputShape[1];
  }
  getInputSamplingString() {
    return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sce(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { blockSize: r, dataFormat: o } = s, a = i.shape[0], c = o === "NHWC" ? i.shape[1] : i.shape[2], l = o === "NHWC" ? i.shape[2] : i.shape[3], u = o === "NHWC" ? i.shape[3] : i.shape[1], h = c * r, d = l * r, f = u / (r * r), p = o === "NHWC" ? [a, h, d, f] : [a, f, h, d], y = new nce(p, r, o);
  return n.runWebGLProgram(y, [i], i.dtype);
}
const ice = {
  kernelName: Mx,
  backendName: "webgl",
  kernelFunc: sce
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class pO {
  constructor(e, n = !1, s = null, i = !1, r = !1) {
    this.variableNames = ["x", "W"], this.customUniforms = [
      { name: "pads", type: "ivec2" },
      { name: "strides", type: "ivec2" },
      { name: "dilations", type: "ivec2" },
      { name: "inDims", type: "ivec2" }
    ], this.outputShape = e.outShape, this.enableShapeUniforms = As(this.outputShape.length);
    const o = e.filterHeight, a = e.filterWidth, c = e.outChannels / e.inChannels;
    let l = "", u = "";
    s && (i ? l = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }` : r ? l = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }` : l = `
          float activation(float x) {
            ${s}
          }
        `, u = "result = activation(result);");
    const h = n ? "result += getBiasAtOutCoords();" : "";
    n && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${c};
        int q = d2 - d1 * ${c};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${u}
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class mO {
  constructor(e, n = !1, s = null, i = !1, r = !1) {
    this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [
      { name: "pads", type: "ivec2" },
      { name: "strides", type: "ivec2" },
      { name: "dilations", type: "ivec2" },
      { name: "inDims", type: "ivec2" }
    ], this.outputShape = e.outShape, this.enableShapeUniforms = As(this.outputShape.length);
    const o = e.outChannels / e.inChannels, a = e.padInfo.left, c = e.strideWidth, l = e.dilationWidth, u = e.filterHeight, h = e.filterWidth, d = h;
    let f = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
    for (let m = 0; m < h; m++)
      f += `
          vec4 xTexelC${m * 2};
          int xTexelC${m * 2}Ready;
          vec4 xTexelC${m * 2 + 1};
          int xTexelC${m * 2 + 1}Ready;
          vec4 xC${m};`;
    f += `
    for (int r = 0; r < ${u}; r++) {
      `;
    for (let m = 0; m < h; m++)
      f += `
          xTexelC${m * 2} = vec4(0.0);
          xTexelC${m * 2}Ready = 0;
          xTexelC${m * 2 + 1} = vec4(0.0);
          xTexelC${m * 2 + 1}Ready = 0;
          xC${m} = vec4(0.0);`;
    f += `
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
    for (let m = 0; m < (d + 1) / 2; m++) {
      const x = m * 2;
      if (f += `
          xC = xCCorner + ${x * l};
          `, c === 1) {
        if (x < h && (a % 2 === 1 ? (f += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `, l === 1 && x > 0 ? f += `
                xC${x} = vec4(xTexelC${x - 2}.zw, xTexelC${x}.xy);
                ` : f += `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `) : f += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `, x + 1 < h)) {
          const v = a % 2 === 0 ? gx(l) : l;
          l % 2 === 0 && a % 2 === 1 || l % 2 !== 0 && a % 2 !== 1 ? (f += `
                  xCOffset = xC + imod(pads[1], 2) + ${v};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x + 1}Ready == 0) {
                    xTexelC${x + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x + 1}.zw = vec2(0.0);
                    }
                    xTexelC${x + 1}Ready = 1;
                  }
                  `, l > 1 ? f += `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${x + 1} = vec4(previous.zw, xTexelC${x + 1}.xy);
                    } else {
                     xC${x + 1} = vec4(0.0, 0.0, xTexelC${x + 1}.xy);
                    }
                    ` : f += `
                    xC${x + 1} = vec4(xTexelC${x}.zw, xTexelC${x + 1}.xy);
                    `) : v === 1 ? f += `
                    xC${x + 1} = xTexelC${x};
                    ` : f += `
                    xCOffset = xC + ${v};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x + 1}Ready == 0) {
                      xTexelC${x + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x + 1}.zw = vec2(0.0);
                      }
                      xTexelC${x + 1}Ready = 1;
                    }

                    xC${x + 1} = xTexelC${x + 1};
                    `;
        }
      } else
        x < h && (a % 2 === 1 ? (f += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x + 1}Ready == 0) {
                  xTexelC${x + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x + 1}.zw = vec2(0.0);
                  }
                  xTexelC${x + 1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x + 1}.zw);
              `, x + 1 < h && (f += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x + 1} = vec4(xTexelC${x + 1}.xy, final.xy);
                `)) : (f += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x + 1}Ready == 0) {
                  xTexelC${x + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x + 1}.zw = vec2(0.);
                  }
                  xTexelC${x + 1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x + 1}.xy);
              `, x + 1 < h && (f += `
                  xC${x + 1} = vec4(xTexelC${x}.zw, xTexelC${x + 1}.zw);
                `)));
      x < h && (f += `
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `, x + 1 < h && (f += `
              wTexel = getW(r, ${x + 1}, d1, q);
              dotProd += xC${x + 1} * vec4(wTexel.xz, wTexel.xz);
            `));
    }
    f += `
    }
  `, f += `
      }
    `;
    let p = "", y = "";
    s && (i ? p = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }` : r ? p = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }` : p = `vec4 activation(vec4 x) {
          ${s}
        }`, y = "result = activation(result);");
    const g = n ? "result += getBiasAtOutCoords();" : "";
    n && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${y}
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rce(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, filter: r } = e, { strides: o, pad: a, dilations: c, dimRoundingMode: l } = s;
  let u = c;
  u == null && (u = [1, 1]), A(Ss(o, u), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);
  const h = hs(
    i.shape,
    r.shape,
    o,
    u,
    a,
    l,
    !0
    /* depthwise */
  );
  let d;
  ie().getBool("WEBGL_PACK_DEPTHWISECONV") && h.strideWidth <= 2 && h.outChannels / h.inChannels === 1 ? d = new mO(h) : d = new pO(h);
  const f = [
    [h.padInfo.top, h.padInfo.left],
    [h.strideHeight, h.strideWidth],
    [h.dilationHeight, h.dilationWidth],
    [h.inHeight, h.inWidth]
  ];
  return n.runWebGLProgram(d, [i, r], "float32", f);
}
const oce = {
  kernelName: Jf,
  backendName: "webgl",
  kernelFunc: rce
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ace {
  constructor(e) {
    this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
    const n = e.strideHeight, s = e.strideWidth, i = e.padInfo.top, r = e.padInfo.left, o = e.outChannels / e.inChannels;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
class cce {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
    const n = e.filterHeight, s = e.filterWidth, i = e.strideHeight, r = e.strideWidth, o = n - 1 - e.padInfo.top, a = s - 1 - e.padInfo.left, c = e.outChannels / e.inChannels;
    this.userCode = `
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${c}; dm++) {
              int d2 = d1 * ${c} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lce(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, dy: r } = e, { strides: o, dilations: a, pad: c, dimRoundingMode: l, filterShape: u } = s, h = hs(
    i.shape,
    u,
    o,
    a,
    c,
    l,
    !0
    /* depthwise */
  ), d = new ace(h);
  return n.runWebGLProgram(d, [i, r], "float32");
}
const uce = {
  kernelName: Rx,
  backendName: "webgl",
  kernelFunc: lce
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hce(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, filter: r } = e, { strides: o, dilations: a, pad: c, dimRoundingMode: l, inputShape: u } = s, h = hs(
    u,
    r.shape,
    o,
    a,
    c,
    l,
    !0
    /* depthwise */
  ), d = new cce(h);
  return n.runWebGLProgram(d, [i, r], "float32");
}
const dce = {
  kernelName: Dx,
  backendName: "webgl",
  kernelFunc: hce
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class fce {
  constructor(e) {
    this.variableNames = ["X"], this.outputShape = [e, e], this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pce(t) {
  const { inputs: e, backend: n } = t, { x: s } = e, i = [...s.shape, ...s.shape], r = ue(s.shape), o = ze({ inputs: { x: s }, backend: n, attrs: { shape: [r] } }), a = new fce(r), c = n.runWebGLProgram(a, [o], o.dtype), l = ze({ inputs: { x: c }, backend: n, attrs: { shape: i } });
  return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(c), l;
}
const mce = {
  kernelName: $x,
  backendName: "webgl",
  kernelFunc: pce
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class gce {
  constructor(e) {
    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    const { inHeight: n, inWidth: s, padInfo: i, strideHeight: r, strideWidth: o, filterHeight: a, filterWidth: c, dilationHeight: l, dilationWidth: u } = e, { top: h, left: d } = i;
    this.userCode = `
      const ivec2 strides = ivec2(${r}, ${o});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${c}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yce(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, filter: r } = e, { strides: o, pad: a, dilations: c } = s, l = Gp(i.shape, r.shape, o, a, "NHWC", c);
  let u;
  const h = new gce(l);
  u = n.runWebGLProgram(h, [i, r], "float32");
  const d = ze({ inputs: { x: u }, backend: n, attrs: { shape: l.outShape } });
  return n.disposeIntermediateTensorInfo(u), d;
}
const xce = {
  kernelName: Qf,
  backendName: "webgl",
  kernelFunc: yce
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bce(t) {
  const { inputs: e, backend: n, attrs: s } = t, { equation: i } = s, r = e, { allDims: o, summedDims: a, idDims: c } = W_(i, r.length);
  j_(o.length, c, r);
  const { path: l, steps: u } = q_(a, c), h = u.length;
  let d = null, f = o.length;
  const p = [];
  for (let y = 0; y < h; ++y) {
    for (const g of u[y]) {
      const { permutationIndices: m, expandDims: x } = H_(f, c[g]);
      let v;
      X_(m) ? v = r[g] : (v = Ws({ inputs: { x: r[g] }, backend: n, attrs: { perm: m } }), p.push(v));
      const b = v.shape.slice();
      for (let w = 0; w < x.length; ++w)
        b.splice(x[w], 0, 1);
      Bt(v.shape, b) || (v = ze({ inputs: { x: v }, backend: n, attrs: { shape: b } }), p.push(v)), d === null ? d = v : (d = OT({ inputs: { a: v, b: d }, backend: n }), p.push(d));
    }
    y < h - 1 && (l[y] >= 0 && (d = Ab({
      inputs: { x: d },
      backend: n,
      attrs: {
        axis: l[y] - (o.length - f),
        keepDims: !1
      }
    }), p.push(d)), f--);
  }
  for (const y of p)
    y !== d && n.disposeIntermediateTensorInfo(y);
  return d;
}
const vce = {
  kernelName: Lx,
  backendName: "webgl",
  kernelFunc: bce
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const wce = "return (x >= 0.0) ? x : (exp(x) - 1.0);", Sce = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`, _ce = Wt({ opSnippet: wce, packedOpSnippet: Sce }), Tce = {
  kernelName: Ku,
  backendName: "webgl",
  kernelFunc: _ce
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Cce = "return (b >= 0.0) ? a : a * (b + 1.0);", Ice = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`, Ece = (t) => {
  const { inputs: e, backend: n } = t, { dy: s, y: i } = e, r = ie().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Wh(Ice, s.shape, i.shape) : new Kc(Cce, s.shape, i.shape);
  return n.runWebGLProgram(r, [s, i], s.dtype);
}, Nce = {
  kernelName: Fx,
  backendName: "webgl",
  kernelFunc: Ece
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kce = `
  return vec4(equal(a, b));
`, Ace = "return float(a == b);", Mce = Cs({
  opSnippet: Ace,
  packedOpSnippet: kce,
  dtype: "bool",
  cpuKernelImpl: lie
}), Rce = {
  kernelName: ep,
  backendName: "webgl",
  kernelFunc: Mce
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Dce = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${F_};
  float a1 = ${P_};
  float a2 = ${B_};
  float a3 = ${z_};
  float a4 = ${V_};
  float a5 = ${U_};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`, $ce = Wt({ opSnippet: Dce }), Oce = {
  kernelName: Yu,
  backendName: "webgl",
  kernelFunc: $ce
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Lce = Hh + `
  return exp(x);
`, Fce = `
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, gO = Wt({
  opSnippet: Lce,
  packedOpSnippet: Fce,
  cpuKernelImpl: uie,
  dtype: "float32"
}), Pce = {
  kernelName: Zu,
  backendName: "webgl",
  kernelFunc: gO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function E1(t) {
  const { inputs: e, attrs: n, backend: s } = t, { dim: i } = n, { input: r } = e, o = r.shape.length, a = r.shape.slice();
  let c = i;
  return i < 0 && (A(-(o + 1) <= i, () => `Axis must be in the interval [${-(o + 1)}, ${o}]`), c = o + i + 1), a.splice(c, 0, 1), ze({ inputs: { x: r }, backend: s, attrs: { shape: a } });
}
const Bce = {
  kernelName: tp,
  backendName: "webgl",
  kernelFunc: E1
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const eE = "return exp(x) - 1.0;", zce = Wt({ opSnippet: eE, packedOpSnippet: eE, cpuKernelImpl: hie }), Vce = {
  kernelName: Ju,
  backendName: "webgl",
  kernelFunc: zce
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class tE {
  constructor(e, n, s) {
    this.variableNames = ["real", "imag"];
    const i = n[1];
    this.outputShape = n;
    const r = s ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`, o = s ? `${i}.0` : "1.0";
    let a;
    if (e === "real")
      a = "return real * expR - imag * expI;";
    else if (e === "imag")
      a = "return real * expI + imag * expR;";
    else
      throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);
    this.userCode = `
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yO(t, e, n) {
  const s = n.texData.get(t.dataId), i = ue(t.shape), r = t.shape[t.shape.length - 1], o = i / r, a = ze({ inputs: { x: t }, backend: n, attrs: { shape: [o, r] } }), c = a.shape, l = new tE("real", c, e), u = new tE("imag", c, e), h = [
    {
      dataId: s.complexTensorInfos.real.dataId,
      dtype: s.complexTensorInfos.real.dtype,
      shape: c
    },
    {
      dataId: s.complexTensorInfos.imag.dataId,
      dtype: s.complexTensorInfos.imag.dtype,
      shape: c
    }
  ], d = n.runWebGLProgram(l, h, "float32"), f = n.runWebGLProgram(u, h, "float32"), p = Ha({ inputs: { real: d, imag: f }, backend: n });
  n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(f);
  const y = ze({ inputs: { x: p }, backend: n, attrs: { shape: t.shape } });
  return n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(p), y;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Uce(t) {
  const { inputs: e, backend: n } = t, { input: s } = e;
  return yO(s, !1, n);
}
const Gce = {
  kernelName: Px,
  backendName: "webgl",
  kernelFunc: Uce
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Wce {
  constructor(e, n) {
    this.outputShape = [], this.customUniforms = [{ name: "value", type: "float" }], this.variableNames = ["x"], this.outputShape = e, this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Im(t) {
  const { backend: e, attrs: n } = t, { shape: s, value: i } = n;
  let { dtype: r } = n;
  if (r = r || Zc(i), r === "string") {
    const o = $n(r, ue(s));
    return o.fill(i), e.makeTensorInfo(s, r, o);
  } else {
    const o = new Wce(s, i), a = [[i]];
    return e.runWebGLProgram(o, [], r, a);
  }
}
const Hce = {
  kernelName: Bx,
  backendName: "webgl",
  kernelFunc: Im
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class jce {
  constructor(e) {
    this.variableNames = ["Image"], this.outputShape = [];
    const n = e[2];
    this.outputShape = e, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qce = {
  kernelName: zx,
  backendName: "webgl",
  kernelFunc: ({ inputs: t, backend: e }) => {
    const { image: n } = t, s = e, i = new jce(n.shape);
    return s.runWebGLProgram(i, [n], n.dtype);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nE = "return floor(x);", Xce = Wt({ opSnippet: nE, packedOpSnippet: nE, cpuKernelImpl: die }), Kce = {
  kernelName: Qu,
  backendName: "webgl",
  kernelFunc: Xce
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Yce = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`, Zce = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`, Jce = Cs({ opSnippet: Yce, packedOpSnippet: Zce, dtype: "int32" }), Qce = {
  kernelName: eh,
  backendName: "webgl",
  kernelFunc: Jce
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ele {
  constructor(e) {
    this.variableNames = ["A"];
    const n = qs(), [s, i] = e;
    this.outputShape = e, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${s}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class tle {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
    const n = qs(), [s, i] = e;
    this.outputShape = e, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${s}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nle = {
  kernelName: Dy,
  backendName: "webgl",
  kernelFunc: sle
};
let $l, Dv = ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
function sle(t) {
  const { inputs: e, backend: n, attrs: s } = t;
  let { pixels: i } = e;
  const { numChannels: r } = s, o = typeof HTMLVideoElement < "u" && i instanceof HTMLVideoElement, a = typeof HTMLImageElement < "u" && i instanceof HTMLImageElement, [c, l] = o ? [
    i.videoWidth,
    i.videoHeight
  ] : [i.width, i.height], u = [l, c], h = [l, c, r];
  if (a || o) {
    const y = ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
    ($l == null || y !== Dv) && (Dv = y, $l = document.createElement("canvas").getContext("2d", { willReadFrequently: Dv })), $l.canvas.width = c, $l.canvas.height = l, $l.drawImage(i, 0, 0, c, l), i = $l.canvas;
  }
  const d = n.makeTensorInfo(u, "int32");
  n.texData.get(d.dataId).usage = ki.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId), i);
  const f = ie().getBool("WEBGL_PACK") ? new tle(h) : new ele(h), p = n.runWebGLProgram(f, [d], "int32");
  return n.disposeData(d.dataId), p;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ile(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, filter: r, bias: o, preluActivationWeights: a } = e, { strides: c, pad: l, dataFormat: u, dilations: h, dimRoundingMode: d, activation: f, leakyreluAlpha: p } = s, y = Go(u), g = hs(i.shape, r.shape, c, h, l, d, !1, y);
  let m;
  const x = [], v = o != null, b = a != null, w = f === "leakyrelu", S = () => {
    const E = [i, r], I = (k, M) => {
      if (M === "NCHW" && k.shape.length === 1 && k.shape[0] !== 1) {
        const L = ze({
          inputs: { x: k },
          backend: n,
          attrs: { shape: [k.shape[0], 1, 1] }
        });
        return x.push(L), L;
      }
      return k;
    };
    if (v && E.push(I(o, u)), b && E.push(I(a, u)), w) {
      const k = n.makeTensorInfo([], "float32", Vo(p, "float32"));
      E.push(k), x.push(k);
    }
    return E;
  };
  if (g.filterHeight === 1 && g.filterWidth === 1 && g.dilationHeight === 1 && g.dilationWidth === 1 && g.strideHeight === 1 && g.strideWidth === 1 && (g.padInfo.type === "SAME" || g.padInfo.type === "VALID"))
    m = hO({
      x: i,
      filter: r,
      convInfo: g,
      backend: n,
      bias: o,
      activation: f,
      preluActivationWeights: a,
      leakyreluAlpha: p
    });
  else if (g.strideWidth <= 2 && y === "channelsLast" && ie().getBool("WEBGL_EXP_CONV")) {
    const E = f ? Ef(f, !0) : null, I = new uO(g, v, E, b, w), k = [
      [g.padInfo.top, g.padInfo.left],
      [g.strideHeight, g.strideWidth],
      [g.dilationHeight, g.dilationWidth],
      [g.inHeight, g.inWidth]
    ], M = S();
    m = n.runWebGLProgram(I, M, "float32", k);
  } else if (ie().getBool("WEBGL_CONV_IM2COL"))
    m = dO({
      x: i,
      filter: r,
      convInfo: g,
      backend: n,
      bias: o,
      activation: f,
      preluActivationWeights: a,
      leakyreluAlpha: p
    });
  else {
    const E = f ? Ef(f, !1) : null, I = new lO(g, v, E, b, w), k = S();
    m = n.runWebGLProgram(I, k, "float32");
  }
  const _ = ze({ inputs: { x: m }, backend: n, attrs: { shape: g.outShape } });
  return x.push(m), x.forEach((E) => n.disposeIntermediateTensorInfo(E)), _;
}
const rle = {
  kernelName: df,
  backendName: "webgl",
  kernelFunc: ile
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ole(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, filter: r, bias: o, preluActivationWeights: a } = e, { strides: c, pad: l, dilations: u, dimRoundingMode: h, activation: d, leakyreluAlpha: f } = s, p = [];
  let y = u;
  y == null && (y = [1, 1]), A(Ss(c, y), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${y}'`);
  const g = hs(
    i.shape,
    r.shape,
    c,
    y,
    l,
    h,
    !0
    /* depthwise */
  ), m = ie().getBool("WEBGL_PACK_DEPTHWISECONV") && g.strideWidth <= 2 && g.outChannels / g.inChannels === 1, x = d ? Ef(d, m) : null, v = [i, r], b = o != null, w = a != null, S = d === "leakyrelu";
  if (b && v.push(o), w && v.push(a), S) {
    const k = n.makeTensorInfo([], "float32", Vo(f, "float32"));
    v.push(k), p.push(k);
  }
  let _;
  m ? _ = new mO(g, b, x, w, S) : _ = new pO(g, b, x, w, S);
  const E = [
    [g.padInfo.top, g.padInfo.left],
    [g.strideHeight, g.strideWidth],
    [g.dilationHeight, g.dilationWidth],
    [g.inHeight, g.inWidth]
  ], I = n.runWebGLProgram(_, v, "float32", E);
  return p.forEach((k) => n.disposeIntermediateTensorInfo(k)), I;
}
const ale = {
  kernelName: ff,
  backendName: "webgl",
  kernelFunc: ole
};
class cle {
  constructor(e, n, s, i) {
    this.sliceDim = e, this.strides = n, this.paramsShape = i, this.variableNames = ["x", "indices"], this.outputShape = s;
    const r = rn(s.length);
    let o = `
    int index;`;
    for (let a = 0; a < this.sliceDim; a++)
      o += `
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;
    this.userCode = `
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lle(t) {
  const { inputs: e, backend: n } = t, { params: s, indices: i } = e, r = i.shape, o = r[r.length - 1], a = ue(s.shape), [c, l, u, h] = lb(s, i), d = ze({ inputs: { x: i }, backend: n, attrs: { shape: [l, o] } }), f = ze({
    inputs: { x: s },
    backend: n,
    attrs: { shape: [ue(s.shape) / u, u] }
  });
  if (n.shouldExecuteOnCPU([s, i]) || s.dtype === "string") {
    const m = n.readSync(i.dataId), x = n.bufferSync(s), v = fie(m, x, s.dtype, l, o, u, h, s.shape, a);
    return n.makeTensorInfo(c, s.dtype, v.values);
  }
  const p = new cle(o, h, [l, u], s.shape), y = n.runWebGLProgram(p, [f, d], f.dtype), g = ze({ inputs: { x: y }, backend: n, attrs: { shape: c } });
  return n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(y), g;
}
const ule = {
  kernelName: Vx,
  backendName: "webgl",
  kernelFunc: lle
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class hle {
  constructor(e, n) {
    this.variableNames = ["A", "indices"], this.outputShape = n, this.rank = n.length;
    const s = rn(this.rank), i = dle(e);
    this.userCode = `
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `;
  }
}
function dle(t, e) {
  const n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], s = [];
  for (let i = 0; i < t.length; i++)
    i === 2 ? s.push("index") : s.push(`${n[i]}`);
  return s.join();
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xO(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, indices: r } = e, { axis: o, batchDims: a } = s, c = Rt(o, i.shape)[0];
  if (ie().get("DEBUG")) {
    const x = n.readSync(r.dataId), v = i.shape[c];
    for (let b = 0; b < x.length; ++b) {
      const w = x[b];
      A(w <= v - 1 && w >= 0, () => `GatherV2: the index value ${w} is not in [0, ${v - 1}]`);
    }
  }
  const l = Y_(i, r, c, a), u = ue(r.shape), h = [], d = ze({
    inputs: { x: i },
    backend: n,
    attrs: {
      shape: [
        l.batchSize,
        l.outerSize,
        l.dimSize,
        l.sliceSize
      ]
    }
  }), f = ze({
    inputs: { x: r },
    backend: n,
    attrs: { shape: [l.batchSize, u / l.batchSize] }
  });
  h.push(d), h.push(f);
  const p = [
    l.batchSize,
    l.outerSize,
    u / l.batchSize,
    l.sliceSize
  ];
  if (n.shouldExecuteOnCPU([i, r]) || i.dtype === "string") {
    const x = n.bufferSync(f), v = n.bufferSync(d), b = pie(v, x, p);
    return h.forEach((w) => n.disposeIntermediateTensorInfo(w)), n.makeTensorInfo(l.outputShape, b.dtype, b.values);
  }
  const y = new hle(d.shape, p), g = n.runWebGLProgram(y, [d, f], d.dtype);
  h.push(g);
  const m = ze({ inputs: { x: g }, backend: n, attrs: { shape: l.outputShape } });
  return h.forEach((x) => n.disposeIntermediateTensorInfo(x)), m;
}
const fle = {
  kernelName: sp,
  backendName: "webgl",
  kernelFunc: xO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ple = "return float(a > b);", mle = `
  return vec4(greaterThan(a, b));
`, gle = Cs({
  opSnippet: ple,
  packedOpSnippet: mle,
  cpuKernelImpl: mie,
  dtype: "bool"
}), yle = {
  kernelName: ip,
  backendName: "webgl",
  kernelFunc: gle
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xle = "return float(a >= b);", ble = `
  return vec4(greaterThanEqual(a, b));
`, vle = Cs({
  opSnippet: xle,
  packedOpSnippet: ble,
  dtype: "bool",
  cpuKernelImpl: gie
}), wle = {
  kernelName: th,
  backendName: "webgl",
  kernelFunc: vle
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sle(t) {
  const { inputs: e, backend: n } = t, { input: s } = e;
  return yO(s, !0, n);
}
const _le = {
  kernelName: Ux,
  backendName: "webgl",
  kernelFunc: Sle
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Tle = "return float(!isnan(x) && !isinf(x));", Cle = Wt({ opSnippet: Tle, dtype: "bool" }), Ile = {
  kernelName: sh,
  backendName: "webgl",
  kernelFunc: Cle
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ele = "return float(isinf(x));", Nle = Wt({ opSnippet: Ele, dtype: "bool" }), kle = {
  kernelName: ih,
  backendName: "webgl",
  kernelFunc: Nle
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ale = "return float(isnan(x));", Mle = Wt({ opSnippet: Ale, dtype: "bool" }), Rle = {
  kernelName: rh,
  backendName: "webgl",
  kernelFunc: Mle
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Dle = "return float(a < b);", $le = `
  return vec4(lessThan(a, b));
`, Ole = Cs({
  opSnippet: Dle,
  packedOpSnippet: $le,
  cpuKernelImpl: yie,
  dtype: "bool"
}), Lle = {
  kernelName: op,
  backendName: "webgl",
  kernelFunc: Ole
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Fle = "return float(a <= b);", Ple = `
  return vec4(lessThanEqual(a, b));
`, Ble = Cs({
  opSnippet: Fle,
  packedOpSnippet: Ple,
  cpuKernelImpl: xie,
  dtype: "bool"
}), zle = {
  kernelName: ap,
  backendName: "webgl",
  kernelFunc: Ble
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Vle(t) {
  const { backend: e, attrs: n } = t, { start: s, stop: i, num: r } = n, o = bie(s, i, r);
  return e.makeTensorInfo([o.length], "float32", o);
}
const Ule = {
  kernelName: Wx,
  backendName: "webgl",
  kernelFunc: Vle
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Gle = Hh + `
  return x < 0.0 ? 0./0. : log(x);
`, Wle = `
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`, Hle = Wt({ opSnippet: Gle, packedOpSnippet: Wle, cpuKernelImpl: vie }), jle = {
  kernelName: oh,
  backendName: "webgl",
  kernelFunc: Hle
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qle = Hh + `
  return log(1.0 + x);
`, Xle = Wt({ opSnippet: qle }), Kle = {
  kernelName: ah,
  backendName: "webgl",
  kernelFunc: Xle
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Yle = "return float(a >= 1.0 && b >= 1.0);", Zle = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`, Jle = Cs({
  opSnippet: Yle,
  packedOpSnippet: Zle,
  dtype: "bool"
}), Qle = {
  kernelName: cp,
  backendName: "webgl",
  kernelFunc: Jle
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const eue = "return float(!(x >= 1.0));", tue = Wt({ opSnippet: eue }), nue = {
  kernelName: lp,
  backendName: "webgl",
  kernelFunc: tue
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sue = "return float(a >= 1.0 || b >= 1.0);", iue = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`, rue = Cs({ opSnippet: sue, packedOpSnippet: iue, dtype: "bool" }), oue = {
  kernelName: up,
  backendName: "webgl",
  kernelFunc: rue
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class aue {
  constructor(e, n, s, i, r) {
    this.variableNames = ["x"], this.outputShape = [];
    const o = n, a = e[3] - 1;
    this.outputShape = e;
    let c;
    const l = `float(${s}) + float(${i}) * sum`;
    r === 0.5 ? c = `inversesqrt(${l})` : r === 1 ? c = `1.0/(${l})` : c = `exp(log(${l}) * float(-${r}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${c};
        setOutput(val);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class cue {
  constructor(e, n, s, i, r) {
    this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
    const o = n, a = e[3] - 1;
    this.outputShape = e;
    let c;
    const l = `float(${s}) + float(${i}) * sum`;
    r === 0.5 ? c = `inversesqrt(${l})` : r === 1 ? c = `1.0/(${l})` : c = `exp(log(${l}) * float(-${r}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${c};
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const lue = (t) => {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { depthRadius: r, bias: o, alpha: a, beta: c } = s, l = ie().getBool("WEBGL_PACK_NORMALIZATION") ? new cue(i.shape, r, o, a, c) : new aue(i.shape, r, o, a, c);
  return n.runWebGLProgram(l, [i], i.dtype);
}, uue = {
  kernelName: hp,
  backendName: "webgl",
  kernelFunc: lue
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class hue {
  constructor(e, n, s, i, r) {
    this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = e, this.depth = e[3], this.depthRadius = n, this.bias = s, this.alpha = i, this.beta = r, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const due = (t) => {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, y: r, dy: o } = e, { depthRadius: a, bias: c, alpha: l, beta: u } = s, h = new hue(i.shape, a, c, l, u);
  return n.runWebGLProgram(h, [i, r, o], i.dtype);
}, fue = {
  kernelName: Hx,
  backendName: "webgl",
  kernelFunc: due
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pue(t, e, n, s) {
  const i = ue(e), o = ue(t.shape) / i, a = ze({ inputs: { x: t }, attrs: { shape: [o, i] }, backend: s }), c = dl(a, t.dtype, "max", s), l = ze({ inputs: { x: c }, attrs: { shape: n }, backend: s });
  return s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(c), l;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bO(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { reductionIndices: r, keepDims: o } = s, a = i.shape.length, c = Rt(r, i.shape);
  let l = c;
  const u = An(l, a), h = u != null, d = n.shouldExecuteOnCPU([i]);
  let f = i;
  if (h) {
    if (d) {
      const v = n.texData.get(f.dataId).values, b = new Array(a);
      for (let _ = 0; _ < b.length; _++)
        b[_] = i.shape[u[_]];
      const w = DT(v, i.shape, i.dtype, u, b);
      f = n.makeTensorInfo(b, i.dtype);
      const S = n.texData.get(f.dataId);
      S.values = w;
    } else
      f = kb(i, u, n);
    l = Vn(l.length, a);
  }
  _s("max", l, a);
  const [p, y] = ds(f.shape, l);
  let g = p;
  o && (g = zn(p, c));
  let m;
  if (d) {
    const v = n.texData.get(f.dataId).values, b = wie(v, ue(y), g, i.dtype);
    m = n.makeTensorInfo(g, i.dtype);
    const w = n.texData.get(m.dataId);
    w.values = b;
  } else
    m = pue(f, y, g, n);
  return h && n.disposeIntermediateTensorInfo(f), m;
}
const mue = {
  kernelName: dp,
  backendName: "webgl",
  kernelFunc: bO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const gue = $T + `
  return max(a, b);
`, yue = `
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + hl + `
  return result;
`, xue = Cs({
  opSnippet: gue,
  packedOpSnippet: yue,
  cpuKernelImpl: Sie
}), bue = {
  kernelName: ch,
  backendName: "webgl",
  kernelFunc: xue
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vue(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e;
  _m(i, "maxPool");
  const { filterSize: r, strides: o, pad: a, dimRoundingMode: c } = s, l = 1;
  A(Ss(o, l), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);
  const u = ir(i.shape, r, o, l, a, c);
  if (u.filterWidth === 1 && u.filterHeight === 1 && Bt(u.inShape, u.outShape))
    return Si({ inputs: { x: i }, backend: n });
  const h = new Nf(u, "max", !1);
  return n.runWebGLProgram(h, [i], i.dtype);
}
const wue = {
  kernelName: fp,
  backendName: "webgl",
  kernelFunc: vue
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sue(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { filterSize: r, strides: o, pad: a, dataFormat: c, dimRoundingMode: l } = s, u = [1, 1, 1], h = Uo(i.shape, r, o, u, a, l, c), d = new LT(h, "max", !1);
  return n.runWebGLProgram(d, [i], i.dtype);
}
const _ue = {
  kernelName: pp,
  backendName: "webgl",
  kernelFunc: Sue
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Tue {
  constructor(e) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
    const n = e.strideHeight, s = e.strideWidth, i = e.dilationHeight, r = e.effectiveFilterHeight, o = e.effectiveFilterWidth, a = r - 1 - e.padInfo.top, c = o - 1 - e.padInfo.left, l = r * o - 1;
    this.userCode = `
      const ivec2 pads = ivec2(${a}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
class Cue {
  constructor(e) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
    const n = e.strideDepth, s = e.strideHeight, i = e.strideWidth, r = e.dilationDepth, o = e.dilationHeight, a = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, u = e.effectiveFilterWidth, h = c - 1 - e.padInfo.front, d = l - 1 - e.padInfo.top, f = u - 1 - e.padInfo.left, p = c * l * u - 1;
    this.userCode = `
      const ivec3 pads = ivec3(${h}, ${d}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Iue(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, input: r } = e, o = r, { filterSize: a, strides: c, pad: l, dimRoundingMode: u } = s, h = [1, 1, 1], d = Uo(o.shape, a, c, h, l, u), f = new LT(
    d,
    "max",
    !0
    /* get positions */
  ), p = n.runWebGLProgram(f, [o], o.dtype), y = new Cue(d), g = n.runWebGLProgram(y, [i, p], o.dtype);
  return n.disposeIntermediateTensorInfo(p), g;
}
const Eue = {
  kernelName: qx,
  backendName: "webgl",
  kernelFunc: Iue
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nue(t) {
  const { inputs: e, backend: n, attrs: s } = t, { dy: i, input: r, output: o } = e, a = r;
  _m([r, o], "maxPoolGrad");
  const { filterSize: c, strides: l, pad: u, dimRoundingMode: h } = s, d = ir(a.shape, c, l, 1, u, h), f = !0, p = new Nf(d, "max", f), y = n.runWebGLProgram(p, [a], a.dtype), g = new Tue(d), m = n.runWebGLProgram(g, [i, y], a.dtype);
  return n.disposeIntermediateTensorInfo(y), m;
}
const kue = {
  kernelName: jx,
  backendName: "webgl",
  kernelFunc: Nue
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Aue(t, e, n, s) {
  let i = new Nf(n, "max", !1);
  const r = s.runWebGLProgram(i, [t], "float32");
  i = new Nf(n, "max", !0, !0, e);
  const o = s.runWebGLProgram(i, [t], "float32");
  return [r, o];
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Mue = {
  kernelName: Xx,
  backendName: "webgl",
  kernelFunc: ({ inputs: t, attrs: e, backend: n }) => {
    const { x: s } = t, { filterSize: i, strides: r, pad: o, includeBatchInIndex: a } = e, c = n;
    A(s.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);
    const l = [1, 1];
    A(Ss(r, l), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${l}'`);
    const u = ir(s.shape, i, r, l, o), [h, d] = Aue(s, a, u, c);
    return [h, d];
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Rue(t, e, n, s) {
  const i = ue(e), o = ue(t.shape) / i, a = ze({ inputs: { x: t }, attrs: { shape: [o, i] }, backend: s }), c = dl(a, "float32", "mean", s), l = ze({ inputs: { x: c }, attrs: { shape: n }, backend: s });
  return s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(c), l;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Due = {
  kernelName: mp,
  backendName: "webgl",
  kernelFunc: ({ inputs: t, attrs: e, backend: n }) => {
    const { x: s } = t, { keepDims: i, axis: r } = e, o = n, a = s.shape.length, c = Rt(r, s.shape);
    let l = c;
    const u = An(l, a), h = u != null, d = o.shouldExecuteOnCPU([s]), f = [];
    let p = s;
    if (h) {
      if (d) {
        const b = o.texData.get(p.dataId).values, w = new Array(a);
        for (let E = 0; E < w.length; E++)
          w[E] = s.shape[u[E]];
        const S = DT(b, s.shape, s.dtype, u, w);
        p = o.makeTensorInfo(w, s.dtype);
        const _ = o.texData.get(p.dataId);
        _.values = S;
      } else
        p = kb(s, u, o);
      f.push(p), l = Vn(l.length, a);
    }
    _s("sum", l, a);
    const [y, g] = ds(p.shape, l);
    let m = y;
    i && (m = zn(y, c));
    const x = Rue(p, g, m, o);
    for (const v of f)
      o.disposeIntermediateTensorInfo(v);
    return x;
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $ue(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, keepDims: o } = s, a = i.shape.length, c = Rt(r, i.shape);
  let l = c;
  const u = An(l, a);
  let h = i;
  u != null && (h = Ws({ inputs: { x: i }, backend: n, attrs: { perm: u } }), l = Vn(l.length, i.shape.length)), _s("min", l, a);
  const [d, f] = ds(h.shape, l), p = ue(f), y = ze({ inputs: { x: h }, backend: n, attrs: { shape: [-1, p] } }), g = dl(y, y.dtype, "min", n);
  let m;
  if (o) {
    const x = zn(d, c);
    m = ze({ inputs: { x: g }, backend: n, attrs: { shape: x } });
  } else
    m = ze({ inputs: { x: g }, backend: n, attrs: { shape: d } });
  return n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(g), u != null && n.disposeIntermediateTensorInfo(h), m;
}
const Oue = {
  kernelName: gp,
  backendName: "webgl",
  kernelFunc: $ue
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Lue = $T + `
  return min(a, b);
`, Fue = `
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + hl + `
  return result;
`, Pue = Cs({
  opSnippet: Lue,
  packedOpSnippet: Fue,
  cpuKernelImpl: _ie
}), Bue = {
  kernelName: lh,
  backendName: "webgl",
  kernelFunc: Pue
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class zue {
  constructor(e, n, s) {
    this.variableNames = ["x"], this.outputShape = n.map(
      (u, h) => u[0] + e[h] + u[1]
      /* afterPad */
    );
    const i = e.length, r = rn(i), o = n.map((u) => u[0]).join(","), a = n.map((u, h) => u[0] + e[h]).join(","), c = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, i), l = s === "reflect" ? 0 : 1;
    if (i === 1) {
      this.userCode = `
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;
      return;
    }
    this.userCode = `
      ${r} start = ${r}(${o});
      ${r} end = ${r}(${a});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${c}));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Vue {
  constructor(e, n, s) {
    this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n.map(
      (p, y) => p[0] + e[y] + p[1]
      /* afterPad */
    );
    const i = e.length, r = rn(i), o = n.map((p) => p[0]).join(","), a = n.map((p, y) => p[0] + e[y]).join(","), c = zs("rc", i), l = zs("source", i), u = `${c[i - 1]} < ${this.outputShape[i - 1]}`, h = i === 1 ? "source" : `vec2(${l.slice(-2).join()})`, d = s === "reflect" ? 0 : 1;
    let f = "";
    if (i === 1) {
      const p = `
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;
      f = `
        ${r} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${h});
        ${c[i - 1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${h});
        }
      `;
    } else {
      const p = `
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;
      f = `
        ${r} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${h});
        ${c[i - 1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${h});
        }
        rc = outputLoc;
        ${c[i - 2]} += 1;
        if(${c[i - 2]} < ${this.outputShape[i - 2]}) {
          ${p}
          result[2] = getChannel(getX(${l.join()}), ${h});
          ${c[i - 1]} += 1;
          if(${u}) {
            ${p}
            result[3] = getChannel(getX(${l.join()}), ${h});
          }
        }
      `;
    }
    this.userCode = `
      const ${r} start = ${r}(${o});
      const ${r} end = ${r}(${a});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Uue = ({ inputs: t, backend: e, attrs: n }) => {
  const { x: s } = t, { paddings: i, mode: r } = n, o = ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Vue(s.shape, i, r) : new zue(s.shape, i, r);
  return e.runWebGLProgram(o, [s], s.dtype);
}, Gue = {
  kernelName: yp,
  backendName: "webgl",
  kernelFunc: Uue
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Wue = `if (b == 0.0) return NAN;
  return mod(a, b);`, Hue = `
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  ` + hl + `
  return result;
`, jue = Cs({
  opSnippet: Wue,
  packedOpSnippet: Hue
}), que = {
  kernelName: uh,
  backendName: "webgl",
  kernelFunc: jue
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Xue {
  constructor(e, n, s) {
    this.variableNames = ["probs"], this.customUniforms = [{ name: "seed", type: "float" }], this.outputShape = [e, s], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n - 1}));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Kue = `
if (a == b) {
  return 1.0;
};
return a / b;`, Yue = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`, vO = Cs({ opSnippet: Kue, packedOpSnippet: Yue, checkOutOfBounds: !0 }), Zue = {
  kernelName: Xu,
  backendName: "webgl",
  kernelFunc: vO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sE = "return a - b;", wO = Cs({
  opSnippet: sE,
  packedOpSnippet: sE,
  supportsComplex: !0,
  cpuKernelImpl: Wie
}), Jue = {
  kernelName: Ih,
  backendName: "webgl",
  kernelFunc: wO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SO(t) {
  const { inputs: e, backend: n, attrs: s } = t, { logits: i } = e, { dim: r } = s, o = Rt([r], i.shape), a = bO({
    inputs: { x: i },
    backend: n,
    attrs: { reductionIndices: o, keepDims: !1 }
  }), c = zn(a.shape, o), l = ze({ inputs: { x: a }, backend: n, attrs: { shape: c } }), u = wO({ inputs: { a: i, b: l }, backend: n }), h = gO({ inputs: { x: u }, backend: n }), d = Ab({ inputs: { x: h }, backend: n, attrs: { axis: o, keepDims: !1 } }), f = ze({ inputs: { x: d }, backend: n, attrs: { shape: c } }), p = vO({ inputs: { a: h, b: f }, backend: n });
  return n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(f), p;
}
const Que = {
  kernelName: Op,
  backendName: "webgl",
  kernelFunc: SO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ehe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { logits: i } = e, { numSamples: r, seed: o, normalized: a } = s, c = a ? i : SO({ inputs: { logits: i }, backend: n, attrs: { dim: i.shape.length - 1 } }), l = c.shape[0], u = c.shape[1], h = new Xue(l, u, r), d = [[o]], f = n.runWebGLProgram(h, [c], "int32", d);
  return a || n.disposeIntermediateTensorInfo(c), f;
}
const the = {
  kernelName: Kx,
  backendName: "webgl",
  kernelFunc: ehe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nhe = or + `
  return -x;
`, she = `
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
function ihe(t) {
  const { inputs: e, backend: n } = t, { x: s } = e;
  if (n.shouldExecuteOnCPU([s])) {
    const r = n.texData.get(s.dataId), [o, a] = Cie(r.values, s.shape, s.dtype);
    return n.makeTensorInfo(a, s.dtype, o);
  }
  let i;
  return ie().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? i = new ua(s.shape, she) : i = new Hr(s.shape, nhe), n.runWebGLProgram(i, [s], s.dtype);
}
const rhe = {
  kernelName: xp,
  backendName: "webgl",
  kernelFunc: ihe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ohe = rb;
function ahe(t) {
  Ei("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  const { inputs: e, backend: n, attrs: s } = t, { boxes: i, scores: r } = e, { maxOutputSize: o, iouThreshold: a, scoreThreshold: c } = s, l = n.readSync(i.dataId), u = n.readSync(r.dataId), { selectedIndices: h } = ohe(l, u, o, a, c);
  return n.makeTensorInfo([h.length], "int32", new Int32Array(h));
}
const che = {
  kernelName: Yx,
  backendName: "webgl",
  kernelFunc: ahe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const lhe = ob;
function uhe(t) {
  Ei("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  const { inputs: e, backend: n, attrs: s } = t, { boxes: i, scores: r } = e, { maxOutputSize: o, iouThreshold: a, scoreThreshold: c, padToMaxOutputSize: l } = s, u = n.readSync(i.dataId), h = n.readSync(r.dataId), { selectedIndices: d, validOutputs: f } = lhe(u, h, o, a, c, l);
  return [
    n.makeTensorInfo([d.length], "int32", new Int32Array(d)),
    n.makeTensorInfo([], "int32", new Int32Array([f]))
  ];
}
const hhe = {
  kernelName: Zx,
  backendName: "webgl",
  kernelFunc: uhe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dhe = ab;
function fhe(t) {
  Ei("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  const { inputs: e, backend: n, attrs: s } = t, { boxes: i, scores: r } = e, { maxOutputSize: o, iouThreshold: a, scoreThreshold: c, softNmsSigma: l } = s, u = n.readSync(i.dataId), h = n.readSync(r.dataId), d = o, f = a, p = c, y = l, { selectedIndices: g, selectedScores: m } = dhe(u, h, d, f, p, y);
  return [
    n.makeTensorInfo([g.length], "int32", new Int32Array(g)),
    n.makeTensorInfo([m.length], "float32", new Float32Array(m))
  ];
}
const phe = {
  kernelName: Jx,
  backendName: "webgl",
  kernelFunc: fhe
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class mhe {
  constructor(e, n, s, i) {
    this.variableNames = ["indices"], this.outputShape = [e, n], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${s}),
                      float(index == coords.y)));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ghe = (t) => {
  const { inputs: e, backend: n, attrs: s } = t, { indices: i } = e, { dtype: r, depth: o, onValue: a, offValue: c } = s, l = ue(i.shape), u = new mhe(l, o, a, c), h = ze({ inputs: { x: i }, backend: n, attrs: { shape: [l] } }), d = n.runWebGLProgram(u, [h], r);
  n.disposeIntermediateTensorInfo(h);
  const f = [...i.shape, o], p = ze({ inputs: { x: d }, backend: n, attrs: { shape: f } });
  return n.disposeIntermediateTensorInfo(d), p;
}, yhe = {
  kernelName: wp,
  backendName: "webgl",
  kernelFunc: ghe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sx(t) {
  const { inputs: e, backend: n } = t, { x: s } = e;
  if (s.dtype === "complex64") {
    const i = Cm({ inputs: { input: s }, backend: n }), r = sx({ inputs: { x: i }, backend: n }), o = Mb({ inputs: { input: s }, backend: n }), a = sx({ inputs: { x: o }, backend: n }), c = Ha({ inputs: { real: r, imag: a }, backend: n });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(r), n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(a), c;
  } else
    return Im({
      attrs: {
        shape: s.shape,
        dtype: s.dtype,
        value: s.dtype === "string" ? "" : 0
      },
      backend: n
    });
}
const xhe = {
  kernelName: Bp,
  backendName: "webgl",
  kernelFunc: sx
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _O(t) {
  const { inputs: e, backend: n } = t, { x: s } = e;
  if (s.dtype === "string")
    throw new Error("onesLike is not supported under string dtype");
  if (s.dtype === "complex64") {
    const i = Cm({ inputs: { input: s }, backend: n }), r = _O({ inputs: { x: i }, backend: n }), o = Mb({ inputs: { input: s }, backend: n }), a = sx({ inputs: { x: o }, backend: n }), c = Ha({ inputs: { real: r, imag: a }, backend: n });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(r), n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(a), c;
  } else
    return Im({ attrs: { shape: s.shape, dtype: s.dtype, value: 1 }, backend: n });
}
const bhe = {
  kernelName: vp,
  backendName: "webgl",
  kernelFunc: _O
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vhe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { axis: i } = s;
  if (e.length === 1)
    return E1({ inputs: { input: e[0] }, backend: n, attrs: { dim: i } });
  const r = e[0].shape, o = e[0].dtype;
  e.forEach((u) => {
    ws(r, u.shape, "All tensors passed to stack must have matching shapes"), A(o === u.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  const a = [], c = e.map((u) => {
    const h = E1({ inputs: { input: u }, backend: n, attrs: { dim: i } });
    return a.push(h), h;
  }), l = cO({ inputs: c, backend: n, attrs: { axis: i } });
  return a.forEach((u) => n.disposeIntermediateTensorInfo(u)), l;
}
const whe = {
  kernelName: Sp,
  backendName: "webgl",
  kernelFunc: vhe
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class She {
  constructor(e, n, s) {
    this.variableNames = ["x"], this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = n.map(
      (l, u) => l[0] + e[u] + l[1]
      /* afterPad */
    );
    const i = e.length, r = rn(i), o = n.map((l) => l[0]).join(","), a = n.map((l, u) => l[0] + e[u]).join(","), c = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, i);
    if (i === 1) {
      this.userCode = `
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
      return;
    }
    this.userCode = `
      ${r} start = ${r}(${o});
      ${r} end = ${r}(${a});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${c}));
        }
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class _he {
  constructor(e, n, s) {
    this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = n.map(
      (y, g) => y[0] + e[g] + y[1]
      /* afterPad */
    );
    const i = e.length, r = rn(i), o = n.map((y) => y[0]).join(","), a = n.map((y, g) => y[0] + e[g]).join(","), c = zs("rc", i), l = zs("source", i), u = `${c[i - 1]} < ${this.outputShape[i - 1]}`, h = i === 1 ? "source" : `vec2(${l.slice(-2).join()})`, d = [
      `${r} rc = outputLoc;`,
      `${c[i - 1]} += 1;
       if(${u}) {
      `,
      i === 1 ? "" : `}
       rc = outputLoc;
       ${c[i - 2]} += 1;
       if(${c[i - 2]} < ${this.outputShape[i - 2]}) {`,
      i === 1 ? "" : `  ${c[i - 1]} += 1;
         if(${u}) {`
    ], f = i === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
    let p = "";
    for (let y = 0, g = i === 1 ? 2 : 4; y < g; y++)
      p += `
        ${d[y]}
        if (${f}) {
          result[${y}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${y}] = getChannel(getX(${l.join()}), ${h});
        }
      `;
    p += i === 1 ? "} " : "}}", this.userCode = `
      const ${r} start = ${r}(${o});
      const ${r} end = ${r}(${a});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const TO = (t) => {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { paddings: r, constantValue: o } = s;
  if (ue(i.shape) === 0) {
    const l = r.map(
      (u, h) => u[0] + i.shape[h] + u[1]
      /* afterPad */
    );
    return Im({
      backend: n,
      attrs: { shape: l, value: o, dtype: i.dtype }
    });
  }
  const a = ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new _he(i.shape, r, o) : new She(i.shape, r, o), c = [[o]];
  return n.runWebGLProgram(a, [i], i.dtype, c);
}, The = {
  kernelName: _p,
  backendName: "webgl",
  kernelFunc: TO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Che = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`, Ihe = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  ` + hl + `
  return result;
`, Ehe = Cs({ opSnippet: Che, packedOpSnippet: Ihe }), Nhe = {
  kernelName: dh,
  backendName: "webgl",
  kernelFunc: Ehe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function khe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { axis: r, keepDims: o } = s, a = i.shape.length, c = [], l = Rt(r, i.shape);
  let u = l;
  const h = An(u, a);
  let d = i;
  h != null && (d = Ws({ inputs: { x: i }, backend: n, attrs: { perm: h } }), u = Vn(u.length, a), c.push(d)), _s("prod", u, a);
  let f;
  if (n.shouldExecuteOnCPU([d])) {
    const p = n.texData.get(d.dataId).values, { outVals: y, outShape: g, outDtype: m } = Eie(d.shape, d.dtype, p, u);
    f = n.makeTensorInfo(g, m, y);
  } else {
    const [p, y] = ds(d.shape, u), g = ue(y), m = ze({ inputs: { x: d }, backend: n, attrs: { shape: [-1, g] } }), x = T0(i.dtype), v = dl(m, x, "prod", n);
    f = ze({ inputs: { x: v }, backend: n, attrs: { shape: p } }), c.push(m), c.push(v);
  }
  if (o) {
    c.push(f);
    const p = zn(f.shape, l);
    f = ze({ inputs: { x: f }, backend: n, attrs: { shape: p } });
  }
  return c.forEach((p) => n.disposeIntermediateTensorInfo(p)), f;
}
const Ahe = {
  kernelName: Cp,
  backendName: "webgl",
  kernelFunc: khe
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mhe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { paramsNestedSplits: i, paramsDenseValues: r, indices: o } = e, { outputRaggedRank: a } = s, c = i.map((m) => n.readSync(m.dataId)), l = i.map((m) => m.shape), u = n.readSync(r.dataId), h = n.readSync(o.dataId), [d, f, p] = Nie(c, l, u, r.shape, r.dtype, h, o.shape, a), y = d.map((m) => n.makeTensorInfo([m.length], "int32", m)), g = n.makeTensorInfo(p, r.dtype, f);
  return y.concat([g]);
}
const Rhe = {
  kernelName: Qx,
  backendName: "webgl",
  kernelFunc: Mhe
};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dhe(t) {
  const { inputs: e, backend: n } = t, { starts: s, limits: i, deltas: r } = e, o = n.readSync(s.dataId), a = n.readSync(i.dataId), c = n.readSync(r.dataId), [l, u] = kie(o, s.shape, s.dtype, a, i.shape, c, r.shape), h = n.makeTensorInfo([l.length], "int32", l), d = n.makeTensorInfo([u.length], s.dtype, u);
  return [h, d];
}
const $he = {
  kernelName: e0,
  backendName: "webgl",
  kernelFunc: Dhe
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ohe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { shape: i, values: r, defaultValue: o, rowPartitionTensors: a } = e, { rowPartitionTypes: c } = s, l = n.readSync(i.dataId), u = n.readSync(r.dataId), h = n.readSync(o.dataId), d = a.map((g) => n.readSync(g.dataId)), f = a.map((g) => g.shape), [p, y] = Aie(l, i.shape, u, r.shape, r.dtype, h, o.shape, d, f, c);
  return n.makeTensorInfo(p, r.dtype, y);
}
const Lhe = {
  kernelName: t0,
  backendName: "webgl",
  kernelFunc: Ohe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const CO = (t) => {
  const { backend: e, attrs: n } = t, { start: s, stop: i, step: r, dtype: o } = n, a = Mie(s, i, r, o);
  return e.makeTensorInfo([a.length], o, a);
}, Fhe = {
  kernelName: n0,
  backendName: "webgl",
  kernelFunc: CO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Phe = "return 1.0 / x;", Bhe = Wt({ opSnippet: Phe }), zhe = {
  kernelName: fh,
  backendName: "webgl",
  kernelFunc: Bhe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Vhe = or + `
  return (x < 0.0) ? 0.0 : x;
`, Uhe = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, Ghe = Wt({ opSnippet: Vhe, packedOpSnippet: Uhe }), Whe = {
  kernelName: ph,
  backendName: "webgl",
  kernelFunc: Ghe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Hhe = or + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`, jhe = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, qhe = Wt({ opSnippet: Hhe, packedOpSnippet: jhe }), Xhe = {
  kernelName: mh,
  backendName: "webgl",
  kernelFunc: qhe
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Khe {
  constructor(e, n, s, i, r) {
    this.variableNames = ["A"], this.outputShape = [];
    const [o, a, c, l] = e;
    this.outputShape = [o, n, s, l];
    const u = [
      i && n > 1 ? a - 1 : a,
      i && s > 1 ? c - 1 : c
    ], h = [
      i && n > 1 ? n - 1 : n,
      i && s > 1 ? s - 1 : s
    ];
    let d;
    r ? d = "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : d = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0] / h[0]},
          ${u[1] / h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Yhe {
  constructor(e, n, s, i, r) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
    const [o, a, c, l] = e;
    this.outputShape = [o, n, s, l];
    const u = [
      i && n > 1 ? a - 1 : a,
      i && s > 1 ? c - 1 : c
    ], h = [
      i && n > 1 ? n - 1 : n,
      i && s > 1 ? s - 1 : s
    ];
    let d;
    r ? d = "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : d = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0] / h[0]},
          ${u[1] / h[1]},
          ${u[1] / h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l - 1};
        bool hasNextRow = coords.z < ${s - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zhe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { images: i } = e, { alignCorners: r, halfPixelCenters: o, size: a } = s, [c, l] = a, u = ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new Yhe(i.shape, c, l, r, o) : new Khe(i.shape, c, l, r, o);
  return n.runWebGLProgram(u, [i], "float32");
}
const Jhe = {
  kernelName: Np,
  backendName: "webgl",
  kernelFunc: Zhe
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Qhe {
  constructor(e, n, s) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = n;
    const [, i, r] = n, [, o, a] = e, c = [
      s && o > 1 ? i - 1 : i,
      s && a > 1 ? r - 1 : r
    ], l = [
      s && o > 1 ? o - 1 : o,
      s && a > 1 ? a - 1 : a
    ], u = c[0] / l[0], h = c[1] / l[1], d = 1 / u, f = 1 / h, p = Math.ceil(d) * 2 + 2, y = Math.ceil(f) * 2 + 2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${p});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ede(t) {
  const { inputs: e, backend: n, attrs: s } = t, { images: i, dy: r } = e, { alignCorners: o } = s, a = new Qhe(r.shape, i.shape, o);
  return n.runWebGLProgram(a, [r], r.dtype);
}
const tde = {
  kernelName: r0,
  backendName: "webgl",
  kernelFunc: ede
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class nde {
  constructor(e, n, s, i, r) {
    this.variableNames = ["A"], this.outputShape = [];
    const [o, a, c, l] = e;
    this.outputShape = [o, n, s, l];
    const u = [
      i && n > 1 ? a - 1 : a,
      i && s > 1 ? c - 1 : c
    ], h = [
      i && n > 1 ? n - 1 : n,
      i && s > 1 ? s - 1 : s
    ], d = i ? "0.5" : "0.0";
    let f;
    r ? f = "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : f = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0] / h[0]},
          ${u[1] / h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class sde {
  constructor(e, n, s, i, r) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
    const [o, a, c, l] = e;
    this.outputShape = [o, n, s, l];
    const u = [
      i && n > 1 ? a - 1 : a,
      i && s > 1 ? c - 1 : c
    ], h = [
      i && n > 1 ? n - 1 : n,
      i && s > 1 ? s - 1 : s
    ], d = i ? "0.5" : "0.0";
    let f;
    r ? f = "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : f = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0] / h[0]},
          ${u[1] / h[1]},
          ${u[1] / h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l - 1};
        bool hasNextRow = coords.z < ${s - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ide(t) {
  const { inputs: e, backend: n, attrs: s } = t, { images: i } = e, { alignCorners: r, halfPixelCenters: o, size: a } = s, [c, l] = a, u = ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new sde(i.shape, c, l, r, o) : new nde(i.shape, c, l, r, o);
  return n.runWebGLProgram(u, [i], i.dtype);
}
const rde = {
  kernelName: Ep,
  backendName: "webgl",
  kernelFunc: ide
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ode {
  constructor(e, n, s) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = n;
    const [, i, r] = n, [, o, a] = e, c = [
      s && o > 1 ? i - 1 : i,
      s && a > 1 ? r - 1 : r
    ], l = [
      s && o > 1 ? o - 1 : o,
      s && a > 1 ? a - 1 : a
    ], u = c[0] / l[0], h = c[1] / l[1], d = 1 / u, f = 1 / h, p = Math.ceil(d) * 2 + 2, y = Math.ceil(f) * 2 + 2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${p});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${c[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${c[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ade(t) {
  const { inputs: e, backend: n, attrs: s } = t, { images: i, dy: r } = e, { alignCorners: o } = s, a = new ode(r.shape, i.shape, o);
  return n.runWebGLProgram(a, [r], r.dtype);
}
const cde = {
  kernelName: i0,
  backendName: "webgl",
  kernelFunc: ade
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class lde {
  constructor(e, n) {
    this.variableNames = ["x"];
    const s = e.length;
    if (s > 4)
      throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);
    if (this.outputShape = e, s === 1) {
      this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;
      return;
    }
    const i = (a) => n.indexOf(a) !== -1 && e[a] !== 1 ? `${e[a]} - coords[${a}] - 1` : `coords[${a}]`, r = e.map((a, c) => i(c)).join(","), o = rn(s);
    this.userCode = `
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ude {
  constructor(e, n) {
    this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
    const s = e.length;
    if (s > 4)
      throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);
    this.outputShape = e;
    const i = zs("rc", s), r = `${i[s - 1]} + 1 < ${this.outputShape[s - 1]}`, o = `${i[s - 2]} + 1 < ${this.outputShape[s - 2]}`, a = rn(s);
    s === 1 ? this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      ` : this.userCode = `
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${c(i.slice())};
          if(${r}){
            result.g = ${l(i.slice())};
          }
          if(${o}) {
            result.b = ${u(i.slice())};
            if(${r}) {
              result.a = ${h(i.slice())};
            }
          }
          setOutput(result);
        }
    `;
    function c(p) {
      return d(p);
    }
    function l(p) {
      return p[s - 1] = "(" + p[s - 1] + " + 1)", d(p);
    }
    function u(p) {
      return p[s - 2] = "(" + p[s - 2] + " + 1)", d(p);
    }
    function h(p) {
      return p[s - 1] = "(" + p[s - 1] + " + 1)", p[s - 2] = "(" + p[s - 2] + " + 1)", d(p);
    }
    function d(p) {
      const y = e.map((x, v) => f(v, p)), g = y.join(","), m = y.slice(-2).join(",");
      return `getChannel(getX(${g}), vec2(${m}))`;
    }
    function f(p, y) {
      return n.indexOf(p) !== -1 && e[p] !== 1 ? `${e[p]} - ${y[p]} - 1` : `${y[p]}`;
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hde(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { dims: r } = s, o = i.shape.length, a = Rt(r, i.shape);
  if (o === 0)
    return Si({ inputs: { x: i }, backend: n });
  const c = ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ude(i.shape, a) : new lde(i.shape, a);
  return n.runWebGLProgram(c, [i], i.dtype);
}
const dde = {
  kernelName: kp,
  backendName: "webgl",
  kernelFunc: hde
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class fde {
  constructor(e, n) {
    this.variableNames = ["Image"], this.outputShape = [], this.customUniforms = [{ name: "params", type: "vec4" }];
    const s = e[1], i = e[2];
    this.outputShape = e;
    let r = "";
    typeof n == "number" ? r = `float outputValue = ${n.toFixed(2)};` : r = `
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pde = {
  kernelName: S0,
  backendName: "webgl",
  kernelFunc: ({ inputs: t, attrs: e, backend: n }) => {
    const { image: s } = t, { radians: i, fillValue: r, center: o } = e, a = n, c = new fde(s.shape, r), [l, u] = $_(o, s.shape[1], s.shape[2]), h = [[l, u, Math.sin(i), Math.cos(i)]];
    return a.runWebGLProgram(c, [s], s.dtype, h);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const mde = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`, gde = Wt({ opSnippet: mde }), yde = {
  kernelName: gh,
  backendName: "webgl",
  kernelFunc: gde
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xde = "return inversesqrt(x);", bde = Wt({ opSnippet: xde, cpuKernelImpl: Rie }), vde = {
  kernelName: yh,
  backendName: "webgl",
  kernelFunc: bde
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class FT {
  constructor(e, n, s, i, r, o, a = !0, c = !1) {
    this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = o;
    const l = rn(r.length), u = rn(o.length);
    let h = "";
    s === 1 ? h = "i" : s === 2 && (h = "i, j");
    const d = `getIndices(${h})`;
    let f = "";
    i === 1 ? f = "i" : i === 2 && (f = "i, coords[1]");
    const p = `getUpdates(${f})`;
    let y = "";
    c && (y = "coords[0], coords[1]");
    const g = `getDefaultValue(${y})`, m = n > 1 ? "strides[j]" : "strides";
    this.userCode = `
        ${l} strides = ${l}(${r});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${m};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class wde {
  constructor(e, n, s, i, r, o, a = !0, c = !1) {
    this.variableNames = ["updates", "indices", "defaultValue"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = o;
    const l = rn(r.length), u = rn(o.length);
    let h = "";
    s === 1 ? h = "i" : s === 2 && (h = "i, j");
    const d = `getIndices(${h})`;
    let f = "";
    i === 1 ? f = "i" : i === 2 && (f = "i, coords[1]");
    const p = `getUpdates(${f})`;
    let y = "";
    c && (y = "coords[0], coords[1]");
    const g = `getDefaultValue(${y})`, m = n > 1 ? "strides[j]" : "strides", x = n > 1 ? "strides[j + 1]" : "strides";
    this.userCode = `
        ${l} strides = ${l}(${r});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${m};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${x};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sde(t) {
  const { inputs: e, backend: n, attrs: s } = t, { indices: i, updates: r } = e, { shape: o } = s, { sliceRank: a, numUpdates: c, sliceSize: l, strides: u, outputSize: h } = Ua(r, i, o), d = [h / l, l];
  if (h === 0)
    return n.makeTensorInfo(o, i.dtype);
  const f = ze({ inputs: { x: i }, backend: n, attrs: { shape: [c, a] } }), p = ze({ inputs: { x: r }, backend: n, attrs: { shape: [c, l] } }), y = n.makeTensorInfo([], "float32", new Float32Array([0]));
  let g;
  ie().getBool("WEBGL_PACK") ? g = new wde(c, a, f.shape.length, p.shape.length, u, d) : g = new FT(c, a, f.shape.length, p.shape.length, u, d);
  const m = n.runWebGLProgram(g, [p, f, y], p.dtype), x = ze({ inputs: { x: m }, backend: n, attrs: { shape: o } });
  return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(y), x;
}
const _de = {
  kernelName: o0,
  backendName: "webgl",
  kernelFunc: Sde
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Tde {
  constructor(e, n, s, i) {
    this.variableNames = ["sortedSequence", "values"], this.customUniforms = [{ name: "numInputs", type: "int" }], this.outputShape = [e, s];
    const r = "while (left < right) {", o = `for (int i = 0; i < ${Math.ceil(Math.log2(n + 1))}; ++i) { if (left >= right) break;`, a = ie().getNumber("WEBGL_VERSION") === 2 ? r : o, c = i === "left" ? "<" : "<=";
    this.userCode = `
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${c} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `;
  }
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Cde(t) {
  const { inputs: e, backend: n, attrs: s } = t, { sortedSequence: i, values: r } = e, { side: o } = s, a = new Tde(i.shape[0], i.shape[1], r.shape[1], o), c = [[i.shape[1]]];
  return n.runWebGLProgram(a, [i, r], "int32", c);
}
const Ide = {
  kernelName: c0,
  backendName: "webgl",
  kernelFunc: Cde
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Ede {
  constructor(e, n, s) {
    this.variableNames = ["c", "a", "b"], this.outputShape = n;
    let i, r;
    if (s > 4)
      throw Error(`Where for rank ${s} is not yet supported`);
    if (s === 1)
      r = "resRC", i = "resRC";
    else {
      const a = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], c = [], l = [];
      for (let u = 0; u < n.length; u++)
        l.push(`${a[u]}`), u < e && c.push(`${a[u]}`);
      i = c.join(), r = l.join();
    }
    const o = rn(s);
    this.userCode = `
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nde(t) {
  const { inputs: e, backend: n } = t, { condition: s, t: i, e: r } = e, o = new Ede(s.shape.length, i.shape, i.shape.length);
  return n.runWebGLProgram(o, [s, i, r], ni(i.dtype, r.dtype));
}
const kde = {
  kernelName: Ap,
  backendName: "webgl",
  kernelFunc: Nde
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ade = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${db};
  float scale = ${fb};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`, Mde = Wt({ opSnippet: Ade }), Rde = {
  kernelName: xh,
  backendName: "webgl",
  kernelFunc: Mde
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Dde = Hh + `
  return 1.0 / (1.0 + exp(-1.0 * x));
`, $de = `
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, Ode = Wt({
  opSnippet: Dde,
  packedOpSnippet: $de,
  cpuKernelImpl: $ie
}), Lde = {
  kernelName: Sh,
  backendName: "webgl",
  kernelFunc: Ode
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Fde = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`, Pde = Wt({ opSnippet: Fde }), Bde = {
  kernelName: wh,
  backendName: "webgl",
  kernelFunc: Pde
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const zde = Hh + `
  return sin(x);
`, Vde = `
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${hl}
  return result;
`, Ude = Wt({ opSnippet: zde, packedOpSnippet: Vde }), Gde = {
  kernelName: bh,
  backendName: "webgl",
  kernelFunc: Ude
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Wde = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`, Hde = Wt({ opSnippet: Wde }), jde = {
  kernelName: vh,
  backendName: "webgl",
  kernelFunc: Hde
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qde = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`, Xde = Wt({ opSnippet: qde }), Kde = {
  kernelName: _h,
  backendName: "webgl",
  kernelFunc: Xde
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Yde = (t) => {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { blockShape: r, paddings: o } = s;
  A(i.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
  const a = r.reduce((m, x) => m * x), c = [[0, 0]];
  c.push(...o);
  for (let m = 1 + r.length; m < i.shape.length; ++m)
    c.push([0, 0]);
  const l = [], u = TO({
    inputs: { x: i },
    backend: n,
    attrs: { paddings: c, constantValue: 0 }
  }), h = um(u.shape, r, a, !1), d = hm(h.length, r.length, !1), f = dm(u.shape, r, a, !1), p = ze({ inputs: { x: u }, backend: n, attrs: { shape: h } }), y = Ws({
    inputs: { x: p },
    backend: n,
    attrs: { perm: d }
  }), g = ze({ inputs: { x: y }, backend: n, attrs: { shape: f } });
  return l.push(u), l.push(p), l.push(y), l.forEach((m) => n.disposeIntermediateTensorInfo(m)), g;
}, Zde = {
  kernelName: Dp,
  backendName: "webgl",
  kernelFunc: Yde
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jde(t) {
  const { inputs: e, backend: n } = t, { indices: s, values: i, denseShape: r, defaultValue: o } = e;
  if (r.shape.length !== 1)
    throw new Error(`Dense shape must be a vector, saw:
         ${r.shape}`);
  if (s.shape.length !== 2)
    throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);
  if (i.shape.length !== 1)
    throw new Error(`Values must be a vector, saw:
         ${i.shape}`);
  if (o.shape.length !== 0)
    throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);
  const a = n.readSync(s.dataId), c = n.readSync(i.dataId), l = n.readSync(r.dataId), u = n.readSync(o.dataId)[0], [h, d, f, p, y] = Lie(a, s.shape, s.dtype, c, i.dtype, l, u);
  return [
    n.makeTensorInfo(d, s.dtype, h),
    n.makeTensorInfo([d[0]], i.dtype, f),
    n.makeTensorInfo([p.length], "bool", new Uint8Array(p.map((g) => Number(g)))),
    n.makeTensorInfo([y.length], s.dtype, new Int32Array(y))
  ];
}
const Qde = {
  kernelName: l0,
  backendName: "webgl",
  kernelFunc: Jde
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function efe(t) {
  const { inputs: e, backend: n } = t, { inputIndices: s, inputShape: i, newShape: r } = e;
  if (s.shape.length !== 2)
    throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);
  if (i.shape.length !== 1)
    throw new Error(`Input shape should be a vector but received shape ${i.shape}`);
  if (r.shape.length !== 1)
    throw new Error(`Target shape should be a vector but received shape ${r.shape}`);
  const o = Array.from(n.readSync(i.dataId)), a = n.readSync(s.dataId), c = Array.from(n.readSync(r.dataId)), [l, u, h] = Fie(a, s.shape, s.dtype, o, c);
  return [
    n.makeTensorInfo(u, s.dtype, l),
    n.makeTensorInfo([h.length], r.dtype, new Int32Array(h))
  ];
}
const tfe = {
  kernelName: u0,
  backendName: "webgl",
  kernelFunc: efe
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nfe(t) {
  const { inputs: e, backend: n } = t, { data: s, indices: i, segmentIds: r } = e;
  if (s.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (i.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);
  if (r.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
              ${r.shape}`);
  const o = n.readSync(s.dataId), a = n.readSync(i.dataId), c = n.readSync(r.dataId), [l, u] = K$(o, s.shape, s.dtype, a, c, !0);
  return n.makeTensorInfo(u, s.dtype, l);
}
const sfe = {
  kernelName: h0,
  backendName: "webgl",
  kernelFunc: nfe
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ife(t) {
  const { inputs: e, backend: n } = t, { data: s, indices: i, segmentIds: r } = e;
  if (s.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (i.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);
  if (r.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
             ${r.shape}`);
  const o = n.readSync(s.dataId), a = n.readSync(i.dataId), c = n.readSync(r.dataId), [l, u] = K$(o, s.shape, s.dtype, a, c);
  return n.makeTensorInfo(u, s.dtype, l);
}
const rfe = {
  kernelName: d0,
  backendName: "webgl",
  kernelFunc: ife
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ofe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { sparseIndices: i, sparseValues: r, defaultValue: o } = e, { outputShape: a } = s, { sliceRank: c, numUpdates: l, sliceSize: u, strides: h, outputSize: d } = Ua(r, i, a), f = !1;
  if (r.dtype === "string") {
    const m = n.bufferSync(i), x = n.bufferSync(r), v = Ro(n.readSync(o.dataId)[0]), b = Die(m, x, a, d, u, l, c, h, v, f);
    return n.makeTensorInfo(a, b.dtype, b.values);
  }
  const p = new FT(l, c, i.shape.length, r.shape.length, h, [d, 1], f), y = n.runWebGLProgram(p, [r, i, o], r.dtype), g = ze({ inputs: { x: y }, backend: n, attrs: { shape: a } });
  return n.disposeIntermediateTensorInfo(y), g;
}
const afe = {
  kernelName: f0,
  backendName: "webgl",
  kernelFunc: ofe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cfe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { numOrSizeSplits: r, axis: o } = s, a = Rt(o, i.shape)[0], c = K_(i, r, a), l = i.shape.length, u = new Array(l).fill(0), h = i.shape.slice();
  return c.map((d) => {
    const f = [...h];
    f[a] = d;
    const p = jh({ inputs: { x: i }, backend: n, attrs: { begin: u, size: f } });
    return u[a] += d, p;
  });
}
const lfe = {
  kernelName: $p,
  backendName: "webgl",
  kernelFunc: cfe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const iE = "return sqrt(x);", ufe = Wt({ opSnippet: iE, packedOpSnippet: iE, cpuKernelImpl: Pie }), hfe = {
  kernelName: Th,
  backendName: "webgl",
  kernelFunc: ufe
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dfe = "return x * x;", ffe = Wt({ opSnippet: dfe }), pfe = {
  kernelName: p0,
  backendName: "webgl",
  kernelFunc: ffe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const rE = "return (a - b) * (a - b);", mfe = Cs({ opSnippet: rE, packedOpSnippet: rE }), gfe = {
  kernelName: Ch,
  backendName: "webgl",
  kernelFunc: mfe
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yfe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e;
  if (i.dtype !== "string")
    throw new Error("Input must be of datatype string");
  const r = n.readSync(i.dataId), o = Fo(r), a = Bie(o, "string", s);
  return n.makeTensorInfo(i.shape, "string", a);
}
const xfe = {
  kernelName: Lp,
  backendName: "webgl",
  kernelFunc: yfe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bfe({ inputs: t, attrs: e, backend: n }) {
  const { x: s } = t, i = or + `
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `, r = new Hr(s.shape, i);
  return n.runWebGLProgram(r, [s], s.dtype);
}
const vfe = {
  kernelName: Ah,
  backendName: "webgl",
  kernelFunc: bfe
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class wfe {
  constructor(e, n, s) {
    this.variableNames = ["x"], this.outputShape = s;
    const i = s.length, r = rn(s.length), o = rn(s.length);
    let a = "";
    if (i === 1)
      a = "coords * strides + begin";
    else {
      let c = 0;
      a = s.map((l, u) => (c++, s.length === 1 ? `coords * strides[${u}] + begin[${u}]` : `coords[${c - 1}] * strides[${u}] + begin[${u}]`)).join(",");
    }
    this.userCode = `
      ${r} begin = ${r}(${e});
      ${r} strides = ${r}(${n});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sfe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { begin: r, end: o, strides: a, beginMask: c, endMask: l, ellipsisMask: u, newAxisMask: h, shrinkAxisMask: d } = s, { finalShapeSparse: f, finalShape: p, isIdentity: y, sliceDim0: g, isSimpleSlice: m, begin: x, end: v, strides: b } = A_(i.shape, r, o, a, c, l, u, h, d);
  let w;
  if (y)
    w = ze({ inputs: { x: i }, backend: n, attrs: { shape: p } });
  else if (g || m) {
    A(i.shape.length >= 1, () => `Input must have rank at least 1, got: ${i.shape.length}`);
    const _ = E_(x, v, b), E = jh({ inputs: { x: i }, backend: n, attrs: { begin: x, size: _ } });
    w = ze({ inputs: { x: E }, backend: n, attrs: { shape: p } }), n.disposeIntermediateTensorInfo(E);
  } else if (n.shouldExecuteOnCPU([i])) {
    const E = n.readSync(i.dataId), I = It(i.shape, i.dtype, E), k = zie(f, I, b, x);
    w = n.makeTensorInfo(p, i.dtype, k.values);
  } else {
    const E = new wfe(x, b, f);
    w = n.runWebGLProgram(E, [i], i.dtype);
  }
  const S = ze({ inputs: { x: w }, backend: n, attrs: { shape: p } });
  return n.disposeIntermediateTensorInfo(w), S;
}
const _fe = {
  kernelName: m0,
  backendName: "webgl",
  kernelFunc: Sfe
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Tfe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { separator: i, nGramWidths: r, leftPad: o, rightPad: a, padWidth: c, preserveShortSequences: l } = s, { data: u, dataSplits: h } = e, d = n.readSync(u.dataId), f = n.readSync(h.dataId), [p, y] = Vie(d, f, i, r, o, a, c, l);
  return [
    n.makeTensorInfo([p.length], "string", p),
    n.makeTensorInfo(h.shape, "int32", y)
  ];
}
const Cfe = {
  kernelName: g0,
  backendName: "webgl",
  kernelFunc: Tfe
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ife(t) {
  const { inputs: e, backend: n, attrs: s } = t, { skipEmpty: i } = s, { input: r, delimiter: o } = e;
  if (r.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (r.shape.length !== 1)
    throw new Error(`Input must be a vector, got shape: ${r.shape}`);
  if (o.shape.length !== 0)
    throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);
  const a = n.readSync(r.dataId), c = n.readSync(o.dataId)[0], [l, u, h] = Uie(a, c, i), d = u.length;
  return [
    n.makeTensorInfo([d, 2], "int32", l),
    n.makeTensorInfo([d], "string", u),
    n.makeTensorInfo([2], "int32", new Int32Array(h))
  ];
}
const Efe = {
  kernelName: y0,
  backendName: "webgl",
  kernelFunc: Ife
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nfe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { numBuckets: i } = s, { input: r } = e;
  if (r.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (i <= 0)
    throw new Error("Number of buckets must be at least 1");
  const o = n.readSync(r.dataId), a = Gie(o, i);
  return n.makeTensorInfo(r.shape, "int32", a);
}
const kfe = {
  kernelName: x0,
  backendName: "webgl",
  kernelFunc: Nfe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Afe = "return tan(x);", Mfe = Wt({ opSnippet: Afe }), Rfe = {
  kernelName: Eh,
  backendName: "webgl",
  kernelFunc: Mfe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Dfe = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`, $fe = Wt({ opSnippet: Dfe }), Ofe = {
  kernelName: Nh,
  backendName: "webgl",
  kernelFunc: $fe
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Lfe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { tensor: i, indices: r, updates: o } = e, { sliceRank: a, numUpdates: c, sliceSize: l, strides: u, outputSize: h } = Ua(o, r, i.shape), d = [h / l, l];
  if (h === 0)
    return n.makeTensorInfo(i.shape, r.dtype);
  const f = ze({ inputs: { x: r }, backend: n, attrs: { shape: [c, a] } }), p = ze({ inputs: { x: o }, backend: n, attrs: { shape: [c, l] } }), y = ze({ inputs: { x: i }, backend: n, attrs: { shape: d } }), g = new FT(c, a, f.shape.length, p.shape.length, u, d, !1, !0), m = n.runWebGLProgram(g, [p, f, y], y.dtype), x = ze({ inputs: { x: m }, backend: n, attrs: { shape: i.shape } });
  return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(m), x;
}
const Ffe = {
  kernelName: a0,
  backendName: "webgl",
  kernelFunc: Lfe
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Pfe {
  constructor(e, n) {
    this.variableNames = ["A"];
    const s = new Array(e.length);
    for (let o = 0; o < s.length; o++)
      s[o] = e[o] * n[o];
    this.outputShape = s, this.rank = s.length;
    const i = rn(this.rank), r = Bfe(e);
    this.userCode = `
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `;
  }
}
function Bfe(t) {
  const e = t.length;
  if (e > 5)
    throw Error(`Tile for rank ${e} is not yet supported`);
  if (e === 1)
    return `imod(resRC, ${t[0]})`;
  const n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], s = [];
  for (let i = 0; i < t.length; i++)
    s.push(`imod(${n[i]}, ${t[i]})`);
  return s.join();
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function IO(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { reps: r } = s;
  if (i.dtype === "string" || i.shape.length > 5) {
    const c = n.readSync(i.dataId), l = i.dtype === "string" ? c.map((d) => Ro(d)) : c, u = It(i.shape, i.dtype, l), h = Hie(u, r);
    return n.makeTensorInfo(h.shape, h.dtype, h.values);
  }
  const o = new Pfe(i.shape, r);
  return n.runWebGLProgram(o, [i], i.dtype);
}
const zfe = {
  kernelName: kh,
  backendName: "webgl",
  kernelFunc: IO
};
class Vfe {
  /**
   * @param shape desired output shape (can be larger than input shape, output
   *                                    will be padded with -Infinity)
   */
  constructor(e) {
    this.variableNames = ["x", "indices"], this.customUniforms = [
      { name: "n", type: "int" },
      { name: "firstPass", type: "int" },
      { name: "negativeInf", type: "float" },
      { name: "dir", type: "int" },
      { name: "inc", type: "int" }
    ], this.outputShape = e, this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
  }
}
class Ufe {
  /**
   * @param shape desired output shape (must be half of the input size)
   */
  constructor(e) {
    this.variableNames = ["x", "indices"], this.customUniforms = [
      { name: "n", type: "int" },
      { name: "firstPass", type: "int" },
      { name: "k", type: "int" }
    ], this.outputShape = e, this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oc(t, e) {
  e !== null && t.disposeIntermediateTensorInfo(e);
}
function oE(t) {
  let e = 1;
  for (; e < t; )
    e *= 2;
  return e;
}
function Gfe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i } = e, { k: r, sorted: o } = s, a = ie().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"), c = ie().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"), l = i.shape, u = l[l.length - 1];
  if (n.shouldExecuteOnCPU([i]) || u < a || r > c) {
    const k = n.readSync(i.dataId), [M, L] = jie(k, l, i.dtype, r, o);
    return [
      n.makeTensorInfo(M.shape, M.dtype, M.values),
      n.makeTensorInfo(L.shape, L.dtype, L.values)
    ];
  }
  if (r === 0)
    return l[l.length - 1] = 0, [
      n.makeTensorInfo(l, i.dtype, []),
      n.makeTensorInfo(l, "int32", [])
    ];
  if (u === 1)
    return [
      i,
      Im({ attrs: { shape: l, dtype: "int32", value: 0 }, backend: n })
    ];
  const h = n.texData.get(i.dataId), d = h !== null && h.isPacked, f = d ? n.unpackTensor(i) : i, y = ue(l) / u, g = ze({ inputs: { x: f }, attrs: { shape: [y, u] }, backend: n });
  d && oc(n, f);
  const m = oE(r), x = oE(u);
  let v = null;
  const b = () => v === null ? [g, g] : [g, v], w = (k, M, L) => {
    const O = b(), $ = new Vfe(L), z = [[u], [v === null ? 1 : 0], [Number.NEGATIVE_INFINITY], [k], [M]], W = v;
    v = n.runWebGLProgram($, O, "int32", z), oc(n, W);
  };
  for (let k = 1; k < m; k *= 2) {
    const M = k * 2;
    for (let L = k; L >= 1; L /= 2)
      w(M, L, [y, x]);
  }
  for (let k = x; k > m; k /= 2) {
    const M = b(), L = new Ufe([y, k / 2]), $ = [[u], [v === null ? 1 : 0], [m]], D = v;
    v = n.runWebGLProgram(L, M, "int32", $), oc(n, D);
    const z = m / 2, W = z * 2;
    for (let j = z; j >= 1; j /= 2)
      w(W, j, v.shape);
  }
  let S = v;
  v = jh({ inputs: { x: v }, backend: n, attrs: { begin: 0, size: [y, r] } }), oc(n, S);
  let _ = xO({ inputs: { x: g, indices: v }, backend: n, attrs: { axis: 1, batchDims: 1 } });
  oc(n, g);
  const E = l.slice(0, -1);
  E.push(r), S = v, v = ze({ inputs: { x: v }, attrs: { shape: E }, backend: n }), oc(n, S);
  const I = _;
  return _ = ze({ inputs: { x: _ }, attrs: { shape: E }, backend: n }), oc(n, I), [_, v];
}
const Wfe = {
  kernelName: b0,
  backendName: "webgl",
  kernelFunc: Gfe
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Hfe {
  constructor(e, n, s, i, r, o) {
    this.variableNames = ["Image", "Transforms"], this.outputShape = o;
    const a = s === "nearest" ? 1 : 2;
    let c;
    switch (i) {
      case "constant":
        c = 1;
        break;
      case "reflect":
        c = 2;
        break;
      case "wrap":
        c = 3;
        break;
      case "nearest":
        c = 4;
        break;
      default:
        c = 1;
        break;
    }
    this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${c} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
  }
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jfe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { image: i, transforms: r } = e, { interpolation: o, fillMode: a, fillValue: c, outputShape: l } = s, [u, h, d, f] = i.shape, [p, y] = l ?? [h, d], g = [
    u,
    p,
    y,
    f
  ], m = new Hfe(h, d, o, a, c, g);
  return n.runWebGLProgram(m, [i, r], "float32");
}
const qfe = {
  kernelName: v0,
  backendName: "webgl",
  kernelFunc: jfe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xfe(t) {
  const { inputs: e, attrs: n, backend: s } = t, { axis: i } = n, { x: r } = e;
  _m(r, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
  const o = s.readSync(r.dataId), { outputValues: a, outputShape: c, indices: l } = qie(o, i, r.shape, r.dtype);
  return [
    s.makeTensorInfo(c, r.dtype, a),
    s.makeTensorInfo([l.length], "int32", l)
  ];
}
const Kfe = {
  kernelName: w0,
  backendName: "webgl",
  kernelFunc: Xfe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yfe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { value: i } = e;
  let { axis: r } = s;
  r < 0 && (r += i.shape.length);
  const o = i, a = o.shape.length, c = i.shape[r], l = new Array(a - 1);
  let u = 0;
  for (let y = 0; y < a; y++)
    y !== r && (l[u++] = o.shape[y]);
  const h = [], d = new Array(a).fill(0), f = o.shape.slice();
  f[r] = 1;
  const p = new Array(c);
  for (let y = 0; y < p.length; y++) {
    d[r] = y;
    const g = jh({ inputs: { x: o }, backend: n, attrs: { begin: d, size: f } }), m = ze({ inputs: { x: g }, backend: n, attrs: { shape: l } });
    p[y] = m, h.push(g);
  }
  return h.forEach((y) => n.disposeIntermediateTensorInfo(y)), p;
}
const Zfe = {
  kernelName: Fp,
  backendName: "webgl",
  kernelFunc: Yfe
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Jfe {
  constructor(e, n) {
    this.variableNames = ["x", "segmentIds"];
    const s = e.windowSize, i = e.batchSize, r = e.inSize, o = e.numSegments, a = o * Math.ceil(r / s);
    this.outputShape = [i, a];
    const c = "0.0", l = "sumValue", u = Math.floor(s / 4) * 4, h = s % 4, d = `
        sumValue += dot(values, segFilter);
    `;
    let f = "";
    r % s > 0 && (f = `
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);
    let p = "";
    r % s > 0 && (p = `
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `), this.userCode = `
      const float initializationValue = ${c};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qfe(t) {
  const { inputs: e, backend: n, attrs: s } = t, { x: i, segmentIds: r } = e, { numSegments: o } = s, a = i.shape.length, c = [];
  let l = 0;
  const u = An([l], a);
  let h = i;
  u != null && (h = Ws({ inputs: { x: i }, backend: n, attrs: { perm: u } }), c.push(h), l = Vn(1, a)[0]);
  const d = nM(h.shape, l, o), f = ue([h.shape[l]]), p = ze({ inputs: { x: h }, backend: n, attrs: { shape: [-1, f] } });
  c.push(p);
  const y = T0(i.dtype), g = (b, w, S, _, E) => {
    const I = b.shape[0], k = b.shape[1], M = tM(k, E), L = { windowSize: M, inSize: k, batchSize: I, numSegments: E }, O = new Jfe(L, w), $ = n.compileAndRun(O, [b, S], _);
    if (c.push($), $.shape[1] === E)
      return $;
    const D = CO({
      backend: n,
      attrs: { start: 0, stop: E, step: 1, dtype: "float32" }
    }), z = IO({
      inputs: { x: D },
      backend: n,
      attrs: { reps: [k / M] }
    });
    return c.push(D), c.push(z), g($, w, z, _, E);
  }, m = g(p, "unsortedSegmentSum", r, y, o), x = ze({ inputs: { x: m }, backend: n, attrs: { shape: d } });
  let v = x;
  if (u != null) {
    c.push(x);
    const b = Ba(u);
    v = Ws({ inputs: { x: v }, backend: n, attrs: { perm: b } });
  }
  return c.forEach((b) => n.disposeIntermediateTensorInfo(b)), v;
}
const epe = {
  kernelName: Pp,
  backendName: "webgl",
  kernelFunc: Qfe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const tpe = [
  Pre,
  zre,
  Gre,
  jre,
  Xre,
  Zre,
  Qre,
  toe,
  roe,
  aoe,
  uoe,
  foe,
  goe,
  voe,
  _oe,
  Coe,
  Eoe,
  Moe,
  Doe,
  Ooe,
  Boe,
  joe,
  Xoe,
  Joe,
  eae,
  oae,
  cae,
  dae,
  wre,
  mae,
  vae,
  Tae,
  Aae,
  Dae,
  Oae,
  Fae,
  Bae,
  Gae,
  jae,
  Kae,
  Zae,
  Qae,
  tce,
  ice,
  oce,
  uce,
  dce,
  mce,
  xce,
  vce,
  Tce,
  Nce,
  Rce,
  Oce,
  Pce,
  Bce,
  Vce,
  Gce,
  Hce,
  qce,
  Kce,
  Qce,
  nle,
  rle,
  ale,
  ule,
  fle,
  yle,
  wle,
  vre,
  _le,
  xae,
  Ile,
  kle,
  Rle,
  _re,
  Lle,
  zle,
  Ule,
  jle,
  Kle,
  Qle,
  nue,
  oue,
  uue,
  fue,
  mue,
  bue,
  wue,
  _ue,
  Eue,
  kue,
  Mue,
  Due,
  Oue,
  Bue,
  Gue,
  que,
  the,
  Ire,
  rhe,
  che,
  hhe,
  phe,
  nae,
  yhe,
  bhe,
  whe,
  The,
  Nhe,
  Cre,
  Ahe,
  Rhe,
  $he,
  Lhe,
  Fhe,
  sae,
  Zue,
  zhe,
  Whe,
  Xhe,
  Nre,
  Jhe,
  tde,
  rde,
  cde,
  dde,
  pde,
  yde,
  vde,
  _de,
  Ide,
  kde,
  Rde,
  Lde,
  Bde,
  Gde,
  jde,
  Woe,
  Que,
  Kde,
  Zde,
  Qde,
  tfe,
  sfe,
  rfe,
  afe,
  lfe,
  hfe,
  pfe,
  gfe,
  xfe,
  vfe,
  _fe,
  Cfe,
  Efe,
  kfe,
  Jue,
  Ore,
  Rfe,
  Ofe,
  Ffe,
  zfe,
  Wfe,
  qfe,
  Lre,
  Kfe,
  Zfe,
  epe,
  xhe
];
for (const t of tpe)
  _0(t);
/**
    * @license
    * Copyright 2022 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */
var Af = function() {
  return Af = Object.assign || function(t) {
    for (var e, n = 1, s = arguments.length; n < s; n++)
      for (var i in e = arguments[n])
        Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    return t;
  }, Af.apply(this, arguments);
};
function Ic(t, e, n, s) {
  return new (n || (n = Promise))(function(i, r) {
    function o(l) {
      try {
        c(s.next(l));
      } catch (u) {
        r(u);
      }
    }
    function a(l) {
      try {
        c(s.throw(l));
      } catch (u) {
        r(u);
      }
    }
    function c(l) {
      var u;
      l.done ? i(l.value) : (u = l.value, u instanceof n ? u : new n(function(h) {
        h(u);
      })).then(o, a);
    }
    c((s = s.apply(t, e || [])).next());
  });
}
function Ec(t, e) {
  var n, s, i, r, o = { label: 0, sent: function() {
    if (1 & i[0])
      throw i[1];
    return i[1];
  }, trys: [], ops: [] };
  return r = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (r[Symbol.iterator] = function() {
    return this;
  }), r;
  function a(c) {
    return function(l) {
      return function(u) {
        if (n)
          throw new TypeError("Generator is already executing.");
        for (; o; )
          try {
            if (n = 1, s && (i = 2 & u[0] ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, u[1])).done)
              return i;
            switch (s = 0, i && (u = [2 & u[0], i.value]), u[0]) {
              case 0:
              case 1:
                i = u;
                break;
              case 4:
                return o.label++, { value: u[1], done: !1 };
              case 5:
                o.label++, s = u[1], u = [0];
                continue;
              case 7:
                u = o.ops.pop(), o.trys.pop();
                continue;
              default:
                if (i = o.trys, !((i = i.length > 0 && i[i.length - 1]) || u[0] !== 6 && u[0] !== 2)) {
                  o = 0;
                  continue;
                }
                if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
                  o.label = u[1];
                  break;
                }
                if (u[0] === 6 && o.label < i[1]) {
                  o.label = i[1], i = u;
                  break;
                }
                if (i && o.label < i[2]) {
                  o.label = i[2], o.ops.push(u);
                  break;
                }
                i[2] && o.ops.pop(), o.trys.pop();
                continue;
            }
            u = e.call(t, o);
          } catch (h) {
            u = [6, h], s = 0;
          } finally {
            n = i = 0;
          }
        if (5 & u[0])
          throw u[1];
        return { value: u[0] ? u[1] : void 0, done: !0 };
      }([c, l]);
    };
  }
}
var $v = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, npe = {};
(function() {
  var t;
  function e(T) {
    var N = 0;
    return function() {
      return N < T.length ? { done: !1, value: T[N++] } : { done: !0 };
    };
  }
  var n = typeof Object.defineProperties == "function" ? Object.defineProperty : function(T, N, B) {
    return T == Array.prototype || T == Object.prototype || (T[N] = B.value), T;
  }, s = function(T) {
    T = [typeof globalThis == "object" && globalThis, T, typeof window == "object" && window, typeof self == "object" && self, typeof $v == "object" && $v];
    for (var N = 0; N < T.length; ++N) {
      var B = T[N];
      if (B && B.Math == Math)
        return B;
    }
    throw Error("Cannot find global object");
  }(this);
  function i(T, N) {
    if (N)
      e: {
        var B = s;
        T = T.split(".");
        for (var K = 0; K < T.length - 1; K++) {
          var oe = T[K];
          if (!(oe in B))
            break e;
          B = B[oe];
        }
        (N = N(K = B[T = T[T.length - 1]])) != K && N != null && n(B, T, { configurable: !0, writable: !0, value: N });
      }
  }
  function r(T) {
    return (T = { next: T })[Symbol.iterator] = function() {
      return this;
    }, T;
  }
  function o(T) {
    var N = typeof Symbol < "u" && Symbol.iterator && T[Symbol.iterator];
    return N ? N.call(T) : { next: e(T) };
  }
  function a(T) {
    if (!(T instanceof Array)) {
      T = o(T);
      for (var N, B = []; !(N = T.next()).done; )
        B.push(N.value);
      T = B;
    }
    return T;
  }
  i("Symbol", function(T) {
    function N(oe, se) {
      this.g = oe, n(this, "description", { configurable: !0, writable: !0, value: se });
    }
    if (T)
      return T;
    N.prototype.toString = function() {
      return this.g;
    };
    var B = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", K = 0;
    return function oe(se) {
      if (this instanceof oe)
        throw new TypeError("Symbol is not a constructor");
      return new N(B + (se || "") + "_" + K++, se);
    };
  }), i("Symbol.iterator", function(T) {
    if (T)
      return T;
    T = Symbol("Symbol.iterator");
    for (var N = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), B = 0; B < N.length; B++) {
      var K = s[N[B]];
      typeof K == "function" && typeof K.prototype[T] != "function" && n(K.prototype, T, { configurable: !0, writable: !0, value: function() {
        return r(e(this));
      } });
    }
    return T;
  });
  var c, l = typeof Object.create == "function" ? Object.create : function(T) {
    function N() {
    }
    return N.prototype = T, new N();
  };
  if (typeof Object.setPrototypeOf == "function")
    c = Object.setPrototypeOf;
  else {
    var u;
    e: {
      var h = {};
      try {
        h.__proto__ = { a: !0 }, u = h.a;
        break e;
      } catch {
      }
      u = !1;
    }
    c = u ? function(T, N) {
      if (T.__proto__ = N, T.__proto__ !== N)
        throw new TypeError(T + " is not extensible");
      return T;
    } : null;
  }
  var d = c;
  function f(T, N) {
    if (T.prototype = l(N.prototype), T.prototype.constructor = T, d)
      d(T, N);
    else
      for (var B in N)
        if (B != "prototype")
          if (Object.defineProperties) {
            var K = Object.getOwnPropertyDescriptor(N, B);
            K && Object.defineProperty(T, B, K);
          } else
            T[B] = N[B];
    T.ea = N.prototype;
  }
  function p() {
    this.l = !1, this.i = null, this.h = void 0, this.g = 1, this.s = this.m = 0, this.j = null;
  }
  function y(T) {
    if (T.l)
      throw new TypeError("Generator is already running");
    T.l = !0;
  }
  function g(T, N) {
    T.j = { U: N, V: !0 }, T.g = T.m || T.s;
  }
  function m(T, N, B) {
    return T.g = B, { value: N };
  }
  function x(T) {
    this.g = new p(), this.h = T;
  }
  function v(T, N, B, K) {
    try {
      var oe = N.call(T.g.i, B);
      if (!(oe instanceof Object))
        throw new TypeError("Iterator result " + oe + " is not an object");
      if (!oe.done)
        return T.g.l = !1, oe;
      var se = oe.value;
    } catch (le) {
      return T.g.i = null, g(T.g, le), b(T);
    }
    return T.g.i = null, K.call(T.g, se), b(T);
  }
  function b(T) {
    for (; T.g.g; )
      try {
        var N = T.h(T.g);
        if (N)
          return T.g.l = !1, { value: N.value, done: !1 };
      } catch (B) {
        T.g.h = void 0, g(T.g, B);
      }
    if (T.g.l = !1, T.g.j) {
      if (N = T.g.j, T.g.j = null, N.V)
        throw N.U;
      return { value: N.return, done: !0 };
    }
    return { value: void 0, done: !0 };
  }
  function w(T) {
    this.next = function(N) {
      return y(T.g), T.g.i ? N = v(T, T.g.i.next, N, T.g.o) : (T.g.o(N), N = b(T)), N;
    }, this.throw = function(N) {
      return y(T.g), T.g.i ? N = v(T, T.g.i.throw, N, T.g.o) : (g(T.g, N), N = b(T)), N;
    }, this.return = function(N) {
      return function(B, K) {
        y(B.g);
        var oe = B.g.i;
        return oe ? v(B, "return" in oe ? oe.return : function(se) {
          return { value: se, done: !0 };
        }, K, B.g.return) : (B.g.return(K), b(B));
      }(T, N);
    }, this[Symbol.iterator] = function() {
      return this;
    };
  }
  function S(T, N) {
    return N = new w(new x(N)), d && T.prototype && d(N, T.prototype), N;
  }
  p.prototype.o = function(T) {
    this.h = T;
  }, p.prototype.return = function(T) {
    this.j = { return: T }, this.g = this.s;
  };
  var _ = typeof Object.assign == "function" ? Object.assign : function(T, N) {
    for (var B = 1; B < arguments.length; B++) {
      var K = arguments[B];
      if (K)
        for (var oe in K)
          Object.prototype.hasOwnProperty.call(K, oe) && (T[oe] = K[oe]);
    }
    return T;
  };
  i("Object.assign", function(T) {
    return T || _;
  }), i("Promise", function(T) {
    function N(le) {
      this.h = 0, this.i = void 0, this.g = [], this.o = !1;
      var be = this.j();
      try {
        le(be.resolve, be.reject);
      } catch (Ne) {
        be.reject(Ne);
      }
    }
    function B() {
      this.g = null;
    }
    function K(le) {
      return le instanceof N ? le : new N(function(be) {
        be(le);
      });
    }
    if (T)
      return T;
    B.prototype.h = function(le) {
      if (this.g == null) {
        this.g = [];
        var be = this;
        this.i(function() {
          be.l();
        });
      }
      this.g.push(le);
    };
    var oe = s.setTimeout;
    B.prototype.i = function(le) {
      oe(le, 0);
    }, B.prototype.l = function() {
      for (; this.g && this.g.length; ) {
        var le = this.g;
        this.g = [];
        for (var be = 0; be < le.length; ++be) {
          var Ne = le[be];
          le[be] = null;
          try {
            Ne();
          } catch (at) {
            this.j(at);
          }
        }
      }
      this.g = null;
    }, B.prototype.j = function(le) {
      this.i(function() {
        throw le;
      });
    }, N.prototype.j = function() {
      function le(at) {
        return function(Gt) {
          Ne || (Ne = !0, at.call(be, Gt));
        };
      }
      var be = this, Ne = !1;
      return { resolve: le(this.C), reject: le(this.l) };
    }, N.prototype.C = function(le) {
      if (le === this)
        this.l(new TypeError("A Promise cannot resolve to itself"));
      else if (le instanceof N)
        this.F(le);
      else {
        e:
          switch (typeof le) {
            case "object":
              var be = le != null;
              break e;
            case "function":
              be = !0;
              break e;
            default:
              be = !1;
          }
        be ? this.u(le) : this.m(le);
      }
    }, N.prototype.u = function(le) {
      var be = void 0;
      try {
        be = le.then;
      } catch (Ne) {
        return void this.l(Ne);
      }
      typeof be == "function" ? this.G(be, le) : this.m(le);
    }, N.prototype.l = function(le) {
      this.s(2, le);
    }, N.prototype.m = function(le) {
      this.s(1, le);
    }, N.prototype.s = function(le, be) {
      if (this.h != 0)
        throw Error("Cannot settle(" + le + ", " + be + "): Promise already settled in state" + this.h);
      this.h = le, this.i = be, this.h === 2 && this.D(), this.A();
    }, N.prototype.D = function() {
      var le = this;
      oe(function() {
        if (le.B()) {
          var be = s.console;
          be !== void 0 && be.error(le.i);
        }
      }, 1);
    }, N.prototype.B = function() {
      if (this.o)
        return !1;
      var le = s.CustomEvent, be = s.Event, Ne = s.dispatchEvent;
      return Ne === void 0 || (typeof le == "function" ? le = new le("unhandledrejection", { cancelable: !0 }) : typeof be == "function" ? le = new be("unhandledrejection", { cancelable: !0 }) : (le = s.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection", !1, !0, le), le.promise = this, le.reason = this.i, Ne(le));
    }, N.prototype.A = function() {
      if (this.g != null) {
        for (var le = 0; le < this.g.length; ++le)
          se.h(this.g[le]);
        this.g = null;
      }
    };
    var se = new B();
    return N.prototype.F = function(le) {
      var be = this.j();
      le.J(be.resolve, be.reject);
    }, N.prototype.G = function(le, be) {
      var Ne = this.j();
      try {
        le.call(be, Ne.resolve, Ne.reject);
      } catch (at) {
        Ne.reject(at);
      }
    }, N.prototype.then = function(le, be) {
      function Ne(We, Je) {
        return typeof We == "function" ? function(pt) {
          try {
            at(We(pt));
          } catch (dt) {
            Gt(dt);
          }
        } : Je;
      }
      var at, Gt, mt = new N(function(We, Je) {
        at = We, Gt = Je;
      });
      return this.J(Ne(le, at), Ne(be, Gt)), mt;
    }, N.prototype.catch = function(le) {
      return this.then(void 0, le);
    }, N.prototype.J = function(le, be) {
      function Ne() {
        switch (at.h) {
          case 1:
            le(at.i);
            break;
          case 2:
            be(at.i);
            break;
          default:
            throw Error("Unexpected state: " + at.h);
        }
      }
      var at = this;
      this.g == null ? se.h(Ne) : this.g.push(Ne), this.o = !0;
    }, N.resolve = K, N.reject = function(le) {
      return new N(function(be, Ne) {
        Ne(le);
      });
    }, N.race = function(le) {
      return new N(function(be, Ne) {
        for (var at = o(le), Gt = at.next(); !Gt.done; Gt = at.next())
          K(Gt.value).J(be, Ne);
      });
    }, N.all = function(le) {
      var be = o(le), Ne = be.next();
      return Ne.done ? K([]) : new N(function(at, Gt) {
        function mt(pt) {
          return function(dt) {
            We[pt] = dt, --Je == 0 && at(We);
          };
        }
        var We = [], Je = 0;
        do
          We.push(void 0), Je++, K(Ne.value).J(mt(We.length - 1), Gt), Ne = be.next();
        while (!Ne.done);
      });
    }, N;
  }), i("Object.is", function(T) {
    return T || function(N, B) {
      return N === B ? N !== 0 || 1 / N == 1 / B : N != N && B != B;
    };
  }), i("Array.prototype.includes", function(T) {
    return T || function(N, B) {
      var K = this;
      K instanceof String && (K = String(K));
      var oe = K.length;
      for (0 > (B = B || 0) && (B = Math.max(B + oe, 0)); B < oe; B++) {
        var se = K[B];
        if (se === N || Object.is(se, N))
          return !0;
      }
      return !1;
    };
  }), i("String.prototype.includes", function(T) {
    return T || function(N, B) {
      if (this == null)
        throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");
      if (N instanceof RegExp)
        throw new TypeError("First argument to String.prototype.includes must not be a regular expression");
      return this.indexOf(N, B || 0) !== -1;
    };
  }), i("Array.prototype.keys", function(T) {
    return T || function() {
      return function(N, B) {
        N instanceof String && (N += "");
        var K = 0, oe = !1, se = { next: function() {
          if (!oe && K < N.length) {
            var le = K++;
            return { value: B(le, N[le]), done: !1 };
          }
          return oe = !0, { done: !0, value: void 0 };
        } };
        return se[Symbol.iterator] = function() {
          return se;
        }, se;
      }(this, function(N) {
        return N;
      });
    };
  });
  var E = this || self;
  function I(T, N) {
    T = T.split(".");
    var B, K = E;
    for ((T[0] in K) || K.execScript === void 0 || K.execScript("var " + T[0]); T.length && (B = T.shift()); )
      T.length || N === void 0 ? K = K[B] && K[B] !== Object.prototype[B] ? K[B] : K[B] = {} : K[B] = N;
  }
  function k(T, N) {
    return N = String.fromCharCode.apply(null, N), T == null ? N : T + N;
  }
  var M, L, O = typeof TextDecoder < "u", $ = typeof TextEncoder < "u";
  function D(T) {
    if ($)
      T = (L || (L = new TextEncoder())).encode(T);
    else {
      var N = void 0;
      N = N !== void 0 && N;
      for (var B = 0, K = new Uint8Array(3 * T.length), oe = 0; oe < T.length; oe++) {
        var se = T.charCodeAt(oe);
        if (128 > se)
          K[B++] = se;
        else {
          if (2048 > se)
            K[B++] = se >> 6 | 192;
          else {
            if (55296 <= se && 57343 >= se) {
              if (56319 >= se && oe < T.length) {
                var le = T.charCodeAt(++oe);
                if (56320 <= le && 57343 >= le) {
                  se = 1024 * (se - 55296) + le - 56320 + 65536, K[B++] = se >> 18 | 240, K[B++] = se >> 12 & 63 | 128, K[B++] = se >> 6 & 63 | 128, K[B++] = 63 & se | 128;
                  continue;
                }
                oe--;
              }
              if (N)
                throw Error("Found an unpaired surrogate");
              se = 65533;
            }
            K[B++] = se >> 12 | 224, K[B++] = se >> 6 & 63 | 128;
          }
          K[B++] = 63 & se | 128;
        }
      }
      T = K.subarray(0, B);
    }
    return T;
  }
  var z = {}, W = null;
  function j(T, N) {
    N === void 0 && (N = 0), ne(), N = z[N];
    for (var B = Array(Math.floor(T.length / 3)), K = N[64] || "", oe = 0, se = 0; oe < T.length - 2; oe += 3) {
      var le = T[oe], be = T[oe + 1], Ne = T[oe + 2], at = N[le >> 2];
      le = N[(3 & le) << 4 | be >> 4], be = N[(15 & be) << 2 | Ne >> 6], Ne = N[63 & Ne], B[se++] = at + le + be + Ne;
    }
    switch (at = 0, Ne = K, T.length - oe) {
      case 2:
        Ne = N[(15 & (at = T[oe + 1])) << 2] || K;
      case 1:
        T = T[oe], B[se] = N[T >> 2] + N[(3 & T) << 4 | at >> 4] + Ne + K;
    }
    return B.join("");
  }
  function J(T) {
    var N = T.length, B = 3 * N / 4;
    B % 3 ? B = Math.floor(B) : "=.".indexOf(T[N - 1]) != -1 && (B = "=.".indexOf(T[N - 2]) != -1 ? B - 2 : B - 1);
    var K = new Uint8Array(B), oe = 0;
    return function(se, le) {
      function be(Je) {
        for (; Ne < se.length; ) {
          var pt = se.charAt(Ne++), dt = W[pt];
          if (dt != null)
            return dt;
          if (!/^[\s\xa0]*$/.test(pt))
            throw Error("Unknown base64 encoding at char: " + pt);
        }
        return Je;
      }
      ne();
      for (var Ne = 0; ; ) {
        var at = be(-1), Gt = be(0), mt = be(64), We = be(64);
        if (We === 64 && at === -1)
          break;
        le(at << 2 | Gt >> 4), mt != 64 && (le(Gt << 4 & 240 | mt >> 2), We != 64 && le(mt << 6 & 192 | We));
      }
    }(T, function(se) {
      K[oe++] = se;
    }), K.subarray(0, oe);
  }
  function ne() {
    if (!W) {
      W = {};
      for (var T = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), N = ["+/=", "+/", "-_=", "-_.", "-_"], B = 0; 5 > B; B++) {
        var K = T.concat(N[B].split(""));
        z[B] = K;
        for (var oe = 0; oe < K.length; oe++) {
          var se = K[oe];
          W[se] === void 0 && (W[se] = oe);
        }
      }
    }
  }
  var re, fe = typeof Uint8Array.prototype.slice == "function";
  function ae(T, N, B) {
    return N === B ? re || (re = new Uint8Array(0)) : fe ? T.slice(N, B) : new Uint8Array(T.subarray(N, B));
  }
  var ve = 0;
  function me(T, N) {
    N = (N = N === void 0 ? {} : N).v !== void 0 && N.v, this.h = null, this.g = this.i = this.j = 0, this.l = !1, this.v = N, T && te(this, T);
  }
  function te(T, N) {
    N = N.constructor === Uint8Array ? N : N.constructor === ArrayBuffer || N.constructor === Array ? new Uint8Array(N) : N.constructor === String ? J(N) : N instanceof Uint8Array ? new Uint8Array(N.buffer, N.byteOffset, N.byteLength) : new Uint8Array(0), T.h = N, T.j = 0, T.i = T.h.length, T.g = T.j;
  }
  function $e(T) {
    var N = T.h, B = N[T.g], K = 127 & B;
    return 128 > B ? (T.g += 1, K) : (K |= (127 & (B = N[T.g + 1])) << 7, 128 > B ? (T.g += 2, K) : (K |= (127 & (B = N[T.g + 2])) << 14, 128 > B ? (T.g += 3, K) : (K |= (127 & (B = N[T.g + 3])) << 21, 128 > B ? (T.g += 4, K) : (K |= (15 & (B = N[T.g + 4])) << 28, 128 > B ? (T.g += 5, K >>> 0) : (T.g += 5, 128 <= N[T.g++] && 128 <= N[T.g++] && 128 <= N[T.g++] && 128 <= N[T.g++] && T.g++, K)))));
  }
  function _e(T) {
    var N = T.h[T.g], B = T.h[T.g + 1], K = T.h[T.g + 2], oe = T.h[T.g + 3];
    return T.g += 4, T = 2 * ((B = (N << 0 | B << 8 | K << 16 | oe << 24) >>> 0) >> 31) + 1, N = B >>> 23 & 255, B &= 8388607, N == 255 ? B ? NaN : 1 / 0 * T : N == 0 ? T * Math.pow(2, -149) * B : T * Math.pow(2, N - 150) * (B + Math.pow(2, 23));
  }
  me.prototype.reset = function() {
    this.g = this.j;
  };
  var ke = [];
  function Re() {
    this.g = new Uint8Array(64), this.h = 0;
  }
  function ce(T, N) {
    for (; 127 < N; )
      T.push(127 & N | 128), N >>>= 7;
    T.push(N);
  }
  function xe(T) {
    var N = {}, B = N.N !== void 0 && N.N;
    this.o = { v: N.v !== void 0 && N.v }, this.N = B, N = this.o, ke.length ? (B = ke.pop(), N && (B.v = N.v), T && te(B, T), T = B) : T = new me(T, N), this.g = T, this.m = this.g.g, this.h = this.i = this.l = -1, this.j = !1;
  }
  function we(T) {
    var N = T.g;
    if ((N = N.g == N.i) || (N = T.j) || (N = (N = T.g).l || 0 > N.g || N.g > N.i), N)
      return !1;
    T.m = T.g.g;
    var B = 7 & (N = $e(T.g));
    return B != 0 && B != 5 && B != 1 && B != 2 && B != 3 && B != 4 ? (T.j = !0, !1) : (T.i = N, T.l = N >>> 3, T.h = B, !0);
  }
  function Pe(T) {
    switch (T.h) {
      case 0:
        if (T.h != 0)
          Pe(T);
        else {
          for (T = T.g; 128 & T.h[T.g]; )
            T.g++;
          T.g++;
        }
        break;
      case 1:
        T.h != 1 ? Pe(T) : (T = T.g).g += 8;
        break;
      case 2:
        if (T.h != 2)
          Pe(T);
        else {
          var N = $e(T.g);
          (T = T.g).g += N;
        }
        break;
      case 5:
        T.h != 5 ? Pe(T) : (T = T.g).g += 4;
        break;
      case 3:
        for (N = T.l; ; ) {
          if (!we(T)) {
            T.j = !0;
            break;
          }
          if (T.h == 4) {
            T.l != N && (T.j = !0);
            break;
          }
          Pe(T);
        }
        break;
      default:
        T.j = !0;
    }
  }
  function Me(T, N, B) {
    var K = T.g.i, oe = $e(T.g);
    return oe = T.g.g + oe, T.g.i = oe, B(N, T), T.g.g = oe, T.g.i = K, N;
  }
  function Ge(T) {
    var N, B = $e(T.g), K = (T = T.g).g;
    if (T.g += B, T = T.h, O)
      (N = M) || (N = M = new TextDecoder("utf-8", { fatal: !1 })), N = N.decode(T.subarray(K, K + B));
    else {
      B = K + B;
      for (var oe, se, le, be = [], Ne = null; K < B; )
        128 > (oe = T[K++]) ? be.push(oe) : 224 > oe ? K >= B ? be.push(65533) : (se = T[K++], 194 > oe || (192 & se) != 128 ? (K--, be.push(65533)) : be.push((31 & oe) << 6 | 63 & se)) : 240 > oe ? K >= B - 1 ? be.push(65533) : (192 & (se = T[K++])) != 128 || oe === 224 && 160 > se || oe === 237 && 160 <= se || (192 & (N = T[K++])) != 128 ? (K--, be.push(65533)) : be.push((15 & oe) << 12 | (63 & se) << 6 | 63 & N) : 244 >= oe ? K >= B - 2 ? be.push(65533) : (192 & (se = T[K++])) != 128 || se - 144 + (oe << 28) >> 30 || (192 & (N = T[K++])) != 128 || (192 & (le = T[K++])) != 128 ? (K--, be.push(65533)) : (oe = (7 & oe) << 18 | (63 & se) << 12 | (63 & N) << 6 | 63 & le, oe -= 65536, be.push(55296 + (oe >> 10 & 1023), 56320 + (1023 & oe))) : be.push(65533), 8192 <= be.length && (Ne = k(Ne, be), be.length = 0);
      N = k(Ne, be);
    }
    return N;
  }
  function F() {
    this.h = [], this.i = 0, this.g = new Re();
  }
  function V(T, N) {
    N.length !== 0 && (T.h.push(N), T.i += N.length);
  }
  function Ae(T) {
    var N = T.i + T.g.length();
    if (N === 0)
      return new Uint8Array(0);
    N = new Uint8Array(N);
    for (var B = T.h, K = B.length, oe = 0, se = 0; se < K; se++) {
      var le = B[se];
      le.length !== 0 && (N.set(le, oe), oe += le.length);
    }
    return (K = (B = T.g).h) !== 0 && (N.set(B.g.subarray(0, K), oe), B.h = 0), T.h = [N], N;
  }
  function ge(T, N, B) {
    if (B != null) {
      ce(T.g, 8 * N + 5), T = T.g;
      var K = B;
      (K = (B = 0 > K ? 1 : 0) ? -K : K) === 0 ? 0 < 1 / K ? ve = 0 : ve = 2147483648 : isNaN(K) ? ve = 2147483647 : 34028234663852886e22 < K ? ve = (B << 31 | 2139095040) >>> 0 : 11754943508222875e-54 > K ? (K = Math.round(K / Math.pow(2, -149)), ve = (B << 31 | K) >>> 0) : (N = Math.floor(Math.log(K) / Math.LN2), K *= Math.pow(2, -N), K = 8388607 & Math.round(8388608 * K), ve = (B << 31 | N + 127 << 23 | K) >>> 0), B = ve, T.push(B >>> 0 & 255), T.push(B >>> 8 & 255), T.push(B >>> 16 & 255), T.push(B >>> 24 & 255);
    }
  }
  Re.prototype.push = function(T) {
    if (!(this.h + 1 < this.g.length)) {
      var N = this.g;
      this.g = new Uint8Array(Math.ceil(1 + 2 * this.g.length)), this.g.set(N);
    }
    this.g[this.h++] = T;
  }, Re.prototype.length = function() {
    return this.h;
  }, Re.prototype.end = function() {
    var T = this.g, N = this.h;
    return this.h = 0, ae(T, 0, N);
  }, xe.prototype.reset = function() {
    this.g.reset(), this.h = this.l = -1;
  };
  var ee = typeof Uint8Array == "function";
  function De(T, N, B) {
    if (T != null)
      return typeof T == "object" ? ee && T instanceof Uint8Array ? B(T) : Fe(T, N, B) : N(T);
  }
  function Fe(T, N, B) {
    if (Array.isArray(T)) {
      for (var K = Array(T.length), oe = 0; oe < T.length; oe++)
        K[oe] = De(T[oe], N, B);
      return Array.isArray(T) && T.W && Oe(K), K;
    }
    for (oe in K = {}, T)
      K[oe] = De(T[oe], N, B);
    return K;
  }
  function tt(T) {
    return typeof T == "number" ? isFinite(T) ? T : String(T) : T;
  }
  var X, pe = { W: { value: !0, configurable: !0 } };
  function Oe(T) {
    return Array.isArray(T) && !Object.isFrozen(T) && Object.defineProperties(T, pe), T;
  }
  function Ie(T, N, B) {
    var K = X;
    if (X = null, T || (T = K), K = this.constructor.ca, T || (T = K ? [K] : []), this.j = K ? 0 : -1, this.i = null, this.g = T, T = (K = this.g.length) - 1, K && (K = this.g[T]) !== null && typeof K == "object" && K.constructor === Object ? (this.l = T - this.j, this.h = K) : N !== void 0 && -1 < N ? (this.l = Math.max(N, T + 1 - this.j), this.h = null) : this.l = Number.MAX_VALUE, B)
      for (N = 0; N < B.length; N++)
        (T = B[N]) < this.l ? (T += this.j, (K = this.g[T]) ? Oe(K) : this.g[T] = Be) : (Ue(this), (K = this.h[T]) ? Oe(K) : this.h[T] = Be);
  }
  var Be = Object.freeze(Oe([]));
  function Ue(T) {
    var N = T.l + T.j;
    T.g[N] || (T.h = T.g[N] = {});
  }
  function Ke(T, N, B) {
    return N === -1 ? null : B !== void 0 && B || N >= T.l ? T.h ? T.h[N] : void 0 : T.g[N + T.j];
  }
  function wt(T) {
    var N = N !== void 0 && N, B = Ke(T, 1, N);
    return B == null && (B = Be), B === Be && St(T, 1, B = Oe([]), N), B;
  }
  function Yt(T, N, B) {
    return (T = (T = Ke(T, N)) == null ? T : +T) == null ? B === void 0 ? 0 : B : T;
  }
  function St(T, N, B, K) {
    K !== void 0 && K || N >= T.l ? (Ue(T), T.h[N] = B) : T.g[N + T.j] = B;
  }
  function Mr(T, N) {
    T.i || (T.i = {});
    var B = T.i[1];
    if (!B) {
      var K = wt(T);
      B = [];
      for (var oe = 0; oe < K.length; oe++)
        B[oe] = new N(K[oe]);
      T.i[1] = B;
    }
    return B;
  }
  function fo(T, N, B, K) {
    var oe = Mr(T, B);
    N = N || new B(), T = wt(T), K != null ? (oe.splice(K, 0, N), T.splice(K, 0, ar(N))) : (oe.push(N), T.push(ar(N)));
  }
  function ar(T, N) {
    if (T.i)
      for (var B in T.i) {
        var K = T.i[B];
        if (Array.isArray(K))
          for (var oe = 0; oe < K.length; oe++)
            K[oe] && ar(K[oe]);
        else
          K && ar(K);
      }
    return T.g;
  }
  function zi(T, N) {
    return (T = Ke(T, N)) == null ? 0 : T;
  }
  function fl(T, N) {
    return (T = Ke(T, N)) == null ? "" : T;
  }
  function ja(T, N) {
    if (T = T.m) {
      V(N, N.g.end());
      for (var B = 0; B < T.length; B++)
        V(N, T[B]);
    }
  }
  function po(T, N) {
    if (N.h == 4)
      return !1;
    var B = N.m;
    return Pe(N), N.N || (N = ae(N.g.h, B, N.g.g), (B = T.m) ? B.push(N) : T.m = [N]), !0;
  }
  function on(T, N) {
    var B = void 0;
    return new (B || (B = Promise))(function(K, oe) {
      function se(Ne) {
        try {
          be(N.next(Ne));
        } catch (at) {
          oe(at);
        }
      }
      function le(Ne) {
        try {
          be(N.throw(Ne));
        } catch (at) {
          oe(at);
        }
      }
      function be(Ne) {
        Ne.done ? K(Ne.value) : new B(function(at) {
          at(Ne.value);
        }).then(se, le);
      }
      be((N = N.apply(T, void 0)).next());
    });
  }
  function Xo(T) {
    Ie.call(this, T);
  }
  function $b(T, N) {
    for (; we(N); )
      switch (N.i) {
        case 8:
          var B = $e(N.g);
          St(T, 1, B);
          break;
        case 21:
          St(T, 2, B = _e(N.g));
          break;
        case 26:
          St(T, 3, B = Ge(N));
          break;
        case 34:
          St(T, 4, B = Ge(N));
          break;
        default:
          if (!po(T, N))
            return T;
      }
    return T;
  }
  function qh(T) {
    Ie.call(this, T, -1, U);
  }
  Ie.prototype.toJSON = function() {
    return Fe(ar(this), tt, j);
  }, Ie.prototype.toString = function() {
    return ar(this).toString();
  }, f(Xo, Ie), f(qh, Ie), qh.prototype.addClassification = function(T, N) {
    fo(this, T, Xo, N);
  };
  var U = [1];
  function ye(T) {
    Ie.call(this, T);
  }
  function he(T, N) {
    for (; we(N); )
      switch (N.i) {
        case 13:
          var B = _e(N.g);
          St(T, 1, B);
          break;
        case 21:
          St(T, 2, B = _e(N.g));
          break;
        case 29:
          St(T, 3, B = _e(N.g));
          break;
        case 37:
          St(T, 4, B = _e(N.g));
          break;
        case 45:
          St(T, 5, B = _e(N.g));
          break;
        default:
          if (!po(T, N))
            return T;
      }
    return T;
  }
  function Te(T) {
    Ie.call(this, T, -1, Xe);
  }
  f(ye, Ie), f(Te, Ie);
  var Xe = [1];
  function Dt(T) {
    Ie.call(this, T);
  }
  function _t(T, N, B) {
    if (B = T.createShader(B === 0 ? T.VERTEX_SHADER : T.FRAGMENT_SHADER), T.shaderSource(B, N), T.compileShader(B), !T.getShaderParameter(B, T.COMPILE_STATUS))
      throw Error(`Could not compile WebGL shader.

` + T.getShaderInfoLog(B));
    return B;
  }
  function lt(T) {
    return Mr(T, Xo).map(function(N) {
      return { index: zi(N, 1), Y: Yt(N, 2), label: Ke(N, 3) != null ? fl(N, 3) : void 0, displayName: Ke(N, 4) != null ? fl(N, 4) : void 0 };
    });
  }
  function Tn(T) {
    return { x: Yt(T, 1), y: Yt(T, 2), z: Yt(T, 3), visibility: Ke(T, 4) != null ? Yt(T, 4) : void 0 };
  }
  function pn(T, N) {
    this.h = T, this.g = N, this.l = 0;
  }
  function ln(T, N, B) {
    return function(K, oe) {
      var se = K.g;
      if (K.m === void 0) {
        var le = _t(se, `
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`, 0), be = _t(se, `
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`, 1), Ne = se.createProgram();
        if (se.attachShader(Ne, le), se.attachShader(Ne, be), se.linkProgram(Ne), !se.getProgramParameter(Ne, se.LINK_STATUS))
          throw Error(`Could not compile WebGL program.

` + se.getProgramInfoLog(Ne));
        le = K.m = Ne, se.useProgram(le), be = se.getUniformLocation(le, "sampler0"), K.j = { I: se.getAttribLocation(le, "aVertex"), H: se.getAttribLocation(le, "aTex"), da: be }, K.s = se.createBuffer(), se.bindBuffer(se.ARRAY_BUFFER, K.s), se.enableVertexAttribArray(K.j.I), se.vertexAttribPointer(K.j.I, 2, se.FLOAT, !1, 0, 0), se.bufferData(se.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), se.STATIC_DRAW), se.bindBuffer(se.ARRAY_BUFFER, null), K.o = se.createBuffer(), se.bindBuffer(se.ARRAY_BUFFER, K.o), se.enableVertexAttribArray(K.j.H), se.vertexAttribPointer(K.j.H, 2, se.FLOAT, !1, 0, 0), se.bufferData(se.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]), se.STATIC_DRAW), se.bindBuffer(se.ARRAY_BUFFER, null), se.uniform1i(be, 0);
      }
      le = K.j, se.useProgram(K.m), se.canvas.width = oe.width, se.canvas.height = oe.height, se.viewport(0, 0, oe.width, oe.height), se.activeTexture(se.TEXTURE0), K.h.bindTexture2d(oe.glName), se.enableVertexAttribArray(le.I), se.bindBuffer(se.ARRAY_BUFFER, K.s), se.vertexAttribPointer(le.I, 2, se.FLOAT, !1, 0, 0), se.enableVertexAttribArray(le.H), se.bindBuffer(se.ARRAY_BUFFER, K.o), se.vertexAttribPointer(le.H, 2, se.FLOAT, !1, 0, 0), se.bindFramebuffer(se.DRAW_FRAMEBUFFER ? se.DRAW_FRAMEBUFFER : se.FRAMEBUFFER, null), se.clearColor(0, 0, 0, 0), se.clear(se.COLOR_BUFFER_BIT), se.colorMask(!0, !0, !0, !0), se.drawArrays(se.TRIANGLE_FAN, 0, 4), se.disableVertexAttribArray(le.I), se.disableVertexAttribArray(le.H), se.bindBuffer(se.ARRAY_BUFFER, null), K.h.bindTexture2d(0);
    }(T, N), typeof T.g.canvas.transferToImageBitmap == "function" ? Promise.resolve(T.g.canvas.transferToImageBitmap()) : B ? Promise.resolve(T.g.canvas) : typeof createImageBitmap == "function" ? createImageBitmap(T.g.canvas) : (T.i === void 0 && (T.i = document.createElement("canvas")), new Promise(function(K) {
      T.i.height = T.g.canvas.height, T.i.width = T.g.canvas.width, T.i.getContext("2d", {}).drawImage(T.g.canvas, 0, 0, T.g.canvas.width, T.g.canvas.height), K(T.i);
    }));
  }
  function Mn(T) {
    this.g = T;
  }
  f(Dt, Ie);
  var vt = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]);
  function Cn(T, N) {
    return N + T;
  }
  function On(T, N) {
    window[T] = N;
  }
  function Qt(T) {
    if (this.g = T, this.listeners = {}, this.j = {}, this.F = {}, this.m = {}, this.s = {}, this.G = this.o = this.R = !0, this.C = Promise.resolve(), this.P = "", this.B = {}, this.locateFile = T && T.locateFile || Cn, typeof window == "object")
      var N = window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/";
    else {
      if (typeof location > "u")
        throw Error("solutions can only be loaded on a web page or in a web worker");
      N = location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/";
    }
    if (this.S = N, T.options)
      for (var B = (N = o(Object.keys(T.options))).next(); !B.done; B = N.next()) {
        B = B.value;
        var K = T.options[B].default;
        K !== void 0 && (this.j[B] = typeof K == "function" ? K() : K);
      }
  }
  function pl(T) {
    return on(T, function N() {
      var B, K, oe, se, le, be, Ne, at, Gt, mt, We, Je = this;
      return S(N, function(pt) {
        switch (pt.g) {
          case 1:
            return B = Je, Je.R ? (K = function(dt, ft) {
              return dt.g.files === void 0 ? [] : typeof dt.g.files == "function" ? dt.g.files(ft) : dt.g.files;
            }(Je, Je.j), m(pt, function() {
              return on(this, function dt() {
                return S(dt, function(ft) {
                  switch (ft.g) {
                    case 1:
                      return ft.m = 2, m(ft, WebAssembly.instantiate(vt), 4);
                    case 4:
                      ft.g = 3, ft.m = 0;
                      break;
                    case 2:
                      return ft.m = 0, ft.j = null, ft.return(!1);
                    case 3:
                      return ft.return(!0);
                  }
                });
              });
            }(), 2)) : pt.return();
          case 2:
            if (oe = pt.h, typeof window == "object")
              return On("createMediapipeSolutionsWasm", { locateFile: Je.locateFile }), On("createMediapipeSolutionsPackedAssets", { locateFile: Je.locateFile }), be = K.filter(function(dt) {
                return dt.data !== void 0;
              }), Ne = K.filter(function(dt) {
                return dt.data === void 0;
              }), at = Promise.all(be.map(function(dt) {
                var ft = Ms(B, dt.url);
                if (dt.path !== void 0) {
                  var $t = dt.path;
                  ft = ft.then(function(mn) {
                    return B.overrideFile($t, mn), Promise.resolve(mn);
                  });
                }
                return ft;
              })), Gt = Promise.all(Ne.map(function(dt) {
                return dt.simd === void 0 || dt.simd && oe || !dt.simd && !oe ? function(ft) {
                  var $t = document.createElement("script");
                  return $t.setAttribute("src", ft), $t.setAttribute("crossorigin", "anonymous"), new Promise(function(mn) {
                    $t.addEventListener("load", function() {
                      mn();
                    }, !1), $t.addEventListener("error", function() {
                      mn();
                    }, !1), document.body.appendChild($t);
                  });
                }(B.locateFile(dt.url, B.S)) : Promise.resolve();
              })).then(function() {
                return on(B, function dt() {
                  var ft, $t, mn = this;
                  return S(dt, function(gn) {
                    if (gn.g == 1)
                      return ft = window.createMediapipeSolutionsWasm, $t = window.createMediapipeSolutionsPackedAssets, m(gn, ft($t), 2);
                    mn.h = gn.h, gn.g = 0;
                  });
                });
              }), mt = on(B, function dt() {
                var ft = this;
                return S(dt, function($t) {
                  return ft.g.graph && ft.g.graph.url ? $t = m($t, Ms(ft, ft.g.graph.url), 0) : ($t.g = 0, $t = void 0), $t;
                });
              }), m(pt, Promise.all([Gt, at, mt]), 7);
            if (typeof importScripts != "function")
              throw Error("solutions can only be loaded on a web page or in a web worker");
            return se = K.filter(function(dt) {
              return dt.simd === void 0 || dt.simd && oe || !dt.simd && !oe;
            }).map(function(dt) {
              return B.locateFile(dt.url, B.S);
            }), importScripts.apply(null, a(se)), m(pt, createMediapipeSolutionsWasm(Module), 6);
          case 6:
            Je.h = pt.h, Je.l = new OffscreenCanvas(1, 1), Je.h.canvas = Je.l, le = Je.h.GL.createContext(Je.l, { antialias: !1, alpha: !1, ba: typeof WebGL2RenderingContext < "u" ? 2 : 1 }), Je.h.GL.makeContextCurrent(le), pt.g = 4;
            break;
          case 7:
            if (Je.l = document.createElement("canvas"), !(We = Je.l.getContext("webgl2", {})) && !(We = Je.l.getContext("webgl", {})))
              return alert("Failed to create WebGL canvas context when passing video frame."), pt.return();
            Je.D = We, Je.h.canvas = Je.l, Je.h.createContext(Je.l, !0, !0, {});
          case 4:
            Je.i = new Je.h.SolutionWasm(), Je.R = !1, pt.g = 0;
        }
      });
    });
  }
  function Ms(T, N) {
    return on(T, function B() {
      var K, oe, se = this;
      return S(B, function(le) {
        return N in se.F ? le.return(se.F[N]) : (K = se.locateFile(N, ""), oe = fetch(K).then(function(be) {
          return be.arrayBuffer();
        }), se.F[N] = oe, le.return(oe));
      });
    });
  }
  function Rr(T, N, B) {
    return on(T, function K() {
      var oe, se, le, be, Ne, at, Gt, mt, We, Je, pt, dt, ft, $t, mn = this;
      return S(K, function(gn) {
        switch (gn.g) {
          case 1:
            if (!B)
              return gn.return(N);
            for (oe = {}, se = 0, le = o(Object.keys(B)), be = le.next(); !be.done; be = le.next())
              Ne = be.value, typeof (at = B[Ne]) != "string" && at.type === "texture" && N[at.stream] !== void 0 && ++se;
            1 < se && (mn.G = !1), Gt = o(Object.keys(B)), be = Gt.next();
          case 2:
            if (be.done) {
              gn.g = 4;
              break;
            }
            if (mt = be.value, typeof (We = B[mt]) == "string")
              return ft = oe, $t = mt, m(gn, function(GO, zT, ml) {
                return on(GO, function WO() {
                  var Em, Ka = this;
                  return S(WO, function(Lb) {
                    return typeof ml == "number" || ml instanceof Uint8Array || ml instanceof Ka.h.Uint8BlobList ? Lb.return(ml) : ml instanceof Ka.h.Texture2dDataOut ? ((Em = Ka.s[zT]) || (Em = new pn(Ka.h, Ka.D), Ka.s[zT] = Em), Lb.return(ln(Em, ml, Ka.G))) : Lb.return(void 0);
                  });
                });
              }(mn, mt, N[We]), 14);
            if (Je = N[We.stream], We.type === "detection_list") {
              if (Je) {
                for (var Xs = Je.getRectList(), Wn = Je.getLandmarksList(), Ot = Je.getClassificationsList(), jt = [], Kt = 0; Kt < Xs.size(); ++Kt) {
                  var Nt = Xs.get(Kt);
                  e: {
                    var qt = new Dt();
                    for (Nt = new xe(Nt); we(Nt); )
                      switch (Nt.i) {
                        case 13:
                          var kt = _e(Nt.g);
                          St(qt, 1, kt);
                          break;
                        case 21:
                          St(qt, 2, kt = _e(Nt.g));
                          break;
                        case 29:
                          St(qt, 3, kt = _e(Nt.g));
                          break;
                        case 37:
                          St(qt, 4, kt = _e(Nt.g));
                          break;
                        case 45:
                          St(qt, 5, kt = _e(Nt.g));
                          break;
                        case 48:
                          for (var Ln = Nt.g, Ks = 128, Ob = 0, Xa = kt = 0; 4 > Xa && 128 <= Ks; Xa++)
                            Ob |= (127 & (Ks = Ln.h[Ln.g++])) << 7 * Xa;
                          if (128 <= Ks && (Ob |= (127 & (Ks = Ln.h[Ln.g++])) << 28, kt |= (127 & Ks) >> 4), 128 <= Ks)
                            for (Xa = 0; 5 > Xa && 128 <= Ks; Xa++)
                              kt |= (127 & (Ks = Ln.h[Ln.g++])) << 7 * Xa + 3;
                          128 > Ks ? (Ln = Ob >>> 0, (kt = 2147483648 & (Ks = kt >>> 0)) && (Ks = ~Ks >>> 0, (Ln = 1 + ~Ln >>> 0) == 0 && (Ks = Ks + 1 >>> 0)), Ln = 4294967296 * Ks + (Ln >>> 0), kt = kt ? -Ln : Ln) : (Ln.l = !0, kt = void 0), St(qt, 6, kt);
                          break;
                        default:
                          if (!po(qt, Nt))
                            break e;
                      }
                  }
                  qt = { Z: Yt(qt, 1), $: Yt(qt, 2), height: Yt(qt, 3), width: Yt(qt, 4), rotation: Yt(qt, 5, 0), X: zi(qt, 6) }, kt = Wn.get(Kt);
                  e:
                    for (Nt = new Te(), kt = new xe(kt); we(kt); )
                      if (kt.i === 10)
                        fo(Nt, Ln = Me(kt, new ye(), he), ye, void 0);
                      else if (!po(Nt, kt))
                        break e;
                  Nt = Mr(Nt, ye).map(Tn), Ln = Ot.get(Kt);
                  e:
                    for (kt = new qh(), Ln = new xe(Ln); we(Ln); )
                      if (Ln.i === 10)
                        kt.addClassification(Me(Ln, new Xo(), $b));
                      else if (!po(kt, Ln))
                        break e;
                  qt = { T: qt, O: Nt, M: lt(kt) }, jt.push(qt);
                }
                Xs = jt;
              } else
                Xs = [];
              oe[mt] = Xs, gn.g = 7;
              break;
            }
            if (We.type === "proto_list") {
              if (Je) {
                for (Xs = Array(Je.size()), Wn = 0; Wn < Je.size(); Wn++)
                  Xs[Wn] = Je.get(Wn);
                Je.delete();
              } else
                Xs = [];
              oe[mt] = Xs, gn.g = 7;
              break;
            }
            if (Je === void 0) {
              gn.g = 3;
              break;
            }
            if (We.type === "float_list") {
              oe[mt] = Je, gn.g = 7;
              break;
            }
            if (We.type === "proto") {
              oe[mt] = Je, gn.g = 7;
              break;
            }
            if (We.type !== "texture")
              throw Error("Unknown output config type: '" + We.type + "'");
            return (pt = mn.s[mt]) || (pt = new pn(mn.h, mn.D), mn.s[mt] = pt), m(gn, ln(pt, Je, mn.G), 13);
          case 13:
            dt = gn.h, oe[mt] = dt;
          case 7:
            We.transform && oe[mt] && (oe[mt] = We.transform(oe[mt])), gn.g = 3;
            break;
          case 14:
            ft[$t] = gn.h;
          case 3:
            be = Gt.next(), gn.g = 2;
            break;
          case 4:
            return gn.return(oe);
        }
      });
    });
  }
  function Xh(T, N) {
    for (var B = N.name || "$", K = [].concat(a(N.wants)), oe = new T.h.StringList(), se = o(N.wants), le = se.next(); !le.done; le = se.next())
      oe.push_back(le.value);
    se = T.h.PacketListener.implement({ onResults: function(be) {
      for (var Ne = {}, at = 0; at < N.wants.length; ++at)
        Ne[K[at]] = be.get(at);
      var Gt = T.listeners[B];
      Gt && (T.C = Rr(T, Ne, N.outs).then(function(mt) {
        mt = Gt(mt);
        for (var We = 0; We < N.wants.length; ++We) {
          var Je = Ne[K[We]];
          typeof Je == "object" && Je.hasOwnProperty && Je.hasOwnProperty("delete") && Je.delete();
        }
        mt && (T.C = mt);
      }));
    } }), T.i.attachMultiListener(oe, se), oe.delete();
  }
  function qa(T) {
    return T === void 0 && (T = 0), T === 1 ? "selfie_segmentation_landscape.tflite" : "selfie_segmentation.tflite";
  }
  function Ko(T) {
    var N = this;
    T = T || {}, this.g = new Qt({ locateFile: T.locateFile, files: function(B) {
      return [{ simd: !0, url: "selfie_segmentation_solution_simd_wasm_bin.js" }, { simd: !1, url: "selfie_segmentation_solution_wasm_bin.js" }, { data: !0, url: qa(B.modelSelection) }];
    }, graph: { url: "selfie_segmentation.binarypb" }, listeners: [{ wants: ["segmentation_mask", "image_transformed"], outs: { image: { type: "texture", stream: "image_transformed" }, segmentationMask: { type: "texture", stream: "segmentation_mask" } } }], inputs: { image: { type: "video", stream: "input_frames_gpu" } }, options: { useCpuInference: { type: 0, graphOptionXref: { calculatorType: "InferenceCalculator", fieldName: "use_cpu_inference" }, default: "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document }, selfieMode: { type: 0, graphOptionXref: { calculatorType: "GlScalerCalculator", calculatorIndex: 1, fieldName: "flip_horizontal" } }, modelSelection: { type: 1, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorModelSelection", fieldName: "int_value" }, onChange: function(B) {
      return on(N, function K() {
        var oe, se, le, be = this;
        return S(K, function(Ne) {
          return Ne.g == 1 ? (oe = qa(B), se = "third_party/mediapipe/modules/selfie_segmentation/" + oe, m(Ne, Ms(be.g, oe), 2)) : (le = Ne.h, be.g.overrideFile(se, le), Ne.return(!0));
        });
      });
    } } } });
  }
  (t = Qt.prototype).close = function() {
    return this.i && this.i.delete(), Promise.resolve();
  }, t.reset = function() {
    return on(this, function T() {
      var N = this;
      return S(T, function(B) {
        N.i && (N.i.reset(), N.m = {}, N.s = {}), B.g = 0;
      });
    });
  }, t.setOptions = function(T, N) {
    var B = this;
    if (N = N || this.g.options) {
      for (var K = [], oe = [], se = {}, le = o(Object.keys(T)), be = le.next(); !be.done; se = { K: se.K, L: se.L }, be = le.next()) {
        var Ne = be.value;
        Ne in this.j && this.j[Ne] === T[Ne] || (this.j[Ne] = T[Ne], (be = N[Ne]) !== void 0 && (be.onChange && (se.K = be.onChange, se.L = T[Ne], K.push(function(at) {
          return function() {
            return on(B, function Gt() {
              var mt = this;
              return S(Gt, function(We) {
                if (We.g == 1)
                  return m(We, at.K(at.L), 2);
                We.h === !0 && (mt.o = !0), We.g = 0;
              });
            });
          };
        }(se))), be.graphOptionXref && (Ne = { valueNumber: be.type === 1 ? T[Ne] : 0, valueBoolean: be.type === 0 && T[Ne], valueString: be.type === 2 ? T[Ne] : "" }, be = Object.assign(Object.assign(Object.assign({}, { calculatorName: "", calculatorIndex: 0 }), be.graphOptionXref), Ne), oe.push(be))));
      }
      K.length === 0 && oe.length === 0 || (this.o = !0, this.A = (this.A === void 0 ? [] : this.A).concat(oe), this.u = (this.u === void 0 ? [] : this.u).concat(K));
    }
  }, t.initialize = function() {
    return on(this, function T() {
      var N = this;
      return S(T, function(B) {
        return B.g == 1 ? m(B, pl(N), 2) : B.g != 3 ? m(B, on(N, function K() {
          var oe, se, le, be, Ne, at, Gt, mt, We = this;
          return S(K, function(Je) {
            if (Je.g == 1)
              return We.g.graph && We.g.graph.url && We.P === We.g.graph.url ? Je.return() : (We.o = !0, We.g.graph && We.g.graph.url ? (We.P = We.g.graph.url, m(Je, Ms(We, We.g.graph.url), 3)) : void (Je.g = 2));
            for (Je.g != 2 && (oe = Je.h, We.i.loadGraph(oe)), se = o(Object.keys(We.B)), le = se.next(); !le.done; le = se.next())
              be = le.value, We.i.overrideFile(be, We.B[be]);
            if (We.B = {}, We.g.listeners)
              for (Ne = o(We.g.listeners), at = Ne.next(); !at.done; at = Ne.next())
                Gt = at.value, Xh(We, Gt);
            mt = We.j, We.j = {}, We.setOptions(mt), Je.g = 0;
          });
        }), 3) : m(B, function(K) {
          return on(K, function oe() {
            var se, le, be, Ne, at, Gt, mt = this;
            return S(oe, function(We) {
              switch (We.g) {
                case 1:
                  if (!mt.o)
                    return We.return();
                  if (!mt.u) {
                    We.g = 2;
                    break;
                  }
                  se = o(mt.u), le = se.next();
                case 3:
                  if (le.done) {
                    We.g = 5;
                    break;
                  }
                  return m(We, (0, le.value)(), 4);
                case 4:
                  le = se.next(), We.g = 3;
                  break;
                case 5:
                  mt.u = void 0;
                case 2:
                  if (mt.A) {
                    for (be = new mt.h.GraphOptionChangeRequestList(), Ne = o(mt.A), at = Ne.next(); !at.done; at = Ne.next())
                      Gt = at.value, be.push_back(Gt);
                    mt.i.changeOptions(be), be.delete(), mt.A = void 0;
                  }
                  mt.o = !1, We.g = 0;
              }
            });
          });
        }(N), 0);
      });
    });
  }, t.overrideFile = function(T, N) {
    this.i ? this.i.overrideFile(T, N) : this.B[T] = N;
  }, t.clearOverriddenFiles = function() {
    this.B = {}, this.i && this.i.clearOverriddenFiles();
  }, t.send = function(T, N) {
    return on(this, function B() {
      var K, oe, se, le, be, Ne, at, Gt, mt, We = this;
      return S(B, function(Je) {
        switch (Je.g) {
          case 1:
            return We.g.inputs ? (K = 1e3 * (N ?? performance.now()), m(Je, We.C, 2)) : Je.return();
          case 2:
            return m(Je, We.initialize(), 3);
          case 3:
            for (oe = new We.h.PacketDataList(), se = o(Object.keys(T)), le = se.next(); !le.done; le = se.next())
              if (be = le.value, Ne = We.g.inputs[be]) {
                e: {
                  var pt = We, dt = T[be];
                  switch (Ne.type) {
                    case "video":
                      var ft = pt.m[Ne.stream];
                      if (ft || (ft = new pn(pt.h, pt.D), pt.m[Ne.stream] = ft), (pt = ft).l === 0 && (pt.l = pt.h.createTexture()), typeof HTMLVideoElement < "u" && dt instanceof HTMLVideoElement) {
                        var $t = dt.videoWidth;
                        ft = dt.videoHeight;
                      } else
                        typeof HTMLImageElement < "u" && dt instanceof HTMLImageElement ? ($t = dt.naturalWidth, ft = dt.naturalHeight) : ($t = dt.width, ft = dt.height);
                      ft = { glName: pt.l, width: $t, height: ft }, ($t = pt.g).canvas.width = ft.width, $t.canvas.height = ft.height, $t.activeTexture($t.TEXTURE0), pt.h.bindTexture2d(pt.l), $t.texImage2D($t.TEXTURE_2D, 0, $t.RGBA, $t.RGBA, $t.UNSIGNED_BYTE, dt), pt.h.bindTexture2d(0), pt = ft;
                      break e;
                    case "detections":
                      for ((ft = pt.m[Ne.stream]) || (ft = new Mn(pt.h), pt.m[Ne.stream] = ft), (pt = ft).data || (pt.data = new pt.g.DetectionListData()), pt.data.reset(dt.length), ft = 0; ft < dt.length; ++ft) {
                        $t = dt[ft];
                        var mn = pt.data, gn = mn.setBoundingBox, Xs = ft, Wn = $t.T, Ot = new Dt();
                        St(Ot, 1, Wn.Z), St(Ot, 2, Wn.$), St(Ot, 3, Wn.height), St(Ot, 4, Wn.width), St(Ot, 5, Wn.rotation), St(Ot, 6, Wn.X);
                        var jt = Wn = new F();
                        ge(jt, 1, Ke(Ot, 1)), ge(jt, 2, Ke(Ot, 2)), ge(jt, 3, Ke(Ot, 3)), ge(jt, 4, Ke(Ot, 4)), ge(jt, 5, Ke(Ot, 5));
                        var Kt = Ke(Ot, 6);
                        if (Kt != null && Kt != null) {
                          ce(jt.g, 48);
                          var Nt = jt.g, qt = Kt;
                          Kt = 0 > qt;
                          var kt = (qt = Math.abs(qt)) >>> 0;
                          for (qt = Math.floor((qt - kt) / 4294967296), qt >>>= 0, Kt && (qt = ~qt >>> 0, 4294967295 < (kt = 1 + (~kt >>> 0)) && (kt = 0, 4294967295 < ++qt && (qt = 0))), Kt = ve = kt, kt = qt; 0 < kt || 127 < Kt; )
                            Nt.push(127 & Kt | 128), Kt = (Kt >>> 7 | kt << 25) >>> 0, kt >>>= 7;
                          Nt.push(Kt);
                        }
                        if (ja(Ot, jt), Wn = Ae(Wn), gn.call(mn, Xs, Wn), $t.O)
                          for (mn = 0; mn < $t.O.length; ++mn)
                            jt = !!(Ot = $t.O[mn]).visibility, Xs = (gn = pt.data).addNormalizedLandmark, Wn = ft, Ot = Object.assign(Object.assign({}, Ot), { visibility: jt ? Ot.visibility : 0 }), St(jt = new ye(), 1, Ot.x), St(jt, 2, Ot.y), St(jt, 3, Ot.z), Ot.visibility && St(jt, 4, Ot.visibility), ge(Nt = Ot = new F(), 1, Ke(jt, 1)), ge(Nt, 2, Ke(jt, 2)), ge(Nt, 3, Ke(jt, 3)), ge(Nt, 4, Ke(jt, 4)), ge(Nt, 5, Ke(jt, 5)), ja(jt, Nt), Ot = Ae(Ot), Xs.call(gn, Wn, Ot);
                        if ($t.M)
                          for (mn = 0; mn < $t.M.length; ++mn) {
                            if (Xs = (gn = pt.data).addClassification, Wn = ft, Ot = $t.M[mn], St(jt = new Xo(), 2, Ot.Y), Ot.index && St(jt, 1, Ot.index), Ot.label && St(jt, 3, Ot.label), Ot.displayName && St(jt, 4, Ot.displayName), Nt = Ot = new F(), (kt = Ke(jt, 1)) != null && kt != null)
                              if (ce(Nt.g, 8), Kt = Nt.g, 0 <= kt)
                                ce(Kt, kt);
                              else {
                                for (qt = 0; 9 > qt; qt++)
                                  Kt.push(127 & kt | 128), kt >>= 7;
                                Kt.push(1);
                              }
                            ge(Nt, 2, Ke(jt, 2)), (Kt = Ke(jt, 3)) != null && (Kt = D(Kt), ce(Nt.g, 26), ce(Nt.g, Kt.length), V(Nt, Nt.g.end()), V(Nt, Kt)), (Kt = Ke(jt, 4)) != null && (Kt = D(Kt), ce(Nt.g, 34), ce(Nt.g, Kt.length), V(Nt, Nt.g.end()), V(Nt, Kt)), ja(jt, Nt), Ot = Ae(Ot), Xs.call(gn, Wn, Ot);
                          }
                      }
                      pt = pt.data;
                      break e;
                    default:
                      pt = {};
                  }
                }
                switch (at = pt, Gt = Ne.stream, Ne.type) {
                  case "video":
                    oe.pushTexture2d(Object.assign(Object.assign({}, at), { stream: Gt, timestamp: K }));
                    break;
                  case "detections":
                    (mt = at).stream = Gt, mt.timestamp = K, oe.pushDetectionList(mt);
                    break;
                  default:
                    throw Error("Unknown input config type: '" + Ne.type + "'");
                }
              }
            return We.i.send(oe), m(Je, We.C, 4);
          case 4:
            oe.delete(), Je.g = 0;
        }
      });
    });
  }, t.onResults = function(T, N) {
    this.listeners[N || "$"] = T;
  }, I("Solution", Qt), I("OptionType", { BOOL: 0, NUMBER: 1, aa: 2, 0: "BOOL", 1: "NUMBER", 2: "STRING" }), (t = Ko.prototype).close = function() {
    return this.g.close(), Promise.resolve();
  }, t.onResults = function(T) {
    this.g.onResults(T);
  }, t.initialize = function() {
    return on(this, function T() {
      var N = this;
      return S(T, function(B) {
        return m(B, N.g.initialize(), 0);
      });
    });
  }, t.reset = function() {
    this.g.reset();
  }, t.send = function(T) {
    return on(this, function N() {
      var B = this;
      return S(N, function(K) {
        return m(K, B.g.send(T), 0);
      });
    });
  }, t.setOptions = function(T) {
    this.g.setOptions(T);
  }, I("SelfieSegmentation", Ko), I("VERSION", "0.1.1632777926");
}).call($v);
var N1 = function(t, e) {
  return N1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, s) {
    n.__proto__ = s;
  } || function(n, s) {
    for (var i in s)
      s.hasOwnProperty(i) && (n[i] = s[i]);
  }, N1(t, e);
};
function EO(t, e) {
  function n() {
    this.constructor = t;
  }
  N1(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var Os = function() {
  return Os = Object.assign || function(t) {
    for (var e, n = 1, s = arguments.length; n < s; n++)
      for (var i in e = arguments[n])
        Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    return t;
  }, Os.apply(this, arguments);
};
function nn(t, e, n, s) {
  return new (n || (n = Promise))(function(i, r) {
    function o(l) {
      try {
        c(s.next(l));
      } catch (u) {
        r(u);
      }
    }
    function a(l) {
      try {
        c(s.throw(l));
      } catch (u) {
        r(u);
      }
    }
    function c(l) {
      var u;
      l.done ? i(l.value) : (u = l.value, u instanceof n ? u : new n(function(h) {
        h(u);
      })).then(o, a);
    }
    c((s = s.apply(t, e || [])).next());
  });
}
function sn(t, e) {
  var n, s, i, r, o = { label: 0, sent: function() {
    if (1 & i[0])
      throw i[1];
    return i[1];
  }, trys: [], ops: [] };
  return r = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (r[Symbol.iterator] = function() {
    return this;
  }), r;
  function a(c) {
    return function(l) {
      return function(u) {
        if (n)
          throw new TypeError("Generator is already executing.");
        for (; o; )
          try {
            if (n = 1, s && (i = 2 & u[0] ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, u[1])).done)
              return i;
            switch (s = 0, i && (u = [2 & u[0], i.value]), u[0]) {
              case 0:
              case 1:
                i = u;
                break;
              case 4:
                return o.label++, { value: u[1], done: !1 };
              case 5:
                o.label++, s = u[1], u = [0];
                continue;
              case 7:
                u = o.ops.pop(), o.trys.pop();
                continue;
              default:
                if (!((i = (i = o.trys).length > 0 && i[i.length - 1]) || u[0] !== 6 && u[0] !== 2)) {
                  o = 0;
                  continue;
                }
                if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
                  o.label = u[1];
                  break;
                }
                if (u[0] === 6 && o.label < i[1]) {
                  o.label = i[1], i = u;
                  break;
                }
                if (i && o.label < i[2]) {
                  o.label = i[2], o.ops.push(u);
                  break;
                }
                i[2] && o.ops.pop(), o.trys.pop();
                continue;
            }
            u = e.call(t, o);
          } catch (h) {
            u = [6, h], s = 0;
          } finally {
            n = i = 0;
          }
        if (5 & u[0])
          throw u[1];
        return { value: u[0] ? u[1] : void 0, done: !0 };
      }([c, l]);
    };
  }
}
function ix(t) {
  return t instanceof SVGAnimatedLength ? t.baseVal.value : t;
}
function PT(t) {
  return nn(this, void 0, void 0, function() {
    var e, n;
    return sn(this, function(s) {
      switch (s.label) {
        case 0:
          return e = document.createElement("canvas"), t instanceof Lt ? [4, cm(t, e)] : [3, 2];
        case 1:
          return s.sent(), [3, 3];
        case 2:
          e.width = ix(t.width), e.height = ix(t.height), n = e.getContext("2d"), t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0), s.label = 3;
        case 3:
          return [2, e];
      }
    });
  });
}
function NO(t) {
  return nn(this, void 0, void 0, function() {
    var e, n, s, i, r, o;
    return sn(this, function(a) {
      switch (a.label) {
        case 0:
          return t instanceof Lt ? (e = t.shape.slice(0, 2), n = e[0], s = e[1], i = ImageData.bind, [4, cm(t)]) : [3, 2];
        case 1:
          return [2, new (i.apply(ImageData, [void 0, a.sent(), s, n]))()];
        case 2:
          return r = document.createElement("canvas"), o = r.getContext("2d"), r.width = ix(t.width), r.height = ix(t.height), o.drawImage(t, 0, 0), [2, o.getImageData(0, 0, r.width, r.height)];
      }
    });
  });
}
function kO(t) {
  return nn(this, void 0, void 0, function() {
    var e, n;
    return sn(this, function(s) {
      switch (s.label) {
        case 0:
          return t instanceof SVGImageElement || t instanceof OffscreenCanvas ? [4, PT(t)] : [3, 2];
        case 1:
          return n = s.sent(), [3, 3];
        case 2:
          n = t, s.label = 3;
        case 3:
          return e = n, [2, lm(e, 4)];
      }
    });
  });
}
function Rb(t) {
  if (t < 0 || t >= 256)
    throw new Error("Mask value must be in range [0, 255] but got " + t);
  if (!Number.isInteger(t))
    throw new Error("Mask value must be an integer but got " + t);
}
function AO(t) {
  var e = t.shape[2], n = Ea(t, 2), s = Y(n, [-1]);
  return Gc(s, e);
}
function kg(t, e) {
  return Q(function() {
    return Le(js(t, ot(e)), "int32");
  });
}
function spe(t, e) {
  var n = e.shape, s = n[0], i = n[1], r = n[2];
  return Q(function() {
    var o = AO(e), a = vn(Oo(0, r, 1, "int32"), 1), c = Le(Tt(o, a), "int32"), l = Y(c, [s, i]), u = Se(l, ot(1, "int32"));
    return je(function(h, d) {
      return q(h, d);
    }(u, t), ot(1, "int32"));
  });
}
var MO = function() {
  function t(e, n) {
    this.model = e, this.outputStride = n;
    var s = this.model.inputs[0].shape;
    A(s[1] === -1 && s[2] === -1, function() {
      return "Input shape [" + s[1] + ", " + s[2] + "] must both be equal to or -1";
    });
  }
  return t.prototype.predict = function(e) {
    var n = this;
    return Q(function() {
      var s = n.preprocessInput(Le(e, "float32")), i = vn(s, 0), r = n.model.predict(i).map(function(a) {
        return ys(a, [0]);
      }), o = n.nameOutputResults(r);
      return { heatmapScores: mi(o.heatmap), offsets: o.offsets, displacementFwd: o.displacementFwd, displacementBwd: o.displacementBwd, segmentation: o.segmentation, partHeatmaps: o.partHeatmaps, longOffsets: o.longOffsets, partOffsets: o.partOffsets };
    });
  }, t.prototype.dispose = function() {
    this.model.dispose();
  }, t;
}(), ipe = function(t) {
  function e() {
    return t !== null && t.apply(this, arguments) || this;
  }
  return EO(e, t), e.prototype.preprocessInput = function(n) {
    return Q(function() {
      return je(it(n, 127.5), 1);
    });
  }, e.prototype.nameOutputResults = function(n) {
    return { offsets: n[0], segmentation: n[1], partHeatmaps: n[2], longOffsets: n[3], heatmap: n[4], displacementFwd: n[5], displacementBwd: n[6], partOffsets: n[7] };
  }, e;
}(MO), Db = ["nose", "leftEye", "rightEye", "leftEar", "rightEar", "leftShoulder", "rightShoulder", "leftElbow", "rightElbow", "leftWrist", "rightWrist", "leftHip", "rightHip", "leftKnee", "rightKnee", "leftAnkle", "rightAnkle"], gr = Db.length, rx = Db.reduce(function(t, e, n) {
  return t[e] = n, t;
}, {});
function BT(t, e, n) {
  var s = t[0], i = t[1], r = e[0], o = e[1], a = n.top, c = n.bottom;
  return [o / (n.left + n.right + i), r / (a + c + s)];
}
function RO(t, e, n, s) {
  return { y: s.get(t, e, n), x: s.get(t, e, n + gr) };
}
function DO(t, e, n) {
  var s = RO(t.heatmapY, t.heatmapX, t.id, n), i = s.y, r = s.x;
  return { x: t.heatmapX * e + r, y: t.heatmapY * e + i };
}
function aE(t, e, n) {
  return t < e ? e : t > n ? n : t;
}
function cE(t, e) {
  return { x: t.x + e.x, y: t.y + e.y };
}
function rpe(t, e, n) {
  n === void 0 && (n = 0.3);
  for (var s = 0, i = 0, r = 0; r < t.length; r++)
    e.keypoints[r].score > n && (i += 1, s += Math.pow(t[r].x - e.keypoints[r].position.x, 2) + Math.pow(t[r].y - e.keypoints[r].position.y, 2));
  return i === 0 ? s = 1 / 0 : s /= i, s;
}
function ope(t, e, n, s, i, r, o) {
  for (var a = o[0], c = o[1], l = n(t), u = l.y * s + l.x, h = i[gr * (2 * u) + e], d = i[gr * (2 * u + 1) + e], f = t.y + h, p = t.x + d, y = 0; y < r; y++) {
    f = Math.min(f, a - 1);
    var g = n({ x: p = Math.min(p, c - 1), y: f }), m = g.y * s + g.x;
    f += h = i[gr * (2 * m) + e], p += d = i[gr * (2 * m + 1) + e];
  }
  return { x: p, y: f };
}
function $O(t, e, n, s, i, r, o, a, c, l) {
  for (var u = i[0], h = i[1], d = r[0], f = r[1], p = a[0], y = a[1], g = [], m = function(E) {
    return function(I, k, M, L) {
      var O = k[0], $ = k[1], D = M[0], z = M[1], W = Math.round(((O + I.y + 1) * z - 1) / L);
      return { x: Math.round((($ + I.x + 1) * D - 1) / L), y: W };
    }(E, [u, h], [d, f], c);
  }, x = 0; x < s; x++) {
    var v = ope(t, x, m, o, e, l, [p, y]);
    g.push(v);
  }
  for (var b = -1, w = 1 / 0, S = 0; S < n.length; S++) {
    var _ = rpe(g, n[S]);
    _ < w && (b = S, w = _);
  }
  return b;
}
function OO(t, e) {
  var n = t[0], s = t[1];
  return [Math.round((s - 1) / e + 1), Math.round((n - 1) / e + 1)];
}
function LO(t, e, n, s, i, r, o, a, c, l, u) {
  for (var h = o[0], d = o[1], f = t.shape, p = f[0], y = f[1], g = e.shape.slice(0, 2), m = g[0], x = g[1], v = Y(e, [m, x, 2, gr]), b = new Float32Array(u * gr * 3).fill(0), w = 0; w < n.length; w++)
    for (var S = w * gr * 3, _ = n[w], E = 0; E < gr; E++) {
      var I = _.keypoints[E], k = S + 3 * E;
      b[k] = I.score, b[k + 1] = I.position.y, b[k + 2] = I.position.x;
    }
  var M = BT([s, i], [h, d], a), L = M[0], O = M[1], $ = Mi(b, [u, gr, 3]), D = a.top, z = a.left, W = { variableNames: ["segmentation", "longOffsets", "poses"], outputShape: [p, y], userCode: `
    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {
      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));
    }

    float convertToPositionInOutputFloat(
        int pos, int pad, float scale, int stride) {
      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);
    }

    float dist(float x1, float y1, float x2, float y2) {
      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);
    }

    float sampleLongOffsets(float h, float w, int d, int k) {
      float fh = fract(h);
      float fw = fract(w);
      int clH = int(ceil(h));
      int clW = int(ceil(w));
      int flH = int(floor(h));
      int flW = int(floor(w));
      float o11 = getLongOffsets(flH, flW, d, k);
      float o12 = getLongOffsets(flH, clW, d, k);
      float o21 = getLongOffsets(clH, flW, d, k);
      float o22 = getLongOffsets(clH, clW, d, k);
      float o1 = mix(o11, o12, fw);
      float o2 = mix(o21, o22, fw);
      return mix(o1, o2, fh);
    }

    int findNearestPose(int h, int w) {
      float prob = getSegmentation(h, w);
      if (prob < 1.0) {
        return -1;
      }

      // Done(Tyler): convert from output space h/w to strided space.
      float stridedH = convertToPositionInOutputFloat(
        h, ` + D + ", " + O + ", " + r + `);
      float stridedW = convertToPositionInOutputFloat(
        w, ` + z + ", " + L + ", " + r + `);

      float minDist = 1000000.0;
      int iMin = -1;
      for (int i = 0; i < ` + u + `; i++) {
        float curDistSum = 0.0;
        int numKpt = 0;
        for (int k = 0; k < ` + gr + `; k++) {
          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);
          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);

          float y = float(h) + dy;
          float x = float(w) + dx;

          for (int s = 0; s < ` + c + `; s++) {
            int yRounded = round(min(y, float(` + (s - 1) + `)));
            int xRounded = round(min(x, float(` + (i - 1) + `)));

            float yStrided = convertToPositionInOutputFloat(
              yRounded, ` + D + ", " + O + ", " + r + `);
            float xStrided = convertToPositionInOutputFloat(
              xRounded, ` + z + ", " + L + ", " + r + `);

            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);
            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);

            y = y + dy;
            x = x + dx;
          }

          float poseScore = getPoses(i, k, 0);
          float poseY = getPoses(i, k, 1);
          float poseX = getPoses(i, k, 2);
          if (poseScore > ` + l + `) {
            numKpt = numKpt + 1;
            curDistSum = curDistSum + dist(x, y, poseX, poseY);
          }
        }
        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {
          minDist = curDistSum / float(numKpt);
          iMin = i;
        }
      }
      return iMin;
    }

    void main() {
        ivec2 coords = getOutputCoords();
        int nearestPose = findNearestPose(coords[0], coords[1]);
        setOutput(float(nearestPose));
      }
  ` };
  return Vp().compileAndRun(W, [t, v, $]);
}
function FO() {
  return C0() === "webgl";
}
function ape(t, e, n, s, i, r, o, a, c, l, u, h) {
  var d = o[0], f = o[1];
  return c === void 0 && (c = 0.2), l === void 0 && (l = 8), u === void 0 && (u = 0.3), h === void 0 && (h = 10), nn(this, void 0, void 0, function() {
    var p, y, g, m, x;
    return sn(this, function(v) {
      switch (v.label) {
        case 0:
          return p = n.filter(function(b) {
            return b.score >= c;
          }), FO() ? (g = Q(function() {
            var b = LO(t, e, p, s, i, r, [d, f], a, l, u, h), w = ui().makeTensorFromDataId(b.dataId, b.shape, b.dtype);
            return p.map(function(S, _) {
              return function(E, I) {
                return Q(function() {
                  return Le(xi(E, ot(I)), "int32");
                });
              }(w, _);
            });
          }), [4, Promise.all(g.map(function(b) {
            return b.data();
          }))]) : [3, 2];
        case 1:
          return y = v.sent(), g.forEach(function(b) {
            return b.dispose();
          }), [3, 5];
        case 2:
          return [4, t.data()];
        case 3:
          return m = v.sent(), [4, e.data()];
        case 4:
          x = v.sent(), y = function(b, w, S, _, E, I, k, M, L, O) {
            var $ = k[0], D = k[1];
            O === void 0 && (O = 5);
            for (var z = S.map(function($e) {
              return new Uint8Array(_ * E).fill(0);
            }), W = M.top, j = M.left, J = BT([_, E], [$, D], M), ne = J[0], re = J[1], fe = OO([$, D], I)[0], ae = 0; ae < _; ae += 1)
              for (var ve = 0; ve < E; ve += 1) {
                var me = ae * E + ve;
                if (b[me] === 1) {
                  var te = $O({ x: ve, y: ae }, w, S, O, [W, j], [ne, re], fe, [_, E], I, L);
                  te >= 0 && (z[te][me] = 1);
                }
              }
            return z;
          }(m, x, p, s, i, r, [d, f], a, l), v.label = 5;
        case 5:
          return [2, y.map(function(b, w) {
            return { data: b, pose: p[w], width: i, height: s };
          })];
      }
    });
  });
}
function cpe(t, e, n, s, i, r, o, a, c, l, u, h, d) {
  var f = a[0], p = a[1];
  return l === void 0 && (l = 0.2), u === void 0 && (u = 8), h === void 0 && (h = 0.3), d === void 0 && (d = 10), nn(this, void 0, void 0, function() {
    var y, g, m, x, v, b;
    return sn(this, function(w) {
      switch (w.label) {
        case 0:
          return y = s.filter(function(S) {
            return S.score >= l;
          }), FO() ? (m = Q(function() {
            var S = LO(t, e, y, i, r, o, [f, p], c, u, h, d), _ = ui().makeTensorFromDataId(S.dataId, S.shape, S.dtype);
            return y.map(function(E, I) {
              return function(k, M, L) {
                return Q(function() {
                  return je(q(Le(xi(k, ot(L)), "int32"), Se(M, 1)), 1);
                });
              }(_, n, I);
            });
          }), [4, Promise.all(m.map(function(S) {
            return S.data();
          }))]) : [3, 2];
        case 1:
          return g = w.sent(), m.forEach(function(S) {
            return S.dispose();
          }), [3, 6];
        case 2:
          return [4, t.data()];
        case 3:
          return x = w.sent(), [4, e.data()];
        case 4:
          return v = w.sent(), [4, n.data()];
        case 5:
          b = w.sent(), g = function(S, _, E, I, k, M, L, O, $, D, z) {
            var W = O[0], j = O[1];
            z === void 0 && (z = 5);
            for (var J = I.map(function(Re) {
              return new Int32Array(k * M).fill(-1);
            }), ne = $.top, re = $.left, fe = BT([k, M], [W, j], $), ae = fe[0], ve = fe[1], me = OO([W, j], L)[0], te = 0; te < k; te += 1)
              for (var $e = 0; $e < M; $e += 1) {
                var _e = te * M + $e;
                if (S[_e] === 1) {
                  var ke = $O({ x: $e, y: te }, _, I, z, [ne, re], [ae, ve], me, [k, M], L, D);
                  ke >= 0 && (J[ke][_e] = E[_e]);
                }
              }
            return J;
          }(x, v, b, y, i, r, o, [f, p], c, u), w.label = 6;
        case 6:
          return [2, g.map(function(S, _) {
            return { pose: y[_], data: S, height: i, width: r };
          })];
      }
    });
  });
}
function Ov(t) {
  return Math.floor(t / 2);
}
[["leftHip", "leftShoulder"], ["leftElbow", "leftShoulder"], ["leftElbow", "leftWrist"], ["leftHip", "leftKnee"], ["leftKnee", "leftAnkle"], ["rightHip", "rightShoulder"], ["rightElbow", "rightShoulder"], ["rightElbow", "rightWrist"], ["rightHip", "rightKnee"], ["rightKnee", "rightAnkle"], ["leftShoulder", "rightShoulder"], ["leftHip", "rightHip"]].map(function(t) {
  var e = t[0], n = t[1];
  return [rx[e], rx[n]];
});
var lpe = function() {
  function t(e, n) {
    this.priorityQueue = new Array(e), this.numberOfElements = -1, this.getElementValue = n;
  }
  return t.prototype.enqueue = function(e) {
    this.priorityQueue[++this.numberOfElements] = e, this.swim(this.numberOfElements);
  }, t.prototype.dequeue = function() {
    var e = this.priorityQueue[0];
    return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e;
  }, t.prototype.empty = function() {
    return this.numberOfElements === -1;
  }, t.prototype.size = function() {
    return this.numberOfElements + 1;
  }, t.prototype.all = function() {
    return this.priorityQueue.slice(0, this.numberOfElements + 1);
  }, t.prototype.max = function() {
    return this.priorityQueue[0];
  }, t.prototype.swim = function(e) {
    for (; e > 0 && this.less(Ov(e), e); )
      this.exchange(e, Ov(e)), e = Ov(e);
  }, t.prototype.sink = function(e) {
    for (; 2 * e <= this.numberOfElements; ) {
      var n = 2 * e;
      if (n < this.numberOfElements && this.less(n, n + 1) && n++, !this.less(e, n))
        break;
      this.exchange(e, n), e = n;
    }
  }, t.prototype.getValueAt = function(e) {
    return this.getElementValue(this.priorityQueue[e]);
  }, t.prototype.less = function(e, n) {
    return this.getValueAt(e) < this.getValueAt(n);
  }, t.prototype.exchange = function(e, n) {
    var s = this.priorityQueue[e];
    this.priorityQueue[e] = this.priorityQueue[n], this.priorityQueue[n] = s;
  }, t;
}();
function upe(t, e, n, s, i, r) {
  for (var o = r.shape, a = o[0], c = o[1], l = !0, u = Math.max(n - i, 0), h = Math.min(n + i + 1, a), d = u; d < h; ++d) {
    for (var f = Math.max(s - i, 0), p = Math.min(s + i + 1, c), y = f; y < p; ++y)
      if (r.get(d, y, t) > e) {
        l = !1;
        break;
      }
    if (!l)
      break;
  }
  return l;
}
var PO = [["nose", "leftEye"], ["leftEye", "leftEar"], ["nose", "rightEye"], ["rightEye", "rightEar"], ["nose", "leftShoulder"], ["leftShoulder", "leftElbow"], ["leftElbow", "leftWrist"], ["leftShoulder", "leftHip"], ["leftHip", "leftKnee"], ["leftKnee", "leftAnkle"], ["nose", "rightShoulder"], ["rightShoulder", "rightElbow"], ["rightElbow", "rightWrist"], ["rightShoulder", "rightHip"], ["rightHip", "rightKnee"], ["rightKnee", "rightAnkle"]].map(function(t) {
  var e = t[0], n = t[1];
  return [rx[e], rx[n]];
}), Lv = PO.map(function(t) {
  return t[1];
}), lE = PO.map(function(t) {
  return t[0];
});
function Fv(t, e, n, s) {
  return { y: aE(Math.round(t.y / e), 0, n - 1), x: aE(Math.round(t.x / e), 0, s - 1) };
}
function uE(t, e, n, s, i, r, o, a) {
  a === void 0 && (a = 2);
  for (var c = s.shape, l = c[0], u = c[1], h = function(x, v, b) {
    var w = b.shape[2] / 2;
    return { y: b.get(v.y, v.x, x), x: b.get(v.y, v.x, w + x) };
  }(t, Fv(e.position, r, l, u), o), d = cE(e.position, h), f = 0; f < a; f++) {
    var p = Fv(d, r, l, u), y = RO(p.y, p.x, n, i);
    d = cE({ x: p.x * r, y: p.y * r }, { x: y.x, y: y.y });
  }
  var g = Fv(d, r, l, u), m = s.get(g.y, g.x, n);
  return { position: d, part: Db[n], score: m };
}
function hpe(t, e, n, s, i, r) {
  var o = e.shape[2], a = Lv.length, c = new Array(o), l = t.part, u = t.score, h = DO(l, s, n);
  c[l.id] = { score: u, part: Db[l.id], position: h };
  for (var d = a - 1; d >= 0; --d) {
    var f = Lv[d], p = lE[d];
    c[f] && !c[p] && (c[p] = uE(d, c[f], p, e, n, s, r));
  }
  for (d = 0; d < a; ++d)
    f = lE[d], p = Lv[d], c[f] && !c[p] && (c[p] = uE(d, c[f], p, e, n, s, i));
  return c;
}
function BO(t, e, n, s) {
  var i = n.x, r = n.y;
  return t.some(function(o) {
    var a, c, l, u, h = o.keypoints[s].position;
    return a = r, c = i, (l = h.y - a) * l + (u = h.x - c) * u <= e;
  });
}
function dpe(t, e, n) {
  var s = n.reduce(function(i, r, o) {
    var a = r.position, c = r.score;
    return BO(t, e, a, o) || (i += c), i;
  }, 0);
  return s / n.length;
}
function Ag(t, e, n, s, i, r, o, a) {
  o === void 0 && (o = 0.5), a === void 0 && (a = 20);
  for (var c = [], l = function(p, y, g) {
    for (var m = g.shape, x = m[0], v = m[1], b = m[2], w = new lpe(x * v * b, function(k) {
      return k.score;
    }), S = 0; S < x; ++S)
      for (var _ = 0; _ < v; ++_)
        for (var E = 0; E < b; ++E) {
          var I = g.get(S, _, E);
          I < p || upe(E, I, S, _, 1, g) && w.enqueue({ score: I, part: { heatmapY: S, heatmapX: _, id: E } });
        }
    return w;
  }(o, 0, t), u = a * a; c.length < r && !l.empty(); ) {
    var h = l.dequeue();
    if (!BO(c, u, DO(h.part, i, e), h.part.id)) {
      var d = hpe(h, t, e, i, n, s), f = dpe(c, u, d);
      c.push({ keypoints: d, score: f });
    }
  }
  return c;
}
var ld, fpe = [-123.15, -115.9, -103.06], ppe = function(t) {
  function e() {
    return t !== null && t.apply(this, arguments) || this;
  }
  return EO(e, t), e.prototype.preprocessInput = function(n) {
    return Se(n, fpe);
  }, e.prototype.nameOutputResults = function(n) {
    var s = n[0], i = n[1], r = n[2], o = n[3], a = n[4], c = n[5];
    return { offsets: a, segmentation: n[6], partHeatmaps: c, longOffsets: o, heatmap: r, displacementFwd: i, displacementBwd: s, partOffsets: n[7] };
  }, e;
}(MO), hE = "https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/", dE = "https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/";
function xd(t) {
  if (typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas || typeof HTMLImageElement < "u" && t instanceof HTMLImageElement)
    return function(e) {
      if ("offsetHeight" in e && e.offsetHeight !== 0 && "offsetWidth" in e && e.offsetWidth !== 0)
        return [e.offsetHeight, e.offsetWidth];
      if (e.height != null && e.width != null)
        return [e.height, e.width];
      throw new Error("HTMLImageElement must have height and width attributes set.");
    }(t);
  if (typeof ImageData < "u" && t instanceof ImageData)
    return [t.height, t.width];
  if (typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement)
    return function(e) {
      return e.hasAttribute("height") && e.hasAttribute("width") ? [e.height, e.width] : [e.videoHeight, e.videoWidth];
    }(t);
  if (t instanceof Lt)
    return [t.shape[0], t.shape[1]];
  throw new Error("error: Unknown input type: " + t + ".");
}
function fE(t, e) {
  return function(n, s) {
    return (n - 1) % s == 0;
  }(t, e) ? t : Math.floor(t / e) * e + 1;
}
var bd = { low: "low", medium: "medium", high: "high", full: "full" }, mpe = ((ld = {})[bd.low] = 0.25, ld[bd.medium] = 0.5, ld[bd.high] = 0.75, ld[bd.full] = 1, ld);
function Mg(t, e, n) {
  var s = n[0], i = n[1], r = function(o) {
    if (typeof o == "string") {
      var a = mpe[o];
      return A(typeof a == "number", function() {
        return "string value of inputResolution must be one of " + Object.values(bd).join(",") + " but was " + o + ".";
      }), a;
    }
    return A(typeof o == "number" && o <= 2 && o >= 0.1, function() {
      return "inputResolution must be a string or number between 0.1 and 2, but was " + o;
    }), o;
  }(t);
  return [fE(s * r, e), fE(i * r, e)];
}
function Ol(t, e, n, s, i) {
  var r = e[0], o = e[1], a = n[0], c = n[1], l = s[0], u = l[0], h = l[1], d = s[1], f = d[0], p = d[1];
  return i === void 0 && (i = !1), Q(function() {
    var y = as.resizeBilinear(t, [a, c], !0);
    return i && (y = mi(y)), function(g, m, x) {
      var v = m[0], b = m[1], w = x[0], S = w[0], _ = w[1], E = x[1], I = E[0], k = E[1];
      return Q(function() {
        var M = vn(g);
        return ys(as.cropAndResize(M, [[S / (v + S + _ - 1), I / (b + I + k - 1), (S + v - 1) / (v + S + _ - 1), (I + b - 1) / (b + I + k - 1)]], [0], [v, b]), [0]);
      });
    }(y, [r, o], [[u, h], [f, p]]);
  });
}
function Rg(t, e) {
  var n = e[0], s = e[1], i = xd(t), r = i[0], o = i[1], a = s / n, c = [0, 0, 0, 0], l = c[0], u = c[1], h = c[2], d = c[3];
  o / r < a ? (l = 0, u = 0, h = Math.round(0.5 * (a * r - o)), d = Math.round(0.5 * (a * r - o))) : (l = Math.round(0.5 * (1 / a * o - r)), u = Math.round(0.5 * (1 / a * o - r)), h = 0, d = 0);
  var f = Q(function() {
    var p = function(y) {
      return y instanceof Lt ? y : lm(y);
    }(t);
    return p = WS(p, [[l, u], [h, d], [0, 0]]), as.resizeBilinear(p, [n, s]);
  });
  return { resized: f, padding: { top: l, left: h, right: d, bottom: u } };
}
function Dg(t) {
  return nn(this, void 0, void 0, function() {
    return sn(this, function(e) {
      return [2, Promise.all(t.map(function(n) {
        return n.buffer();
      }))];
    });
  });
}
function $g(t, e, n, s, i) {
  var r = e[0], o = e[1], a = n[0], c = n[1], l = function(u, h, d, f, p) {
    return f === void 0 && (f = 0), p === void 0 && (p = 0), d === 1 && h === 1 && f === 0 && p === 0 ? u : u.map(function(y) {
      return function(g, m, x, v, b) {
        return v === void 0 && (v = 0), b === void 0 && (b = 0), { score: g.score, keypoints: g.keypoints.map(function(w) {
          var S = w.score, _ = w.part, E = w.position;
          return { score: S, part: _, position: { x: E.x * x + b, y: E.y * m + v } };
        }) };
      }(y, h, d, f, p);
    });
  }(t, (r + s.top + s.bottom) / a, (o + s.left + s.right) / c, -s.top, -s.left);
  return i ? function(u, h) {
    return h <= 0 ? u : u.map(function(d) {
      return function(f, p) {
        return { score: f.score, keypoints: f.keypoints.map(function(y) {
          var g = y.score, m = y.part, x = y.position;
          return { score: g, part: m, position: { x: p - 1 - x.x, y: x.y } };
        }) };
      }(d, h);
    });
  }(l, o) : l;
}
var pE = { architecture: "MobileNetV1", outputStride: 16, quantBytes: 4, multiplier: 0.75 }, mE = ["MobileNetV1", "ResNet50"], gE = { MobileNetV1: [8, 16, 32], ResNet50: [32, 16] }, yE = { MobileNetV1: [0.5, 0.75, 1], ResNet50: [1] }, xE = [1, 2, 4], Og = { flipHorizontal: !1, internalResolution: "medium", segmentationThreshold: 0.7, maxDetections: 10, scoreThreshold: 0.4, nmsRadius: 20 }, Lg = { flipHorizontal: !1, internalResolution: "medium", segmentationThreshold: 0.7, maxDetections: 10, scoreThreshold: 0.4, nmsRadius: 20, minKeypointScore: 0.3, refineSteps: 10 };
function bE(t) {
  var e = t.segmentationThreshold, n = t.maxDetections, s = t.scoreThreshold, i = t.nmsRadius;
  if (e < 0 || e > 1)
    throw new Error("segmentationThreshold " + e + ". Should be in range [0.0, 1.0]");
  if (n <= 0)
    throw new Error("Invalid maxDetections " + n + ". Should be > 0");
  if (s < 0 || s > 1)
    throw new Error("Invalid scoreThreshold " + s + ". Should be in range [0.0, 1.0]");
  if (i <= 0)
    throw new Error("Invalid nmsRadius " + i + ".");
}
function vE(t) {
  var e = t.segmentationThreshold, n = t.maxDetections, s = t.scoreThreshold, i = t.nmsRadius, r = t.minKeypointScore, o = t.refineSteps;
  if (e < 0 || e > 1)
    throw new Error("segmentationThreshold " + e + ". Should be in range [0.0, 1.0]");
  if (n <= 0)
    throw new Error("Invalid maxDetections " + n + ". Should be > 0");
  if (s < 0 || s > 1)
    throw new Error("Invalid scoreThreshold " + s + ". Should be in range [0.0, 1.0]");
  if (i <= 0)
    throw new Error("Invalid nmsRadius " + i + ".");
  if (r < 0 || r > 1)
    throw new Error("Invalid minKeypointScore " + r + ".Should be in range [0.0, 1.0]");
  if (o <= 0 || o > 20)
    throw new Error("Invalid refineSteps " + o + ".Should be in range [1, 20]");
}
var zO = function() {
  function t(e) {
    this.baseModel = e;
  }
  return t.prototype.predictForPersonSegmentation = function(e) {
    var n = this.baseModel.predict(e);
    return { segmentLogits: n.segmentation, heatmapScores: n.heatmapScores, offsets: n.offsets, displacementFwd: n.displacementFwd, displacementBwd: n.displacementBwd };
  }, t.prototype.predictForPersonSegmentationAndPart = function(e) {
    var n = this.baseModel.predict(e);
    return { segmentLogits: n.segmentation, partHeatmapLogits: n.partHeatmaps, heatmapScores: n.heatmapScores, offsets: n.offsets, displacementFwd: n.displacementFwd, displacementBwd: n.displacementBwd };
  }, t.prototype.predictForMultiPersonInstanceSegmentationAndPart = function(e) {
    var n = this.baseModel.predict(e);
    return { segmentLogits: n.segmentation, longOffsets: n.longOffsets, heatmapScores: n.heatmapScores, offsets: n.offsets, displacementFwd: n.displacementFwd, displacementBwd: n.displacementBwd, partHeatmaps: n.partHeatmaps };
  }, t.prototype.segmentPersonActivation = function(e, n, s) {
    var i = this;
    s === void 0 && (s = 0.5);
    var r = xd(e), o = r[0], a = r[1], c = Mg(n, this.baseModel.outputStride, [o, a]), l = Rg(e, c), u = l.resized, h = l.padding, d = Q(function() {
      var x = i.predictForPersonSegmentation(u), v = x.segmentLogits, b = x.heatmapScores, w = x.offsets, S = x.displacementFwd, _ = x.displacementBwd, E = u.shape, I = E[0], k = E[1], M = Ol(v, [o, a], [I, k], [[h.top, h.bottom], [h.left, h.right]], !0);
      return { segmentation: kg(ys(M), s), heatmapScores: b, offsets: w, displacementFwd: S, displacementBwd: _ };
    }), f = d.segmentation, p = d.heatmapScores, y = d.offsets, g = d.displacementFwd, m = d.displacementBwd;
    return u.dispose(), { segmentation: f, heatmapScores: p, offsets: y, displacementFwd: g, displacementBwd: m, padding: h, internalResolutionHeightAndWidth: c };
  }, t.prototype.segmentPerson = function(e, n) {
    return n === void 0 && (n = Og), nn(this, void 0, void 0, function() {
      var s, i, r, o, a, c, l, u, h, d, f, p, y, g, m, x, v, b;
      return sn(this, function(w) {
        switch (w.label) {
          case 0:
            return bE(n = Os(Os({}, Og), n)), s = this.segmentPersonActivation(e, n.internalResolution, n.segmentationThreshold), i = s.segmentation, r = s.heatmapScores, o = s.offsets, a = s.displacementFwd, c = s.displacementBwd, l = s.padding, u = s.internalResolutionHeightAndWidth, h = i.shape, d = h[0], f = h[1], [4, i.data()];
          case 1:
            return p = w.sent(), i.dispose(), [4, Dg([r, o, a, c])];
          case 2:
            return y = w.sent(), g = y[0], m = y[1], x = y[2], v = y[3], b = $g(b = Ag(g, m, x, v, this.baseModel.outputStride, n.maxDetections, n.scoreThreshold, n.nmsRadius), [d, f], u, l, !1), r.dispose(), o.dispose(), a.dispose(), c.dispose(), [2, { height: d, width: f, data: p, allPoses: b }];
        }
      });
    });
  }, t.prototype.segmentMultiPerson = function(e, n) {
    return n === void 0 && (n = Lg), nn(this, void 0, void 0, function() {
      var s, i, r, o, a, c, l, u, h, d, f, p, y, g, m, x, v, b, w, S, _, E = this;
      return sn(this, function(I) {
        switch (I.label) {
          case 0:
            return vE(n = Os(Os({}, Lg), n)), s = xd(e), i = s[0], r = s[1], o = Mg(n.internalResolution, this.baseModel.outputStride, [i, r]), a = Rg(e, o), c = a.resized, l = a.padding, u = Q(function() {
              var k, M = E.predictForMultiPersonInstanceSegmentationAndPart(c), L = M.segmentLogits, O = M.longOffsets, $ = M.heatmapScores, D = M.offsets, z = M.displacementFwd, W = M.displacementBwd, j = Ol(L, [i, r], o, [[l.top, l.bottom], [l.left, l.right]], !0);
              return k = O, { segmentation: kg(ys(j), n.segmentationThreshold), longOffsets: k, heatmapScoresRaw: $, offsetsRaw: D, displacementFwdRaw: z, displacementBwdRaw: W };
            }), h = u.segmentation, d = u.longOffsets, f = u.heatmapScoresRaw, p = u.offsetsRaw, y = u.displacementFwdRaw, g = u.displacementBwdRaw, [4, Dg([f, p, y, g])];
          case 1:
            return m = I.sent(), x = m[0], v = m[1], b = m[2], w = m[3], S = $g(S = Ag(x, v, b, w, this.baseModel.outputStride, n.maxDetections, n.scoreThreshold, n.nmsRadius), [i, r], o, l, !1), [4, ape(h, d, S, i, r, this.baseModel.outputStride, o, l, n.scoreThreshold, n.refineSteps, n.minKeypointScore, n.maxDetections)];
          case 2:
            return _ = I.sent(), c.dispose(), h.dispose(), d.dispose(), f.dispose(), p.dispose(), y.dispose(), g.dispose(), [2, _];
        }
      });
    });
  }, t.prototype.segmentPersonPartsActivation = function(e, n, s) {
    var i = this;
    s === void 0 && (s = 0.5);
    var r = xd(e), o = r[0], a = r[1], c = Mg(n, this.baseModel.outputStride, [o, a]), l = Rg(e, c), u = l.resized, h = l.padding, d = Q(function() {
      var x = i.predictForPersonSegmentationAndPart(u), v = x.segmentLogits, b = x.partHeatmapLogits, w = x.heatmapScores, S = x.offsets, _ = x.displacementFwd, E = x.displacementBwd, I = u.shape, k = I[0], M = I[1], L = Ol(v, [o, a], [k, M], [[h.top, h.bottom], [h.left, h.right]], !0), O = Ol(b, [o, a], [k, M], [[h.top, h.bottom], [h.left, h.right]], !0);
      return { partSegmentation: spe(kg(ys(L), s), O), heatmapScores: w, offsets: S, displacementFwd: _, displacementBwd: E };
    }), f = d.partSegmentation, p = d.heatmapScores, y = d.offsets, g = d.displacementFwd, m = d.displacementBwd;
    return u.dispose(), { partSegmentation: f, heatmapScores: p, offsets: y, displacementFwd: g, displacementBwd: m, padding: h, internalResolutionHeightAndWidth: c };
  }, t.prototype.segmentPersonParts = function(e, n) {
    return n === void 0 && (n = Og), nn(this, void 0, void 0, function() {
      var s, i, r, o, a, c, l, u, h, d, f, p, y, g, m, x, v, b;
      return sn(this, function(w) {
        switch (w.label) {
          case 0:
            return bE(n = Os(Os({}, Og), n)), s = this.segmentPersonPartsActivation(e, n.internalResolution, n.segmentationThreshold), i = s.partSegmentation, r = s.heatmapScores, o = s.offsets, a = s.displacementFwd, c = s.displacementBwd, l = s.padding, u = s.internalResolutionHeightAndWidth, h = i.shape, d = h[0], f = h[1], [4, i.data()];
          case 1:
            return p = w.sent(), i.dispose(), [4, Dg([r, o, a, c])];
          case 2:
            return y = w.sent(), g = y[0], m = y[1], x = y[2], v = y[3], b = $g(b = Ag(g, m, x, v, this.baseModel.outputStride, n.maxDetections, n.scoreThreshold, n.nmsRadius), [d, f], u, l, !1), r.dispose(), o.dispose(), a.dispose(), c.dispose(), [2, { height: d, width: f, data: p, allPoses: b }];
        }
      });
    });
  }, t.prototype.segmentMultiPersonParts = function(e, n) {
    return n === void 0 && (n = Lg), nn(this, void 0, void 0, function() {
      var s, i, r, o, a, c, l, u, h, d, f, p, y, g, m, x, v, b, w, S, _, E, I = this;
      return sn(this, function(k) {
        switch (k.label) {
          case 0:
            return vE(n = Os(Os({}, Lg), n)), s = xd(e), i = s[0], r = s[1], o = Mg(n.internalResolution, this.baseModel.outputStride, [i, r]), a = Rg(e, o), c = a.resized, l = a.padding, u = Q(function() {
              var M = I.predictForMultiPersonInstanceSegmentationAndPart(c), L = M.segmentLogits, O = M.longOffsets, $ = M.heatmapScores, D = M.offsets, z = M.displacementFwd, W = M.displacementBwd, j = M.partHeatmaps, J = Ol(L, [i, r], o, [[l.top, l.bottom], [l.left, l.right]], !0), ne = Ol(j, [i, r], o, [[l.top, l.bottom], [l.left, l.right]], !0), re = O, fe = kg(ys(J), n.segmentationThreshold), ae = function(ve) {
                var me = ve.shape, te = me[0], $e = me[1], _e = me[2];
                return Q(function() {
                  var ke = AO(ve), Re = vn(Oo(0, _e, 1, "int32"), 1), ce = Le(Tt(ke, Re), "int32");
                  return Y(ce, [te, $e]);
                });
              }(ne);
              return { segmentation: fe, longOffsets: re, heatmapScoresRaw: $, offsetsRaw: D, displacementFwdRaw: z, displacementBwdRaw: W, partSegmentation: ae };
            }), h = u.segmentation, d = u.longOffsets, f = u.heatmapScoresRaw, p = u.offsetsRaw, y = u.displacementFwdRaw, g = u.displacementBwdRaw, m = u.partSegmentation, [4, Dg([f, p, y, g])];
          case 1:
            return x = k.sent(), v = x[0], b = x[1], w = x[2], S = x[3], _ = $g(_ = Ag(v, b, w, S, this.baseModel.outputStride, n.maxDetections, n.scoreThreshold, n.nmsRadius), [i, r], o, l, !1), [4, cpe(h, d, m, _, i, r, this.baseModel.outputStride, o, l, n.scoreThreshold, n.refineSteps, n.minKeypointScore, n.maxDetections)];
          case 2:
            return E = k.sent(), c.dispose(), h.dispose(), d.dispose(), f.dispose(), p.dispose(), y.dispose(), g.dispose(), m.dispose(), [2, E];
        }
      });
    });
  }, t.prototype.dispose = function() {
    this.baseModel.dispose();
  }, t;
}();
function gpe(t) {
  return nn(this, void 0, void 0, function() {
    var e, n, s, i, r, o;
    return sn(this, function(a) {
      switch (a.label) {
        case 0:
          if (e = t.outputStride, n = t.quantBytes, s = t.multiplier, rM == null)
            throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);
          return i = function(c, l, u) {
            var h = { 1: "100", 0.75: "075", 0.5: "050" }, d = "model-stride" + c + ".json";
            return u === 4 ? dE + "float/" + h[l] + "/" + d : dE + "quant" + u + "/" + h[l] + "/" + d;
          }(e, s, n), [4, Tb(t.modelUrl || i)];
        case 1:
          return r = a.sent(), o = new ipe(r, e), [2, new zO(o)];
      }
    });
  });
}
function ype(t) {
  return nn(this, void 0, void 0, function() {
    var e, n, s, i, r;
    return sn(this, function(o) {
      switch (o.label) {
        case 0:
          if (e = t.outputStride, n = t.quantBytes, rM == null)
            throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);
          return s = function(a, c) {
            var l = "model-stride" + a + ".json";
            return c === 4 ? hE + "float/" + l : hE + "quant" + c + "/" + l;
          }(e, n), [4, Tb(t.modelUrl || s)];
        case 1:
          return i = o.sent(), r = new ppe(i, e), [2, new zO(r)];
      }
    });
  });
}
function xpe(t) {
  return t === void 0 && (t = pE), nn(this, void 0, void 0, function() {
    return sn(this, function(e) {
      return (t = function(n) {
        if ((n = n || pE).architecture == null && (n.architecture = "MobileNetV1"), mE.indexOf(n.architecture) < 0)
          throw new Error("Invalid architecture " + n.architecture + ". Should be one of " + mE);
        if (n.outputStride == null && (n.outputStride = 16), gE[n.architecture].indexOf(n.outputStride) < 0)
          throw new Error("Invalid outputStride " + n.outputStride + ". Should be one of " + gE[n.architecture] + " for architecture " + n.architecture + ".");
        if (n.multiplier == null && (n.multiplier = 1), yE[n.architecture].indexOf(n.multiplier) < 0)
          throw new Error("Invalid multiplier " + n.multiplier + ". Should be one of " + yE[n.architecture] + " for architecture " + n.architecture + ".");
        if (n.quantBytes == null && (n.quantBytes = 4), xE.indexOf(n.quantBytes) < 0)
          throw new Error("Invalid quantBytes " + n.quantBytes + ". Should be one of " + xE + " for architecture " + n.architecture + ".");
        return n;
      }(t)).architecture === "ResNet50" ? [2, ype(t)] : t.architecture === "MobileNetV1" ? [2, gpe(t)] : [2, null];
    });
  });
}
var k1 = ["left_face", "right_face", "left_upper_arm_front", "left_upper_arm_back", "right_upper_arm_front", "right_upper_arm_back", "left_lower_arm_front", "left_lower_arm_back", "right_lower_arm_front", "right_lower_arm_back", "left_hand", "right_hand", "torso_front", "torso_back", "left_upper_leg_front", "left_upper_leg_back", "right_upper_leg_front", "right_upper_leg_back", "left_lower_leg_front", "left_lower_leg_back", "right_lower_leg_front", "right_lower_leg_back", "left_feet", "right_feet"], wE = function() {
  function t(e) {
    this.mask = e;
  }
  return t.prototype.toCanvasImageSource = function() {
    return nn(this, void 0, void 0, function() {
      return sn(this, function(e) {
        return [2, PT(this.mask)];
      });
    });
  }, t.prototype.toImageData = function() {
    return nn(this, void 0, void 0, function() {
      return sn(this, function(e) {
        return [2, this.mask];
      });
    });
  }, t.prototype.toTensor = function() {
    return nn(this, void 0, void 0, function() {
      return sn(this, function(e) {
        return [2, kO(this.mask)];
      });
    });
  }, t.prototype.getUnderlyingType = function() {
    return "imagedata";
  }, t;
}();
function bpe(t) {
  if (Rb(t), t !== 255)
    throw new Error("Foreground id must be 255 but got " + t);
  return "person";
}
function vpe(t) {
  if (Rb(t), t >= k1.length)
    throw new Error("Invalid body part value " + t);
  return k1[t];
}
var wpe = function() {
  function t(e) {
    this.bodyPixModel = e;
  }
  return t.prototype.segmentPeople = function(e, n) {
    return nn(this, void 0, void 0, function() {
      var s, i, r, o;
      return sn(this, function(a) {
        switch (a.label) {
          case 0:
            return e instanceof ImageBitmap && ((s = document.createElement("canvas")).getContext("2d").drawImage(e, 0, 0), e = s), n.segmentBodyParts ? n.multiSegmentation ? [4, this.bodyPixModel.segmentMultiPersonParts(e, n)] : [3, 2] : [3, 5];
          case 1:
            return r = a.sent(), [3, 4];
          case 2:
            return [4, this.bodyPixModel.segmentPersonParts(e, n)];
          case 3:
            r = [a.sent()], a.label = 4;
          case 4:
            return i = r.map(function(c) {
              var l = c.data, u = c.width, h = c.height, d = new Uint8ClampedArray(u * h * 4).fill(0);
              return l.forEach(function(f, p) {
                f === -1 ? (d[4 * p] = k1.length, d[4 * p + 3] = 0) : (d[4 * p] = f, d[4 * p + 3] = 255);
              }), { maskValueToLabel: vpe, mask: new wE(new ImageData(d, u, h)) };
            }), [3, 10];
          case 5:
            return n.multiSegmentation ? [4, this.bodyPixModel.segmentMultiPerson(e, n)] : [3, 7];
          case 6:
            return o = a.sent(), [3, 9];
          case 7:
            return [4, this.bodyPixModel.segmentPerson(e, n)];
          case 8:
            o = [a.sent()], a.label = 9;
          case 9:
            i = o.map(function(c) {
              var l = c.data, u = c.width, h = c.height, d = new Uint8ClampedArray(u * h * 4).fill(0);
              return l.forEach(function(f, p) {
                f === 0 ? (d[4 * p] = 0, d[4 * p + 3] = 0) : (d[4 * p] = 255, d[4 * p + 3] = 255);
              }), { maskValueToLabel: bpe, mask: new wE(new ImageData(d, u, h)) };
            }), a.label = 10;
          case 10:
            return [2, i];
        }
      });
    });
  }, t.prototype.dispose = function() {
    this.bodyPixModel.dispose();
  }, t.prototype.reset = function() {
  }, t;
}();
function Spe(t) {
  return nn(this, void 0, void 0, function() {
    return sn(this, function(e) {
      return [2, xpe(t).then(function(n) {
        return new wpe(n);
      })];
    });
  });
}
var SE = { runtime: "mediapipe", modelType: "general" }, _pe = function() {
  function t(e) {
    this.mask = e;
  }
  return t.prototype.toCanvasImageSource = function() {
    return nn(this, void 0, void 0, function() {
      return sn(this, function(e) {
        return [2, this.mask];
      });
    });
  }, t.prototype.toImageData = function() {
    return nn(this, void 0, void 0, function() {
      return sn(this, function(e) {
        return [2, NO(this.mask)];
      });
    });
  }, t.prototype.toTensor = function() {
    return nn(this, void 0, void 0, function() {
      return sn(this, function(e) {
        return [2, kO(this.mask)];
      });
    });
  }, t.prototype.getUnderlyingType = function() {
    return "canvasimagesource";
  }, t;
}();
function Tpe(t) {
  return Rb(t), "person";
}
var Cpe = function() {
  function t(e) {
    var n, s = this;
    this.selfieMode = !1, this.selfieSegmentationSolution = new npe.SelfieSegmentation({ locateFile: function(i, r) {
      return e.solutionPath ? e.solutionPath.replace(/\/+$/, "") + "/" + i : r + "/" + i;
    } }), n = e.modelType === "landscape" ? 1 : 0, this.selfieSegmentationSolution.setOptions({ modelSelection: n, selfieMode: this.selfieMode }), this.selfieSegmentationSolution.onResults(function(i) {
      s.segmentation = [{ maskValueToLabel: Tpe, mask: new _pe(i.segmentationMask) }];
    });
  }
  return t.prototype.segmentPeople = function(e, n) {
    return nn(this, void 0, void 0, function() {
      var s, i;
      return sn(this, function(r) {
        switch (r.label) {
          case 0:
            return n && n.flipHorizontal && n.flipHorizontal !== this.selfieMode && (this.selfieMode = n.flipHorizontal, this.selfieSegmentationSolution.setOptions({ selfieMode: this.selfieMode })), e instanceof Lt ? (i = ImageData.bind, [4, cm(e)]) : [3, 2];
          case 1:
            return s = new (i.apply(ImageData, [void 0, r.sent(), e.shape[1], e.shape[0]]))(), [3, 3];
          case 2:
            s = e, r.label = 3;
          case 3:
            return e = s, [4, this.selfieSegmentationSolution.send({ image: e })];
          case 4:
            return r.sent(), [2, this.segmentation];
        }
      });
    });
  }, t.prototype.dispose = function() {
    this.selfieSegmentationSolution.close();
  }, t.prototype.reset = function() {
    this.selfieSegmentationSolution.reset(), this.segmentation = null, this.selfieMode = !1;
  }, t.prototype.initialize = function() {
    return this.selfieSegmentationSolution.initialize();
  }, t;
}();
function Ipe(t) {
  return nn(this, void 0, void 0, function() {
    var e, n;
    return sn(this, function(s) {
      switch (s.label) {
        case 0:
          return e = function(i) {
            if (i == null)
              return Os({}, SE);
            var r = Os({}, i);
            return r.runtime = "mediapipe", r.modelType == null && (r.modelType = SE.modelType), r;
          }(t), [4, (n = new Cpe(e)).initialize()];
        case 1:
          return s.sent(), [2, n];
      }
    });
  });
}
function VO(t) {
  return t instanceof Lt ? { height: t.shape[0], width: t.shape[1] } : { height: t.height, width: t.width };
}
function Pv(t, e) {
  A(t.width !== 0, function() {
    return e + " width cannot be 0.";
  }), A(t.height !== 0, function() {
    return e + " height cannot be 0.";
  });
}
function Epe(t, e, n) {
  var s = e.outputTensorSize, i = e.keepAspectRatio, r = e.borderMode, o = e.outputTensorFloatRange, a = VO(t), c = function(d, f) {
    return f ? { xCenter: f.xCenter * d.width, yCenter: f.yCenter * d.height, width: f.width * d.width, height: f.height * d.height, rotation: f.rotation } : { xCenter: 0.5 * d.width, yCenter: 0.5 * d.height, width: d.width, height: d.height, rotation: 0 };
  }(a, n), l = function(d, f, p) {
    if (p === void 0 && (p = !1), !p)
      return { top: 0, left: 0, right: 0, bottom: 0 };
    var y = f.height, g = f.width;
    Pv(f, "targetSize"), Pv(d, "roi");
    var m, x, v = y / g, b = d.height / d.width, w = 0, S = 0;
    return v > b ? (m = d.width, x = d.width * v, S = (1 - b / v) / 2) : (m = d.height / v, x = d.height, w = (1 - v / b) / 2), d.width = m, d.height = x, { top: S, left: w, right: w, bottom: S };
  }(c, s, i), u = function(d, f, p, y) {
    var g = d.width, m = d.height, x = y ? -1 : 1, v = Math.cos(d.rotation), b = Math.sin(d.rotation), w = d.xCenter, S = d.yCenter, _ = 1 / f, E = 1 / p, I = new Array(16);
    return I[0] = g * v * x * _, I[1] = -m * b * _, I[2] = 0, I[3] = (-0.5 * g * v * x + 0.5 * m * b + w) * _, I[4] = g * b * x * E, I[5] = m * v * E, I[6] = 0, I[7] = (-0.5 * m * v - 0.5 * g * b * x + S) * E, I[8] = 0, I[9] = 0, I[10] = g * _, I[11] = 0, I[12] = 0, I[13] = 0, I[14] = 0, I[15] = 1, function(k) {
      if (k.length !== 16)
        throw new Error("Array length must be 16 but got " + k.length);
      return [[k[0], k[1], k[2], k[3]], [k[4], k[5], k[6], k[7]], [k[8], k[9], k[10], k[11]], [k[12], k[13], k[14], k[15]]];
    }(I);
  }(c, a.width, a.height, !1), h = Q(function() {
    var d, f = (d = t) instanceof Lt ? d : lm(d), p = _c(function(m, x, v) {
      return Pv(v, "inputResolution"), [1 / v.width * m[0][0] * x.width, 1 / v.height * m[0][1] * x.width, m[0][3] * x.width, 1 / v.width * m[1][0] * x.height, 1 / v.height * m[1][1] * x.height, m[1][3] * x.height, 0, 0];
    }(u, a, s), [1, 8]), y = r === "zero" ? "constant" : "nearest", g = as.transform(vn(Le(f, "float32")), p, "bilinear", y, 0, [s.height, s.width]);
    return o != null ? function(m, x) {
      var v = function(b, w, S, _) {
        var E = (_ - S) / 255;
        return { scale: E, offset: S - 0 * E };
      }(0, 0, x[0], x[1]);
      return Q(function() {
        return Se(q(m, v.scale), v.offset);
      });
    }(g, o) : g;
  });
  return { imageTensor: h, padding: l, transformationMatrix: u };
}
var _E = { runtime: "tfjs", modelType: "general", modelUrl: "https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/general/1" }, TE = { flipHorizontal: !1 }, Npe = { outputTensorSize: { width: 256, height: 256 }, keepAspectRatio: !1, borderMode: "zero", outputTensorFloatRange: [0, 1] }, kpe = { outputTensorSize: { width: 256, height: 144 }, keepAspectRatio: !1, borderMode: "zero", outputTensorFloatRange: [0, 1] }, Ape = { activation: "none" }, Mpe = function() {
  function t(e) {
    this.mask = e;
  }
  return t.prototype.toCanvasImageSource = function() {
    return nn(this, void 0, void 0, function() {
      return sn(this, function(e) {
        return [2, PT(this.mask)];
      });
    });
  }, t.prototype.toImageData = function() {
    return nn(this, void 0, void 0, function() {
      return sn(this, function(e) {
        return [2, NO(this.mask)];
      });
    });
  }, t.prototype.toTensor = function() {
    return nn(this, void 0, void 0, function() {
      return sn(this, function(e) {
        return [2, this.mask];
      });
    });
  }, t.prototype.getUnderlyingType = function() {
    return "tensor";
  }, t;
}();
function Rpe(t) {
  return Rb(t), "person";
}
var Mf, CE, Dpe = function() {
  function t(e, n) {
    this.modelType = e, this.model = n;
  }
  return t.prototype.segmentPeople = function(e, n) {
    return nn(this, void 0, void 0, function() {
      var s, i = this;
      return sn(this, function(r) {
        return n = function(o) {
          if (o == null)
            return Os({}, TE);
          var a = Os({}, o);
          return a.flipHorizontal == null && (a.flipHorizontal = TE.flipHorizontal), a;
        }(n), e == null ? (this.reset(), [2, []]) : (s = Q(function() {
          var o = Epe(e, i.modelType === "general" ? Npe : kpe).imageTensor, a = Pt(i.model.predict(o), [0, 0, 0, 1], -1), c = VO(e), l = function(d, f, p) {
            return Q(function() {
              var y = ys(d, [0]), g = y.shape[2];
              if (g === 1) {
                var m = y;
                switch (f.activation) {
                  case "none":
                    break;
                  case "sigmoid":
                    m = mi(m);
                    break;
                  case "softmax":
                    throw new Error("Softmax activation requires two channels.");
                  default:
                    throw new Error("Activation not supported (" + f.activation + ")");
                }
                var x = p ? as.resizeBilinear(m, [p.height, p.width]) : m;
                return ys(x, [2]);
              }
              throw new Error("Unsupported number of tensor channels " + g);
            });
          }(a, Ape, c), u = vn(l, 2), h = uo(u, [[0, 0], [0, 0], [0, 1]]);
          return P0(h, [[0, 0], [0, 0], [0, 2]], "symmetric");
        }), [2, [{ maskValueToLabel: Rpe, mask: new Mpe(s) }]]);
      });
    });
  }, t.prototype.dispose = function() {
    this.model.dispose();
  }, t.prototype.reset = function() {
  }, t;
}();
function $pe(t) {
  return nn(this, void 0, void 0, function() {
    var e, n, s;
    return sn(this, function(i) {
      switch (i.label) {
        case 0:
          return e = function(r) {
            if (r == null)
              return Os({}, _E);
            var o = Os({}, r);
            if (o.runtime = "tfjs", o.modelType == null && (o.modelType = _E.modelType), o.modelType !== "general" && o.modelType !== "landscape")
              throw new Error("Model type must be one of general or landscape, but got " + o.modelType);
            return o.modelUrl == null && (o.modelType === "general" ? o.modelUrl = "https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/general/1" : o.modelUrl = "https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/landscape/1"), o;
          }(t), n = typeof e.modelUrl == "string" && e.modelUrl.indexOf("https://tfhub.dev") > -1, [4, Tb(e.modelUrl, { fromTFHub: n })];
        case 1:
          return s = i.sent(), [2, new Dpe(e.modelType, s)];
      }
    });
  });
}
function Ope(t, e) {
  return nn(this, void 0, void 0, function() {
    var n, s;
    return sn(this, function(i) {
      switch (t) {
        case Mf.MediaPipeSelfieSegmentation:
          if (n = void 0, (s = e) != null) {
            if (s.runtime === "tfjs")
              return [2, $pe(s)];
            if (s.runtime === "mediapipe")
              return [2, Ipe(s)];
            n = s.runtime;
          }
          throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got " + n);
        case Mf.BodyPix:
          return [2, Spe(s = e)];
        default:
          throw new Error(t + " is not a supported model name.");
      }
    });
  });
}
function UO(t, e, n, s) {
  var i = e - t, r = s - n;
  if (i === 0)
    throw new Error("Original min and max are both " + t + ", range cannot be 0.");
  var o = r / i;
  return { scale: o, offset: n - t * o };
}
function IE(t) {
  return t instanceof SVGAnimatedLength ? t.baseVal.value : t;
}
function Lpe(t) {
  return Ic(this, void 0, void 0, function() {
    var e, n;
    return Ec(this, function(s) {
      switch (s.label) {
        case 0:
          return e = document.createElement("canvas"), t instanceof Lt ? [4, cm(t, e)] : [3, 2];
        case 1:
          return s.sent(), [3, 3];
        case 2:
          e.width = IE(t.width), e.height = IE(t.height), n = e.getContext("2d"), t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0), s.label = 3;
        case 3:
          return [2, e];
      }
    });
  });
}
function Fpe(t, e) {
  if (C0() === "webgl")
    return function(l, u) {
      var h = { variableNames: ["image", "segmentation"], outputShape: l.shape, userCode: `
  void main() {
      ivec3 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];
      int channel = coords[2];
      float value = getImage(height, width, channel);
      float foregroundProbability = getSegmentation(height, width, 0);
      setOutput(foregroundProbability >= 0.5 ? value : 0.0);
    }
` }, d = Vp().compileAndRun(h, [l, u]);
      return ui().makeTensorFromDataId(d.dataId, d.shape, d.dtype);
    }(t, e);
  var n = t.shape, s = n[0], i = n[1], r = n[2], o = Pt(e, 0, [s, i, 1]), a = nm(o), c = pi(a, [1, 1, r]);
  return q(t, c);
}
(CE = Mf || (Mf = {})).BodyPix = "BodyPix", CE.MediaPipeSelfieSegmentation = "MediaPipeSelfieSegmentation";
var EE = { flipHorizontal: !1 }, ox, Ppe = function() {
  function t(e) {
    this.depthTensor = e;
  }
  return t.prototype.toCanvasImageSource = function() {
    return Ic(this, void 0, void 0, function() {
      return Ec(this, function(e) {
        return [2, Lpe(this.depthTensor)];
      });
    });
  }, t.prototype.toArray = function() {
    return Ic(this, void 0, void 0, function() {
      return Ec(this, function(e) {
        return [2, this.depthTensor.arraySync()];
      });
    });
  }, t.prototype.toTensor = function() {
    return Ic(this, void 0, void 0, function() {
      return Ec(this, function(e) {
        return [2, this.depthTensor];
      });
    });
  }, t.prototype.getUnderlyingType = function() {
    return "tensor";
  }, t;
}(), NE = UO(0, 255, 0, 1), Bpe = function() {
  function t(e, n, s, i) {
    this.segmenter = e, this.estimatorModel = n, this.minDepth = s, this.maxDepth = i;
  }
  return t.prototype.estimateDepth = function(e, n) {
    return Ic(this, void 0, void 0, function() {
      var s, i, r, o, a, c, l, u, h = this;
      return Ec(this, function(d) {
        switch (d.label) {
          case 0:
            return s = function(f) {
              if (f == null)
                return Af({}, EE);
              var p = Af({}, f);
              return p.flipHorizontal == null && (p.flipHorizontal = EE.flipHorizontal), p;
            }(n), e == null ? (this.reset(), [2, null]) : (i = Q(function() {
              var f, p = Le((f = e) instanceof Lt ? f : lm(f), "float32");
              return s.flipHorizontal && (p = ys(as.flipLeftRight(vn(p, 0)), [0])), p;
            }), r = i.shape, o = r[0], a = r[1], [4, this.segmenter.segmentPeople(i)]);
          case 1:
            return c = d.sent(), [4, c[0].mask.toTensor()];
          case 2:
            return l = d.sent(), u = Q(function() {
              var f = Fpe(i, l);
              l.dispose();
              var p = Se(q(f, NE.scale), NE.offset), y = as.resizeBilinear(p, [256, 192]), g = vn(y), m = h.estimatorModel.predict(g), x = UO(h.minDepth, h.maxDepth, 0, 1), v = x.scale / 2, b = Se(q(m, v), x.offset), w = Gs(b, 0, 1), S = as.resizeBilinear(w, [o, a]);
              return ys(S, [0, 3]);
            }), i.dispose(), [2, new Ppe(u)];
        }
      });
    });
  }, t.prototype.dispose = function() {
    this.segmenter.dispose(), this.estimatorModel.dispose();
  }, t.prototype.reset = function() {
    this.segmenter.reset();
  }, t;
}();
function zpe(t) {
  return Ic(this, void 0, void 0, function() {
    var e, n, s, i;
    return Ec(this, function(r) {
      switch (r.label) {
        case 0:
          return e = function(o) {
            if (o == null || o.minDepth == null || o.maxDepth == null)
              throw new Error("A model config with minDepth and maxDepth set must be provided.");
            if (o.minDepth > o.maxDepth)
              throw new Error("minDepth must be <= maxDepth.");
            var a = Af({}, o);
            return a.depthModelUrl == null && (a.depthModelUrl = "https://tfhub.dev/tensorflow/tfjs-model/ar_portrait_depth/1"), a;
          }(t), n = typeof e.depthModelUrl == "string" && e.depthModelUrl.indexOf("https://tfhub.dev") > -1, [4, Tb(e.depthModelUrl, { fromTFHub: n })];
        case 1:
          return s = r.sent(), [4, Ope(Mf.MediaPipeSelfieSegmentation, { runtime: "tfjs", modelUrl: e.segmentationModelUrl })];
        case 2:
          return i = r.sent(), [2, new Bpe(i, s, e.minDepth, e.maxDepth)];
      }
    });
  });
}
function Vpe(t, e) {
  return Ic(this, void 0, void 0, function() {
    return Ec(this, function(n) {
      if (t === ox.ARPortraitDepth)
        return [2, zpe(e)];
      throw new Error(t + " is not a supported model name.");
    });
  });
}
(function(t) {
  t.ARPortraitDepth = "ARPortraitDepth";
})(ox || (ox = {}));
const Upe = {
  viewer: null,
  depthEstimator: null,
  depthOverlay: null,
  depthCanvas: null,
  isProcessing: !1,
  isDepthVisible: !1,
  button: null,
  init: function(t) {
    this.viewer = t, this.createDepthButton(), this.createDepthOverlay(), this.setupKeyboardHandler();
  },
  createDepthButton: function() {
    const t = Lr("BUTTON", {
      class: "geocam-viewer-control-button depth-viewer-button",
      title: "Generate Depth Map (Click to show, Space to hide)",
      "aria-label": "Generate Depth Map"
    });
    t.style.cssText = `
      background-color: rgba(255, 255, 255, 0.8);
      border-radius: 4px;
      border: 2px solid #333;
      width: 40px;
      height: 40px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    `, t.innerHTML = `
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="2" y="4" width="20" height="3" rx="1" fill="#333" opacity="0.3"/>
        <rect x="2" y="10" width="20" height="3" rx="1" fill="#333" opacity="0.6"/>
        <rect x="2" y="16" width="20" height="3" rx="1" fill="#333" opacity="0.9"/>
        <text x="12" y="13" text-anchor="middle" font-size="8" font-weight="bold" fill="#fff">D</text>
      </svg>
    `, t.addEventListener("click", () => {
      this.toggleDepthView();
    }), this.viewer.addControl(t, "right-top"), this.button = t;
  },
  createDepthOverlay: function() {
    const t = document.createElement("div");
    t.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: none;
      z-index: 1;
    `;
    const e = document.createElement("canvas");
    e.style.cssText = `
      width: 100%;
      height: 100%;
      opacity: 0.7;
    `, t.appendChild(e), this.viewer.element.appendChild(t), this.depthOverlay = t, this.depthCanvas = e;
  },
  setupKeyboardHandler: function() {
    this.keyHandler = (t) => {
      t.code === "Space" && this.isDepthVisible && (t.preventDefault(), this.clearDepthView());
    }, document.addEventListener("keydown", this.keyHandler);
  },
  toggleDepthView: async function() {
    this.isDepthVisible ? this.clearDepthView() : await this.generateDepthMap();
  },
  generateDepthMap: async function() {
    if (!this.isProcessing) {
      this.isProcessing = !0, this.updateButtonState("processing");
      try {
        this.depthEstimator || await this.loadModel();
        const t = this.viewer.renderer.domElement, e = await this.depthEstimator.estimateDepth(t);
        this.visualizeDepthMap(e), this.isDepthVisible = !0, this.updateButtonState("active"), this.depthOverlay.style.display = "block";
      } catch (t) {
        console.error("Depth estimation error:", t), alert("Error generating depth map. Please try again."), this.updateButtonState("ready");
      } finally {
        this.isProcessing = !1;
      }
    }
  },
  loadModel: async function() {
    console.log("Loading depth estimation model...");
    const t = ox.ARPortraitDepth, e = {
      outputDepthRange: [0, 1]
    };
    this.depthEstimator = await Vpe(
      t,
      e
    ), console.log("Depth model loaded successfully!");
  },
  visualizeDepthMap: function(t) {
    const { width: e, height: n, data: s } = t.toCanvasImageSource();
    this.depthCanvas.width = e, this.depthCanvas.height = n;
    const i = this.depthCanvas.getContext("2d"), r = i.createImageData(e, n);
    for (let o = 0; o < s.length; o++) {
      const a = s[o], c = o * 4, l = Math.min(Math.max(a, 0), 1);
      l < 0.5 ? (r.data[c] = 0, r.data[c + 1] = Math.floor(l * 2 * 255), r.data[c + 2] = Math.floor((1 - l * 2) * 255)) : (r.data[c] = Math.floor((l - 0.5) * 2 * 255), r.data[c + 1] = Math.floor((1 - (l - 0.5) * 2) * 255), r.data[c + 2] = 0), r.data[c + 3] = 255;
    }
    i.putImageData(r, 0, 0);
  },
  clearDepthView: function() {
    this.depthOverlay.style.display = "none", this.isDepthVisible = !1, this.updateButtonState("ready");
  },
  updateButtonState: function(t) {
    if (this.button)
      switch (t) {
        case "processing":
          this.button.style.backgroundColor = "rgba(255, 255, 0, 0.8)", this.button.style.borderColor = "#cc0";
          break;
        case "active":
          this.button.style.backgroundColor = "rgba(0, 255, 0, 0.8)", this.button.style.borderColor = "#0c0";
          break;
        case "ready":
        default:
          this.button.style.backgroundColor = "rgba(255, 255, 255, 0.8)", this.button.style.borderColor = "#333";
          break;
      }
  },
  destroy: function() {
    this.button && this.button.remove(), this.depthOverlay && this.depthOverlay.remove(), this.keyHandler && document.removeEventListener("keydown", this.keyHandler), this.depthEstimator && this.depthEstimator.dispose();
  }
};
class Gpe extends HTMLElement {
  static get observedAttributes() {
    return ["fov", "facing", "horizon", "src"];
  }
  constructor() {
    super(), this.viewer = null, console.log("init");
  }
  attributeChangedCallback(e, n, s) {
    console.log("attribute changed", e, s);
    const i = this, r = function(o, a) {
      if (console.log("debouceAttrChange", o, a), i.viewer) {
        if (i.viewer[o])
          console.log("setting", o, a), i.viewer[o](a);
        else if (o == "src") {
          const [c, l] = a.split(".");
          i.viewer.show(
            [
              [`${c}/0.${l}`],
              [`${c}/1.${l}`],
              [`${c}/2.${l}`]
            ],
            0,
            [`${c}/0.obj`, `${c}/1.obj`, `${c}/2.obj`]
          );
        }
      } else
        setTimeout(() => r(o, a), 100);
    };
    r(e, s);
  }
  connectedCallback() {
    console.log("connected");
    const e = this;
    this.style.display = "block", this.viewer = new FV(e, {
      plugins: [
        // Plugins go here
        Upe
      ]
    });
  }
  updateViewer() {
    console.log("updating viewer"), this.viewer.show(
      [
        [
          "https://image.geocam.xyz/gc2-2022-10-28-5985_s-Boise_driving_v-Ben1027_n-2/0/0000/00002506.jpg?bytes=8431183872-8434173007&container=https%3A%2F%2Fs3proxy.geocam.xyz%2Fgc-raw-surveys-archive%2FNIST%2FBoiseDriving%2FBen_10-27%2Fgc2-2022-10-28-5985_s-Boise_driving_v-Ben1027_n-2_0.tar"
        ],
        [
          "https://image.geocam.xyz/gc2-2022-10-28-5985_s-Boise_driving_v-Ben1027_n-2/1/0000/00002506.jpg?bytes=8022497792-8025797203&container=https%3A%2F%2Fs3proxy.geocam.xyz%2Fgc-raw-surveys-archive%2FNIST%2FBoiseDriving%2FBen_10-27%2Fgc2-2022-10-28-5985_s-Boise_driving_v-Ben1027_n-2_1.tar"
        ],
        [
          "https://image.geocam.xyz/gc2-2022-10-28-5985_s-Boise_driving_v-Ben1027_n-2/2/0000/00002506.jpg?bytes=8256700416-8259564683&container=https%3A%2F%2Fs3proxy.geocam.xyz%2Fgc-raw-surveys-archive%2FNIST%2FBoiseDriving%2FBen_10-27%2Fgc2-2022-10-28-5985_s-Boise_driving_v-Ben1027_n-2_2.tar"
        ]
      ],
      0,
      [
        "https://manager.geocam.xyz/calibration/717/hemisphere_0.obj",
        "https://manager.geocam.xyz/calibration/717/hemisphere_1.obj",
        "https://manager.geocam.xyz/calibration/717/hemisphere_2.obj"
      ]
    );
  }
  disconnectedCallback() {
    console.log("disconnected"), this.viewer = null;
  }
}
window.customElements.define("geocam-viewer", Gpe);
export {
  Gpe as GeocamViewer
};
